{-# LANGUAGE OverloadedStrings #-}

-- | Enum module generation.
--
-- Generates @Internal.Enums@ modules containing, for each named enum:
--
-- * A newtype over the underlying Haskell C type
-- * Pattern synonyms for each constant
-- * For @NS_OPTIONS@ (bitmask) enums: @Bits@, @FiniteBits@,
--   @Semigroup@, @Monoid@ instances
module ObjC.CodeGen.Generate.Enums
  ( generateEnumsModule
  , generatePublicEnumsModule
  , frameworkEnums
    -- * Per-enum helpers (used by Method for ret/arg expressions)
  , enumRetFunction
  , enumRetFunctionType
  , enumArgFunction
  , enumFFIType
  , enumSizeAlign
  ) where

import qualified Data.Char as Char
import Data.List (sortBy)
import qualified Data.Map.Strict as Map
import Data.Ord (comparing)
import Data.Text (Text)
import qualified Data.Text as T

import ObjC.CodeGen.IR (ClassHierarchy(..), EnumDef(..), EnumConstant(..))
import ObjC.CodeGen.PrimitiveTypes (lookupPrimitive, PrimitiveTypeInfo(..))
import ObjC.CodeGen.Generate.Types (GeneratedModule(..))
import ObjC.CodeGen.Generate.Naming (formatHaddock)

-- ---------------------------------------------------------------------------
-- Framework enum collection
-- ---------------------------------------------------------------------------

-- | Get all enums belonging to a framework, sorted by name.
frameworkEnums :: ClassHierarchy -> Text -> [EnumDef]
frameworkEnums hierarchy fw =
  sortBy (comparing enumName) $
  filter (\ed -> enumFramework ed == Just fw)
         (Map.elems (hierarchyEnums hierarchy))

-- ---------------------------------------------------------------------------
-- Module generation
-- ---------------------------------------------------------------------------

-- | Generate the @Internal.Enums@ module for a framework.
generateEnumsModule :: Text -> [EnumDef] -> GeneratedModule
generateEnumsModule framework enums =
  let modName = "ObjC." <> framework <> ".Internal.Enums"
  in GeneratedModule
    { genModuleName = modName
    , genModuleContent = T.unlines $ concat
        [ enumsModuleHeader modName
        , [""]
        , enumsModuleImports
        , concatMap (\ed -> [""] ++ generateEnumDecls ed) enums
        ]
    }

-- | Generate the public @ObjC.Framework.Enums@ re-export module.
generatePublicEnumsModule :: Text -> [EnumDef] -> GeneratedModule
generatePublicEnumsModule prefix _enums = GeneratedModule
  { genModuleName = publicMod
  , genModuleContent = T.unlines
      [ "{-# LANGUAGE PatternSynonyms #-}"
      , ""
      , "-- | Public re-export of enum types for the framework."
      , "--"
      , "-- Generated by objc-codegen. Do not edit."
      , "module " <> publicMod
      , "  ( module " <> internalMod
      , "  ) where"
      , ""
      , "import " <> internalMod
      ]
  }
  where
    publicMod   = prefix <> ".Enums"
    internalMod = prefix <> ".Internal.Enums"

-- ---------------------------------------------------------------------------
-- Internal helpers
-- ---------------------------------------------------------------------------

enumsModuleHeader :: Text -> [Text]
enumsModuleHeader modName =
  [ "{-# LANGUAGE PatternSynonyms #-}"
  , "{-# LANGUAGE GeneralizedNewtypeDeriving #-}"
  , "{-# LANGUAGE DerivingStrategies #-}"
  , "{-# LANGUAGE TypeFamilies #-}"
  , ""
  , "-- | Enum types for this framework."
  , "--"
  , "-- Generated by objc-codegen. Do not edit."
  , "module " <> modName <> " where"
  ]

enumsModuleImports :: [Text]
enumsModuleImports =
  [ "import Data.Bits (Bits, FiniteBits, (.|.))"
  , "import Foreign.C.Types"
  , "import Foreign.Storable (Storable)"
  , "import Foreign.LibFFI"
  , "import ObjC.Runtime.Message (ObjCArgument(..), ObjCReturn(..), MsgSendVariant(..))"
  ]

-- | Generate the newtype, instances, and pattern synonyms for one enum.
generateEnumDecls :: EnumDef -> [Text]
generateEnumDecls ed =
  let name = enumName ed
      hsUnderlying = enumUnderlyingHsType ed
      isOpts = enumIsOptions ed
      docLines = case enumDoc ed of
        Nothing  -> []
        Just doc -> formatHaddock doc
      kindTag = if isOpts then " (bitmask)" else ""
      headerComment = ["-- | @" <> name <> "@" <> kindTag]
      newtypeDecl =
        [ "newtype " <> name <> " = " <> name <> " " <> hsUnderlying
        , "  deriving stock (Eq, Ord, Show)"
        ] ++ if isOpts
             then [ "  deriving newtype (Storable, Bits, FiniteBits)" ]
             else [ "  deriving newtype (Storable)" ]
      semigroupInst
        | isOpts =
            [ ""
            , "instance Semigroup " <> name <> " where"
            , "  (<>) = (.|.)"
            , ""
            , "instance Monoid " <> name <> " where"
            , "  mempty = " <> name <> " 0"
            ]
        | otherwise = []
      patternDecls = concatMap (generateEnumPattern name) (enumConstants ed)
      msgInstances = generateEnumMsgInstances ed
  in concat
    [ docLines ++ headerComment
    , newtypeDecl
    , semigroupInst
    , patternDecls
    , msgInstances
    ]

-- | Generate @ObjCArgument@ and @ObjCReturn@ instances for an enum type.
--
-- These allow the enum to be used directly with @sendMessage@ and friends.
generateEnumMsgInstances :: EnumDef -> [Text]
generateEnumMsgInstances ed =
  let name   = enumName ed
      hsUnderlying = enumUnderlyingHsType ed
      argFn  = enumArgFunction ed
      retFn  = enumRetFunction ed
      retFnTy = enumRetFunctionType ed
      -- When the FFI return type matches the underlying Haskell type,
      -- the conversion is direct.  Otherwise go through fromIntegral.
      directConversion = retFnTy == hsUnderlying
      -- ObjCArgument instance
      argBody
        | directConversion =
            "  withObjCArg (" <> name <> " x) k = k (" <> argFn <> " x)"
        | otherwise =
            "  withObjCArg (" <> name <> " x) k = k (" <> argFn <> " (fromIntegral x))"
      -- ObjCReturn instance
      retFromBody
        | directConversion =
            "  fromRetained x = pure (" <> name <> " x)"
        | otherwise =
            "  fromRetained x = pure (" <> name <> " (fromIntegral x))"
      retOwnBody
        | directConversion =
            "  fromOwned x = pure (" <> name <> " x)"
        | otherwise =
            "  fromOwned x = pure (" <> name <> " (fromIntegral x))"
  in [ ""
     , "instance ObjCArgument " <> name <> " where"
     , argBody
     , ""
     , "instance ObjCReturn " <> name <> " where"
     , "  type RawReturn " <> name <> " = " <> retFnTy
     , "  objcRetType = " <> retFn
     , "  msgSendVariant = MsgSendNormal"
     , retFromBody
     , retOwnBody
     ]

-- | Generate a single pattern synonym for an enum constant.
generateEnumPattern :: Text -> EnumConstant -> [Text]
generateEnumPattern enumTyName ec =
  let cName = ecName ec
      hsName = case T.uncons cName of
        Just (c, rest) | Char.isLower c -> T.cons (Char.toUpper c) rest
        _ -> cName
      val   = ecValue ec
      valText
        | val < 0   = "(" <> T.pack (show val) <> ")"
        | otherwise = T.pack (show val)
  in [ ""
     , "pattern " <> hsName <> " :: " <> enumTyName
     , "pattern " <> hsName <> " = " <> enumTyName <> " " <> valText
     ]

-- ---------------------------------------------------------------------------
-- Enum type info (delegating to PrimitiveTypes where possible)
-- ---------------------------------------------------------------------------

-- | Map an enum's underlying desugared type to the Haskell FFI type.
enumUnderlyingHsType :: EnumDef -> Text
enumUnderlyingHsType ed =
  case lookupPrimitive (enumUnderlyingQual ed) (enumUnderlyingDesugared ed) of
    Just info -> ptHsType info
    Nothing   -> "CInt"  -- conservative default

-- | The libffi RetType function for an enum's underlying type.
enumRetFunction :: EnumDef -> Text
enumRetFunction ed =
  case lookupPrimitive (enumUnderlyingQual ed) (enumUnderlyingDesugared ed) of
    Just info -> ptRetFunction info
    Nothing   -> "retCInt"

-- | The Haskell type returned by the libffi ret function.
enumRetFunctionType :: EnumDef -> Text
enumRetFunctionType ed =
  case lookupPrimitive (enumUnderlyingQual ed) (enumUnderlyingDesugared ed) of
    Just info -> ptRetFuncType info
    Nothing   -> "CInt"

-- | The libffi Arg function for an enum's underlying type.
enumArgFunction :: EnumDef -> Text
enumArgFunction ed =
  case lookupPrimitive (enumUnderlyingQual ed) (enumUnderlyingDesugared ed) of
    Just info -> ptArgFunction info
    Nothing   -> "argCInt"

-- | The libffi FFI type constant for an enum's underlying type.
enumFFIType :: EnumDef -> Text
enumFFIType ed =
  case lookupPrimitive (enumUnderlyingQual ed) (enumUnderlyingDesugared ed) of
    Just info -> ptFFIType info
    Nothing   -> "ffi_type_sint"

-- | Size and alignment for an enum's underlying type.
enumSizeAlign :: EnumDef -> (Int, Int)
enumSizeAlign ed =
  case lookupPrimitive (enumUnderlyingQual ed) (enumUnderlyingDesugared ed) of
    Just info -> (ptSize info, ptAlignment info)
    Nothing   -> (4, 4)
