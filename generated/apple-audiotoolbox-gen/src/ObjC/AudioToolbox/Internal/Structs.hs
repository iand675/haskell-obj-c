{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TypeFamilies #-}

-- | Struct types for this framework.
--
-- Generated by objc-codegen. Do not edit.
module ObjC.AudioToolbox.Internal.Structs where

import Foreign.Ptr (Ptr, FunPtr)
import Foreign.Storable (Storable(..))
import Foreign.C.Types
import Foreign.LibFFI.Base (Arg, RetType, mkStorableArg, mkStorableRetType, newStructCType)
import Foreign.LibFFI.FFITypes
import Foreign.LibFFI.Internal (CType)
import System.IO.Unsafe (unsafePerformIO)
import ObjC.Runtime.Message (ObjCArgument(..), ObjCReturn(..), MsgSendVariant(..))
import ObjC.CoreAudioTypes.Internal.Structs
import ObjC.AudioToolbox.Internal.Enums

-- | AUChannelInfo
--
-- Define an audio unit's channel handling capabilities
data AUChannelInfo = AUChannelInfo
  { auChannelInfoInChannels :: !CShort
  , auChannelInfoOutChannels :: !CShort
  } deriving (Eq, Show)

instance Storable AUChannelInfo where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = AUChannelInfo <$> peekByteOff p 0
    <*> peekByteOff p 2
  poke p (AUChannelInfo {..}) = do
    pokeByteOff p 0 auChannelInfoInChannels
    pokeByteOff p 2 auChannelInfoOutChannels

{-# NOINLINE auChannelInfoStructType #-}
auChannelInfoStructType :: Ptr CType
auChannelInfoStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16, ffi_type_sint16]

argAUChannelInfo :: AUChannelInfo -> Arg
argAUChannelInfo = mkStorableArg auChannelInfoStructType

retAUChannelInfo :: RetType AUChannelInfo
retAUChannelInfo = mkStorableRetType auChannelInfoStructType

instance ObjCArgument AUChannelInfo where
  withObjCArg x k = k (argAUChannelInfo x)

instance ObjCReturn AUChannelInfo where
  type RawReturn AUChannelInfo = AUChannelInfo
  objcRetType = retAUChannelInfo
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AUDependentParameter
--
-- Used to represent a dependent parameter that can change as a result of its parent meta-parameter					changing
data AUDependentParameter = AUDependentParameter
  { auDependentParameterMScope :: !CUInt
  , auDependentParameterMParameterID :: !CUInt
  } deriving (Eq, Show)

instance Storable AUDependentParameter where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = AUDependentParameter <$> peekByteOff p 0
    <*> peekByteOff p 4
  poke p (AUDependentParameter {..}) = do
    pokeByteOff p 0 auDependentParameterMScope
    pokeByteOff p 4 auDependentParameterMParameterID

{-# NOINLINE auDependentParameterStructType #-}
auDependentParameterStructType :: Ptr CType
auDependentParameterStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint]

argAUDependentParameter :: AUDependentParameter -> Arg
argAUDependentParameter = mkStorableArg auDependentParameterStructType

retAUDependentParameter :: RetType AUDependentParameter
retAUDependentParameter = mkStorableRetType auDependentParameterStructType

instance ObjCArgument AUDependentParameter where
  withObjCArg x k = k (argAUDependentParameter x)

instance ObjCReturn AUDependentParameter where
  type RawReturn AUDependentParameter = AUDependentParameter
  objcRetType = retAUDependentParameter
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data AUDistanceAttenuationData = AUDistanceAttenuationData
  { auDistanceAttenuationDataInNumberOfPairs :: !CUInt
  , auDistanceAttenuationDataPairs :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable AUDistanceAttenuationData where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = AUDistanceAttenuationData <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (AUDistanceAttenuationData {..}) = do
    pokeByteOff p 0 auDistanceAttenuationDataInNumberOfPairs
    pokeByteOff p 8 auDistanceAttenuationDataPairs

{-# NOINLINE auDistanceAttenuationDataStructType #-}
auDistanceAttenuationDataStructType :: Ptr CType
auDistanceAttenuationDataStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_pointer]

argAUDistanceAttenuationData :: AUDistanceAttenuationData -> Arg
argAUDistanceAttenuationData = mkStorableArg auDistanceAttenuationDataStructType

retAUDistanceAttenuationData :: RetType AUDistanceAttenuationData
retAUDistanceAttenuationData = mkStorableRetType auDistanceAttenuationDataStructType

instance ObjCArgument AUDistanceAttenuationData where
  withObjCArg x k = k (argAUDistanceAttenuationData x)

instance ObjCReturn AUDistanceAttenuationData where
  type RawReturn AUDistanceAttenuationData = AUDistanceAttenuationData
  objcRetType = retAUDistanceAttenuationData
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AUHostVersionIdentifier
--
-- Used to describe the name and version of the audio unit's host
data AUHostVersionIdentifier = AUHostVersionIdentifier
  { auHostVersionIdentifierHostName :: !(Ptr ())
  , auHostVersionIdentifierHostVersion :: !CUInt
  } deriving (Eq, Show)

instance Storable AUHostVersionIdentifier where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = AUHostVersionIdentifier <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (AUHostVersionIdentifier {..}) = do
    pokeByteOff p 0 auHostVersionIdentifierHostName
    pokeByteOff p 8 auHostVersionIdentifierHostVersion

{-# NOINLINE auHostVersionIdentifierStructType #-}
auHostVersionIdentifierStructType :: Ptr CType
auHostVersionIdentifierStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer, ffi_type_uint]

argAUHostVersionIdentifier :: AUHostVersionIdentifier -> Arg
argAUHostVersionIdentifier = mkStorableArg auHostVersionIdentifierStructType

retAUHostVersionIdentifier :: RetType AUHostVersionIdentifier
retAUHostVersionIdentifier = mkStorableRetType auHostVersionIdentifierStructType

instance ObjCArgument AUHostVersionIdentifier where
  withObjCArg x k = k (argAUHostVersionIdentifier x)

instance ObjCReturn AUHostVersionIdentifier where
  type RawReturn AUHostVersionIdentifier = AUHostVersionIdentifier
  objcRetType = retAUHostVersionIdentifier
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AUInputSamplesInOutputCallbackStruct
--
-- Used by a host when registering a callback with an audio unit, to provide 					input-to-output samples mapping
data AUInputSamplesInOutputCallbackStruct = AUInputSamplesInOutputCallbackStruct
  { auInputSamplesInOutputCallbackStructInputToOutputCallback :: !(Ptr ())
  , auInputSamplesInOutputCallbackStructUserData :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable AUInputSamplesInOutputCallbackStruct where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = AUInputSamplesInOutputCallbackStruct <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (AUInputSamplesInOutputCallbackStruct {..}) = do
    pokeByteOff p 0 auInputSamplesInOutputCallbackStructInputToOutputCallback
    pokeByteOff p 8 auInputSamplesInOutputCallbackStructUserData

{-# NOINLINE auInputSamplesInOutputCallbackStructStructType #-}
auInputSamplesInOutputCallbackStructStructType :: Ptr CType
auInputSamplesInOutputCallbackStructStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer, ffi_type_pointer]

argAUInputSamplesInOutputCallbackStruct :: AUInputSamplesInOutputCallbackStruct -> Arg
argAUInputSamplesInOutputCallbackStruct = mkStorableArg auInputSamplesInOutputCallbackStructStructType

retAUInputSamplesInOutputCallbackStruct :: RetType AUInputSamplesInOutputCallbackStruct
retAUInputSamplesInOutputCallbackStruct = mkStorableRetType auInputSamplesInOutputCallbackStructStructType

instance ObjCArgument AUInputSamplesInOutputCallbackStruct where
  withObjCArg x k = k (argAUInputSamplesInOutputCallbackStruct x)

instance ObjCReturn AUInputSamplesInOutputCallbackStruct where
  type RawReturn AUInputSamplesInOutputCallbackStruct = AUInputSamplesInOutputCallbackStruct
  objcRetType = retAUInputSamplesInOutputCallbackStruct
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | Describes a single scheduled MIDIEventList.
data AUMIDIEventList = AUMIDIEventList
  { aumidiEventListNext :: !(Ptr ())
  , aumidiEventListEventSampleTime :: !CLong
  , aumidiEventListEventType :: !AURenderEventType
  , aumidiEventListReserved :: !CUChar
  , aumidiEventListCable :: !CUChar
  , aumidiEventListEventList :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable AUMIDIEventList where
  sizeOf    _ = 32
  alignment _ = 8
  peek p = AUMIDIEventList <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 17
    <*> peekByteOff p 18
    <*> peekByteOff p 24
  poke p (AUMIDIEventList {..}) = do
    pokeByteOff p 0 aumidiEventListNext
    pokeByteOff p 8 aumidiEventListEventSampleTime
    pokeByteOff p 16 aumidiEventListEventType
    pokeByteOff p 17 aumidiEventListReserved
    pokeByteOff p 18 aumidiEventListCable
    pokeByteOff p 24 aumidiEventListEventList

{-# NOINLINE aumidiEventListStructType #-}
aumidiEventListStructType :: Ptr CType
aumidiEventListStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer, ffi_type_slong, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_pointer]

argAUMIDIEventList :: AUMIDIEventList -> Arg
argAUMIDIEventList = mkStorableArg aumidiEventListStructType

retAUMIDIEventList :: RetType AUMIDIEventList
retAUMIDIEventList = mkStorableRetType aumidiEventListStructType

instance ObjCArgument AUMIDIEventList where
  withObjCArg x k = k (argAUMIDIEventList x)

instance ObjCReturn AUMIDIEventList where
  type RawReturn AUMIDIEventList = AUMIDIEventList
  objcRetType = retAUMIDIEventList
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AUMIDIOutputCallbackStruct
--
-- Set by host application to provide the callback and user data for an audio 					unit that provides MIDI output
data AUMIDIOutputCallbackStruct = AUMIDIOutputCallbackStruct
  { aumidiOutputCallbackStructMidiOutputCallback :: !(Ptr ())
  , aumidiOutputCallbackStructUserData :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable AUMIDIOutputCallbackStruct where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = AUMIDIOutputCallbackStruct <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (AUMIDIOutputCallbackStruct {..}) = do
    pokeByteOff p 0 aumidiOutputCallbackStructMidiOutputCallback
    pokeByteOff p 8 aumidiOutputCallbackStructUserData

{-# NOINLINE aumidiOutputCallbackStructStructType #-}
aumidiOutputCallbackStructStructType :: Ptr CType
aumidiOutputCallbackStructStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer, ffi_type_pointer]

argAUMIDIOutputCallbackStruct :: AUMIDIOutputCallbackStruct -> Arg
argAUMIDIOutputCallbackStruct = mkStorableArg aumidiOutputCallbackStructStructType

retAUMIDIOutputCallbackStruct :: RetType AUMIDIOutputCallbackStruct
retAUMIDIOutputCallbackStruct = mkStorableRetType aumidiOutputCallbackStructStructType

instance ObjCArgument AUMIDIOutputCallbackStruct where
  withObjCArg x k = k (argAUMIDIOutputCallbackStruct x)

instance ObjCReturn AUMIDIOutputCallbackStruct where
  type RawReturn AUMIDIOutputCallbackStruct = AUMIDIOutputCallbackStruct
  objcRetType = retAUMIDIOutputCallbackStruct
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AudioUnitNodeConnection
--
-- A connection between two nodes
--
-- sourceNode
--
-- sourceOutputNumber
--
-- destNode
--
-- destInputNumber
data AUNodeConnection = AUNodeConnection
  { auNodeConnectionSourceNode :: !CInt
  , auNodeConnectionSourceOutputNumber :: !CUInt
  , auNodeConnectionDestNode :: !CInt
  , auNodeConnectionDestInputNumber :: !CUInt
  } deriving (Eq, Show)

instance Storable AUNodeConnection where
  sizeOf    _ = 16
  alignment _ = 4
  peek p = AUNodeConnection <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
  poke p (AUNodeConnection {..}) = do
    pokeByteOff p 0 auNodeConnectionSourceNode
    pokeByteOff p 4 auNodeConnectionSourceOutputNumber
    pokeByteOff p 8 auNodeConnectionDestNode
    pokeByteOff p 12 auNodeConnectionDestInputNumber

{-# NOINLINE auNodeConnectionStructType #-}
auNodeConnectionStructType :: Ptr CType
auNodeConnectionStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_uint, ffi_type_sint, ffi_type_uint]

argAUNodeConnection :: AUNodeConnection -> Arg
argAUNodeConnection = mkStorableArg auNodeConnectionStructType

retAUNodeConnection :: RetType AUNodeConnection
retAUNodeConnection = mkStorableRetType auNodeConnectionStructType

instance ObjCArgument AUNodeConnection where
  withObjCArg x k = k (argAUNodeConnection x)

instance ObjCReturn AUNodeConnection where
  type RawReturn AUNodeConnection = AUNodeConnection
  objcRetType = retAUNodeConnection
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data AUNumVersion = AUNumVersion
  { auNumVersionNonRelRev :: !CUChar
  , auNumVersionStage :: !CUChar
  , auNumVersionMinorAndBugRev :: !CUChar
  , auNumVersionMajorRev :: !CUChar
  } deriving (Eq, Show)

instance Storable AUNumVersion where
  sizeOf    _ = 4
  alignment _ = 1
  peek p = AUNumVersion <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
    <*> peekByteOff p 3
  poke p (AUNumVersion {..}) = do
    pokeByteOff p 0 auNumVersionNonRelRev
    pokeByteOff p 1 auNumVersionStage
    pokeByteOff p 2 auNumVersionMinorAndBugRev
    pokeByteOff p 3 auNumVersionMajorRev

{-# NOINLINE auNumVersionStructType #-}
auNumVersionStructType :: Ptr CType
auNumVersionStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8]

argAUNumVersion :: AUNumVersion -> Arg
argAUNumVersion = mkStorableArg auNumVersionStructType

retAUNumVersion :: RetType AUNumVersion
retAUNumVersion = mkStorableRetType auNumVersionStructType

instance ObjCArgument AUNumVersion where
  withObjCArg x k = k (argAUNumVersion x)

instance ObjCReturn AUNumVersion where
  type RawReturn AUNumVersion = AUNumVersion
  objcRetType = retAUNumVersion
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AUParameterAutomationEvent
--
-- An event recording the changing of a parameter, possibly including events				such as touch and release gestures, at a particular host time.
data AUParameterAutomationEvent = AUParameterAutomationEvent
  { auParameterAutomationEventHostTime :: !CULong
  , auParameterAutomationEventAddress :: !CULong
  , auParameterAutomationEventValue :: !CFloat
  , auParameterAutomationEventEventType :: !AUParameterAutomationEventType
  , auParameterAutomationEventReserved :: !CULong
  } deriving (Eq, Show)

instance Storable AUParameterAutomationEvent where
  sizeOf    _ = 32
  alignment _ = 8
  peek p = AUParameterAutomationEvent <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 20
    <*> peekByteOff p 24
  poke p (AUParameterAutomationEvent {..}) = do
    pokeByteOff p 0 auParameterAutomationEventHostTime
    pokeByteOff p 8 auParameterAutomationEventAddress
    pokeByteOff p 16 auParameterAutomationEventValue
    pokeByteOff p 20 auParameterAutomationEventEventType
    pokeByteOff p 24 auParameterAutomationEventReserved

{-# NOINLINE auParameterAutomationEventStructType #-}
auParameterAutomationEventStructType :: Ptr CType
auParameterAutomationEventStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_ulong, ffi_type_ulong, ffi_type_float, ffi_type_uint, ffi_type_ulong]

argAUParameterAutomationEvent :: AUParameterAutomationEvent -> Arg
argAUParameterAutomationEvent = mkStorableArg auParameterAutomationEventStructType

retAUParameterAutomationEvent :: RetType AUParameterAutomationEvent
retAUParameterAutomationEvent = mkStorableRetType auParameterAutomationEventStructType

instance ObjCArgument AUParameterAutomationEvent where
  withObjCArg x k = k (argAUParameterAutomationEvent x)

instance ObjCReturn AUParameterAutomationEvent where
  type RawReturn AUParameterAutomationEvent = AUParameterAutomationEvent
  objcRetType = retAUParameterAutomationEvent
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AUParameterMIDIMapping
--
-- Represents a mapping between a MIDI message and an audio unit's parameter.
--
-- The reserved fields in this structure are for future use. In the current implementation, 					they help align the structure to 64 bit size. Do not use the names of these fields in a 					host application. They are subject to change.
data AUParameterMIDIMapping = AUParameterMIDIMapping
  { auParameterMIDIMappingMScope :: !CUInt
  , auParameterMIDIMappingMElement :: !CUInt
  , auParameterMIDIMappingMParameterID :: !CUInt
  , auParameterMIDIMappingMFlags :: !AUParameterMIDIMappingFlags
  , auParameterMIDIMappingMSubRangeMin :: !CFloat
  , auParameterMIDIMappingMSubRangeMax :: !CFloat
  , auParameterMIDIMappingMStatus :: !CUChar
  , auParameterMIDIMappingMData1 :: !CUChar
  , auParameterMIDIMappingReserved1 :: !CUChar
  , auParameterMIDIMappingReserved2 :: !CUChar
  , auParameterMIDIMappingReserved3 :: !CUInt
  } deriving (Eq, Show)

instance Storable AUParameterMIDIMapping where
  sizeOf    _ = 32
  alignment _ = 4
  peek p = AUParameterMIDIMapping <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
    <*> peekByteOff p 16
    <*> peekByteOff p 20
    <*> peekByteOff p 24
    <*> peekByteOff p 25
    <*> peekByteOff p 26
    <*> peekByteOff p 27
    <*> peekByteOff p 28
  poke p (AUParameterMIDIMapping {..}) = do
    pokeByteOff p 0 auParameterMIDIMappingMScope
    pokeByteOff p 4 auParameterMIDIMappingMElement
    pokeByteOff p 8 auParameterMIDIMappingMParameterID
    pokeByteOff p 12 auParameterMIDIMappingMFlags
    pokeByteOff p 16 auParameterMIDIMappingMSubRangeMin
    pokeByteOff p 20 auParameterMIDIMappingMSubRangeMax
    pokeByteOff p 24 auParameterMIDIMappingMStatus
    pokeByteOff p 25 auParameterMIDIMappingMData1
    pokeByteOff p 26 auParameterMIDIMappingReserved1
    pokeByteOff p 27 auParameterMIDIMappingReserved2
    pokeByteOff p 28 auParameterMIDIMappingReserved3

{-# NOINLINE auParameterMIDIMappingStructType #-}
auParameterMIDIMappingStructType :: Ptr CType
auParameterMIDIMappingStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_float, ffi_type_float, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint]

argAUParameterMIDIMapping :: AUParameterMIDIMapping -> Arg
argAUParameterMIDIMapping = mkStorableArg auParameterMIDIMappingStructType

retAUParameterMIDIMapping :: RetType AUParameterMIDIMapping
retAUParameterMIDIMapping = mkStorableRetType auParameterMIDIMappingStructType

instance ObjCArgument AUParameterMIDIMapping where
  withObjCArg x k = k (argAUParameterMIDIMapping x)

instance ObjCReturn AUParameterMIDIMapping where
  type RawReturn AUParameterMIDIMapping = AUParameterMIDIMapping
  objcRetType = retAUParameterMIDIMapping
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AUPreset
--
-- Used to publish and set factory presets on an audio unit
--
-- presetNumber
--
-- If < 0, then preset is a user preset						If >= 0, then this field is used to select the factory preset
--
-- presetName
--
-- If a factory preset, the name of the specified factory preset
data AUPreset = AUPreset
  { auPresetPresetNumber :: !CInt
  , auPresetPresetName :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable AUPreset where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = AUPreset <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (AUPreset {..}) = do
    pokeByteOff p 0 auPresetPresetNumber
    pokeByteOff p 8 auPresetPresetName

{-# NOINLINE auPresetStructType #-}
auPresetStructType :: Ptr CType
auPresetStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_pointer]

argAUPreset :: AUPreset -> Arg
argAUPreset = mkStorableArg auPresetStructType

retAUPreset :: RetType AUPreset
retAUPreset = mkStorableRetType auPresetStructType

instance ObjCArgument AUPreset where
  withObjCArg x k = k (argAUPreset x)

instance ObjCReturn AUPreset where
  type RawReturn AUPreset = AUPreset
  objcRetType = retAUPreset
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AUPresetEvent
--
-- The parameters to specify a preset for an audio unit.
data AUPresetEvent = AUPresetEvent
  { auPresetEventScope :: !CUInt
  , auPresetEventElement :: !CUInt
  , auPresetEventPreset :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable AUPresetEvent where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = AUPresetEvent <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (AUPresetEvent {..}) = do
    pokeByteOff p 0 auPresetEventScope
    pokeByteOff p 4 auPresetEventElement
    pokeByteOff p 8 auPresetEventPreset

{-# NOINLINE auPresetEventStructType #-}
auPresetEventStructType :: Ptr CType
auPresetEventStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_pointer]

argAUPresetEvent :: AUPresetEvent -> Arg
argAUPresetEvent = mkStorableArg auPresetEventStructType

retAUPresetEvent :: RetType AUPresetEvent
retAUPresetEvent = mkStorableRetType auPresetEventStructType

instance ObjCArgument AUPresetEvent where
  withObjCArg x k = k (argAUPresetEvent x)

instance ObjCReturn AUPresetEvent where
  type RawReturn AUPresetEvent = AUPresetEvent
  objcRetType = retAUPresetEvent
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AURecordedParameterEvent
--
-- An event recording the changing of a parameter at a particular host time.
data AURecordedParameterEvent = AURecordedParameterEvent
  { auRecordedParameterEventHostTime :: !CULong
  , auRecordedParameterEventAddress :: !CULong
  , auRecordedParameterEventValue :: !CFloat
  } deriving (Eq, Show)

instance Storable AURecordedParameterEvent where
  sizeOf    _ = 24
  alignment _ = 8
  peek p = AURecordedParameterEvent <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
  poke p (AURecordedParameterEvent {..}) = do
    pokeByteOff p 0 auRecordedParameterEventHostTime
    pokeByteOff p 8 auRecordedParameterEventAddress
    pokeByteOff p 16 auRecordedParameterEventValue

{-# NOINLINE auRecordedParameterEventStructType #-}
auRecordedParameterEventStructType :: Ptr CType
auRecordedParameterEventStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_ulong, ffi_type_ulong, ffi_type_float]

argAURecordedParameterEvent :: AURecordedParameterEvent -> Arg
argAURecordedParameterEvent = mkStorableArg auRecordedParameterEventStructType

retAURecordedParameterEvent :: RetType AURecordedParameterEvent
retAURecordedParameterEvent = mkStorableRetType auRecordedParameterEventStructType

instance ObjCArgument AURecordedParameterEvent where
  withObjCArg x k = k (argAURecordedParameterEvent x)

instance ObjCReturn AURecordedParameterEvent where
  type RawReturn AURecordedParameterEvent = AURecordedParameterEvent
  objcRetType = retAURecordedParameterEvent
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AURenderCallbackStruct
--
-- Used by a host when registering a callback with the audio unit to provide input
data AURenderCallbackStruct = AURenderCallbackStruct
  { auRenderCallbackStructInputProc :: !(Ptr ())
  , auRenderCallbackStructInputProcRefCon :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable AURenderCallbackStruct where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = AURenderCallbackStruct <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (AURenderCallbackStruct {..}) = do
    pokeByteOff p 0 auRenderCallbackStructInputProc
    pokeByteOff p 8 auRenderCallbackStructInputProcRefCon

{-# NOINLINE auRenderCallbackStructStructType #-}
auRenderCallbackStructStructType :: Ptr CType
auRenderCallbackStructStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer, ffi_type_pointer]

argAURenderCallbackStruct :: AURenderCallbackStruct -> Arg
argAURenderCallbackStruct = mkStorableArg auRenderCallbackStructStructType

retAURenderCallbackStruct :: RetType AURenderCallbackStruct
retAURenderCallbackStruct = mkStorableRetType auRenderCallbackStructStructType

instance ObjCArgument AURenderCallbackStruct where
  withObjCArg x k = k (argAURenderCallbackStruct x)

instance ObjCReturn AURenderCallbackStruct where
  type RawReturn AURenderCallbackStruct = AURenderCallbackStruct
  objcRetType = retAURenderCallbackStruct
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | Common header for an AURenderEvent.
data AURenderEventHeader = AURenderEventHeader
  { auRenderEventHeaderNext :: !(Ptr ())
  , auRenderEventHeaderEventSampleTime :: !CLong
  , auRenderEventHeaderEventType :: !AURenderEventType
  , auRenderEventHeaderReserved :: !CUChar
  } deriving (Eq, Show)

instance Storable AURenderEventHeader where
  sizeOf    _ = 24
  alignment _ = 8
  peek p = AURenderEventHeader <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 17
  poke p (AURenderEventHeader {..}) = do
    pokeByteOff p 0 auRenderEventHeaderNext
    pokeByteOff p 8 auRenderEventHeaderEventSampleTime
    pokeByteOff p 16 auRenderEventHeaderEventType
    pokeByteOff p 17 auRenderEventHeaderReserved

{-# NOINLINE auRenderEventHeaderStructType #-}
auRenderEventHeaderStructType :: Ptr CType
auRenderEventHeaderStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer, ffi_type_slong, ffi_type_uint8, ffi_type_uint8]

argAURenderEventHeader :: AURenderEventHeader -> Arg
argAURenderEventHeader = mkStorableArg auRenderEventHeaderStructType

retAURenderEventHeader :: RetType AURenderEventHeader
retAURenderEventHeader = mkStorableRetType auRenderEventHeaderStructType

instance ObjCArgument AURenderEventHeader where
  withObjCArg x k = k (argAURenderEventHeader x)

instance ObjCReturn AURenderEventHeader where
  type RawReturn AURenderEventHeader = AURenderEventHeader
  objcRetType = retAURenderEventHeader
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data AUSamplerBankPresetData = AUSamplerBankPresetData
  { auSamplerBankPresetDataBankURL :: !(Ptr ())
  , auSamplerBankPresetDataBankMSB :: !CUChar
  , auSamplerBankPresetDataBankLSB :: !CUChar
  , auSamplerBankPresetDataPresetID :: !CUChar
  , auSamplerBankPresetDataReserved :: !CUChar
  } deriving (Eq, Show)

instance Storable AUSamplerBankPresetData where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = AUSamplerBankPresetData <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 9
    <*> peekByteOff p 10
    <*> peekByteOff p 11
  poke p (AUSamplerBankPresetData {..}) = do
    pokeByteOff p 0 auSamplerBankPresetDataBankURL
    pokeByteOff p 8 auSamplerBankPresetDataBankMSB
    pokeByteOff p 9 auSamplerBankPresetDataBankLSB
    pokeByteOff p 10 auSamplerBankPresetDataPresetID
    pokeByteOff p 11 auSamplerBankPresetDataReserved

{-# NOINLINE auSamplerBankPresetDataStructType #-}
auSamplerBankPresetDataStructType :: Ptr CType
auSamplerBankPresetDataStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8]

argAUSamplerBankPresetData :: AUSamplerBankPresetData -> Arg
argAUSamplerBankPresetData = mkStorableArg auSamplerBankPresetDataStructType

retAUSamplerBankPresetData :: RetType AUSamplerBankPresetData
retAUSamplerBankPresetData = mkStorableRetType auSamplerBankPresetDataStructType

instance ObjCArgument AUSamplerBankPresetData where
  withObjCArg x k = k (argAUSamplerBankPresetData x)

instance ObjCReturn AUSamplerBankPresetData where
  type RawReturn AUSamplerBankPresetData = AUSamplerBankPresetData
  objcRetType = retAUSamplerBankPresetData
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data AUSamplerInstrumentData = AUSamplerInstrumentData
  { auSamplerInstrumentDataFileURL :: !(Ptr ())
  , auSamplerInstrumentDataInstrumentType :: !CUChar
  , auSamplerInstrumentDataBankMSB :: !CUChar
  , auSamplerInstrumentDataBankLSB :: !CUChar
  , auSamplerInstrumentDataPresetID :: !CUChar
  } deriving (Eq, Show)

instance Storable AUSamplerInstrumentData where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = AUSamplerInstrumentData <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 9
    <*> peekByteOff p 10
    <*> peekByteOff p 11
  poke p (AUSamplerInstrumentData {..}) = do
    pokeByteOff p 0 auSamplerInstrumentDataFileURL
    pokeByteOff p 8 auSamplerInstrumentDataInstrumentType
    pokeByteOff p 9 auSamplerInstrumentDataBankMSB
    pokeByteOff p 10 auSamplerInstrumentDataBankLSB
    pokeByteOff p 11 auSamplerInstrumentDataPresetID

{-# NOINLINE auSamplerInstrumentDataStructType #-}
auSamplerInstrumentDataStructType :: Ptr CType
auSamplerInstrumentDataStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8]

argAUSamplerInstrumentData :: AUSamplerInstrumentData -> Arg
argAUSamplerInstrumentData = mkStorableArg auSamplerInstrumentDataStructType

retAUSamplerInstrumentData :: RetType AUSamplerInstrumentData
retAUSamplerInstrumentData = mkStorableRetType auSamplerInstrumentDataStructType

instance ObjCArgument AUSamplerInstrumentData where
  withObjCArg x k = k (argAUSamplerInstrumentData x)

instance ObjCReturn AUSamplerInstrumentData where
  type RawReturn AUSamplerInstrumentData = AUSamplerInstrumentData
  objcRetType = retAUSamplerInstrumentData
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AUVoiceIOOtherAudioDuckingConfiguration
--
-- The configuration of ducking other (i.e. non-voice) audio
--
-- mEnableAdvancedDucking
--
-- Enables advanced ducking which ducks other audio based on the presence of voice activity from local and/or remote chat participants.
--
-- mDuckingLevel
--
-- Ducking level of other audio
data AUVoiceIOOtherAudioDuckingConfiguration = AUVoiceIOOtherAudioDuckingConfiguration
  { auVoiceIOOtherAudioDuckingConfigurationMEnableAdvancedDucking :: !CUChar
  , auVoiceIOOtherAudioDuckingConfigurationMDuckingLevel :: !AUVoiceIOOtherAudioDuckingLevel
  } deriving (Eq, Show)

instance Storable AUVoiceIOOtherAudioDuckingConfiguration where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = AUVoiceIOOtherAudioDuckingConfiguration <$> peekByteOff p 0
    <*> peekByteOff p 4
  poke p (AUVoiceIOOtherAudioDuckingConfiguration {..}) = do
    pokeByteOff p 0 auVoiceIOOtherAudioDuckingConfigurationMEnableAdvancedDucking
    pokeByteOff p 4 auVoiceIOOtherAudioDuckingConfigurationMDuckingLevel

{-# NOINLINE auVoiceIOOtherAudioDuckingConfigurationStructType #-}
auVoiceIOOtherAudioDuckingConfigurationStructType :: Ptr CType
auVoiceIOOtherAudioDuckingConfigurationStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint]

argAUVoiceIOOtherAudioDuckingConfiguration :: AUVoiceIOOtherAudioDuckingConfiguration -> Arg
argAUVoiceIOOtherAudioDuckingConfiguration = mkStorableArg auVoiceIOOtherAudioDuckingConfigurationStructType

retAUVoiceIOOtherAudioDuckingConfiguration :: RetType AUVoiceIOOtherAudioDuckingConfiguration
retAUVoiceIOOtherAudioDuckingConfiguration = mkStorableRetType auVoiceIOOtherAudioDuckingConfigurationStructType

instance ObjCArgument AUVoiceIOOtherAudioDuckingConfiguration where
  withObjCArg x k = k (argAUVoiceIOOtherAudioDuckingConfiguration x)

instance ObjCReturn AUVoiceIOOtherAudioDuckingConfiguration where
  type RawReturn AUVoiceIOOtherAudioDuckingConfiguration = AUVoiceIOOtherAudioDuckingConfiguration
  objcRetType = retAUVoiceIOOtherAudioDuckingConfiguration
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AudioBytePacketTranslation
--
-- used for properties kAudioFileByteToPacket and kAudioFilePacketToByte
--
-- See description of kAudioFileByteToPacket and kAudioFilePacketToByte
--
-- mByte		a byte number.
--
-- mPacket		a packet number.
--
-- mByteOffsetInPacket		a byte offset in a packet.
--
-- mFlags		if kBytePacketTranslationFlag_IsEstimate is set, then the value is an estimate.
data AudioBytePacketTranslation = AudioBytePacketTranslation
  { audioBytePacketTranslationMByte :: !CLong
  , audioBytePacketTranslationMPacket :: !CLong
  , audioBytePacketTranslationMByteOffsetInPacket :: !CUInt
  , audioBytePacketTranslationMFlags :: !AudioBytePacketTranslationFlags
  } deriving (Eq, Show)

instance Storable AudioBytePacketTranslation where
  sizeOf    _ = 24
  alignment _ = 8
  peek p = AudioBytePacketTranslation <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 20
  poke p (AudioBytePacketTranslation {..}) = do
    pokeByteOff p 0 audioBytePacketTranslationMByte
    pokeByteOff p 8 audioBytePacketTranslationMPacket
    pokeByteOff p 16 audioBytePacketTranslationMByteOffsetInPacket
    pokeByteOff p 20 audioBytePacketTranslationMFlags

{-# NOINLINE audioBytePacketTranslationStructType #-}
audioBytePacketTranslationStructType :: Ptr CType
audioBytePacketTranslationStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_slong, ffi_type_slong, ffi_type_uint, ffi_type_uint]

argAudioBytePacketTranslation :: AudioBytePacketTranslation -> Arg
argAudioBytePacketTranslation = mkStorableArg audioBytePacketTranslationStructType

retAudioBytePacketTranslation :: RetType AudioBytePacketTranslation
retAudioBytePacketTranslation = mkStorableRetType audioBytePacketTranslationStructType

instance ObjCArgument AudioBytePacketTranslation where
  withObjCArg x k = k (argAudioBytePacketTranslation x)

instance ObjCReturn AudioBytePacketTranslation where
  type RawReturn AudioBytePacketTranslation = AudioBytePacketTranslation
  objcRetType = retAudioBytePacketTranslation
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AudioCodecMagicCookieInfo
--
-- Structure holding the magic cookie information.
--
-- Passed as input to AudioCodecGetProperty for kAudioCodecPropertyFormatList.				The first four + sizeof(void *) bytes of the buffer pointed at by outPropertyData				will contain this struct.
--
-- mMagicCookieSize
--
-- The size of the magic cookie
--
-- mMagicCookie
--
-- Generic const pointer to magic cookie
data AudioCodecMagicCookieInfo = AudioCodecMagicCookieInfo
  { audioCodecMagicCookieInfoMMagicCookieSize :: !CUInt
  , audioCodecMagicCookieInfoMMagicCookie :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable AudioCodecMagicCookieInfo where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = AudioCodecMagicCookieInfo <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (AudioCodecMagicCookieInfo {..}) = do
    pokeByteOff p 0 audioCodecMagicCookieInfoMMagicCookieSize
    pokeByteOff p 8 audioCodecMagicCookieInfoMMagicCookie

{-# NOINLINE audioCodecMagicCookieInfoStructType #-}
audioCodecMagicCookieInfoStructType :: Ptr CType
audioCodecMagicCookieInfoStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_pointer]

argAudioCodecMagicCookieInfo :: AudioCodecMagicCookieInfo -> Arg
argAudioCodecMagicCookieInfo = mkStorableArg audioCodecMagicCookieInfoStructType

retAudioCodecMagicCookieInfo :: RetType AudioCodecMagicCookieInfo
retAudioCodecMagicCookieInfo = mkStorableRetType audioCodecMagicCookieInfoStructType

instance ObjCArgument AudioCodecMagicCookieInfo where
  withObjCArg x k = k (argAudioCodecMagicCookieInfo x)

instance ObjCReturn AudioCodecMagicCookieInfo where
  type RawReturn AudioCodecMagicCookieInfo = AudioCodecMagicCookieInfo
  objcRetType = retAudioCodecMagicCookieInfo
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AudioCodecPrimeInfo
--
-- Specifies the number of leading and trailing empty frames					which have to be inserted.
--
-- leadingFrames
--
-- An unsigned integer specifying the number of leading empty frames
--
-- trailingFrames
--
-- An unsigned integer specifying the number of trailing empty frames
data AudioCodecPrimeInfo = AudioCodecPrimeInfo
  { audioCodecPrimeInfoLeadingFrames :: !CUInt
  , audioCodecPrimeInfoTrailingFrames :: !CUInt
  } deriving (Eq, Show)

instance Storable AudioCodecPrimeInfo where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = AudioCodecPrimeInfo <$> peekByteOff p 0
    <*> peekByteOff p 4
  poke p (AudioCodecPrimeInfo {..}) = do
    pokeByteOff p 0 audioCodecPrimeInfoLeadingFrames
    pokeByteOff p 4 audioCodecPrimeInfoTrailingFrames

{-# NOINLINE audioCodecPrimeInfoStructType #-}
audioCodecPrimeInfoStructType :: Ptr CType
audioCodecPrimeInfoStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint]

argAudioCodecPrimeInfo :: AudioCodecPrimeInfo -> Arg
argAudioCodecPrimeInfo = mkStorableArg audioCodecPrimeInfoStructType

retAudioCodecPrimeInfo :: RetType AudioCodecPrimeInfo
retAudioCodecPrimeInfo = mkStorableRetType audioCodecPrimeInfoStructType

instance ObjCArgument AudioCodecPrimeInfo where
  withObjCArg x k = k (argAudioCodecPrimeInfo x)

instance ObjCReturn AudioCodecPrimeInfo where
  type RawReturn AudioCodecPrimeInfo = AudioCodecPrimeInfo
  objcRetType = retAudioCodecPrimeInfo
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data AudioComponentDescription = AudioComponentDescription
  { audioComponentDescriptionComponentType :: !CUInt
  , audioComponentDescriptionComponentSubType :: !CUInt
  , audioComponentDescriptionComponentManufacturer :: !CUInt
  , audioComponentDescriptionComponentFlags :: !CUInt
  , audioComponentDescriptionComponentFlagsMask :: !CUInt
  } deriving (Eq, Show)

instance Storable AudioComponentDescription where
  sizeOf    _ = 20
  alignment _ = 4
  peek p = AudioComponentDescription <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
    <*> peekByteOff p 16
  poke p (AudioComponentDescription {..}) = do
    pokeByteOff p 0 audioComponentDescriptionComponentType
    pokeByteOff p 4 audioComponentDescriptionComponentSubType
    pokeByteOff p 8 audioComponentDescriptionComponentManufacturer
    pokeByteOff p 12 audioComponentDescriptionComponentFlags
    pokeByteOff p 16 audioComponentDescriptionComponentFlagsMask

{-# NOINLINE audioComponentDescriptionStructType #-}
audioComponentDescriptionStructType :: Ptr CType
audioComponentDescriptionStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint]

argAudioComponentDescription :: AudioComponentDescription -> Arg
argAudioComponentDescription = mkStorableArg audioComponentDescriptionStructType

retAudioComponentDescription :: RetType AudioComponentDescription
retAudioComponentDescription = mkStorableRetType audioComponentDescriptionStructType

instance ObjCArgument AudioComponentDescription where
  withObjCArg x k = k (argAudioComponentDescription x)

instance ObjCReturn AudioComponentDescription where
  type RawReturn AudioComponentDescription = AudioComponentDescription
  objcRetType = retAudioComponentDescription
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AudioComponentPlugInInterface
--
-- A structure used to represent an audio plugin's routines
--
-- Open
--
-- the function used to open (or create) an audio plugin instance
--
-- Close
--
-- the function used to close (or dispose) an audio plugin instance
--
-- Lookup
--
-- this is used to return a function pointer for a given selector, 						or NULL if that selector is not implemented
--
-- reserved
--
-- must be NULL
data AudioComponentPlugInInterface = AudioComponentPlugInInterface
  { audioComponentPlugInInterfaceOpen :: !(Ptr ())
  , audioComponentPlugInInterfaceClose :: !(Ptr ())
  , audioComponentPlugInInterfaceLookup :: !(Ptr ())
  , audioComponentPlugInInterfaceReserved :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable AudioComponentPlugInInterface where
  sizeOf    _ = 32
  alignment _ = 8
  peek p = AudioComponentPlugInInterface <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 24
  poke p (AudioComponentPlugInInterface {..}) = do
    pokeByteOff p 0 audioComponentPlugInInterfaceOpen
    pokeByteOff p 8 audioComponentPlugInInterfaceClose
    pokeByteOff p 16 audioComponentPlugInInterfaceLookup
    pokeByteOff p 24 audioComponentPlugInInterfaceReserved

{-# NOINLINE audioComponentPlugInInterfaceStructType #-}
audioComponentPlugInInterfaceStructType :: Ptr CType
audioComponentPlugInInterfaceStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer]

argAudioComponentPlugInInterface :: AudioComponentPlugInInterface -> Arg
argAudioComponentPlugInInterface = mkStorableArg audioComponentPlugInInterfaceStructType

retAudioComponentPlugInInterface :: RetType AudioComponentPlugInInterface
retAudioComponentPlugInInterface = mkStorableRetType audioComponentPlugInInterfaceStructType

instance ObjCArgument AudioComponentPlugInInterface where
  withObjCArg x k = k (argAudioComponentPlugInInterface x)

instance ObjCReturn AudioComponentPlugInInterface where
  type RawReturn AudioComponentPlugInInterface = AudioComponentPlugInInterface
  objcRetType = retAudioComponentPlugInInterface
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AudioConverterPrimeInfo
--
-- Specifies priming information.
--
-- When using AudioConverterFillComplexBuffer() (either a single call or a series of calls), some	conversions, particularly involving sample-rate conversion, ideally require a certain	number of input frames previous to the normal start input frame and beyond the end of	the last expected input frame in order to yield high-quality results.
--
-- These are expressed in the leadingFrames and trailingFrames members of the structure.
--
-- The very first call to AudioConverterFillComplexBuffer(), or first call after	AudioConverterReset(), will request additional input frames beyond those normally	expected in the input proc callback to fulfill this first AudioConverterFillComplexBuffer()	request. The number of additional frames requested, depending on the prime method, will	be approximately:
--
-- Prime method                  | Additional frames	------------------------------|----------------------	kConverterPrimeMethod_Pre     | leadingFrames + trailingFrames	kConverterPrimeMethod_Normal  | trailingFrames	kConverterPrimeMethod_None    | 0
--
-- Thus, in effect, the first input proc callback(s) may provide not only the leading	frames, but also may "read ahead" by an additional number of trailing frames depending	on the prime method.
--
-- kConverterPrimeMethod_None is useful in a real-time application processing live input,	in which case trailingFrames (relative to input sample rate) of through latency will be	seen at the beginning of the output of the AudioConverter.  In other real-time	applications such as DAW systems, it may be possible to provide these initial extra	audio frames since they are stored on disk or in memory somewhere and	kConverterPrimeMethod_Pre may be preferable.  The default method is	kConverterPrimeMethod_Normal, which requires no pre-seeking of the input stream and	generates no latency at the output.
--
-- leadingFrames
--
-- Specifies the number of leading (previous) input frames, relative to the normal/desired        start input frame, required by the converter to perform a high quality conversion. If        using kConverterPrimeMethod_Pre, the client should "pre-seek" the input stream provided        through the input proc by leadingFrames. If no frames are available previous to the        desired input start frame (because, for example, the desired start frame is at the very        beginning of available audio), then provide "leadingFrames" worth of initial zero frames        in the input proc.  Do not "pre-seek" in the default case of        kConverterPrimeMethod_Normal or when using kConverterPrimeMethod_None.
--
-- trailingFrames
--
-- Specifies the number of trailing input frames (past the normal/expected end input frame)        required by the converter to perform a high quality conversion.  The client should be        prepared to provide this number of additional input frames except when using        kConverterPrimeMethod_None. If no more frames of input are available in the input stream        (because, for example, the desired end frame is at the end of an audio file), then zero        (silent) trailing frames will be synthesized for the client.
data AudioConverterPrimeInfo = AudioConverterPrimeInfo
  { audioConverterPrimeInfoLeadingFrames :: !CUInt
  , audioConverterPrimeInfoTrailingFrames :: !CUInt
  } deriving (Eq, Show)

instance Storable AudioConverterPrimeInfo where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = AudioConverterPrimeInfo <$> peekByteOff p 0
    <*> peekByteOff p 4
  poke p (AudioConverterPrimeInfo {..}) = do
    pokeByteOff p 0 audioConverterPrimeInfoLeadingFrames
    pokeByteOff p 4 audioConverterPrimeInfoTrailingFrames

{-# NOINLINE audioConverterPrimeInfoStructType #-}
audioConverterPrimeInfoStructType :: Ptr CType
audioConverterPrimeInfoStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint]

argAudioConverterPrimeInfo :: AudioConverterPrimeInfo -> Arg
argAudioConverterPrimeInfo = mkStorableArg audioConverterPrimeInfoStructType

retAudioConverterPrimeInfo :: RetType AudioConverterPrimeInfo
retAudioConverterPrimeInfo = mkStorableRetType audioConverterPrimeInfoStructType

instance ObjCArgument AudioConverterPrimeInfo where
  withObjCArg x k = k (argAudioConverterPrimeInfo x)

instance ObjCReturn AudioConverterPrimeInfo where
  type RawReturn AudioConverterPrimeInfo = AudioConverterPrimeInfo
  objcRetType = retAudioConverterPrimeInfo
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data AudioFileFDFTable = AudioFileFDFTable
  { audioFileFDFTableMComponentStorage :: !(Ptr ())
  , audioFileFDFTableMReadBytesFDF :: !(Ptr ())
  , audioFileFDFTableMWriteBytesFDF :: !(Ptr ())
  , audioFileFDFTableMReadPacketsFDF :: !(Ptr ())
  , audioFileFDFTableMWritePacketsFDF :: !(Ptr ())
  , audioFileFDFTableMGetPropertyInfoFDF :: !(Ptr ())
  , audioFileFDFTableMGetPropertyFDF :: !(Ptr ())
  , audioFileFDFTableMSetPropertyFDF :: !(Ptr ())
  , audioFileFDFTableMCountUserDataFDF :: !(Ptr ())
  , audioFileFDFTableMGetUserDataSizeFDF :: !(Ptr ())
  , audioFileFDFTableMGetUserDataFDF :: !(Ptr ())
  , audioFileFDFTableMSetUserDataFDF :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable AudioFileFDFTable where
  sizeOf    _ = 96
  alignment _ = 8
  peek p = AudioFileFDFTable <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 24
    <*> peekByteOff p 32
    <*> peekByteOff p 40
    <*> peekByteOff p 48
    <*> peekByteOff p 56
    <*> peekByteOff p 64
    <*> peekByteOff p 72
    <*> peekByteOff p 80
    <*> peekByteOff p 88
  poke p (AudioFileFDFTable {..}) = do
    pokeByteOff p 0 audioFileFDFTableMComponentStorage
    pokeByteOff p 8 audioFileFDFTableMReadBytesFDF
    pokeByteOff p 16 audioFileFDFTableMWriteBytesFDF
    pokeByteOff p 24 audioFileFDFTableMReadPacketsFDF
    pokeByteOff p 32 audioFileFDFTableMWritePacketsFDF
    pokeByteOff p 40 audioFileFDFTableMGetPropertyInfoFDF
    pokeByteOff p 48 audioFileFDFTableMGetPropertyFDF
    pokeByteOff p 56 audioFileFDFTableMSetPropertyFDF
    pokeByteOff p 64 audioFileFDFTableMCountUserDataFDF
    pokeByteOff p 72 audioFileFDFTableMGetUserDataSizeFDF
    pokeByteOff p 80 audioFileFDFTableMGetUserDataFDF
    pokeByteOff p 88 audioFileFDFTableMSetUserDataFDF

{-# NOINLINE audioFileFDFTableStructType #-}
audioFileFDFTableStructType :: Ptr CType
audioFileFDFTableStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer]

argAudioFileFDFTable :: AudioFileFDFTable -> Arg
argAudioFileFDFTable = mkStorableArg audioFileFDFTableStructType

retAudioFileFDFTable :: RetType AudioFileFDFTable
retAudioFileFDFTable = mkStorableRetType audioFileFDFTableStructType

instance ObjCArgument AudioFileFDFTable where
  withObjCArg x k = k (argAudioFileFDFTable x)

instance ObjCReturn AudioFileFDFTable where
  type RawReturn AudioFileFDFTable = AudioFileFDFTable
  objcRetType = retAudioFileFDFTable
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data AudioFileFDFTableExtended = AudioFileFDFTableExtended
  { audioFileFDFTableExtendedMComponentStorage :: !(Ptr ())
  , audioFileFDFTableExtendedMReadBytesFDF :: !(Ptr ())
  , audioFileFDFTableExtendedMWriteBytesFDF :: !(Ptr ())
  , audioFileFDFTableExtendedMReadPacketsFDF :: !(Ptr ())
  , audioFileFDFTableExtendedMWritePacketsFDF :: !(Ptr ())
  , audioFileFDFTableExtendedMGetPropertyInfoFDF :: !(Ptr ())
  , audioFileFDFTableExtendedMGetPropertyFDF :: !(Ptr ())
  , audioFileFDFTableExtendedMSetPropertyFDF :: !(Ptr ())
  , audioFileFDFTableExtendedMCountUserDataFDF :: !(Ptr ())
  , audioFileFDFTableExtendedMGetUserDataSizeFDF :: !(Ptr ())
  , audioFileFDFTableExtendedMGetUserDataFDF :: !(Ptr ())
  , audioFileFDFTableExtendedMSetUserDataFDF :: !(Ptr ())
  , audioFileFDFTableExtendedMReadPacketDataFDF :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable AudioFileFDFTableExtended where
  sizeOf    _ = 104
  alignment _ = 8
  peek p = AudioFileFDFTableExtended <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 24
    <*> peekByteOff p 32
    <*> peekByteOff p 40
    <*> peekByteOff p 48
    <*> peekByteOff p 56
    <*> peekByteOff p 64
    <*> peekByteOff p 72
    <*> peekByteOff p 80
    <*> peekByteOff p 88
    <*> peekByteOff p 96
  poke p (AudioFileFDFTableExtended {..}) = do
    pokeByteOff p 0 audioFileFDFTableExtendedMComponentStorage
    pokeByteOff p 8 audioFileFDFTableExtendedMReadBytesFDF
    pokeByteOff p 16 audioFileFDFTableExtendedMWriteBytesFDF
    pokeByteOff p 24 audioFileFDFTableExtendedMReadPacketsFDF
    pokeByteOff p 32 audioFileFDFTableExtendedMWritePacketsFDF
    pokeByteOff p 40 audioFileFDFTableExtendedMGetPropertyInfoFDF
    pokeByteOff p 48 audioFileFDFTableExtendedMGetPropertyFDF
    pokeByteOff p 56 audioFileFDFTableExtendedMSetPropertyFDF
    pokeByteOff p 64 audioFileFDFTableExtendedMCountUserDataFDF
    pokeByteOff p 72 audioFileFDFTableExtendedMGetUserDataSizeFDF
    pokeByteOff p 80 audioFileFDFTableExtendedMGetUserDataFDF
    pokeByteOff p 88 audioFileFDFTableExtendedMSetUserDataFDF
    pokeByteOff p 96 audioFileFDFTableExtendedMReadPacketDataFDF

{-# NOINLINE audioFileFDFTableExtendedStructType #-}
audioFileFDFTableExtendedStructType :: Ptr CType
audioFileFDFTableExtendedStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer]

argAudioFileFDFTableExtended :: AudioFileFDFTableExtended -> Arg
argAudioFileFDFTableExtended = mkStorableArg audioFileFDFTableExtendedStructType

retAudioFileFDFTableExtended :: RetType AudioFileFDFTableExtended
retAudioFileFDFTableExtended = mkStorableRetType audioFileFDFTableExtendedStructType

instance ObjCArgument AudioFileFDFTableExtended where
  withObjCArg x k = k (argAudioFileFDFTableExtended x)

instance ObjCReturn AudioFileFDFTableExtended where
  type RawReturn AudioFileFDFTableExtended = AudioFileFDFTableExtended
  objcRetType = retAudioFileFDFTableExtended
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AudioFilePacketTableInfo
--
-- This contains information about the number of valid frames in a file and where they begin and end.
--
-- Some data formats may have packets whose contents are not completely valid, but represent priming or remainder 				frames that are not meant to be played. For example a file with 100 packets of AAC is nominally 1024 * 100 = 102400 frames				of data. However the first 2112 frames of that may be priming frames and there may be some 				number of remainder frames added to pad out to a full packet of 1024 frames. The priming and remainder frames should be 				discarded. The total number of packets in the file times the frames per packet (or counting each packet's frames 				individually for a variable frames per packet format) minus mPrimingFrames, minus mRemainderFrames, should 				equal mNumberValidFrames.
--
-- mNumberValidFrames the number of valid frames in the file.
--
-- mPrimingFrames the number of invalid frames at the beginning of the file.
--
-- mRemainderFrames the number of invalid frames at the end of the file.
data AudioFilePacketTableInfo = AudioFilePacketTableInfo
  { audioFilePacketTableInfoMNumberValidFrames :: !CLong
  , audioFilePacketTableInfoMPrimingFrames :: !CInt
  , audioFilePacketTableInfoMRemainderFrames :: !CInt
  } deriving (Eq, Show)

instance Storable AudioFilePacketTableInfo where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = AudioFilePacketTableInfo <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 12
  poke p (AudioFilePacketTableInfo {..}) = do
    pokeByteOff p 0 audioFilePacketTableInfoMNumberValidFrames
    pokeByteOff p 8 audioFilePacketTableInfoMPrimingFrames
    pokeByteOff p 12 audioFilePacketTableInfoMRemainderFrames

{-# NOINLINE audioFilePacketTableInfoStructType #-}
audioFilePacketTableInfoStructType :: Ptr CType
audioFilePacketTableInfoStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_slong, ffi_type_sint, ffi_type_sint]

argAudioFilePacketTableInfo :: AudioFilePacketTableInfo -> Arg
argAudioFilePacketTableInfo = mkStorableArg audioFilePacketTableInfoStructType

retAudioFilePacketTableInfo :: RetType AudioFilePacketTableInfo
retAudioFilePacketTableInfo = mkStorableRetType audioFilePacketTableInfoStructType

instance ObjCArgument AudioFilePacketTableInfo where
  withObjCArg x k = k (argAudioFilePacketTableInfo x)

instance ObjCReturn AudioFilePacketTableInfo where
  type RawReturn AudioFilePacketTableInfo = AudioFilePacketTableInfo
  objcRetType = retAudioFilePacketTableInfo
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AudioFileTypeAndFormatID
--
-- This is used as a specifier for kAudioFileGlobalInfo_AvailableStreamDescriptions
--
-- This struct is used to specify a desired audio file type and data format ID  so				that a list of stream descriptions of available formats can be obtained.
--
-- mFileType
--
-- a four char code for the file type such as kAudioFileAIFFType, kAudioFileCAFType, etc.
--
-- mFormatID
--
-- a four char code for the format ID such as kAudioFormatLinearPCM, kAudioFormatMPEG4AAC, etc.
data AudioFileTypeAndFormatID = AudioFileTypeAndFormatID
  { audioFileTypeAndFormatIDMFileType :: !CUInt
  , audioFileTypeAndFormatIDMFormatID :: !CUInt
  } deriving (Eq, Show)

instance Storable AudioFileTypeAndFormatID where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = AudioFileTypeAndFormatID <$> peekByteOff p 0
    <*> peekByteOff p 4
  poke p (AudioFileTypeAndFormatID {..}) = do
    pokeByteOff p 0 audioFileTypeAndFormatIDMFileType
    pokeByteOff p 4 audioFileTypeAndFormatIDMFormatID

{-# NOINLINE audioFileTypeAndFormatIDStructType #-}
audioFileTypeAndFormatIDStructType :: Ptr CType
audioFileTypeAndFormatIDStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint]

argAudioFileTypeAndFormatID :: AudioFileTypeAndFormatID -> Arg
argAudioFileTypeAndFormatID = mkStorableArg audioFileTypeAndFormatIDStructType

retAudioFileTypeAndFormatID :: RetType AudioFileTypeAndFormatID
retAudioFileTypeAndFormatID = mkStorableRetType audioFileTypeAndFormatIDStructType

instance ObjCArgument AudioFileTypeAndFormatID where
  withObjCArg x k = k (argAudioFileTypeAndFormatID x)

instance ObjCReturn AudioFileTypeAndFormatID where
  type RawReturn AudioFileTypeAndFormatID = AudioFileTypeAndFormatID
  objcRetType = retAudioFileTypeAndFormatID
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AudioFile_SMPTE_Time
--
-- A struct for describing a SMPTE time.
--
-- mHours						The hours.
--
-- mMinutes					The minutes.
--
-- mSeconds					The seconds.
--
-- mFrames						The frames.
--
-- mSubFrameSampleOffset		The sample offset within a frame.
data AudioFile_SMPTE_Time = AudioFile_SMPTE_Time
  { audioFile_SMPTE_TimeMHours :: !CSChar
  , audioFile_SMPTE_TimeMMinutes :: !CUChar
  , audioFile_SMPTE_TimeMSeconds :: !CUChar
  , audioFile_SMPTE_TimeMFrames :: !CUChar
  , audioFile_SMPTE_TimeMSubFrameSampleOffset :: !CUInt
  } deriving (Eq, Show)

instance Storable AudioFile_SMPTE_Time where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = AudioFile_SMPTE_Time <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
    <*> peekByteOff p 3
    <*> peekByteOff p 4
  poke p (AudioFile_SMPTE_Time {..}) = do
    pokeByteOff p 0 audioFile_SMPTE_TimeMHours
    pokeByteOff p 1 audioFile_SMPTE_TimeMMinutes
    pokeByteOff p 2 audioFile_SMPTE_TimeMSeconds
    pokeByteOff p 3 audioFile_SMPTE_TimeMFrames
    pokeByteOff p 4 audioFile_SMPTE_TimeMSubFrameSampleOffset

{-# NOINLINE audioFile_SMPTE_TimeStructType #-}
audioFile_SMPTE_TimeStructType :: Ptr CType
audioFile_SMPTE_TimeStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint]

argAudioFile_SMPTE_Time :: AudioFile_SMPTE_Time -> Arg
argAudioFile_SMPTE_Time = mkStorableArg audioFile_SMPTE_TimeStructType

retAudioFile_SMPTE_Time :: RetType AudioFile_SMPTE_Time
retAudioFile_SMPTE_Time = mkStorableRetType audioFile_SMPTE_TimeStructType

instance ObjCArgument AudioFile_SMPTE_Time where
  withObjCArg x k = k (argAudioFile_SMPTE_Time x)

instance ObjCReturn AudioFile_SMPTE_Time where
  type RawReturn AudioFile_SMPTE_Time = AudioFile_SMPTE_Time
  objcRetType = retAudioFile_SMPTE_Time
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AudioFramePacketTranslation
--
-- used for properties kAudioFilePropertyPacketToFrame and kAudioFilePropertyFrameToPacket
--
-- See description of kAudioFilePropertyPacketToFrame and kAudioFilePropertyFrameToPacket
--
-- mFrame		a frame number.
--
-- mPacket		a packet number.
--
-- mFrameOffsetInPacket		a frame offset in a packet.
data AudioFramePacketTranslation = AudioFramePacketTranslation
  { audioFramePacketTranslationMFrame :: !CLong
  , audioFramePacketTranslationMPacket :: !CLong
  , audioFramePacketTranslationMFrameOffsetInPacket :: !CUInt
  } deriving (Eq, Show)

instance Storable AudioFramePacketTranslation where
  sizeOf    _ = 24
  alignment _ = 8
  peek p = AudioFramePacketTranslation <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
  poke p (AudioFramePacketTranslation {..}) = do
    pokeByteOff p 0 audioFramePacketTranslationMFrame
    pokeByteOff p 8 audioFramePacketTranslationMPacket
    pokeByteOff p 16 audioFramePacketTranslationMFrameOffsetInPacket

{-# NOINLINE audioFramePacketTranslationStructType #-}
audioFramePacketTranslationStructType :: Ptr CType
audioFramePacketTranslationStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_slong, ffi_type_slong, ffi_type_uint]

argAudioFramePacketTranslation :: AudioFramePacketTranslation -> Arg
argAudioFramePacketTranslation = mkStorableArg audioFramePacketTranslationStructType

retAudioFramePacketTranslation :: RetType AudioFramePacketTranslation
retAudioFramePacketTranslation = mkStorableRetType audioFramePacketTranslationStructType

instance ObjCArgument AudioFramePacketTranslation where
  withObjCArg x k = k (argAudioFramePacketTranslation x)

instance ObjCReturn AudioFramePacketTranslation where
  type RawReturn AudioFramePacketTranslation = AudioFramePacketTranslation
  objcRetType = retAudioFramePacketTranslation
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AudioIndependentPacketTranslation
--
-- used for property kAudioFilePropertyPreviousIndependentPacket and kAudioFilePropertyNextIndependentPacket
--
-- See descriptions of kAudioFilePropertyPreviousIndependentPacket and kAudioFilePropertyNextIndependentPacket
--
-- mPacket                         a packet number
--
-- mIndependentlyDecodablePacket   a packet number not equal to mPacket of an independent packet
data AudioIndependentPacketTranslation = AudioIndependentPacketTranslation
  { audioIndependentPacketTranslationMPacket :: !CLong
  , audioIndependentPacketTranslationMIndependentlyDecodablePacket :: !CLong
  } deriving (Eq, Show)

instance Storable AudioIndependentPacketTranslation where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = AudioIndependentPacketTranslation <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (AudioIndependentPacketTranslation {..}) = do
    pokeByteOff p 0 audioIndependentPacketTranslationMPacket
    pokeByteOff p 8 audioIndependentPacketTranslationMIndependentlyDecodablePacket

{-# NOINLINE audioIndependentPacketTranslationStructType #-}
audioIndependentPacketTranslationStructType :: Ptr CType
audioIndependentPacketTranslationStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_slong, ffi_type_slong]

argAudioIndependentPacketTranslation :: AudioIndependentPacketTranslation -> Arg
argAudioIndependentPacketTranslation = mkStorableArg audioIndependentPacketTranslationStructType

retAudioIndependentPacketTranslation :: RetType AudioIndependentPacketTranslation
retAudioIndependentPacketTranslation = mkStorableRetType audioIndependentPacketTranslationStructType

instance ObjCArgument AudioIndependentPacketTranslation where
  withObjCArg x k = k (argAudioIndependentPacketTranslation x)

instance ObjCReturn AudioIndependentPacketTranslation where
  type RawReturn AudioIndependentPacketTranslation = AudioIndependentPacketTranslation
  objcRetType = retAudioIndependentPacketTranslation
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AudioOutputUnitMIDICallbacks
--
-- For inter-app audio, callbacks for receiving MIDI messages.
--
-- The supplied callback functions are called from the realtime rendering thread, before each		render cycle, to provide any incoming MIDI messages.
data AudioOutputUnitMIDICallbacks = AudioOutputUnitMIDICallbacks
  { audioOutputUnitMIDICallbacksUserData :: !(Ptr ())
  , audioOutputUnitMIDICallbacksMIDIEventProc :: !(Ptr ())
  , audioOutputUnitMIDICallbacksMIDISysExProc :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable AudioOutputUnitMIDICallbacks where
  sizeOf    _ = 24
  alignment _ = 8
  peek p = AudioOutputUnitMIDICallbacks <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
  poke p (AudioOutputUnitMIDICallbacks {..}) = do
    pokeByteOff p 0 audioOutputUnitMIDICallbacksUserData
    pokeByteOff p 8 audioOutputUnitMIDICallbacksMIDIEventProc
    pokeByteOff p 16 audioOutputUnitMIDICallbacksMIDISysExProc

{-# NOINLINE audioOutputUnitMIDICallbacksStructType #-}
audioOutputUnitMIDICallbacksStructType :: Ptr CType
audioOutputUnitMIDICallbacksStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer, ffi_type_pointer, ffi_type_pointer]

argAudioOutputUnitMIDICallbacks :: AudioOutputUnitMIDICallbacks -> Arg
argAudioOutputUnitMIDICallbacks = mkStorableArg audioOutputUnitMIDICallbacksStructType

retAudioOutputUnitMIDICallbacks :: RetType AudioOutputUnitMIDICallbacks
retAudioOutputUnitMIDICallbacks = mkStorableRetType audioOutputUnitMIDICallbacksStructType

instance ObjCArgument AudioOutputUnitMIDICallbacks where
  withObjCArg x k = k (argAudioOutputUnitMIDICallbacks x)

instance ObjCReturn AudioOutputUnitMIDICallbacks where
  type RawReturn AudioOutputUnitMIDICallbacks = AudioOutputUnitMIDICallbacks
  objcRetType = retAudioOutputUnitMIDICallbacks
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AudioPacketDependencyInfoTranslation
--
-- used for property kAudioFilePropertyPacketToDependencyInfo
--
-- See descriptions of kAudioFilePropertyPacketToDependencyInfo and kAudioFilePropertyRestrictsRandomAccess
--
-- mPacket                     a packet number
--
-- mIsIndependentlyDecodable   1 means that the specified packet is independently decodable; 0 means it's not
--
-- mNumberPrerollPackets       if the packet is independently decodable, the count of packets that must be decoded after the packet with the specified number in order to refresh the decoder
data AudioPacketDependencyInfoTranslation = AudioPacketDependencyInfoTranslation
  { audioPacketDependencyInfoTranslationMPacket :: !CLong
  , audioPacketDependencyInfoTranslationMIsIndependentlyDecodable :: !CUInt
  , audioPacketDependencyInfoTranslationMNumberPrerollPackets :: !CUInt
  } deriving (Eq, Show)

instance Storable AudioPacketDependencyInfoTranslation where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = AudioPacketDependencyInfoTranslation <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 12
  poke p (AudioPacketDependencyInfoTranslation {..}) = do
    pokeByteOff p 0 audioPacketDependencyInfoTranslationMPacket
    pokeByteOff p 8 audioPacketDependencyInfoTranslationMIsIndependentlyDecodable
    pokeByteOff p 12 audioPacketDependencyInfoTranslationMNumberPrerollPackets

{-# NOINLINE audioPacketDependencyInfoTranslationStructType #-}
audioPacketDependencyInfoTranslationStructType :: Ptr CType
audioPacketDependencyInfoTranslationStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_slong, ffi_type_uint, ffi_type_uint]

argAudioPacketDependencyInfoTranslation :: AudioPacketDependencyInfoTranslation -> Arg
argAudioPacketDependencyInfoTranslation = mkStorableArg audioPacketDependencyInfoTranslationStructType

retAudioPacketDependencyInfoTranslation :: RetType AudioPacketDependencyInfoTranslation
retAudioPacketDependencyInfoTranslation = mkStorableRetType audioPacketDependencyInfoTranslationStructType

instance ObjCArgument AudioPacketDependencyInfoTranslation where
  withObjCArg x k = k (argAudioPacketDependencyInfoTranslation x)

instance ObjCReturn AudioPacketDependencyInfoTranslation where
  type RawReturn AudioPacketDependencyInfoTranslation = AudioPacketDependencyInfoTranslation
  objcRetType = retAudioPacketDependencyInfoTranslation
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AudioPacketRangeByteCountTranslation
--
-- used for property kAudioFilePropertyPacketRangeByteCountUpperBound
--
-- See description of kAudioFilePropertyPacketRangeByteCountUpperBound
--
-- mPacket					a packet number.
--
-- mPacketCount			a packet count.
--
-- mByteCountUpperBound	an upper bound for the total size of the specified packets.
data AudioPacketRangeByteCountTranslation = AudioPacketRangeByteCountTranslation
  { audioPacketRangeByteCountTranslationMPacket :: !CLong
  , audioPacketRangeByteCountTranslationMPacketCount :: !CLong
  , audioPacketRangeByteCountTranslationMByteCountUpperBound :: !CLong
  } deriving (Eq, Show)

instance Storable AudioPacketRangeByteCountTranslation where
  sizeOf    _ = 24
  alignment _ = 8
  peek p = AudioPacketRangeByteCountTranslation <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
  poke p (AudioPacketRangeByteCountTranslation {..}) = do
    pokeByteOff p 0 audioPacketRangeByteCountTranslationMPacket
    pokeByteOff p 8 audioPacketRangeByteCountTranslationMPacketCount
    pokeByteOff p 16 audioPacketRangeByteCountTranslationMByteCountUpperBound

{-# NOINLINE audioPacketRangeByteCountTranslationStructType #-}
audioPacketRangeByteCountTranslationStructType :: Ptr CType
audioPacketRangeByteCountTranslationStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_slong, ffi_type_slong, ffi_type_slong]

argAudioPacketRangeByteCountTranslation :: AudioPacketRangeByteCountTranslation -> Arg
argAudioPacketRangeByteCountTranslation = mkStorableArg audioPacketRangeByteCountTranslationStructType

retAudioPacketRangeByteCountTranslation :: RetType AudioPacketRangeByteCountTranslation
retAudioPacketRangeByteCountTranslation = mkStorableRetType audioPacketRangeByteCountTranslationStructType

instance ObjCArgument AudioPacketRangeByteCountTranslation where
  withObjCArg x k = k (argAudioPacketRangeByteCountTranslation x)

instance ObjCReturn AudioPacketRangeByteCountTranslation where
  type RawReturn AudioPacketRangeByteCountTranslation = AudioPacketRangeByteCountTranslation
  objcRetType = retAudioPacketRangeByteCountTranslation
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AudioPacketRollDistanceTranslation
--
-- used for property kAudioFilePropertyPacketToRollDistance
--
-- See descriptions of kAudioFilePropertyPacketToRollDistance and kAudioFilePropertyRestrictsRandomAccess
--
-- mPacket         a packet number
--
-- mRollDistance   a count of packets that must be decoded prior to the packet with the specified number in order to achieve the best practice for the decoding of that packet
data AudioPacketRollDistanceTranslation = AudioPacketRollDistanceTranslation
  { audioPacketRollDistanceTranslationMPacket :: !CLong
  , audioPacketRollDistanceTranslationMRollDistance :: !CLong
  } deriving (Eq, Show)

instance Storable AudioPacketRollDistanceTranslation where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = AudioPacketRollDistanceTranslation <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (AudioPacketRollDistanceTranslation {..}) = do
    pokeByteOff p 0 audioPacketRollDistanceTranslationMPacket
    pokeByteOff p 8 audioPacketRollDistanceTranslationMRollDistance

{-# NOINLINE audioPacketRollDistanceTranslationStructType #-}
audioPacketRollDistanceTranslationStructType :: Ptr CType
audioPacketRollDistanceTranslationStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_slong, ffi_type_slong]

argAudioPacketRollDistanceTranslation :: AudioPacketRollDistanceTranslation -> Arg
argAudioPacketRollDistanceTranslation = mkStorableArg audioPacketRollDistanceTranslationStructType

retAudioPacketRollDistanceTranslation :: RetType AudioPacketRollDistanceTranslation
retAudioPacketRollDistanceTranslation = mkStorableRetType audioPacketRollDistanceTranslationStructType

instance ObjCArgument AudioPacketRollDistanceTranslation where
  withObjCArg x k = k (argAudioPacketRollDistanceTranslation x)

instance ObjCReturn AudioPacketRollDistanceTranslation where
  type RawReturn AudioPacketRollDistanceTranslation = AudioPacketRollDistanceTranslation
  objcRetType = retAudioPacketRollDistanceTranslation
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AudioQueueChannelAssignment
--
-- Specifies an audio device channel to which the queue will play or from which                it will record.
--
-- mDeviceUID
--
-- On iOS, this is a port UID obtained from AVAudioSession. On macOS, this is the UID        obtained from an AudioDeviceID.
--
-- mChannelNumber
--
-- The 1-based index of the channel.
data AudioQueueChannelAssignment = AudioQueueChannelAssignment
  { audioQueueChannelAssignmentMDeviceUID :: !(Ptr ())
  , audioQueueChannelAssignmentMChannelNumber :: !CUInt
  } deriving (Eq, Show)

instance Storable AudioQueueChannelAssignment where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = AudioQueueChannelAssignment <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (AudioQueueChannelAssignment {..}) = do
    pokeByteOff p 0 audioQueueChannelAssignmentMDeviceUID
    pokeByteOff p 8 audioQueueChannelAssignmentMChannelNumber

{-# NOINLINE audioQueueChannelAssignmentStructType #-}
audioQueueChannelAssignmentStructType :: Ptr CType
audioQueueChannelAssignmentStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer, ffi_type_uint]

argAudioQueueChannelAssignment :: AudioQueueChannelAssignment -> Arg
argAudioQueueChannelAssignment = mkStorableArg audioQueueChannelAssignmentStructType

retAudioQueueChannelAssignment :: RetType AudioQueueChannelAssignment
retAudioQueueChannelAssignment = mkStorableRetType audioQueueChannelAssignmentStructType

instance ObjCArgument AudioQueueChannelAssignment where
  withObjCArg x k = k (argAudioQueueChannelAssignment x)

instance ObjCReturn AudioQueueChannelAssignment where
  type RawReturn AudioQueueChannelAssignment = AudioQueueChannelAssignment
  objcRetType = retAudioQueueChannelAssignment
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AudioQueueLevelMeterState
--
-- Specifies the current level metering information for one channel of an audio queue.
--
-- mAveragePower
--
-- The audio channel's average RMS power.
--
-- mPeakPower
--
-- The audio channel's peak RMS power
data AudioQueueLevelMeterState = AudioQueueLevelMeterState
  { audioQueueLevelMeterStateMAveragePower :: !CFloat
  , audioQueueLevelMeterStateMPeakPower :: !CFloat
  } deriving (Eq, Show)

instance Storable AudioQueueLevelMeterState where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = AudioQueueLevelMeterState <$> peekByteOff p 0
    <*> peekByteOff p 4
  poke p (AudioQueueLevelMeterState {..}) = do
    pokeByteOff p 0 audioQueueLevelMeterStateMAveragePower
    pokeByteOff p 4 audioQueueLevelMeterStateMPeakPower

{-# NOINLINE audioQueueLevelMeterStateStructType #-}
audioQueueLevelMeterStateStructType :: Ptr CType
audioQueueLevelMeterStateStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_float, ffi_type_float]

argAudioQueueLevelMeterState :: AudioQueueLevelMeterState -> Arg
argAudioQueueLevelMeterState = mkStorableArg audioQueueLevelMeterStateStructType

retAudioQueueLevelMeterState :: RetType AudioQueueLevelMeterState
retAudioQueueLevelMeterState = mkStorableRetType audioQueueLevelMeterStateStructType

instance ObjCArgument AudioQueueLevelMeterState where
  withObjCArg x k = k (argAudioQueueLevelMeterState x)

instance ObjCReturn AudioQueueLevelMeterState where
  type RawReturn AudioQueueLevelMeterState = AudioQueueLevelMeterState
  objcRetType = retAudioQueueLevelMeterState
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AudioQueueParameterEvent
--
-- Specifies a value for an audio queue parameter.
--
-- Two ways are available to supply an audio queue with parameters:
--
-- - Provide one or more parameters by calling the AudioQueueEnqueueBufferWithParameters	function. In this case, the parameters are applied to the specified buffer when it is	played.
--
-- - Assign a parameter value immediately to an audio queue by calling the	AudioQueueSetParameter function.
--
-- Note that the AudioQueueGetParameter function always returns the actual value of the	parameter.
--
-- In macOS v10.5, audio queues have one parameter available: kAudioQueueParam_Volume,	which controls the queue's playback volume.
--
-- mID
--
-- The parameter.
--
-- mValue
--
-- The value of the specified parameter.
data AudioQueueParameterEvent = AudioQueueParameterEvent
  { audioQueueParameterEventMID :: !CUInt
  , audioQueueParameterEventMValue :: !CFloat
  } deriving (Eq, Show)

instance Storable AudioQueueParameterEvent where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = AudioQueueParameterEvent <$> peekByteOff p 0
    <*> peekByteOff p 4
  poke p (AudioQueueParameterEvent {..}) = do
    pokeByteOff p 0 audioQueueParameterEventMID
    pokeByteOff p 4 audioQueueParameterEventMValue

{-# NOINLINE audioQueueParameterEventStructType #-}
audioQueueParameterEventStructType :: Ptr CType
audioQueueParameterEventStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_float]

argAudioQueueParameterEvent :: AudioQueueParameterEvent -> Arg
argAudioQueueParameterEvent = mkStorableArg audioQueueParameterEventStructType

retAudioQueueParameterEvent :: RetType AudioQueueParameterEvent
retAudioQueueParameterEvent = mkStorableRetType audioQueueParameterEventStructType

instance ObjCArgument AudioQueueParameterEvent where
  withObjCArg x k = k (argAudioQueueParameterEvent x)

instance ObjCReturn AudioQueueParameterEvent where
  type RawReturn AudioQueueParameterEvent = AudioQueueParameterEvent
  objcRetType = retAudioQueueParameterEvent
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AudioUnitConnection
--
-- This structure contains the information needed to make a connection between a source					and destination audio unit.
--
-- The structure is set on the destination audio unit's input element
--
-- sourceAudioUnit
--
-- The audio unit that is the source for the connection
--
-- sourceOutputNumber
--
-- The source audio unit's output element to be used in the connection
--
-- destInputNumber
--
-- The destination audio unit's input element to be used in the connection
data AudioUnitConnection = AudioUnitConnection
  { audioUnitConnectionSourceAudioUnit :: !(Ptr ())
  , audioUnitConnectionSourceOutputNumber :: !CUInt
  , audioUnitConnectionDestInputNumber :: !CUInt
  } deriving (Eq, Show)

instance Storable AudioUnitConnection where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = AudioUnitConnection <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 12
  poke p (AudioUnitConnection {..}) = do
    pokeByteOff p 0 audioUnitConnectionSourceAudioUnit
    pokeByteOff p 8 audioUnitConnectionSourceOutputNumber
    pokeByteOff p 12 audioUnitConnectionDestInputNumber

{-# NOINLINE audioUnitConnectionStructType #-}
audioUnitConnectionStructType :: Ptr CType
audioUnitConnectionStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer, ffi_type_uint, ffi_type_uint]

argAudioUnitConnection :: AudioUnitConnection -> Arg
argAudioUnitConnection = mkStorableArg audioUnitConnectionStructType

retAudioUnitConnection :: RetType AudioUnitConnection
retAudioUnitConnection = mkStorableRetType audioUnitConnectionStructType

instance ObjCArgument AudioUnitConnection where
  withObjCArg x k = k (argAudioUnitConnection x)

instance ObjCReturn AudioUnitConnection where
  type RawReturn AudioUnitConnection = AudioUnitConnection
  objcRetType = retAudioUnitConnection
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AudioUnitFrequencyResponseBin
--
-- Structure used to get the magnitude of the frequency response at a particular frequency via kAudioUnitProperty_FrequencyResponse.
--
-- An array of AudioUnitFrequencyResponseBin are passed in to kAudioUnitProperty_FrequencyResponse					with the mFrequency field filled in. The array is returned with the mMagnitude fields filled in.					If fewer than kNumberOfResponseFrequencies are needed, then the first unused bin should be marked with 					a negative frequency.
data AudioUnitFrequencyResponseBin = AudioUnitFrequencyResponseBin
  { audioUnitFrequencyResponseBinMFrequency :: !CDouble
  , audioUnitFrequencyResponseBinMMagnitude :: !CDouble
  } deriving (Eq, Show)

instance Storable AudioUnitFrequencyResponseBin where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = AudioUnitFrequencyResponseBin <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (AudioUnitFrequencyResponseBin {..}) = do
    pokeByteOff p 0 audioUnitFrequencyResponseBinMFrequency
    pokeByteOff p 8 audioUnitFrequencyResponseBinMMagnitude

{-# NOINLINE audioUnitFrequencyResponseBinStructType #-}
audioUnitFrequencyResponseBinStructType :: Ptr CType
audioUnitFrequencyResponseBinStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_double, ffi_type_double]

argAudioUnitFrequencyResponseBin :: AudioUnitFrequencyResponseBin -> Arg
argAudioUnitFrequencyResponseBin = mkStorableArg audioUnitFrequencyResponseBinStructType

retAudioUnitFrequencyResponseBin :: RetType AudioUnitFrequencyResponseBin
retAudioUnitFrequencyResponseBin = mkStorableRetType audioUnitFrequencyResponseBinStructType

instance ObjCArgument AudioUnitFrequencyResponseBin where
  withObjCArg x k = k (argAudioUnitFrequencyResponseBin x)

instance ObjCReturn AudioUnitFrequencyResponseBin where
  type RawReturn AudioUnitFrequencyResponseBin = AudioUnitFrequencyResponseBin
  objcRetType = retAudioUnitFrequencyResponseBin
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data AudioUnitMIDIControlMapping = AudioUnitMIDIControlMapping
  { audioUnitMIDIControlMappingMidiNRPN :: !CUShort
  , audioUnitMIDIControlMappingMidiControl :: !CUChar
  , audioUnitMIDIControlMappingScope :: !CUChar
  , audioUnitMIDIControlMappingElement :: !CUInt
  , audioUnitMIDIControlMappingParameter :: !CUInt
  } deriving (Eq, Show)

instance Storable AudioUnitMIDIControlMapping where
  sizeOf    _ = 12
  alignment _ = 4
  peek p = AudioUnitMIDIControlMapping <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 3
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (AudioUnitMIDIControlMapping {..}) = do
    pokeByteOff p 0 audioUnitMIDIControlMappingMidiNRPN
    pokeByteOff p 2 audioUnitMIDIControlMappingMidiControl
    pokeByteOff p 3 audioUnitMIDIControlMappingScope
    pokeByteOff p 4 audioUnitMIDIControlMappingElement
    pokeByteOff p 8 audioUnitMIDIControlMappingParameter

{-# NOINLINE audioUnitMIDIControlMappingStructType #-}
audioUnitMIDIControlMappingStructType :: Ptr CType
audioUnitMIDIControlMappingStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint8, ffi_type_uint8, ffi_type_uint, ffi_type_uint]

argAudioUnitMIDIControlMapping :: AudioUnitMIDIControlMapping -> Arg
argAudioUnitMIDIControlMapping = mkStorableArg audioUnitMIDIControlMappingStructType

retAudioUnitMIDIControlMapping :: RetType AudioUnitMIDIControlMapping
retAudioUnitMIDIControlMapping = mkStorableRetType audioUnitMIDIControlMappingStructType

instance ObjCArgument AudioUnitMIDIControlMapping where
  withObjCArg x k = k (argAudioUnitMIDIControlMapping x)

instance ObjCReturn AudioUnitMIDIControlMapping where
  type RawReturn AudioUnitMIDIControlMapping = AudioUnitMIDIControlMapping
  objcRetType = retAudioUnitMIDIControlMapping
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AudioUnitMeterClipping
--
-- peakValueSinceLastCall;
--
-- The maximum value seen on the channel since the last time the property was retrieved.
--
-- sawInfinity;
--
-- TRUE if there was an infinite value on this channel.
--
-- sawNotANumber
--
-- TRUE if there was a floating point Not-A-Number value on this channel.
data AudioUnitMeterClipping = AudioUnitMeterClipping
  { audioUnitMeterClippingPeakValueSinceLastCall :: !CFloat
  , audioUnitMeterClippingSawInfinity :: !CUChar
  , audioUnitMeterClippingSawNotANumber :: !CUChar
  } deriving (Eq, Show)

instance Storable AudioUnitMeterClipping where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = AudioUnitMeterClipping <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 5
  poke p (AudioUnitMeterClipping {..}) = do
    pokeByteOff p 0 audioUnitMeterClippingPeakValueSinceLastCall
    pokeByteOff p 4 audioUnitMeterClippingSawInfinity
    pokeByteOff p 5 audioUnitMeterClippingSawNotANumber

{-# NOINLINE audioUnitMeterClippingStructType #-}
audioUnitMeterClippingStructType :: Ptr CType
audioUnitMeterClippingStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_float, ffi_type_uint8, ffi_type_uint8]

argAudioUnitMeterClipping :: AudioUnitMeterClipping -> Arg
argAudioUnitMeterClipping = mkStorableArg audioUnitMeterClippingStructType

retAudioUnitMeterClipping :: RetType AudioUnitMeterClipping
retAudioUnitMeterClipping = mkStorableRetType audioUnitMeterClippingStructType

instance ObjCArgument AudioUnitMeterClipping where
  withObjCArg x k = k (argAudioUnitMeterClipping x)

instance ObjCReturn AudioUnitMeterClipping where
  type RawReturn AudioUnitMeterClipping = AudioUnitMeterClipping
  objcRetType = retAudioUnitMeterClipping
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AudioUnitNodeConnection
--
-- A connection between two nodes
--
-- sourceNode
--
-- sourceOutputNumber
--
-- destNode
--
-- destInputNumber
data AudioUnitNodeConnection = AudioUnitNodeConnection
  { audioUnitNodeConnectionSourceNode :: !CInt
  , audioUnitNodeConnectionSourceOutputNumber :: !CUInt
  , audioUnitNodeConnectionDestNode :: !CInt
  , audioUnitNodeConnectionDestInputNumber :: !CUInt
  } deriving (Eq, Show)

instance Storable AudioUnitNodeConnection where
  sizeOf    _ = 16
  alignment _ = 4
  peek p = AudioUnitNodeConnection <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
  poke p (AudioUnitNodeConnection {..}) = do
    pokeByteOff p 0 audioUnitNodeConnectionSourceNode
    pokeByteOff p 4 audioUnitNodeConnectionSourceOutputNumber
    pokeByteOff p 8 audioUnitNodeConnectionDestNode
    pokeByteOff p 12 audioUnitNodeConnectionDestInputNumber

{-# NOINLINE audioUnitNodeConnectionStructType #-}
audioUnitNodeConnectionStructType :: Ptr CType
audioUnitNodeConnectionStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_uint, ffi_type_sint, ffi_type_uint]

argAudioUnitNodeConnection :: AudioUnitNodeConnection -> Arg
argAudioUnitNodeConnection = mkStorableArg audioUnitNodeConnectionStructType

retAudioUnitNodeConnection :: RetType AudioUnitNodeConnection
retAudioUnitNodeConnection = mkStorableRetType audioUnitNodeConnectionStructType

instance ObjCArgument AudioUnitNodeConnection where
  withObjCArg x k = k (argAudioUnitNodeConnection x)

instance ObjCReturn AudioUnitNodeConnection where
  type RawReturn AudioUnitNodeConnection = AudioUnitNodeConnection
  objcRetType = retAudioUnitNodeConnection
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AudioUnitParameter
--
-- An audio unit parameter is defined by the triplet of audio unit scope, element 					and parameterID. This struct is used with the functions in AudioUnitUtilities.h 					to deal with audio unit parameters, but is included in this header file for 					completeness.
--
-- mAudioUnit
--
-- The audio unit instance to which the specified parameter applies.
--
-- mParameterID
--
-- The parameterID for the parameter
--
-- mScope
--
-- The scope for the parameter
--
-- mElement
--
-- The element for the parameter
data AudioUnitParameter = AudioUnitParameter
  { audioUnitParameterMAudioUnit :: !(Ptr ())
  , audioUnitParameterMParameterID :: !CUInt
  , audioUnitParameterMScope :: !CUInt
  , audioUnitParameterMElement :: !CUInt
  } deriving (Eq, Show)

instance Storable AudioUnitParameter where
  sizeOf    _ = 24
  alignment _ = 8
  peek p = AudioUnitParameter <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 12
    <*> peekByteOff p 16
  poke p (AudioUnitParameter {..}) = do
    pokeByteOff p 0 audioUnitParameterMAudioUnit
    pokeByteOff p 8 audioUnitParameterMParameterID
    pokeByteOff p 12 audioUnitParameterMScope
    pokeByteOff p 16 audioUnitParameterMElement

{-# NOINLINE audioUnitParameterStructType #-}
audioUnitParameterStructType :: Ptr CType
audioUnitParameterStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer, ffi_type_uint, ffi_type_uint, ffi_type_uint]

argAudioUnitParameter :: AudioUnitParameter -> Arg
argAudioUnitParameter = mkStorableArg audioUnitParameterStructType

retAudioUnitParameter :: RetType AudioUnitParameter
retAudioUnitParameter = mkStorableRetType audioUnitParameterStructType

instance ObjCArgument AudioUnitParameter where
  withObjCArg x k = k (argAudioUnitParameter x)

instance ObjCReturn AudioUnitParameter where
  type RawReturn AudioUnitParameter = AudioUnitParameter
  objcRetType = retAudioUnitParameter
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AudioUnitParameterHistoryInfo
--
-- This structure contains the suggested update rate and history duration for parameters which have the kAudioUnitParameterFlag_PlotHistory flag set.					The structure is filled out by getting kAudioUnitProperty_ParameterHistoryInfo.
--
-- updatesPerSecond
--
-- This is the number of times per second that it is suggested that the host get the value of this parameter.
--
-- historyDurationInSeconds
--
-- This is the duration in seconds of history that should be plotted.
data AudioUnitParameterHistoryInfo = AudioUnitParameterHistoryInfo
  { audioUnitParameterHistoryInfoUpdatesPerSecond :: !CFloat
  , audioUnitParameterHistoryInfoHistoryDurationInSeconds :: !CFloat
  } deriving (Eq, Show)

instance Storable AudioUnitParameterHistoryInfo where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = AudioUnitParameterHistoryInfo <$> peekByteOff p 0
    <*> peekByteOff p 4
  poke p (AudioUnitParameterHistoryInfo {..}) = do
    pokeByteOff p 0 audioUnitParameterHistoryInfoUpdatesPerSecond
    pokeByteOff p 4 audioUnitParameterHistoryInfoHistoryDurationInSeconds

{-# NOINLINE audioUnitParameterHistoryInfoStructType #-}
audioUnitParameterHistoryInfoStructType :: Ptr CType
audioUnitParameterHistoryInfoStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_float, ffi_type_float]

argAudioUnitParameterHistoryInfo :: AudioUnitParameterHistoryInfo -> Arg
argAudioUnitParameterHistoryInfo = mkStorableArg audioUnitParameterHistoryInfoStructType

retAudioUnitParameterHistoryInfo :: RetType AudioUnitParameterHistoryInfo
retAudioUnitParameterHistoryInfo = mkStorableRetType audioUnitParameterHistoryInfoStructType

instance ObjCArgument AudioUnitParameterHistoryInfo where
  withObjCArg x k = k (argAudioUnitParameterHistoryInfo x)

instance ObjCReturn AudioUnitParameterHistoryInfo where
  type RawReturn AudioUnitParameterHistoryInfo = AudioUnitParameterHistoryInfo
  objcRetType = retAudioUnitParameterHistoryInfo
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AudioUnitParameterNameInfo
--
-- Used to provide shorter names for a specified parameter
data AudioUnitParameterIDName = AudioUnitParameterIDName
  { audioUnitParameterIDNameInID :: !CUInt
  , audioUnitParameterIDNameInDesiredLength :: !CInt
  , audioUnitParameterIDNameOutName :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable AudioUnitParameterIDName where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = AudioUnitParameterIDName <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (AudioUnitParameterIDName {..}) = do
    pokeByteOff p 0 audioUnitParameterIDNameInID
    pokeByteOff p 4 audioUnitParameterIDNameInDesiredLength
    pokeByteOff p 8 audioUnitParameterIDNameOutName

{-# NOINLINE audioUnitParameterIDNameStructType #-}
audioUnitParameterIDNameStructType :: Ptr CType
audioUnitParameterIDNameStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_sint, ffi_type_pointer]

argAudioUnitParameterIDName :: AudioUnitParameterIDName -> Arg
argAudioUnitParameterIDName = mkStorableArg audioUnitParameterIDNameStructType

retAudioUnitParameterIDName :: RetType AudioUnitParameterIDName
retAudioUnitParameterIDName = mkStorableRetType audioUnitParameterIDNameStructType

instance ObjCArgument AudioUnitParameterIDName where
  withObjCArg x k = k (argAudioUnitParameterIDName x)

instance ObjCReturn AudioUnitParameterIDName where
  type RawReturn AudioUnitParameterIDName = AudioUnitParameterIDName
  objcRetType = retAudioUnitParameterIDName
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AudioUnitParameterNameInfo
--
-- Used to provide shorter names for a specified parameter
data AudioUnitParameterNameInfo = AudioUnitParameterNameInfo
  { audioUnitParameterNameInfoInID :: !CUInt
  , audioUnitParameterNameInfoInDesiredLength :: !CInt
  , audioUnitParameterNameInfoOutName :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable AudioUnitParameterNameInfo where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = AudioUnitParameterNameInfo <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (AudioUnitParameterNameInfo {..}) = do
    pokeByteOff p 0 audioUnitParameterNameInfoInID
    pokeByteOff p 4 audioUnitParameterNameInfoInDesiredLength
    pokeByteOff p 8 audioUnitParameterNameInfoOutName

{-# NOINLINE audioUnitParameterNameInfoStructType #-}
audioUnitParameterNameInfoStructType :: Ptr CType
audioUnitParameterNameInfoStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_sint, ffi_type_pointer]

argAudioUnitParameterNameInfo :: AudioUnitParameterNameInfo -> Arg
argAudioUnitParameterNameInfo = mkStorableArg audioUnitParameterNameInfoStructType

retAudioUnitParameterNameInfo :: RetType AudioUnitParameterNameInfo
retAudioUnitParameterNameInfo = mkStorableRetType audioUnitParameterNameInfoStructType

instance ObjCArgument AudioUnitParameterNameInfo where
  withObjCArg x k = k (argAudioUnitParameterNameInfo x)

instance ObjCReturn AudioUnitParameterNameInfo where
  type RawReturn AudioUnitParameterNameInfo = AudioUnitParameterNameInfo
  objcRetType = retAudioUnitParameterNameInfo
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AudioUnitParameterValueFromString
--
-- Provide the parameter's value for a given string representation of it
data AudioUnitParameterValueFromString = AudioUnitParameterValueFromString
  { audioUnitParameterValueFromStringInParamID :: !CUInt
  , audioUnitParameterValueFromStringInString :: !(Ptr ())
  , audioUnitParameterValueFromStringOutValue :: !CFloat
  } deriving (Eq, Show)

instance Storable AudioUnitParameterValueFromString where
  sizeOf    _ = 24
  alignment _ = 8
  peek p = AudioUnitParameterValueFromString <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
  poke p (AudioUnitParameterValueFromString {..}) = do
    pokeByteOff p 0 audioUnitParameterValueFromStringInParamID
    pokeByteOff p 8 audioUnitParameterValueFromStringInString
    pokeByteOff p 16 audioUnitParameterValueFromStringOutValue

{-# NOINLINE audioUnitParameterValueFromStringStructType #-}
audioUnitParameterValueFromStringStructType :: Ptr CType
audioUnitParameterValueFromStringStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_pointer, ffi_type_float]

argAudioUnitParameterValueFromString :: AudioUnitParameterValueFromString -> Arg
argAudioUnitParameterValueFromString = mkStorableArg audioUnitParameterValueFromStringStructType

retAudioUnitParameterValueFromString :: RetType AudioUnitParameterValueFromString
retAudioUnitParameterValueFromString = mkStorableRetType audioUnitParameterValueFromStringStructType

instance ObjCArgument AudioUnitParameterValueFromString where
  withObjCArg x k = k (argAudioUnitParameterValueFromString x)

instance ObjCReturn AudioUnitParameterValueFromString where
  type RawReturn AudioUnitParameterValueFromString = AudioUnitParameterValueFromString
  objcRetType = retAudioUnitParameterValueFromString
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AudioUnitProperty
--
-- An audio unit property is defined by the triplet of audio unit scope, element					and propertyID. This struct is used with the functions in AudioUnitUtilities.h 					to deal with audio unit properties, but is included in this header file for 					completeness.
--
-- mAudioUnit
--
-- The audio unit instance which the specified property applies too
--
-- mPropertyID
--
-- The propertyID for the property
--
-- mScope
--
-- The scope for the property
--
-- mElement
--
-- The element for the property
data AudioUnitProperty = AudioUnitProperty
  { audioUnitPropertyMAudioUnit :: !(Ptr ())
  , audioUnitPropertyMPropertyID :: !CUInt
  , audioUnitPropertyMScope :: !CUInt
  , audioUnitPropertyMElement :: !CUInt
  } deriving (Eq, Show)

instance Storable AudioUnitProperty where
  sizeOf    _ = 24
  alignment _ = 8
  peek p = AudioUnitProperty <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 12
    <*> peekByteOff p 16
  poke p (AudioUnitProperty {..}) = do
    pokeByteOff p 0 audioUnitPropertyMAudioUnit
    pokeByteOff p 8 audioUnitPropertyMPropertyID
    pokeByteOff p 12 audioUnitPropertyMScope
    pokeByteOff p 16 audioUnitPropertyMElement

{-# NOINLINE audioUnitPropertyStructType #-}
audioUnitPropertyStructType :: Ptr CType
audioUnitPropertyStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer, ffi_type_uint, ffi_type_uint, ffi_type_uint]

argAudioUnitProperty :: AudioUnitProperty -> Arg
argAudioUnitProperty = mkStorableArg audioUnitPropertyStructType

retAudioUnitProperty :: RetType AudioUnitProperty
retAudioUnitProperty = mkStorableRetType audioUnitPropertyStructType

instance ObjCArgument AudioUnitProperty where
  withObjCArg x k = k (argAudioUnitProperty x)

instance ObjCReturn AudioUnitProperty where
  type RawReturn AudioUnitProperty = AudioUnitProperty
  objcRetType = retAudioUnitProperty
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | CABarBeatTime
--
-- A display representation of a musical time in beats.
--
-- A clock's internal representation of musical time is in beats based on the	beginning of the timeline. Normally, such times should be displayed to the user	in terms of bars, beats, and subbeats (sometimes called "units" or "parts per	quarter" [PPQ]). This data structure is such a display representation.
--
-- By convention, bar 1 is the beginning of the sequence. Beat 1 is the first beat	of the measure. In 4/4 time, beat will have a value from 1 to 4. Music	applications often use beat divisions such as 480 and 960.
--
-- bar
--
-- A measure number.
--
-- beat
--
-- A beat number (1..n).
--
-- subbeat
--
-- The numerator of the fractional number of beats.
--
-- subbeatDivisor
--
-- The denominator of the fractional number of beats.
--
-- reserved
--
-- Must be 0.
data CABarBeatTime = CABarBeatTime
  { caBarBeatTimeBar :: !CInt
  , caBarBeatTimeBeat :: !CUShort
  , caBarBeatTimeSubbeat :: !CUShort
  , caBarBeatTimeSubbeatDivisor :: !CUShort
  , caBarBeatTimeReserved :: !CUShort
  } deriving (Eq, Show)

instance Storable CABarBeatTime where
  sizeOf    _ = 12
  alignment _ = 4
  peek p = CABarBeatTime <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 6
    <*> peekByteOff p 8
    <*> peekByteOff p 10
  poke p (CABarBeatTime {..}) = do
    pokeByteOff p 0 caBarBeatTimeBar
    pokeByteOff p 4 caBarBeatTimeBeat
    pokeByteOff p 6 caBarBeatTimeSubbeat
    pokeByteOff p 8 caBarBeatTimeSubbeatDivisor
    pokeByteOff p 10 caBarBeatTimeReserved

{-# NOINLINE caBarBeatTimeStructType #-}
caBarBeatTimeStructType :: Ptr CType
caBarBeatTimeStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argCABarBeatTime :: CABarBeatTime -> Arg
argCABarBeatTime = mkStorableArg caBarBeatTimeStructType

retCABarBeatTime :: RetType CABarBeatTime
retCABarBeatTime = mkStorableRetType caBarBeatTimeStructType

instance ObjCArgument CABarBeatTime where
  withObjCArg x k = k (argCABarBeatTime x)

instance ObjCReturn CABarBeatTime where
  type RawReturn CABarBeatTime = CABarBeatTime
  objcRetType = retCABarBeatTime
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data CAFAudioDescription = CAFAudioDescription
  { cafAudioDescriptionMSampleRate :: !CDouble
  , cafAudioDescriptionMFormatID :: !CUInt
  , cafAudioDescriptionMFormatFlags :: !CAFFormatFlags
  , cafAudioDescriptionMBytesPerPacket :: !CUInt
  , cafAudioDescriptionMFramesPerPacket :: !CUInt
  , cafAudioDescriptionMChannelsPerFrame :: !CUInt
  , cafAudioDescriptionMBitsPerChannel :: !CUInt
  } deriving (Eq, Show)

instance Storable CAFAudioDescription where
  sizeOf    _ = 32
  alignment _ = 8
  peek p = CAFAudioDescription <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 12
    <*> peekByteOff p 16
    <*> peekByteOff p 20
    <*> peekByteOff p 24
    <*> peekByteOff p 28
  poke p (CAFAudioDescription {..}) = do
    pokeByteOff p 0 cafAudioDescriptionMSampleRate
    pokeByteOff p 8 cafAudioDescriptionMFormatID
    pokeByteOff p 12 cafAudioDescriptionMFormatFlags
    pokeByteOff p 16 cafAudioDescriptionMBytesPerPacket
    pokeByteOff p 20 cafAudioDescriptionMFramesPerPacket
    pokeByteOff p 24 cafAudioDescriptionMChannelsPerFrame
    pokeByteOff p 28 cafAudioDescriptionMBitsPerChannel

{-# NOINLINE cafAudioDescriptionStructType #-}
cafAudioDescriptionStructType :: Ptr CType
cafAudioDescriptionStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_double, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint]

argCAFAudioDescription :: CAFAudioDescription -> Arg
argCAFAudioDescription = mkStorableArg cafAudioDescriptionStructType

retCAFAudioDescription :: RetType CAFAudioDescription
retCAFAudioDescription = mkStorableRetType cafAudioDescriptionStructType

instance ObjCArgument CAFAudioDescription where
  withObjCArg x k = k (argCAFAudioDescription x)

instance ObjCReturn CAFAudioDescription where
  type RawReturn CAFAudioDescription = CAFAudioDescription
  objcRetType = retCAFAudioDescription
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data CAFChunkHeader = CAFChunkHeader
  { cafChunkHeaderMChunkType :: !CUInt
  , cafChunkHeaderMChunkSize :: !CLong
  } deriving (Eq, Show)

instance Storable CAFChunkHeader where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = CAFChunkHeader <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (CAFChunkHeader {..}) = do
    pokeByteOff p 0 cafChunkHeaderMChunkType
    pokeByteOff p 8 cafChunkHeaderMChunkSize

{-# NOINLINE cafChunkHeaderStructType #-}
cafChunkHeaderStructType :: Ptr CType
cafChunkHeaderStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_slong]

argCAFChunkHeader :: CAFChunkHeader -> Arg
argCAFChunkHeader = mkStorableArg cafChunkHeaderStructType

retCAFChunkHeader :: RetType CAFChunkHeader
retCAFChunkHeader = mkStorableRetType cafChunkHeaderStructType

instance ObjCArgument CAFChunkHeader where
  withObjCArg x k = k (argCAFChunkHeader x)

instance ObjCReturn CAFChunkHeader where
  type RawReturn CAFChunkHeader = CAFChunkHeader
  objcRetType = retCAFChunkHeader
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data CAFFileHeader = CAFFileHeader
  { cafFileHeaderMFileType :: !CUInt
  , cafFileHeaderMFileVersion :: !CUShort
  , cafFileHeaderMFileFlags :: !CUShort
  } deriving (Eq, Show)

instance Storable CAFFileHeader where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = CAFFileHeader <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 6
  poke p (CAFFileHeader {..}) = do
    pokeByteOff p 0 cafFileHeaderMFileType
    pokeByteOff p 4 cafFileHeaderMFileVersion
    pokeByteOff p 6 cafFileHeaderMFileFlags

{-# NOINLINE cafFileHeaderStructType #-}
cafFileHeaderStructType :: Ptr CType
cafFileHeaderStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint16, ffi_type_uint16]

argCAFFileHeader :: CAFFileHeader -> Arg
argCAFFileHeader = mkStorableArg cafFileHeaderStructType

retCAFFileHeader :: RetType CAFFileHeader
retCAFFileHeader = mkStorableRetType cafFileHeaderStructType

instance ObjCArgument CAFFileHeader where
  withObjCArg x k = k (argCAFFileHeader x)

instance ObjCReturn CAFFileHeader where
  type RawReturn CAFFileHeader = CAFFileHeader
  objcRetType = retCAFFileHeader
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data CAFInfoStrings = CAFInfoStrings
  { cafInfoStringsMNumEntries :: !CUInt
  } deriving (Eq, Show)

instance Storable CAFInfoStrings where
  sizeOf    _ = 4
  alignment _ = 4
  peek p = CAFInfoStrings <$> peekByteOff p 0
  poke p (CAFInfoStrings {..}) =
    pokeByteOff p 0 cafInfoStringsMNumEntries

{-# NOINLINE cafInfoStringsStructType #-}
cafInfoStringsStructType :: Ptr CType
cafInfoStringsStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint]

argCAFInfoStrings :: CAFInfoStrings -> Arg
argCAFInfoStrings = mkStorableArg cafInfoStringsStructType

retCAFInfoStrings :: RetType CAFInfoStrings
retCAFInfoStrings = mkStorableRetType cafInfoStringsStructType

instance ObjCArgument CAFInfoStrings where
  withObjCArg x k = k (argCAFInfoStrings x)

instance ObjCReturn CAFInfoStrings where
  type RawReturn CAFInfoStrings = CAFInfoStrings
  objcRetType = retCAFInfoStrings
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data CAFInstrumentChunk = CAFInstrumentChunk
  { cafInstrumentChunkMBaseNote :: !CFloat
  , cafInstrumentChunkMMIDILowNote :: !CUChar
  , cafInstrumentChunkMMIDIHighNote :: !CUChar
  , cafInstrumentChunkMMIDILowVelocity :: !CUChar
  , cafInstrumentChunkMMIDIHighVelocity :: !CUChar
  , cafInstrumentChunkMdBGain :: !CFloat
  , cafInstrumentChunkMStartRegionID :: !CUInt
  , cafInstrumentChunkMSustainRegionID :: !CUInt
  , cafInstrumentChunkMReleaseRegionID :: !CUInt
  , cafInstrumentChunkMInstrumentID :: !CUInt
  } deriving (Eq, Show)

instance Storable CAFInstrumentChunk where
  sizeOf    _ = 28
  alignment _ = 4
  peek p = CAFInstrumentChunk <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 5
    <*> peekByteOff p 6
    <*> peekByteOff p 7
    <*> peekByteOff p 8
    <*> peekByteOff p 12
    <*> peekByteOff p 16
    <*> peekByteOff p 20
    <*> peekByteOff p 24
  poke p (CAFInstrumentChunk {..}) = do
    pokeByteOff p 0 cafInstrumentChunkMBaseNote
    pokeByteOff p 4 cafInstrumentChunkMMIDILowNote
    pokeByteOff p 5 cafInstrumentChunkMMIDIHighNote
    pokeByteOff p 6 cafInstrumentChunkMMIDILowVelocity
    pokeByteOff p 7 cafInstrumentChunkMMIDIHighVelocity
    pokeByteOff p 8 cafInstrumentChunkMdBGain
    pokeByteOff p 12 cafInstrumentChunkMStartRegionID
    pokeByteOff p 16 cafInstrumentChunkMSustainRegionID
    pokeByteOff p 20 cafInstrumentChunkMReleaseRegionID
    pokeByteOff p 24 cafInstrumentChunkMInstrumentID

{-# NOINLINE cafInstrumentChunkStructType #-}
cafInstrumentChunkStructType :: Ptr CType
cafInstrumentChunkStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_float, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_float, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint]

argCAFInstrumentChunk :: CAFInstrumentChunk -> Arg
argCAFInstrumentChunk = mkStorableArg cafInstrumentChunkStructType

retCAFInstrumentChunk :: RetType CAFInstrumentChunk
retCAFInstrumentChunk = mkStorableRetType cafInstrumentChunkStructType

instance ObjCArgument CAFInstrumentChunk where
  withObjCArg x k = k (argCAFInstrumentChunk x)

instance ObjCReturn CAFInstrumentChunk where
  type RawReturn CAFInstrumentChunk = CAFInstrumentChunk
  objcRetType = retCAFInstrumentChunk
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data CAFOverviewSample = CAFOverviewSample
  { cafOverviewSampleMMinValue :: !CShort
  , cafOverviewSampleMMaxValue :: !CShort
  } deriving (Eq, Show)

instance Storable CAFOverviewSample where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = CAFOverviewSample <$> peekByteOff p 0
    <*> peekByteOff p 2
  poke p (CAFOverviewSample {..}) = do
    pokeByteOff p 0 cafOverviewSampleMMinValue
    pokeByteOff p 2 cafOverviewSampleMMaxValue

{-# NOINLINE cafOverviewSampleStructType #-}
cafOverviewSampleStructType :: Ptr CType
cafOverviewSampleStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16, ffi_type_sint16]

argCAFOverviewSample :: CAFOverviewSample -> Arg
argCAFOverviewSample = mkStorableArg cafOverviewSampleStructType

retCAFOverviewSample :: RetType CAFOverviewSample
retCAFOverviewSample = mkStorableRetType cafOverviewSampleStructType

instance ObjCArgument CAFOverviewSample where
  withObjCArg x k = k (argCAFOverviewSample x)

instance ObjCReturn CAFOverviewSample where
  type RawReturn CAFOverviewSample = CAFOverviewSample
  objcRetType = retCAFOverviewSample
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data CAFPositionPeak = CAFPositionPeak
  { cafPositionPeakMValue :: !CFloat
  , cafPositionPeakMFrameNumber :: !CULong
  } deriving (Eq, Show)

instance Storable CAFPositionPeak where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = CAFPositionPeak <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (CAFPositionPeak {..}) = do
    pokeByteOff p 0 cafPositionPeakMValue
    pokeByteOff p 8 cafPositionPeakMFrameNumber

{-# NOINLINE cafPositionPeakStructType #-}
cafPositionPeakStructType :: Ptr CType
cafPositionPeakStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_float, ffi_type_ulong]

argCAFPositionPeak :: CAFPositionPeak -> Arg
argCAFPositionPeak = mkStorableArg cafPositionPeakStructType

retCAFPositionPeak :: RetType CAFPositionPeak
retCAFPositionPeak = mkStorableRetType cafPositionPeakStructType

instance ObjCArgument CAFPositionPeak where
  withObjCArg x k = k (argCAFPositionPeak x)

instance ObjCReturn CAFPositionPeak where
  type RawReturn CAFPositionPeak = CAFPositionPeak
  objcRetType = retCAFPositionPeak
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data CAFStringID = CAFStringID
  { cafStringIDMStringID :: !CUInt
  , cafStringIDMStringStartByteOffset :: !CLong
  } deriving (Eq, Show)

instance Storable CAFStringID where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = CAFStringID <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (CAFStringID {..}) = do
    pokeByteOff p 0 cafStringIDMStringID
    pokeByteOff p 8 cafStringIDMStringStartByteOffset

{-# NOINLINE cafStringIDStructType #-}
cafStringIDStructType :: Ptr CType
cafStringIDStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_slong]

argCAFStringID :: CAFStringID -> Arg
argCAFStringID = mkStorableArg cafStringIDStructType

retCAFStringID :: RetType CAFStringID
retCAFStringID = mkStorableRetType cafStringIDStructType

instance ObjCArgument CAFStringID where
  withObjCArg x k = k (argCAFStringID x)

instance ObjCReturn CAFStringID where
  type RawReturn CAFStringID = CAFStringID
  objcRetType = retCAFStringID
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data CAF_SMPTE_Time = CAF_SMPTE_Time
  { caF_SMPTE_TimeMHours :: !CSChar
  , caF_SMPTE_TimeMMinutes :: !CSChar
  , caF_SMPTE_TimeMSeconds :: !CSChar
  , caF_SMPTE_TimeMFrames :: !CSChar
  , caF_SMPTE_TimeMSubFrameSampleOffset :: !CUInt
  } deriving (Eq, Show)

instance Storable CAF_SMPTE_Time where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = CAF_SMPTE_Time <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
    <*> peekByteOff p 3
    <*> peekByteOff p 4
  poke p (CAF_SMPTE_Time {..}) = do
    pokeByteOff p 0 caF_SMPTE_TimeMHours
    pokeByteOff p 1 caF_SMPTE_TimeMMinutes
    pokeByteOff p 2 caF_SMPTE_TimeMSeconds
    pokeByteOff p 3 caF_SMPTE_TimeMFrames
    pokeByteOff p 4 caF_SMPTE_TimeMSubFrameSampleOffset

{-# NOINLINE caF_SMPTE_TimeStructType #-}
caF_SMPTE_TimeStructType :: Ptr CType
caF_SMPTE_TimeStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint8, ffi_type_sint8, ffi_type_sint8, ffi_type_sint8, ffi_type_uint]

argCAF_SMPTE_Time :: CAF_SMPTE_Time -> Arg
argCAF_SMPTE_Time = mkStorableArg caF_SMPTE_TimeStructType

retCAF_SMPTE_Time :: RetType CAF_SMPTE_Time
retCAF_SMPTE_Time = mkStorableRetType caF_SMPTE_TimeStructType

instance ObjCArgument CAF_SMPTE_Time where
  withObjCArg x k = k (argCAF_SMPTE_Time x)

instance ObjCReturn CAF_SMPTE_Time where
  type RawReturn CAF_SMPTE_Time = CAF_SMPTE_Time
  objcRetType = retCAF_SMPTE_Time
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | CAMeterTrackEntry
--
-- A time signature change event.
--
-- The meter track is used for converting between beats as floating-point	numbers (CAClockBeats) and their display representations (CABarBeatTime).
--
-- beats
--
-- The beat time at which the time signature (meter) changes.
--
-- meterNumer
--
-- The numerator of the new time signature.
--
-- meterDenom
--
-- The denominator of the new time signature (1, 2, 4, 8, etc.).
data CAMeterTrackEntry = CAMeterTrackEntry
  { caMeterTrackEntryBeats :: !CDouble
  , caMeterTrackEntryMeterNumer :: !CUShort
  , caMeterTrackEntryMeterDenom :: !CUShort
  } deriving (Eq, Show)

instance Storable CAMeterTrackEntry where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = CAMeterTrackEntry <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 10
  poke p (CAMeterTrackEntry {..}) = do
    pokeByteOff p 0 caMeterTrackEntryBeats
    pokeByteOff p 8 caMeterTrackEntryMeterNumer
    pokeByteOff p 10 caMeterTrackEntryMeterDenom

{-# NOINLINE caMeterTrackEntryStructType #-}
caMeterTrackEntryStructType :: Ptr CType
caMeterTrackEntryStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_double, ffi_type_uint16, ffi_type_uint16]

argCAMeterTrackEntry :: CAMeterTrackEntry -> Arg
argCAMeterTrackEntry = mkStorableArg caMeterTrackEntryStructType

retCAMeterTrackEntry :: RetType CAMeterTrackEntry
retCAMeterTrackEntry = mkStorableRetType caMeterTrackEntryStructType

instance ObjCArgument CAMeterTrackEntry where
  withObjCArg x k = k (argCAMeterTrackEntry x)

instance ObjCReturn CAMeterTrackEntry where
  type RawReturn CAMeterTrackEntry = CAMeterTrackEntry
  objcRetType = retCAMeterTrackEntry
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | CATempoMapEntry
--
-- A tempo change event.
--
-- The clock's tempo map defines the correspondence between seconds and musical	beats, and is used in conversions between the two.
--
-- beats
--
-- The beat time at which the tempo changes.
--
-- tempoBPM
--
-- The new tempo as of that time.
data CATempoMapEntry = CATempoMapEntry
  { caTempoMapEntryBeats :: !CDouble
  , caTempoMapEntryTempoBPM :: !CDouble
  } deriving (Eq, Show)

instance Storable CATempoMapEntry where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = CATempoMapEntry <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (CATempoMapEntry {..}) = do
    pokeByteOff p 0 caTempoMapEntryBeats
    pokeByteOff p 8 caTempoMapEntryTempoBPM

{-# NOINLINE caTempoMapEntryStructType #-}
caTempoMapEntryStructType :: Ptr CType
caTempoMapEntryStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_double, ffi_type_double]

argCATempoMapEntry :: CATempoMapEntry -> Arg
argCATempoMapEntry = mkStorableArg caTempoMapEntryStructType

retCATempoMapEntry :: RetType CATempoMapEntry
retCATempoMapEntry = mkStorableRetType caTempoMapEntryStructType

instance ObjCArgument CATempoMapEntry where
  withObjCArg x k = k (argCATempoMapEntry x)

instance ObjCReturn CATempoMapEntry where
  type RawReturn CATempoMapEntry = CATempoMapEntry
  objcRetType = retCATempoMapEntry
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data ExtendedControlEvent = ExtendedControlEvent
  { extendedControlEventGroupID :: !CUInt
  , extendedControlEventControlID :: !CUInt
  , extendedControlEventValue :: !CFloat
  } deriving (Eq, Show)

instance Storable ExtendedControlEvent where
  sizeOf    _ = 12
  alignment _ = 4
  peek p = ExtendedControlEvent <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (ExtendedControlEvent {..}) = do
    pokeByteOff p 0 extendedControlEventGroupID
    pokeByteOff p 4 extendedControlEventControlID
    pokeByteOff p 8 extendedControlEventValue

{-# NOINLINE extendedControlEventStructType #-}
extendedControlEventStructType :: Ptr CType
extendedControlEventStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_float]

argExtendedControlEvent :: ExtendedControlEvent -> Arg
argExtendedControlEvent = mkStorableArg extendedControlEventStructType

retExtendedControlEvent :: RetType ExtendedControlEvent
retExtendedControlEvent = mkStorableRetType extendedControlEventStructType

instance ObjCArgument ExtendedControlEvent where
  withObjCArg x k = k (argExtendedControlEvent x)

instance ObjCReturn ExtendedControlEvent where
  type RawReturn ExtendedControlEvent = ExtendedControlEvent
  objcRetType = retExtendedControlEvent
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | ExtendedNoteOnEvent
--
-- The parameters to specify an extended note on event
data ExtendedNoteOnEvent = ExtendedNoteOnEvent
  { extendedNoteOnEventInstrumentID :: !CUInt
  , extendedNoteOnEventGroupID :: !CUInt
  , extendedNoteOnEventDuration :: !CFloat
  , extendedNoteOnEventExtendedParams :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable ExtendedNoteOnEvent where
  sizeOf    _ = 24
  alignment _ = 8
  peek p = ExtendedNoteOnEvent <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 16
  poke p (ExtendedNoteOnEvent {..}) = do
    pokeByteOff p 0 extendedNoteOnEventInstrumentID
    pokeByteOff p 4 extendedNoteOnEventGroupID
    pokeByteOff p 8 extendedNoteOnEventDuration
    pokeByteOff p 16 extendedNoteOnEventExtendedParams

{-# NOINLINE extendedNoteOnEventStructType #-}
extendedNoteOnEventStructType :: Ptr CType
extendedNoteOnEventStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_float, ffi_type_pointer]

argExtendedNoteOnEvent :: ExtendedNoteOnEvent -> Arg
argExtendedNoteOnEvent = mkStorableArg extendedNoteOnEventStructType

retExtendedNoteOnEvent :: RetType ExtendedNoteOnEvent
retExtendedNoteOnEvent = mkStorableRetType extendedNoteOnEventStructType

instance ObjCArgument ExtendedNoteOnEvent where
  withObjCArg x k = k (argExtendedNoteOnEvent x)

instance ObjCReturn ExtendedNoteOnEvent where
  type RawReturn ExtendedNoteOnEvent = ExtendedNoteOnEvent
  objcRetType = retExtendedNoteOnEvent
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | ExtendedTempoEvent
--
-- specifies the value for a tempo in beats per minute
data ExtendedTempoEvent = ExtendedTempoEvent
  { extendedTempoEventBpm :: !CDouble
  } deriving (Eq, Show)

instance Storable ExtendedTempoEvent where
  sizeOf    _ = 8
  alignment _ = 8
  peek p = ExtendedTempoEvent <$> peekByteOff p 0
  poke p (ExtendedTempoEvent {..}) =
    pokeByteOff p 0 extendedTempoEventBpm

{-# NOINLINE extendedTempoEventStructType #-}
extendedTempoEventStructType :: Ptr CType
extendedTempoEventStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_double]

argExtendedTempoEvent :: ExtendedTempoEvent -> Arg
argExtendedTempoEvent = mkStorableArg extendedTempoEventStructType

retExtendedTempoEvent :: RetType ExtendedTempoEvent
retExtendedTempoEvent = mkStorableRetType extendedTempoEventStructType

instance ObjCArgument ExtendedTempoEvent where
  withObjCArg x k = k (argExtendedTempoEvent x)

instance ObjCReturn ExtendedTempoEvent where
  type RawReturn ExtendedTempoEvent = ExtendedTempoEvent
  objcRetType = retExtendedTempoEvent
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | HostCallbackInfo
--
-- Contains the various callbacks for an audio unit to call
--
-- Any callback can be NULL.
data HostCallbackInfo = HostCallbackInfo
  { hostCallbackInfoHostUserData :: !(Ptr ())
  , hostCallbackInfoBeatAndTempoProc :: !(Ptr ())
  , hostCallbackInfoMusicalTimeLocationProc :: !(Ptr ())
  , hostCallbackInfoTransportStateProc :: !(Ptr ())
  , hostCallbackInfoTransportStateProc2 :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable HostCallbackInfo where
  sizeOf    _ = 40
  alignment _ = 8
  peek p = HostCallbackInfo <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 24
    <*> peekByteOff p 32
  poke p (HostCallbackInfo {..}) = do
    pokeByteOff p 0 hostCallbackInfoHostUserData
    pokeByteOff p 8 hostCallbackInfoBeatAndTempoProc
    pokeByteOff p 16 hostCallbackInfoMusicalTimeLocationProc
    pokeByteOff p 24 hostCallbackInfoTransportStateProc
    pokeByteOff p 32 hostCallbackInfoTransportStateProc2

{-# NOINLINE hostCallbackInfoStructType #-}
hostCallbackInfoStructType :: Ptr CType
hostCallbackInfoStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer]

argHostCallbackInfo :: HostCallbackInfo -> Arg
argHostCallbackInfo = mkStorableArg hostCallbackInfoStructType

retHostCallbackInfo :: RetType HostCallbackInfo
retHostCallbackInfo = mkStorableRetType hostCallbackInfoStructType

instance ObjCArgument HostCallbackInfo where
  withObjCArg x k = k (argHostCallbackInfo x)

instance ObjCReturn HostCallbackInfo where
  type RawReturn HostCallbackInfo = HostCallbackInfo
  objcRetType = retHostCallbackInfo
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | MIDIChannelMessage
--
-- The parameters to specify a MIDI channel message
data MIDIChannelMessage = MIDIChannelMessage
  { midiChannelMessageStatus :: !CUChar
  , midiChannelMessageData1 :: !CUChar
  , midiChannelMessageData2 :: !CUChar
  , midiChannelMessageReserved :: !CUChar
  } deriving (Eq, Show)

instance Storable MIDIChannelMessage where
  sizeOf    _ = 4
  alignment _ = 1
  peek p = MIDIChannelMessage <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
    <*> peekByteOff p 3
  poke p (MIDIChannelMessage {..}) = do
    pokeByteOff p 0 midiChannelMessageStatus
    pokeByteOff p 1 midiChannelMessageData1
    pokeByteOff p 2 midiChannelMessageData2
    pokeByteOff p 3 midiChannelMessageReserved

{-# NOINLINE midiChannelMessageStructType #-}
midiChannelMessageStructType :: Ptr CType
midiChannelMessageStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8]

argMIDIChannelMessage :: MIDIChannelMessage -> Arg
argMIDIChannelMessage = mkStorableArg midiChannelMessageStructType

retMIDIChannelMessage :: RetType MIDIChannelMessage
retMIDIChannelMessage = mkStorableRetType midiChannelMessageStructType

instance ObjCArgument MIDIChannelMessage where
  withObjCArg x k = k (argMIDIChannelMessage x)

instance ObjCReturn MIDIChannelMessage where
  type RawReturn MIDIChannelMessage = MIDIChannelMessage
  objcRetType = retMIDIChannelMessage
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | MIDINoteMessage
--
-- The parameters to specify a MIDI note
data MIDINoteMessage = MIDINoteMessage
  { midiNoteMessageChannel :: !CUChar
  , midiNoteMessageNote :: !CUChar
  , midiNoteMessageVelocity :: !CUChar
  , midiNoteMessageReleaseVelocity :: !CUChar
  , midiNoteMessageDuration :: !CFloat
  } deriving (Eq, Show)

instance Storable MIDINoteMessage where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = MIDINoteMessage <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
    <*> peekByteOff p 3
    <*> peekByteOff p 4
  poke p (MIDINoteMessage {..}) = do
    pokeByteOff p 0 midiNoteMessageChannel
    pokeByteOff p 1 midiNoteMessageNote
    pokeByteOff p 2 midiNoteMessageVelocity
    pokeByteOff p 3 midiNoteMessageReleaseVelocity
    pokeByteOff p 4 midiNoteMessageDuration

{-# NOINLINE midiNoteMessageStructType #-}
midiNoteMessageStructType :: Ptr CType
midiNoteMessageStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_float]

argMIDINoteMessage :: MIDINoteMessage -> Arg
argMIDINoteMessage = mkStorableArg midiNoteMessageStructType

retMIDINoteMessage :: RetType MIDINoteMessage
retMIDINoteMessage = mkStorableRetType midiNoteMessageStructType

instance ObjCArgument MIDINoteMessage where
  withObjCArg x k = k (argMIDINoteMessage x)

instance ObjCReturn MIDINoteMessage where
  type RawReturn MIDINoteMessage = MIDINoteMessage
  objcRetType = retMIDINoteMessage
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AudioCodecMagicCookieInfo
--
-- Structure holding the magic cookie information.
--
-- Passed as input to AudioCodecGetProperty for kAudioCodecPropertyFormatList.				The first four + sizeof(void *) bytes of the buffer pointed at by outPropertyData				will contain this struct.
--
-- mMagicCookieSize
--
-- The size of the magic cookie
--
-- mMagicCookie
--
-- Generic const pointer to magic cookie
data MagicCookieInfo = MagicCookieInfo
  { magicCookieInfoMMagicCookieSize :: !CUInt
  , magicCookieInfoMMagicCookie :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable MagicCookieInfo where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = MagicCookieInfo <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (MagicCookieInfo {..}) = do
    pokeByteOff p 0 magicCookieInfoMMagicCookieSize
    pokeByteOff p 8 magicCookieInfoMMagicCookie

{-# NOINLINE magicCookieInfoStructType #-}
magicCookieInfoStructType :: Ptr CType
magicCookieInfoStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_pointer]

argMagicCookieInfo :: MagicCookieInfo -> Arg
argMagicCookieInfo = mkStorableArg magicCookieInfoStructType

retMagicCookieInfo :: RetType MagicCookieInfo
retMagicCookieInfo = mkStorableRetType magicCookieInfoStructType

instance ObjCArgument MagicCookieInfo where
  withObjCArg x k = k (argMagicCookieInfo x)

instance ObjCReturn MagicCookieInfo where
  type RawReturn MagicCookieInfo = MagicCookieInfo
  objcRetType = retMagicCookieInfo
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | MixerDistanceParams
data MixerDistanceParams = MixerDistanceParams
  { mixerDistanceParamsMReferenceDistance :: !CFloat
  , mixerDistanceParamsMMaxDistance :: !CFloat
  , mixerDistanceParamsMMaxAttenuation :: !CFloat
  } deriving (Eq, Show)

instance Storable MixerDistanceParams where
  sizeOf    _ = 12
  alignment _ = 4
  peek p = MixerDistanceParams <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (MixerDistanceParams {..}) = do
    pokeByteOff p 0 mixerDistanceParamsMReferenceDistance
    pokeByteOff p 4 mixerDistanceParamsMMaxDistance
    pokeByteOff p 8 mixerDistanceParamsMMaxAttenuation

{-# NOINLINE mixerDistanceParamsStructType #-}
mixerDistanceParamsStructType :: Ptr CType
mixerDistanceParamsStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_float, ffi_type_float, ffi_type_float]

argMixerDistanceParams :: MixerDistanceParams -> Arg
argMixerDistanceParams = mkStorableArg mixerDistanceParamsStructType

retMixerDistanceParams :: RetType MixerDistanceParams
retMixerDistanceParams = mkStorableRetType mixerDistanceParamsStructType

instance ObjCArgument MixerDistanceParams where
  withObjCArg x k = k (argMixerDistanceParams x)

instance ObjCReturn MixerDistanceParams where
  type RawReturn MixerDistanceParams = MixerDistanceParams
  objcRetType = retMixerDistanceParams
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | MusicDeviceStdNoteParams
--
-- convenience struct for specifying a note and velocity
--
-- This struct is the common usage for MusicDeviceStartNote, as most synths that implement this functionality 				will only allow for the specification of a note number and velocity when starting a new note.
--
-- argCount
--
-- Should be set to 2
--
-- mPitch
--
-- The pitch of the new note, typically specified using a MIDI note number (and a fractional pitch) within the 					range of 0 < 128. So 60 is middle C, 60.5 is middle C + 50 cents.
--
-- mVelocity
--
-- The velocity of the new note - this can be a fractional value - specified as MIDI (within the range of 0 < 128)
data MusicDeviceStdNoteParams = MusicDeviceStdNoteParams
  { musicDeviceStdNoteParamsArgCount :: !CUInt
  , musicDeviceStdNoteParamsMPitch :: !CFloat
  , musicDeviceStdNoteParamsMVelocity :: !CFloat
  } deriving (Eq, Show)

instance Storable MusicDeviceStdNoteParams where
  sizeOf    _ = 12
  alignment _ = 4
  peek p = MusicDeviceStdNoteParams <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (MusicDeviceStdNoteParams {..}) = do
    pokeByteOff p 0 musicDeviceStdNoteParamsArgCount
    pokeByteOff p 4 musicDeviceStdNoteParamsMPitch
    pokeByteOff p 8 musicDeviceStdNoteParamsMVelocity

{-# NOINLINE musicDeviceStdNoteParamsStructType #-}
musicDeviceStdNoteParamsStructType :: Ptr CType
musicDeviceStdNoteParamsStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_float, ffi_type_float]

argMusicDeviceStdNoteParams :: MusicDeviceStdNoteParams -> Arg
argMusicDeviceStdNoteParams = mkStorableArg musicDeviceStdNoteParamsStructType

retMusicDeviceStdNoteParams :: RetType MusicDeviceStdNoteParams
retMusicDeviceStdNoteParams = mkStorableRetType musicDeviceStdNoteParamsStructType

instance ObjCArgument MusicDeviceStdNoteParams where
  withObjCArg x k = k (argMusicDeviceStdNoteParams x)

instance ObjCReturn MusicDeviceStdNoteParams where
  type RawReturn MusicDeviceStdNoteParams = MusicDeviceStdNoteParams
  objcRetType = retMusicDeviceStdNoteParams
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | MusicTrackLoopInfo
--
-- Used to control the looping behaviour of a track
data MusicTrackLoopInfo = MusicTrackLoopInfo
  { musicTrackLoopInfoLoopDuration :: !CDouble
  , musicTrackLoopInfoNumberOfLoops :: !CInt
  } deriving (Eq, Show)

instance Storable MusicTrackLoopInfo where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = MusicTrackLoopInfo <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (MusicTrackLoopInfo {..}) = do
    pokeByteOff p 0 musicTrackLoopInfoLoopDuration
    pokeByteOff p 8 musicTrackLoopInfoNumberOfLoops

{-# NOINLINE musicTrackLoopInfoStructType #-}
musicTrackLoopInfoStructType :: Ptr CType
musicTrackLoopInfoStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_double, ffi_type_sint]

argMusicTrackLoopInfo :: MusicTrackLoopInfo -> Arg
argMusicTrackLoopInfo = mkStorableArg musicTrackLoopInfoStructType

retMusicTrackLoopInfo :: RetType MusicTrackLoopInfo
retMusicTrackLoopInfo = mkStorableRetType musicTrackLoopInfoStructType

instance ObjCArgument MusicTrackLoopInfo where
  withObjCArg x k = k (argMusicTrackLoopInfo x)

instance ObjCReturn MusicTrackLoopInfo where
  type RawReturn MusicTrackLoopInfo = MusicTrackLoopInfo
  objcRetType = retMusicTrackLoopInfo
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | NoteParamsControlValue
--
-- used to describe a control and value
--
-- This struct is used to describe a parameterID (a control in MIDI terminology, though it is not limited to 					MIDI CC specifications) and the value of this parameter.
--
-- mID
--
-- The parameter ID
--
-- mValue
--
-- The value of that parameter
data NoteParamsControlValue = NoteParamsControlValue
  { noteParamsControlValueMID :: !CUInt
  , noteParamsControlValueMValue :: !CFloat
  } deriving (Eq, Show)

instance Storable NoteParamsControlValue where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = NoteParamsControlValue <$> peekByteOff p 0
    <*> peekByteOff p 4
  poke p (NoteParamsControlValue {..}) = do
    pokeByteOff p 0 noteParamsControlValueMID
    pokeByteOff p 4 noteParamsControlValueMValue

{-# NOINLINE noteParamsControlValueStructType #-}
noteParamsControlValueStructType :: Ptr CType
noteParamsControlValueStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_float]

argNoteParamsControlValue :: NoteParamsControlValue -> Arg
argNoteParamsControlValue = mkStorableArg noteParamsControlValueStructType

retNoteParamsControlValue :: RetType NoteParamsControlValue
retNoteParamsControlValue = mkStorableRetType noteParamsControlValueStructType

instance ObjCArgument NoteParamsControlValue where
  withObjCArg x k = k (argNoteParamsControlValue x)

instance ObjCReturn NoteParamsControlValue where
  type RawReturn NoteParamsControlValue = NoteParamsControlValue
  objcRetType = retNoteParamsControlValue
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | ParameterEvent
--
-- The parameters to specify a parameter event to an audio unit.
data ParameterEvent = ParameterEvent
  { parameterEventParameterID :: !CUInt
  , parameterEventScope :: !CUInt
  , parameterEventElement :: !CUInt
  , parameterEventValue :: !CFloat
  } deriving (Eq, Show)

instance Storable ParameterEvent where
  sizeOf    _ = 16
  alignment _ = 4
  peek p = ParameterEvent <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
  poke p (ParameterEvent {..}) = do
    pokeByteOff p 0 parameterEventParameterID
    pokeByteOff p 4 parameterEventScope
    pokeByteOff p 8 parameterEventElement
    pokeByteOff p 12 parameterEventValue

{-# NOINLINE parameterEventStructType #-}
parameterEventStructType :: Ptr CType
parameterEventStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_float]

argParameterEvent :: ParameterEvent -> Arg
argParameterEvent = mkStorableArg parameterEventStructType

retParameterEvent :: RetType ParameterEvent
retParameterEvent = mkStorableRetType parameterEventStructType

instance ObjCArgument ParameterEvent where
  withObjCArg x k = k (argParameterEvent x)

instance ObjCReturn ParameterEvent where
  type RawReturn ParameterEvent = ParameterEvent
  objcRetType = retParameterEvent
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AUHostIdentifier
--
-- Used to describe the name and version of the audio unit's host
data AUHostIdentifier = AUHostIdentifier
  { auHostIdentifierHostName :: !(Ptr ())
  , auHostIdentifierHostVersion :: !AUNumVersion
  } deriving (Eq, Show)

instance Storable AUHostIdentifier where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = AUHostIdentifier <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (AUHostIdentifier {..}) = do
    pokeByteOff p 0 auHostIdentifierHostName
    pokeByteOff p 8 auHostIdentifierHostVersion

{-# NOINLINE auHostIdentifierStructType #-}
auHostIdentifierStructType :: Ptr CType
auHostIdentifierStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer, auNumVersionStructType]

argAUHostIdentifier :: AUHostIdentifier -> Arg
argAUHostIdentifier = mkStorableArg auHostIdentifierStructType

retAUHostIdentifier :: RetType AUHostIdentifier
retAUHostIdentifier = mkStorableRetType auHostIdentifierStructType

instance ObjCArgument AUHostIdentifier where
  withObjCArg x k = k (argAUHostIdentifier x)

instance ObjCReturn AUHostIdentifier where
  type RawReturn AUHostIdentifier = AUHostIdentifier
  objcRetType = retAUHostIdentifier
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AUNodeRenderCallback
--
-- A callback used to provide input to an audio unit
--
-- Used to contain information when a callback is used	to provide input to the specific node's specified input
--
-- destNode
--
-- destInputNumber
--
-- cback
data AUNodeRenderCallback = AUNodeRenderCallback
  { auNodeRenderCallbackDestNode :: !CInt
  , auNodeRenderCallbackDestInputNumber :: !CUInt
  , auNodeRenderCallbackCback :: !AURenderCallbackStruct
  } deriving (Eq, Show)

instance Storable AUNodeRenderCallback where
  sizeOf    _ = 24
  alignment _ = 8
  peek p = AUNodeRenderCallback <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (AUNodeRenderCallback {..}) = do
    pokeByteOff p 0 auNodeRenderCallbackDestNode
    pokeByteOff p 4 auNodeRenderCallbackDestInputNumber
    pokeByteOff p 8 auNodeRenderCallbackCback

{-# NOINLINE auNodeRenderCallbackStructType #-}
auNodeRenderCallbackStructType :: Ptr CType
auNodeRenderCallbackStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_uint, auRenderCallbackStructStructType]

argAUNodeRenderCallback :: AUNodeRenderCallback -> Arg
argAUNodeRenderCallback = mkStorableArg auNodeRenderCallbackStructType

retAUNodeRenderCallback :: RetType AUNodeRenderCallback
retAUNodeRenderCallback = mkStorableRetType auNodeRenderCallbackStructType

instance ObjCArgument AUNodeRenderCallback where
  withObjCArg x k = k (argAUNodeRenderCallback x)

instance ObjCReturn AUNodeRenderCallback where
  type RawReturn AUNodeRenderCallback = AUNodeRenderCallback
  objcRetType = retAUNodeRenderCallback
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AudioFileMarker
--
-- A marker annotates a position in an audio file with additional information.
--
-- (description)
--
-- mFramePosition	The frame in the file counting from the start of the audio data.
--
-- mName			The name of this marker.
--
-- mMarkerID		A unique ID for this marker.
--
-- mSMPTETime		The SMPTE time for this marker.
--
-- mType			The marker type.
--
-- mReserved		A reserved field. Set to zero.
--
-- mChannel		The channel number that the marker refers to. Set to zero if marker applies to all channels.
data AudioFileMarker = AudioFileMarker
  { audioFileMarkerMFramePosition :: !CDouble
  , audioFileMarkerMName :: !(Ptr ())
  , audioFileMarkerMMarkerID :: !CInt
  , audioFileMarkerMSMPTETime :: !AudioFile_SMPTE_Time
  , audioFileMarkerMType :: !CUInt
  , audioFileMarkerMReserved :: !CUShort
  , audioFileMarkerMChannel :: !CUShort
  } deriving (Eq, Show)

instance Storable AudioFileMarker where
  sizeOf    _ = 40
  alignment _ = 8
  peek p = AudioFileMarker <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 20
    <*> peekByteOff p 28
    <*> peekByteOff p 32
    <*> peekByteOff p 34
  poke p (AudioFileMarker {..}) = do
    pokeByteOff p 0 audioFileMarkerMFramePosition
    pokeByteOff p 8 audioFileMarkerMName
    pokeByteOff p 16 audioFileMarkerMMarkerID
    pokeByteOff p 20 audioFileMarkerMSMPTETime
    pokeByteOff p 28 audioFileMarkerMType
    pokeByteOff p 32 audioFileMarkerMReserved
    pokeByteOff p 34 audioFileMarkerMChannel

{-# NOINLINE audioFileMarkerStructType #-}
audioFileMarkerStructType :: Ptr CType
audioFileMarkerStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_double, ffi_type_pointer, ffi_type_sint, audioFile_SMPTE_TimeStructType, ffi_type_uint, ffi_type_uint16, ffi_type_uint16]

argAudioFileMarker :: AudioFileMarker -> Arg
argAudioFileMarker = mkStorableArg audioFileMarkerStructType

retAudioFileMarker :: RetType AudioFileMarker
retAudioFileMarker = mkStorableRetType audioFileMarkerStructType

instance ObjCArgument AudioFileMarker where
  withObjCArg x k = k (argAudioFileMarker x)

instance ObjCReturn AudioFileMarker where
  type RawReturn AudioFileMarker = AudioFileMarker
  objcRetType = retAudioFileMarker
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AudioFormatInfo
--
-- this struct is used as a specifier for the kAudioFormatProperty_FormatList property
--
-- mASBD
--
-- an AudioStreamBasicDescription
--
-- mMagicCookie
--
-- a pointer to the decompression info for the data described in mASBD
--
-- mMagicCookieSize
--
-- the size in bytes of mMagicCookie
data AudioFormatInfo = AudioFormatInfo
  { audioFormatInfoMASBD :: !AudioStreamBasicDescription
  , audioFormatInfoMMagicCookie :: !(Ptr ())
  , audioFormatInfoMMagicCookieSize :: !CUInt
  } deriving (Eq, Show)

instance Storable AudioFormatInfo where
  sizeOf    _ = 56
  alignment _ = 8
  peek p = AudioFormatInfo <$> peekByteOff p 0
    <*> peekByteOff p 40
    <*> peekByteOff p 48
  poke p (AudioFormatInfo {..}) = do
    pokeByteOff p 0 audioFormatInfoMASBD
    pokeByteOff p 40 audioFormatInfoMMagicCookie
    pokeByteOff p 48 audioFormatInfoMMagicCookieSize

{-# NOINLINE audioFormatInfoStructType #-}
audioFormatInfoStructType :: Ptr CType
audioFormatInfoStructType = unsafePerformIO $ fst <$> newStructCType [audioStreamBasicDescriptionStructType, ffi_type_pointer, ffi_type_uint]

argAudioFormatInfo :: AudioFormatInfo -> Arg
argAudioFormatInfo = mkStorableArg audioFormatInfoStructType

retAudioFormatInfo :: RetType AudioFormatInfo
retAudioFormatInfo = mkStorableRetType audioFormatInfoStructType

instance ObjCArgument AudioFormatInfo where
  withObjCArg x k = k (argAudioFormatInfo x)

instance ObjCReturn AudioFormatInfo where
  type RawReturn AudioFormatInfo = AudioFormatInfo
  objcRetType = retAudioFormatInfo
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AudioUnitOtherPluginDesc
--
-- format
--
-- One of the OtherPluginFormat values
--
-- plugin
--
-- struct AudioClassDescription {							OSType mType;							OSType mSubType;							OSType mManufacturer;						};						is defined in <CoreAudioTypes/CoreAudioTypes.h>
--
-- mType specifies a generic, plug-in format defined descriptor							mSubType is usually left to the manufacturer to use at their discretion							mManufacturer is a registered code to identify all plugins from the same manufacturer
data AudioUnitOtherPluginDesc = AudioUnitOtherPluginDesc
  { audioUnitOtherPluginDescFormat :: !CUInt
  , audioUnitOtherPluginDescPlugin :: !AudioClassDescription
  } deriving (Eq, Show)

instance Storable AudioUnitOtherPluginDesc where
  sizeOf    _ = 16
  alignment _ = 4
  peek p = AudioUnitOtherPluginDesc <$> peekByteOff p 0
    <*> peekByteOff p 4
  poke p (AudioUnitOtherPluginDesc {..}) = do
    pokeByteOff p 0 audioUnitOtherPluginDescFormat
    pokeByteOff p 4 audioUnitOtherPluginDescPlugin

{-# NOINLINE audioUnitOtherPluginDescStructType #-}
audioUnitOtherPluginDescStructType :: Ptr CType
audioUnitOtherPluginDescStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, audioClassDescriptionStructType]

argAudioUnitOtherPluginDesc :: AudioUnitOtherPluginDesc -> Arg
argAudioUnitOtherPluginDesc = mkStorableArg audioUnitOtherPluginDescStructType

retAudioUnitOtherPluginDesc :: RetType AudioUnitOtherPluginDesc
retAudioUnitOtherPluginDesc = mkStorableRetType audioUnitOtherPluginDescStructType

instance ObjCArgument AudioUnitOtherPluginDesc where
  withObjCArg x k = k (argAudioUnitOtherPluginDesc x)

instance ObjCReturn AudioUnitOtherPluginDesc where
  type RawReturn AudioUnitOtherPluginDesc = AudioUnitOtherPluginDesc
  objcRetType = retAudioUnitOtherPluginDesc
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data CAFMarker = CAFMarker
  { cafMarkerMType :: !CUInt
  , cafMarkerMFramePosition :: !CDouble
  , cafMarkerMMarkerID :: !CUInt
  , cafMarkerMSMPTETime :: !CAF_SMPTE_Time
  , cafMarkerMChannel :: !CUInt
  } deriving (Eq, Show)

instance Storable CAFMarker where
  sizeOf    _ = 32
  alignment _ = 8
  peek p = CAFMarker <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 20
    <*> peekByteOff p 28
  poke p (CAFMarker {..}) = do
    pokeByteOff p 0 cafMarkerMType
    pokeByteOff p 8 cafMarkerMFramePosition
    pokeByteOff p 16 cafMarkerMMarkerID
    pokeByteOff p 20 cafMarkerMSMPTETime
    pokeByteOff p 28 cafMarkerMChannel

{-# NOINLINE cafMarkerStructType #-}
cafMarkerStructType :: Ptr CType
cafMarkerStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_double, ffi_type_uint, caF_SMPTE_TimeStructType, ffi_type_uint]

argCAFMarker :: CAFMarker -> Arg
argCAFMarker = mkStorableArg cafMarkerStructType

retCAFMarker :: RetType CAFMarker
retCAFMarker = mkStorableRetType cafMarkerStructType

instance ObjCArgument CAFMarker where
  withObjCArg x k = k (argCAFMarker x)

instance ObjCReturn CAFMarker where
  type RawReturn CAFMarker = CAFMarker
  objcRetType = retCAFMarker
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | ExtendedAudioFormatInfo
--
-- this struct is used as a specifier for the kAudioFormatProperty_FormatList property
--
-- mASBD
--
-- an AudioStreamBasicDescription
--
-- mMagicCookie
--
-- a pointer to the decompression info for the data described in mASBD
--
-- mMagicCookieSize
--
-- the size in bytes of mMagicCookie
--
-- mClassDescription
--
-- an AudioClassDescription specifying the codec to be used in answering the question.
data ExtendedAudioFormatInfo = ExtendedAudioFormatInfo
  { extendedAudioFormatInfoMASBD :: !AudioStreamBasicDescription
  , extendedAudioFormatInfoMMagicCookie :: !(Ptr ())
  , extendedAudioFormatInfoMMagicCookieSize :: !CUInt
  , extendedAudioFormatInfoMClassDescription :: !AudioClassDescription
  } deriving (Eq, Show)

instance Storable ExtendedAudioFormatInfo where
  sizeOf    _ = 64
  alignment _ = 8
  peek p = ExtendedAudioFormatInfo <$> peekByteOff p 0
    <*> peekByteOff p 40
    <*> peekByteOff p 48
    <*> peekByteOff p 52
  poke p (ExtendedAudioFormatInfo {..}) = do
    pokeByteOff p 0 extendedAudioFormatInfoMASBD
    pokeByteOff p 40 extendedAudioFormatInfoMMagicCookie
    pokeByteOff p 48 extendedAudioFormatInfoMMagicCookieSize
    pokeByteOff p 52 extendedAudioFormatInfoMClassDescription

{-# NOINLINE extendedAudioFormatInfoStructType #-}
extendedAudioFormatInfoStructType :: Ptr CType
extendedAudioFormatInfoStructType = unsafePerformIO $ fst <$> newStructCType [audioStreamBasicDescriptionStructType, ffi_type_pointer, ffi_type_uint, audioClassDescriptionStructType]

argExtendedAudioFormatInfo :: ExtendedAudioFormatInfo -> Arg
argExtendedAudioFormatInfo = mkStorableArg extendedAudioFormatInfoStructType

retExtendedAudioFormatInfo :: RetType ExtendedAudioFormatInfo
retExtendedAudioFormatInfo = mkStorableRetType extendedAudioFormatInfoStructType

instance ObjCArgument ExtendedAudioFormatInfo where
  withObjCArg x k = k (argExtendedAudioFormatInfo x)

instance ObjCReturn ExtendedAudioFormatInfo where
  type RawReturn ExtendedAudioFormatInfo = ExtendedAudioFormatInfo
  objcRetType = retExtendedAudioFormatInfo
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AudioOutputUnitStartAtTimeParams
data AudioOutputUnitStartAtTimeParams = AudioOutputUnitStartAtTimeParams
  { audioOutputUnitStartAtTimeParamsMTimestamp :: !AudioTimeStamp
  , audioOutputUnitStartAtTimeParamsMFlags :: !CUInt
  } deriving (Eq, Show)

instance Storable AudioOutputUnitStartAtTimeParams where
  sizeOf    _ = 72
  alignment _ = 8
  peek p = AudioOutputUnitStartAtTimeParams <$> peekByteOff p 0
    <*> peekByteOff p 64
  poke p (AudioOutputUnitStartAtTimeParams {..}) = do
    pokeByteOff p 0 audioOutputUnitStartAtTimeParamsMTimestamp
    pokeByteOff p 64 audioOutputUnitStartAtTimeParamsMFlags

{-# NOINLINE audioOutputUnitStartAtTimeParamsStructType #-}
audioOutputUnitStartAtTimeParamsStructType :: Ptr CType
audioOutputUnitStartAtTimeParamsStructType = unsafePerformIO $ fst <$> newStructCType [audioTimeStampStructType, ffi_type_uint]

argAudioOutputUnitStartAtTimeParams :: AudioOutputUnitStartAtTimeParams -> Arg
argAudioOutputUnitStartAtTimeParams = mkStorableArg audioOutputUnitStartAtTimeParamsStructType

retAudioOutputUnitStartAtTimeParams :: RetType AudioOutputUnitStartAtTimeParams
retAudioOutputUnitStartAtTimeParams = mkStorableRetType audioOutputUnitStartAtTimeParamsStructType

instance ObjCArgument AudioOutputUnitStartAtTimeParams where
  withObjCArg x k = k (argAudioOutputUnitStartAtTimeParams x)

instance ObjCReturn AudioOutputUnitStartAtTimeParams where
  type RawReturn AudioOutputUnitStartAtTimeParams = AudioOutputUnitStartAtTimeParams
  objcRetType = retAudioOutputUnitStartAtTimeParams
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AudioUnitParameterValueTranslation
--
-- Used to translate another plug-in's parameter values to  audio unit parameter 					values
data AudioUnitParameterValueTranslation = AudioUnitParameterValueTranslation
  { audioUnitParameterValueTranslationOtherDesc :: !AudioUnitOtherPluginDesc
  , audioUnitParameterValueTranslationOtherParamID :: !CUInt
  , audioUnitParameterValueTranslationOtherValue :: !CFloat
  , audioUnitParameterValueTranslationAuParamID :: !CUInt
  , audioUnitParameterValueTranslationAuValue :: !CFloat
  } deriving (Eq, Show)

instance Storable AudioUnitParameterValueTranslation where
  sizeOf    _ = 32
  alignment _ = 4
  peek p = AudioUnitParameterValueTranslation <$> peekByteOff p 0
    <*> peekByteOff p 16
    <*> peekByteOff p 20
    <*> peekByteOff p 24
    <*> peekByteOff p 28
  poke p (AudioUnitParameterValueTranslation {..}) = do
    pokeByteOff p 0 audioUnitParameterValueTranslationOtherDesc
    pokeByteOff p 16 audioUnitParameterValueTranslationOtherParamID
    pokeByteOff p 20 audioUnitParameterValueTranslationOtherValue
    pokeByteOff p 24 audioUnitParameterValueTranslationAuParamID
    pokeByteOff p 28 audioUnitParameterValueTranslationAuValue

{-# NOINLINE audioUnitParameterValueTranslationStructType #-}
audioUnitParameterValueTranslationStructType :: Ptr CType
audioUnitParameterValueTranslationStructType = unsafePerformIO $ fst <$> newStructCType [audioUnitOtherPluginDescStructType, ffi_type_uint, ffi_type_float, ffi_type_uint, ffi_type_float]

argAudioUnitParameterValueTranslation :: AudioUnitParameterValueTranslation -> Arg
argAudioUnitParameterValueTranslation = mkStorableArg audioUnitParameterValueTranslationStructType

retAudioUnitParameterValueTranslation :: RetType AudioUnitParameterValueTranslation
retAudioUnitParameterValueTranslation = mkStorableRetType audioUnitParameterValueTranslationStructType

instance ObjCArgument AudioUnitParameterValueTranslation where
  withObjCArg x k = k (argAudioUnitParameterValueTranslation x)

instance ObjCReturn AudioUnitParameterValueTranslation where
  type RawReturn AudioUnitParameterValueTranslation = AudioUnitParameterValueTranslation
  objcRetType = retAudioUnitParameterValueTranslation
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | ScheduledAudioFileRegion
--
-- mTimeStamp
--
-- mCompletionProc
--
-- may be NULL
--
-- mCompletionProcUserData
--
-- mAudioFile
--
-- must be a valid and open AudioFileID						defined in AudioToolbox/AudioFile.h: typedef	struct OpaqueAudioFileID	*AudioFileID;
--
-- mLoopCount
--
-- 0 = don't loop
--
-- mStartFrame
--
-- offset into file
--
-- mFramesToPlay
--
-- number of frames to play
data ScheduledAudioFileRegion = ScheduledAudioFileRegion
  { scheduledAudioFileRegionMTimeStamp :: !AudioTimeStamp
  , scheduledAudioFileRegionMCompletionProc :: !(Ptr ())
  , scheduledAudioFileRegionMCompletionProcUserData :: !(Ptr ())
  , scheduledAudioFileRegionMAudioFile :: !(Ptr ())
  , scheduledAudioFileRegionMLoopCount :: !CUInt
  , scheduledAudioFileRegionMStartFrame :: !CLong
  , scheduledAudioFileRegionMFramesToPlay :: !CUInt
  } deriving (Eq, Show)

instance Storable ScheduledAudioFileRegion where
  sizeOf    _ = 112
  alignment _ = 8
  peek p = ScheduledAudioFileRegion <$> peekByteOff p 0
    <*> peekByteOff p 64
    <*> peekByteOff p 72
    <*> peekByteOff p 80
    <*> peekByteOff p 88
    <*> peekByteOff p 96
    <*> peekByteOff p 104
  poke p (ScheduledAudioFileRegion {..}) = do
    pokeByteOff p 0 scheduledAudioFileRegionMTimeStamp
    pokeByteOff p 64 scheduledAudioFileRegionMCompletionProc
    pokeByteOff p 72 scheduledAudioFileRegionMCompletionProcUserData
    pokeByteOff p 80 scheduledAudioFileRegionMAudioFile
    pokeByteOff p 88 scheduledAudioFileRegionMLoopCount
    pokeByteOff p 96 scheduledAudioFileRegionMStartFrame
    pokeByteOff p 104 scheduledAudioFileRegionMFramesToPlay

{-# NOINLINE scheduledAudioFileRegionStructType #-}
scheduledAudioFileRegionStructType :: Ptr CType
scheduledAudioFileRegionStructType = unsafePerformIO $ fst <$> newStructCType [audioTimeStampStructType, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_uint, ffi_type_slong, ffi_type_uint]

argScheduledAudioFileRegion :: ScheduledAudioFileRegion -> Arg
argScheduledAudioFileRegion = mkStorableArg scheduledAudioFileRegionStructType

retScheduledAudioFileRegion :: RetType ScheduledAudioFileRegion
retScheduledAudioFileRegion = mkStorableRetType scheduledAudioFileRegionStructType

instance ObjCArgument ScheduledAudioFileRegion where
  withObjCArg x k = k (argScheduledAudioFileRegion x)

instance ObjCReturn ScheduledAudioFileRegion where
  type RawReturn ScheduledAudioFileRegion = ScheduledAudioFileRegion
  objcRetType = retScheduledAudioFileRegion
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure
