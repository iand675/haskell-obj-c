{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TypeFamilies #-}

-- | Struct types for this framework.
--
-- Generated by objc-codegen. Do not edit.
module ObjC.AVFAudio.Internal.Structs where

import Foreign.Ptr (Ptr, FunPtr)
import Foreign.Storable (Storable(..))
import Foreign.C.Types
import Foreign.LibFFI.Base (Arg, RetType, mkStorableArg, mkStorableRetType, newStructCType)
import Foreign.LibFFI.FFITypes
import Foreign.LibFFI.Internal (CType)
import System.IO.Unsafe (unsafePerformIO)
import ObjC.Runtime.Message (ObjCArgument(..), ObjCReturn(..), MsgSendVariant(..))

-- | AVAudio3DAngularOrientation
--
-- Struct representing the orientation of the listener in 3D space
--
-- Three angles describe the orientation of a listener's head - yaw, pitch and roll.
--
-- Yaw describes the side to side movement of the listener's head.        The yaw axis is perpendicular to the plane of the listener's ears with its origin at the         center of the listener's head and directed towards the bottom of the listener's head. A         positive yaw is in the clockwise direction going from 0 to 180 degrees. A negative yaw is in         the counter-clockwise direction going from 0 to -180 degrees.
--
-- Pitch describes the up-down movement of the listener's head.        The pitch axis is perpendicular to the yaw axis and is parallel to the plane of the         listener's ears with its origin at the center of the listener's head and directed towards         the right ear. A positive pitch is the upwards direction going from 0 to 180 degrees. A         negative pitch is in the downwards direction going from 0 to -180 degrees.
--
-- Roll describes the tilt of the listener's head.        The roll axis is perpendicular to the other two axes with its origin at the center of the         listener's head and is directed towards the listener's nose. A positive roll is to the right         going from 0 to 180 degrees. A negative roll is to the left going from 0 to -180 degrees.
data AVAudio3DAngularOrientation = AVAudio3DAngularOrientation
  { avAudio3DAngularOrientationYaw :: !CFloat
  , avAudio3DAngularOrientationPitch :: !CFloat
  , avAudio3DAngularOrientationRoll :: !CFloat
  } deriving (Eq, Show)

instance Storable AVAudio3DAngularOrientation where
  sizeOf    _ = 12
  alignment _ = 4
  peek p = AVAudio3DAngularOrientation <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (AVAudio3DAngularOrientation {..}) = do
    pokeByteOff p 0 avAudio3DAngularOrientationYaw
    pokeByteOff p 4 avAudio3DAngularOrientationPitch
    pokeByteOff p 8 avAudio3DAngularOrientationRoll

{-# NOINLINE avAudio3DAngularOrientationStructType #-}
avAudio3DAngularOrientationStructType :: Ptr CType
avAudio3DAngularOrientationStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_float, ffi_type_float, ffi_type_float]

argAVAudio3DAngularOrientation :: AVAudio3DAngularOrientation -> Arg
argAVAudio3DAngularOrientation = mkStorableArg avAudio3DAngularOrientationStructType

retAVAudio3DAngularOrientation :: RetType AVAudio3DAngularOrientation
retAVAudio3DAngularOrientation = mkStorableRetType avAudio3DAngularOrientationStructType

instance ObjCArgument AVAudio3DAngularOrientation where
  withObjCArg x k = k (argAVAudio3DAngularOrientation x)

instance ObjCReturn AVAudio3DAngularOrientation where
  type RawReturn AVAudio3DAngularOrientation = AVAudio3DAngularOrientation
  objcRetType = retAVAudio3DAngularOrientation
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AVAudio3DPoint
--
-- Struct representing a point in 3D space
--
-- This struct is used by classes dealing with 3D audio such as @AVAudioMixing@        and @AVAudioEnvironmentNode@ and represents a point in 3D space.
data AVAudio3DPoint = AVAudio3DPoint
  { avAudio3DPointX :: !CFloat
  , avAudio3DPointY :: !CFloat
  , avAudio3DPointZ :: !CFloat
  } deriving (Eq, Show)

instance Storable AVAudio3DPoint where
  sizeOf    _ = 12
  alignment _ = 4
  peek p = AVAudio3DPoint <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (AVAudio3DPoint {..}) = do
    pokeByteOff p 0 avAudio3DPointX
    pokeByteOff p 4 avAudio3DPointY
    pokeByteOff p 8 avAudio3DPointZ

{-# NOINLINE avAudio3DPointStructType #-}
avAudio3DPointStructType :: Ptr CType
avAudio3DPointStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_float, ffi_type_float, ffi_type_float]

argAVAudio3DPoint :: AVAudio3DPoint -> Arg
argAVAudio3DPoint = mkStorableArg avAudio3DPointStructType

retAVAudio3DPoint :: RetType AVAudio3DPoint
retAVAudio3DPoint = mkStorableRetType avAudio3DPointStructType

instance ObjCArgument AVAudio3DPoint where
  withObjCArg x k = k (argAVAudio3DPoint x)

instance ObjCReturn AVAudio3DPoint where
  type RawReturn AVAudio3DPoint = AVAudio3DPoint
  objcRetType = retAVAudio3DPoint
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AVAudio3DPoint
--
-- Struct representing a point in 3D space
--
-- This struct is used by classes dealing with 3D audio such as @AVAudioMixing@        and @AVAudioEnvironmentNode@ and represents a point in 3D space.
data AVAudio3DVector = AVAudio3DVector
  { avAudio3DVectorX :: !CFloat
  , avAudio3DVectorY :: !CFloat
  , avAudio3DVectorZ :: !CFloat
  } deriving (Eq, Show)

instance Storable AVAudio3DVector where
  sizeOf    _ = 12
  alignment _ = 4
  peek p = AVAudio3DVector <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (AVAudio3DVector {..}) = do
    pokeByteOff p 0 avAudio3DVectorX
    pokeByteOff p 4 avAudio3DVectorY
    pokeByteOff p 8 avAudio3DVectorZ

{-# NOINLINE avAudio3DVectorStructType #-}
avAudio3DVectorStructType :: Ptr CType
avAudio3DVectorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_float, ffi_type_float, ffi_type_float]

argAVAudio3DVector :: AVAudio3DVector -> Arg
argAVAudio3DVector = mkStorableArg avAudio3DVectorStructType

retAVAudio3DVector :: RetType AVAudio3DVector
retAVAudio3DVector = mkStorableRetType avAudio3DVectorStructType

instance ObjCArgument AVAudio3DVector where
  withObjCArg x k = k (argAVAudio3DVector x)

instance ObjCReturn AVAudio3DVector where
  type RawReturn AVAudio3DVector = AVAudio3DVector
  objcRetType = retAVAudio3DVector
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AVAudioConverterPrimeInfo
--
-- This struct is the value of the primeInfo property and specifies priming information.
--
-- When using convertToBuffer:error:withInputFromBlock: (either a single call or a series of calls), some	conversions, particularly involving sample-rate conversion, ideally require a certain	number of input frames previous to the normal start input frame and beyond the end of	the last expected input frame in order to yield high-quality results.
--
-- These are expressed in the leadingFrames and trailingFrames members of the structure.
--
-- The very first call to convertToBuffer:error:withInputFromBlock:, or first call after	reset, will request additional input frames beyond those normally	expected in the input proc callback to fulfill this first AudioConverterFillComplexBuffer()	request. The number of additional frames requested, depending on the prime method, will	be approximately:
--
-- Prime method						| Additional frames	------------------------------------|----------------------	AVAudioConverterPrimeMethod_Pre     | leadingFrames + trailingFrames	AVAudioConverterPrimeMethod_Normal  | trailingFrames	AVAudioConverterPrimeMethod_None    | 0
--
-- Thus, in effect, the first input proc callback(s) may provide not only the leading	frames, but also may "read ahead" by an additional number of trailing frames depending	on the prime method.
--
-- AVAudioConverterPrimeMethod_None is useful in a real-time application processing live input,	in which case trailingFrames (relative to input sample rate) of through latency will be	seen at the beginning of the output of the AudioConverter.  In other real-time	applications such as DAW systems, it may be possible to provide these initial extra	audio frames since they are stored on disk or in memory somewhere and	AVAudioConverterPrimeMethod_Pre may be preferable.  The default method is	AVAudioConverterPrimeMethod_Normal, which requires no pre-seeking of the input stream and	generates no latency at the output.
--
-- leadingFrames        Specifies the number of leading (previous) input frames, relative to the normal/desired        start input frame, required by the converter to perform a high quality conversion. If        using AVAudioConverterPrimeMethod_Pre, the client should "pre-seek" the input stream provided        through the input proc by leadingFrames. If no frames are available previous to the        desired input start frame (because, for example, the desired start frame is at the very        beginning of available audio), then provide "leadingFrames" worth of initial zero frames        in the input proc.  Do not "pre-seek" in the default case of        AVAudioConverterPrimeMethod_Normal or when using AVAudioConverterPrimeMethod_None.
--
-- trailingFrames        Specifies the number of trailing input frames (past the normal/expected end input frame)        required by the converter to perform a high quality conversion.  The client should be        prepared to provide this number of additional input frames except when using        AVAudioConverterPrimeMethod_None. If no more frames of input are available in the input stream        (because, for example, the desired end frame is at the end of an audio file), then zero        (silent) trailing frames will be synthesized for the client.
data AVAudioConverterPrimeInfo = AVAudioConverterPrimeInfo
  { avAudioConverterPrimeInfoLeadingFrames :: !CUInt
  , avAudioConverterPrimeInfoTrailingFrames :: !CUInt
  } deriving (Eq, Show)

instance Storable AVAudioConverterPrimeInfo where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = AVAudioConverterPrimeInfo <$> peekByteOff p 0
    <*> peekByteOff p 4
  poke p (AVAudioConverterPrimeInfo {..}) = do
    pokeByteOff p 0 avAudioConverterPrimeInfoLeadingFrames
    pokeByteOff p 4 avAudioConverterPrimeInfoTrailingFrames

{-# NOINLINE avAudioConverterPrimeInfoStructType #-}
avAudioConverterPrimeInfoStructType :: Ptr CType
avAudioConverterPrimeInfoStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint]

argAVAudioConverterPrimeInfo :: AVAudioConverterPrimeInfo -> Arg
argAVAudioConverterPrimeInfo = mkStorableArg avAudioConverterPrimeInfoStructType

retAVAudioConverterPrimeInfo :: RetType AVAudioConverterPrimeInfo
retAVAudioConverterPrimeInfo = mkStorableRetType avAudioConverterPrimeInfoStructType

instance ObjCArgument AVAudioConverterPrimeInfo where
  withObjCArg x k = k (argAVAudioConverterPrimeInfo x)

instance ObjCReturn AVAudioConverterPrimeInfo where
  type RawReturn AVAudioConverterPrimeInfo = AVAudioConverterPrimeInfo
  objcRetType = retAVAudioConverterPrimeInfo
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AVBeatRange
--
-- Used to describe a specific time range within an AVMusicTrack.
data AVBeatRange = AVBeatRange
  { avBeatRangeStart :: !CDouble
  , avBeatRangeLength :: !CDouble
  } deriving (Eq, Show)

instance Storable AVBeatRange where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = AVBeatRange <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (AVBeatRange {..}) = do
    pokeByteOff p 0 avBeatRangeStart
    pokeByteOff p 8 avBeatRangeLength

{-# NOINLINE avBeatRangeStructType #-}
avBeatRangeStructType :: Ptr CType
avBeatRangeStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_double, ffi_type_double]

argAVBeatRange :: AVBeatRange -> Arg
argAVBeatRange = mkStorableArg avBeatRangeStructType

retAVBeatRange :: RetType AVBeatRange
retAVBeatRange = mkStorableRetType avBeatRangeStructType

instance ObjCArgument AVBeatRange where
  withObjCArg x k = k (argAVBeatRange x)

instance ObjCReturn AVBeatRange where
  type RawReturn AVBeatRange = AVBeatRange
  objcRetType = retAVBeatRange
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AVAudio3DVectorOrientation
--
-- Struct representing the orientation of the listener in 3D space
--
-- Two orthogonal vectors describe the orientation of the listener. The forward        vector points in the direction that the listener is facing. The up vector is orthogonal        to the forward vector and points upwards from the listener's head.
data AVAudio3DVectorOrientation = AVAudio3DVectorOrientation
  { avAudio3DVectorOrientationForward :: !AVAudio3DVector
  , avAudio3DVectorOrientationUp :: !AVAudio3DVector
  } deriving (Eq, Show)

instance Storable AVAudio3DVectorOrientation where
  sizeOf    _ = 24
  alignment _ = 4
  peek p = AVAudio3DVectorOrientation <$> peekByteOff p 0
    <*> peekByteOff p 12
  poke p (AVAudio3DVectorOrientation {..}) = do
    pokeByteOff p 0 avAudio3DVectorOrientationForward
    pokeByteOff p 12 avAudio3DVectorOrientationUp

{-# NOINLINE avAudio3DVectorOrientationStructType #-}
avAudio3DVectorOrientationStructType :: Ptr CType
avAudio3DVectorOrientationStructType = unsafePerformIO $ fst <$> newStructCType [avAudio3DVectorStructType, avAudio3DVectorStructType]

argAVAudio3DVectorOrientation :: AVAudio3DVectorOrientation -> Arg
argAVAudio3DVectorOrientation = mkStorableArg avAudio3DVectorOrientationStructType

retAVAudio3DVectorOrientation :: RetType AVAudio3DVectorOrientation
retAVAudio3DVectorOrientation = mkStorableRetType avAudio3DVectorOrientationStructType

instance ObjCArgument AVAudio3DVectorOrientation where
  withObjCArg x k = k (argAVAudio3DVectorOrientation x)

instance ObjCReturn AVAudio3DVectorOrientation where
  type RawReturn AVAudio3DVectorOrientation = AVAudio3DVectorOrientation
  objcRetType = retAVAudio3DVectorOrientation
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure
