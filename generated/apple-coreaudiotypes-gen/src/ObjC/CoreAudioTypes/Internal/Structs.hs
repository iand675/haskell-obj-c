{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TypeFamilies #-}

-- | Struct types for this framework.
--
-- Generated by objc-codegen. Do not edit.
module ObjC.CoreAudioTypes.Internal.Structs where

import Foreign.Ptr (Ptr, FunPtr)
import Foreign.Storable (Storable(..))
import Foreign.C.Types
import Foreign.LibFFI.Base (Arg, RetType, mkStorableArg, mkStorableRetType, newStructCType)
import Foreign.LibFFI.FFITypes
import Foreign.LibFFI.Internal (CType)
import System.IO.Unsafe (unsafePerformIO)
import ObjC.Runtime.Message (ObjCArgument(..), ObjCReturn(..), MsgSendVariant(..))
import ObjC.CoreAudioTypes.Internal.Enums

-- | AudioBuffer
--
-- A structure to hold a buffer of audio data.
--
-- mNumberChannels
--
-- The number of interleaved channels in the buffer.
--
-- mDataByteSize
--
-- The number of bytes in the buffer pointed at by mData.
--
-- mData
--
-- A pointer to the buffer of audio data.
data AudioBuffer = AudioBuffer
  { audioBufferMNumberChannels :: !CUInt
  , audioBufferMDataByteSize :: !CUInt
  , audioBufferMData :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable AudioBuffer where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = AudioBuffer <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (AudioBuffer {..}) = do
    pokeByteOff p 0 audioBufferMNumberChannels
    pokeByteOff p 4 audioBufferMDataByteSize
    pokeByteOff p 8 audioBufferMData

{-# NOINLINE audioBufferStructType #-}
audioBufferStructType :: Ptr CType
audioBufferStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_pointer]

argAudioBuffer :: AudioBuffer -> Arg
argAudioBuffer = mkStorableArg audioBufferStructType

retAudioBuffer :: RetType AudioBuffer
retAudioBuffer = mkStorableRetType audioBufferStructType

instance ObjCArgument AudioBuffer where
  withObjCArg x k = k (argAudioBuffer x)

instance ObjCReturn AudioBuffer where
  type RawReturn AudioBuffer = AudioBuffer
  objcRetType = retAudioBuffer
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AudioClassDescription
--
-- This structure is used to describe codecs installed on the system.
--
-- mType
--
-- The four char code codec type.
--
-- mSubType
--
-- The four char code codec subtype.
--
-- mManufacturer
--
-- The four char code codec manufacturer.
data AudioClassDescription = AudioClassDescription
  { audioClassDescriptionMType :: !CUInt
  , audioClassDescriptionMSubType :: !CUInt
  , audioClassDescriptionMManufacturer :: !CUInt
  } deriving (Eq, Show)

instance Storable AudioClassDescription where
  sizeOf    _ = 12
  alignment _ = 4
  peek p = AudioClassDescription <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (AudioClassDescription {..}) = do
    pokeByteOff p 0 audioClassDescriptionMType
    pokeByteOff p 4 audioClassDescriptionMSubType
    pokeByteOff p 8 audioClassDescriptionMManufacturer

{-# NOINLINE audioClassDescriptionStructType #-}
audioClassDescriptionStructType :: Ptr CType
audioClassDescriptionStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_uint]

argAudioClassDescription :: AudioClassDescription -> Arg
argAudioClassDescription = mkStorableArg audioClassDescriptionStructType

retAudioClassDescription :: RetType AudioClassDescription
retAudioClassDescription = mkStorableRetType audioClassDescriptionStructType

instance ObjCArgument AudioClassDescription where
  withObjCArg x k = k (argAudioClassDescription x)

instance ObjCReturn AudioClassDescription where
  type RawReturn AudioClassDescription = AudioClassDescription
  objcRetType = retAudioClassDescription
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AudioStreamBasicDescription
--
-- This structure encapsulates all the information for describing the basic                    format properties of a stream of audio data.
--
-- This structure is sufficient to describe any constant bit rate format that  has                    channels that are the same size. Extensions are required for variable bit rate                    data and for constant bit rate data where the channels have unequal sizes.                    However, where applicable, the appropriate fields will be filled out correctly                    for these kinds of formats (the extra data is provided via separate properties).                    In all fields, a value of 0 indicates that the field is either unknown, not                    applicable or otherwise is inapproprate for the format and should be ignored.                    Note that 0 is still a valid value for most formats in the mFormatFlags field.
--
-- In audio data a frame is one sample across all channels. In non-interleaved                    audio, the per frame fields identify one channel. In interleaved audio, the per                    frame fields identify the set of n channels. In uncompressed audio, a Packet is                    one frame, (mFramesPerPacket == 1). In compressed audio, a Packet is an                    indivisible chunk of compressed data, for example an AAC packet will contain                    1024 sample frames.
--
-- mSampleRate
--
-- The number of sample frames per second of the data in the stream.
--
-- mFormatID
--
-- The AudioFormatID indicating the general kind of data in the stream.
--
-- mFormatFlags
--
-- The AudioFormatFlags for the format indicated by mFormatID.
--
-- mBytesPerPacket
--
-- The number of bytes in a packet of data.
--
-- mFramesPerPacket
--
-- The number of sample frames in each packet of data.
--
-- mBytesPerFrame
--
-- The number of bytes in a single sample frame of data.
--
-- mChannelsPerFrame
--
-- The number of channels in each frame of data.
--
-- mBitsPerChannel
--
-- The number of bits of sample data for each channel in a frame of data.
--
-- mReserved
--
-- Pads the structure out to force an even 8 byte alignment.
data AudioStreamBasicDescription = AudioStreamBasicDescription
  { audioStreamBasicDescriptionMSampleRate :: !CDouble
  , audioStreamBasicDescriptionMFormatID :: !CUInt
  , audioStreamBasicDescriptionMFormatFlags :: !CUInt
  , audioStreamBasicDescriptionMBytesPerPacket :: !CUInt
  , audioStreamBasicDescriptionMFramesPerPacket :: !CUInt
  , audioStreamBasicDescriptionMBytesPerFrame :: !CUInt
  , audioStreamBasicDescriptionMChannelsPerFrame :: !CUInt
  , audioStreamBasicDescriptionMBitsPerChannel :: !CUInt
  , audioStreamBasicDescriptionMReserved :: !CUInt
  } deriving (Eq, Show)

instance Storable AudioStreamBasicDescription where
  sizeOf    _ = 40
  alignment _ = 8
  peek p = AudioStreamBasicDescription <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 12
    <*> peekByteOff p 16
    <*> peekByteOff p 20
    <*> peekByteOff p 24
    <*> peekByteOff p 28
    <*> peekByteOff p 32
    <*> peekByteOff p 36
  poke p (AudioStreamBasicDescription {..}) = do
    pokeByteOff p 0 audioStreamBasicDescriptionMSampleRate
    pokeByteOff p 8 audioStreamBasicDescriptionMFormatID
    pokeByteOff p 12 audioStreamBasicDescriptionMFormatFlags
    pokeByteOff p 16 audioStreamBasicDescriptionMBytesPerPacket
    pokeByteOff p 20 audioStreamBasicDescriptionMFramesPerPacket
    pokeByteOff p 24 audioStreamBasicDescriptionMBytesPerFrame
    pokeByteOff p 28 audioStreamBasicDescriptionMChannelsPerFrame
    pokeByteOff p 32 audioStreamBasicDescriptionMBitsPerChannel
    pokeByteOff p 36 audioStreamBasicDescriptionMReserved

{-# NOINLINE audioStreamBasicDescriptionStructType #-}
audioStreamBasicDescriptionStructType :: Ptr CType
audioStreamBasicDescriptionStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_double, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint]

argAudioStreamBasicDescription :: AudioStreamBasicDescription -> Arg
argAudioStreamBasicDescription = mkStorableArg audioStreamBasicDescriptionStructType

retAudioStreamBasicDescription :: RetType AudioStreamBasicDescription
retAudioStreamBasicDescription = mkStorableRetType audioStreamBasicDescriptionStructType

instance ObjCArgument AudioStreamBasicDescription where
  withObjCArg x k = k (argAudioStreamBasicDescription x)

instance ObjCReturn AudioStreamBasicDescription where
  type RawReturn AudioStreamBasicDescription = AudioStreamBasicDescription
  objcRetType = retAudioStreamBasicDescription
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AudioStreamPacketDependencyDescription
--
-- A structure to provide a description of the dependencies of one audio packet on other audio packets.
--
-- mIsIndependentlyDecodable
--
-- 1 if the packet is independently decodable, 0 otherwise.
--
-- mPreRollCount
--
-- The count of packets that must be decoded after this packet in order to refresh the decoder,                        if the packet is independently decodable.  This value should be ignored if                        ``mIsIndependentlyDecodable`` is 0.
--
-- mFlags
--
-- Currently unused.
--
-- mReserved
--
-- Reserved for future use.
--
-- For independently decodable packets, the ``mPreRollCount`` indicates how many additional packets need        to be decoded after this packet in order for the decoder to start returning optimal output,        if this is the first packet decoded since the decoder was initialized.
--
-- For example, if this packet is packet #123 of some given packet stream, and ``mIsIndependentlyDecodable``        is 0, or ``mIsIndependentlyDecodable`` is 1 and ``mPreRollCount`` is non-zero, and the client desires optimal        output starting with the output corresponding with packet #123 (because for example the client        is an audio player whose user seeks to a starting playback position corresponding with packet #123),        the client would scan back, starting at packet #122, searching for an independently decodable        packet with a preroll not intersecting packet #123.  If for packet #122 ``mIsIndependentlyDecodable``        is 0, or ``mIsIndependentlyDecodable`` is 1 but ``mPreRollCount`` is 2 or more, the client would still not        get optimal output for packet #123 if starting here, so the client continues to scan back.        If for packet #121 ``mIsIndependentlyDecodable`` is 1 and ``mPreRollCount`` is 2 or less, the client would        start decoding from this point, but discard the output equivalent of the two extra input packets        (desired first output packet - actual first decoded packet, or 122 - 120 == 2).
data AudioStreamPacketDependencyDescription = AudioStreamPacketDependencyDescription
  { audioStreamPacketDependencyDescriptionMIsIndependentlyDecodable :: !CUInt
  , audioStreamPacketDependencyDescriptionMPreRollCount :: !CUInt
  , audioStreamPacketDependencyDescriptionMFlags :: !CUInt
  , audioStreamPacketDependencyDescriptionMReserved :: !CUInt
  } deriving (Eq, Show)

instance Storable AudioStreamPacketDependencyDescription where
  sizeOf    _ = 16
  alignment _ = 4
  peek p = AudioStreamPacketDependencyDescription <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
  poke p (AudioStreamPacketDependencyDescription {..}) = do
    pokeByteOff p 0 audioStreamPacketDependencyDescriptionMIsIndependentlyDecodable
    pokeByteOff p 4 audioStreamPacketDependencyDescriptionMPreRollCount
    pokeByteOff p 8 audioStreamPacketDependencyDescriptionMFlags
    pokeByteOff p 12 audioStreamPacketDependencyDescriptionMReserved

{-# NOINLINE audioStreamPacketDependencyDescriptionStructType #-}
audioStreamPacketDependencyDescriptionStructType :: Ptr CType
audioStreamPacketDependencyDescriptionStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint]

argAudioStreamPacketDependencyDescription :: AudioStreamPacketDependencyDescription -> Arg
argAudioStreamPacketDependencyDescription = mkStorableArg audioStreamPacketDependencyDescriptionStructType

retAudioStreamPacketDependencyDescription :: RetType AudioStreamPacketDependencyDescription
retAudioStreamPacketDependencyDescription = mkStorableRetType audioStreamPacketDependencyDescriptionStructType

instance ObjCArgument AudioStreamPacketDependencyDescription where
  withObjCArg x k = k (argAudioStreamPacketDependencyDescription x)

instance ObjCReturn AudioStreamPacketDependencyDescription where
  type RawReturn AudioStreamPacketDependencyDescription = AudioStreamPacketDependencyDescription
  objcRetType = retAudioStreamPacketDependencyDescription
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AudioStreamPacketDescription
--
-- This structure describes the packet layout of a buffer of data where the size of                    each packet may not be the same or where there is extraneous data between                    packets.
--
-- mStartOffset
--
-- The number of bytes from the start of the buffer to the beginning of the                        packet.
--
-- mVariableFramesInPacket
--
-- The number of sample frames of data in the packet. For formats with a                        constant number of frames per packet, this field is set to 0.
--
-- mDataByteSize
--
-- The number of bytes in the packet.
data AudioStreamPacketDescription = AudioStreamPacketDescription
  { audioStreamPacketDescriptionMStartOffset :: !CLong
  , audioStreamPacketDescriptionMVariableFramesInPacket :: !CUInt
  , audioStreamPacketDescriptionMDataByteSize :: !CUInt
  } deriving (Eq, Show)

instance Storable AudioStreamPacketDescription where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = AudioStreamPacketDescription <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 12
  poke p (AudioStreamPacketDescription {..}) = do
    pokeByteOff p 0 audioStreamPacketDescriptionMStartOffset
    pokeByteOff p 8 audioStreamPacketDescriptionMVariableFramesInPacket
    pokeByteOff p 12 audioStreamPacketDescriptionMDataByteSize

{-# NOINLINE audioStreamPacketDescriptionStructType #-}
audioStreamPacketDescriptionStructType :: Ptr CType
audioStreamPacketDescriptionStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_slong, ffi_type_uint, ffi_type_uint]

argAudioStreamPacketDescription :: AudioStreamPacketDescription -> Arg
argAudioStreamPacketDescription = mkStorableArg audioStreamPacketDescriptionStructType

retAudioStreamPacketDescription :: RetType AudioStreamPacketDescription
retAudioStreamPacketDescription = mkStorableRetType audioStreamPacketDescriptionStructType

instance ObjCArgument AudioStreamPacketDescription where
  withObjCArg x k = k (argAudioStreamPacketDescription x)

instance ObjCReturn AudioStreamPacketDescription where
  type RawReturn AudioStreamPacketDescription = AudioStreamPacketDescription
  objcRetType = retAudioStreamPacketDescription
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AudioValueRange
--
-- This structure holds a pair of numbers that represent a continuous range of                    values.
--
-- mMinimum
--
-- The minimum value.
--
-- mMaximum
--
-- The maximum value.
data AudioValueRange = AudioValueRange
  { audioValueRangeMMinimum :: !CDouble
  , audioValueRangeMMaximum :: !CDouble
  } deriving (Eq, Show)

instance Storable AudioValueRange where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = AudioValueRange <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (AudioValueRange {..}) = do
    pokeByteOff p 0 audioValueRangeMMinimum
    pokeByteOff p 8 audioValueRangeMMaximum

{-# NOINLINE audioValueRangeStructType #-}
audioValueRangeStructType :: Ptr CType
audioValueRangeStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_double, ffi_type_double]

argAudioValueRange :: AudioValueRange -> Arg
argAudioValueRange = mkStorableArg audioValueRangeStructType

retAudioValueRange :: RetType AudioValueRange
retAudioValueRange = mkStorableRetType audioValueRangeStructType

instance ObjCArgument AudioValueRange where
  withObjCArg x k = k (argAudioValueRange x)

instance ObjCReturn AudioValueRange where
  type RawReturn AudioValueRange = AudioValueRange
  objcRetType = retAudioValueRange
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AudioValueTranslation
--
-- This stucture holds the buffers necessary for translation operations.
--
-- mInputData
--
-- The buffer containing the data to be translated.
--
-- mInputDataSize
--
-- The number of bytes in the buffer pointed at by mInputData.
--
-- mOutputData
--
-- The buffer to hold the result of the translation.
--
-- mOutputDataSize
--
-- The number of bytes in the buffer pointed at by mOutputData.
data AudioValueTranslation = AudioValueTranslation
  { audioValueTranslationMInputData :: !(Ptr ())
  , audioValueTranslationMInputDataSize :: !CUInt
  , audioValueTranslationMOutputData :: !(Ptr ())
  , audioValueTranslationMOutputDataSize :: !CUInt
  } deriving (Eq, Show)

instance Storable AudioValueTranslation where
  sizeOf    _ = 32
  alignment _ = 8
  peek p = AudioValueTranslation <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 24
  poke p (AudioValueTranslation {..}) = do
    pokeByteOff p 0 audioValueTranslationMInputData
    pokeByteOff p 8 audioValueTranslationMInputDataSize
    pokeByteOff p 16 audioValueTranslationMOutputData
    pokeByteOff p 24 audioValueTranslationMOutputDataSize

{-# NOINLINE audioValueTranslationStructType #-}
audioValueTranslationStructType :: Ptr CType
audioValueTranslationStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer, ffi_type_uint, ffi_type_pointer, ffi_type_uint]

argAudioValueTranslation :: AudioValueTranslation -> Arg
argAudioValueTranslation = mkStorableArg audioValueTranslationStructType

retAudioValueTranslation :: RetType AudioValueTranslation
retAudioValueTranslation = mkStorableRetType audioValueTranslationStructType

instance ObjCArgument AudioValueTranslation where
  withObjCArg x k = k (argAudioValueTranslation x)

instance ObjCReturn AudioValueTranslation where
  type RawReturn AudioValueTranslation = AudioValueTranslation
  objcRetType = retAudioValueTranslation
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | SMPTETime
--
-- A structure for holding a SMPTE time.
--
-- mSubframes
--
-- The number of subframes in the full message.
--
-- mSubframeDivisor
--
-- The number of subframes per frame (typically 80).
--
-- mCounter
--
-- The total number of messages received.
--
-- mType
--
-- The kind of SMPTE time using the SMPTE time type constants.
--
-- mFlags
--
-- A set of flags that indicate the SMPTE state.
--
-- mHours
--
-- The number of hours in the full message.
--
-- mMinutes
--
-- The number of minutes in the full message.
--
-- mSeconds
--
-- The number of seconds in the full message.
--
-- mFrames
--
-- The number of frames in the full message.
data SMPTETime = SMPTETime
  { smpteTimeMSubframes :: !CShort
  , smpteTimeMSubframeDivisor :: !CShort
  , smpteTimeMCounter :: !CUInt
  , smpteTimeMType :: !SMPTETimeType
  , smpteTimeMFlags :: !SMPTETimeFlags
  , smpteTimeMHours :: !CShort
  , smpteTimeMMinutes :: !CShort
  , smpteTimeMSeconds :: !CShort
  , smpteTimeMFrames :: !CShort
  } deriving (Eq, Show)

instance Storable SMPTETime where
  sizeOf    _ = 24
  alignment _ = 4
  peek p = SMPTETime <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
    <*> peekByteOff p 16
    <*> peekByteOff p 18
    <*> peekByteOff p 20
    <*> peekByteOff p 22
  poke p (SMPTETime {..}) = do
    pokeByteOff p 0 smpteTimeMSubframes
    pokeByteOff p 2 smpteTimeMSubframeDivisor
    pokeByteOff p 4 smpteTimeMCounter
    pokeByteOff p 8 smpteTimeMType
    pokeByteOff p 12 smpteTimeMFlags
    pokeByteOff p 16 smpteTimeMHours
    pokeByteOff p 18 smpteTimeMMinutes
    pokeByteOff p 20 smpteTimeMSeconds
    pokeByteOff p 22 smpteTimeMFrames

{-# NOINLINE smpteTimeStructType #-}
smpteTimeStructType :: Ptr CType
smpteTimeStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16, ffi_type_sint16, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16]

argSMPTETime :: SMPTETime -> Arg
argSMPTETime = mkStorableArg smpteTimeStructType

retSMPTETime :: RetType SMPTETime
retSMPTETime = mkStorableRetType smpteTimeStructType

instance ObjCArgument SMPTETime where
  withObjCArg x k = k (argSMPTETime x)

instance ObjCReturn SMPTETime where
  type RawReturn SMPTETime = SMPTETime
  objcRetType = retSMPTETime
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AudioFormatListItem
--
-- this struct is used as output from the kAudioFormatProperty_FormatList property
--
-- mASBD
--
-- an AudioStreamBasicDescription
--
-- mChannelLayoutTag
--
-- an AudioChannelLayoutTag
data AudioFormatListItem = AudioFormatListItem
  { audioFormatListItemMASBD :: !AudioStreamBasicDescription
  , audioFormatListItemMChannelLayoutTag :: !CUInt
  } deriving (Eq, Show)

instance Storable AudioFormatListItem where
  sizeOf    _ = 48
  alignment _ = 8
  peek p = AudioFormatListItem <$> peekByteOff p 0
    <*> peekByteOff p 40
  poke p (AudioFormatListItem {..}) = do
    pokeByteOff p 0 audioFormatListItemMASBD
    pokeByteOff p 40 audioFormatListItemMChannelLayoutTag

{-# NOINLINE audioFormatListItemStructType #-}
audioFormatListItemStructType :: Ptr CType
audioFormatListItemStructType = unsafePerformIO $ fst <$> newStructCType [audioStreamBasicDescriptionStructType, ffi_type_uint]

argAudioFormatListItem :: AudioFormatListItem -> Arg
argAudioFormatListItem = mkStorableArg audioFormatListItemStructType

retAudioFormatListItem :: RetType AudioFormatListItem
retAudioFormatListItem = mkStorableRetType audioFormatListItemStructType

instance ObjCArgument AudioFormatListItem where
  withObjCArg x k = k (argAudioFormatListItem x)

instance ObjCReturn AudioFormatListItem where
  type RawReturn AudioFormatListItem = AudioFormatListItem
  objcRetType = retAudioFormatListItem
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | AudioTimeStamp
--
-- A structure that holds different representations of the same point in time.
--
-- mSampleTime
--
-- The absolute sample frame time.
--
-- mHostTime
--
-- The host machine's time base, mach_absolute_time.
--
-- mRateScalar
--
-- The ratio of actual host ticks per sample frame to the nominal host ticks                        per sample frame.
--
-- mWordClockTime
--
-- The word clock time.
--
-- mSMPTETime
--
-- The SMPTE time.
--
-- mFlags
--
-- A set of flags indicating which representations of the time are valid.
--
-- mReserved
--
-- Pads the structure out to force an even 8 byte alignment.
data AudioTimeStamp = AudioTimeStamp
  { audioTimeStampMSampleTime :: !CDouble
  , audioTimeStampMHostTime :: !CULong
  , audioTimeStampMRateScalar :: !CDouble
  , audioTimeStampMWordClockTime :: !CULong
  , audioTimeStampMSMPTETime :: !SMPTETime
  , audioTimeStampMFlags :: !AudioTimeStampFlags
  , audioTimeStampMReserved :: !CUInt
  } deriving (Eq, Show)

instance Storable AudioTimeStamp where
  sizeOf    _ = 64
  alignment _ = 8
  peek p = AudioTimeStamp <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 24
    <*> peekByteOff p 32
    <*> peekByteOff p 56
    <*> peekByteOff p 60
  poke p (AudioTimeStamp {..}) = do
    pokeByteOff p 0 audioTimeStampMSampleTime
    pokeByteOff p 8 audioTimeStampMHostTime
    pokeByteOff p 16 audioTimeStampMRateScalar
    pokeByteOff p 24 audioTimeStampMWordClockTime
    pokeByteOff p 32 audioTimeStampMSMPTETime
    pokeByteOff p 56 audioTimeStampMFlags
    pokeByteOff p 60 audioTimeStampMReserved

{-# NOINLINE audioTimeStampStructType #-}
audioTimeStampStructType :: Ptr CType
audioTimeStampStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_double, ffi_type_ulong, ffi_type_double, ffi_type_ulong, smpteTimeStructType, ffi_type_uint, ffi_type_uint]

argAudioTimeStamp :: AudioTimeStamp -> Arg
argAudioTimeStamp = mkStorableArg audioTimeStampStructType

retAudioTimeStamp :: RetType AudioTimeStamp
retAudioTimeStamp = mkStorableRetType audioTimeStampStructType

instance ObjCArgument AudioTimeStamp where
  withObjCArg x k = k (argAudioTimeStamp x)

instance ObjCReturn AudioTimeStamp where
  type RawReturn AudioTimeStamp = AudioTimeStamp
  objcRetType = retAudioTimeStamp
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure
