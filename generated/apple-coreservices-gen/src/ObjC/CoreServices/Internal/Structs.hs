{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TypeFamilies #-}

-- | Struct types for this framework.
--
-- Generated by objc-codegen. Do not edit.
module ObjC.CoreServices.Internal.Structs where

import Foreign.Ptr (Ptr, FunPtr)
import Foreign.Storable (Storable(..))
import Foreign.C.Types
import Foreign.LibFFI.Base (Arg, RetType, mkStorableArg, mkStorableRetType, newStructCType)
import Foreign.LibFFI.FFITypes
import Foreign.LibFFI.Internal (CType)
import System.IO.Unsafe (unsafePerformIO)
import ObjC.Runtime.Message (ObjCArgument(..), ObjCReturn(..), MsgSendVariant(..))
import ObjC.CoreFoundation.Internal.Structs
import ObjC.CoreServices.Internal.Enums

data AEAddressDesc = AEAddressDesc
  { aeAddressDescDescriptorType :: !CUInt
  , aeAddressDescDataHandle :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable AEAddressDesc where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = AEAddressDesc <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (AEAddressDesc {..}) = do
    pokeByteOff p 0 aeAddressDescDescriptorType
    pokeByteOff p 8 aeAddressDescDataHandle

{-# NOINLINE aeAddressDescStructType #-}
aeAddressDescStructType :: Ptr CType
aeAddressDescStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_pointer]

argAEAddressDesc :: AEAddressDesc -> Arg
argAEAddressDesc = mkStorableArg aeAddressDescStructType

retAEAddressDesc :: RetType AEAddressDesc
retAEAddressDesc = mkStorableRetType aeAddressDescStructType

instance ObjCArgument AEAddressDesc where
  withObjCArg x k = k (argAEAddressDesc x)

instance ObjCReturn AEAddressDesc where
  type RawReturn AEAddressDesc = AEAddressDesc
  objcRetType = retAEAddressDesc
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data AEBuildError = AEBuildError
  { aeBuildErrorFError :: !CUInt
  , aeBuildErrorFErrorPos :: !CUInt
  } deriving (Eq, Show)

instance Storable AEBuildError where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = AEBuildError <$> peekByteOff p 0
    <*> peekByteOff p 4
  poke p (AEBuildError {..}) = do
    pokeByteOff p 0 aeBuildErrorFError
    pokeByteOff p 4 aeBuildErrorFErrorPos

{-# NOINLINE aeBuildErrorStructType #-}
aeBuildErrorStructType :: Ptr CType
aeBuildErrorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint]

argAEBuildError :: AEBuildError -> Arg
argAEBuildError = mkStorableArg aeBuildErrorStructType

retAEBuildError :: RetType AEBuildError
retAEBuildError = mkStorableRetType aeBuildErrorStructType

instance ObjCArgument AEBuildError where
  withObjCArg x k = k (argAEBuildError x)

instance ObjCReturn AEBuildError where
  type RawReturn AEBuildError = AEBuildError
  objcRetType = retAEBuildError
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data AEDesc = AEDesc
  { aeDescDescriptorType :: !CUInt
  , aeDescDataHandle :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable AEDesc where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = AEDesc <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (AEDesc {..}) = do
    pokeByteOff p 0 aeDescDescriptorType
    pokeByteOff p 8 aeDescDataHandle

{-# NOINLINE aeDescStructType #-}
aeDescStructType :: Ptr CType
aeDescStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_pointer]

argAEDesc :: AEDesc -> Arg
argAEDesc = mkStorableArg aeDescStructType

retAEDesc :: RetType AEDesc
retAEDesc = mkStorableRetType aeDescStructType

instance ObjCArgument AEDesc where
  withObjCArg x k = k (argAEDesc x)

instance ObjCReturn AEDesc where
  type RawReturn AEDesc = AEDesc
  objcRetType = retAEDesc
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data AEDescList = AEDescList
  { aeDescListDescriptorType :: !CUInt
  , aeDescListDataHandle :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable AEDescList where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = AEDescList <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (AEDescList {..}) = do
    pokeByteOff p 0 aeDescListDescriptorType
    pokeByteOff p 8 aeDescListDataHandle

{-# NOINLINE aeDescListStructType #-}
aeDescListStructType :: Ptr CType
aeDescListStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_pointer]

argAEDescList :: AEDescList -> Arg
argAEDescList = mkStorableArg aeDescListStructType

retAEDescList :: RetType AEDescList
retAEDescList = mkStorableRetType aeDescListStructType

instance ObjCArgument AEDescList where
  withObjCArg x k = k (argAEDescList x)

instance ObjCReturn AEDescList where
  type RawReturn AEDescList = AEDescList
  objcRetType = retAEDescList
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data AERecord = AERecord
  { aeRecordDescriptorType :: !CUInt
  , aeRecordDataHandle :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable AERecord where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = AERecord <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (AERecord {..}) = do
    pokeByteOff p 0 aeRecordDescriptorType
    pokeByteOff p 8 aeRecordDataHandle

{-# NOINLINE aeRecordStructType #-}
aeRecordStructType :: Ptr CType
aeRecordStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_pointer]

argAERecord :: AERecord -> Arg
argAERecord = mkStorableArg aeRecordStructType

retAERecord :: RetType AERecord
retAERecord = mkStorableRetType aeRecordStructType

instance ObjCArgument AERecord where
  withObjCArg x k = k (argAERecord x)

instance ObjCReturn AERecord where
  type RawReturn AERecord = AERecord
  objcRetType = retAERecord
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data AERemoteProcessResolverContext = AERemoteProcessResolverContext
  { aeRemoteProcessResolverContextVersion :: !CLong
  , aeRemoteProcessResolverContextInfo :: !(Ptr ())
  , aeRemoteProcessResolverContextRetain :: !(Ptr ())
  , aeRemoteProcessResolverContextRelease :: !(Ptr ())
  , aeRemoteProcessResolverContextCopyDescription :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable AERemoteProcessResolverContext where
  sizeOf    _ = 40
  alignment _ = 8
  peek p = AERemoteProcessResolverContext <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 24
    <*> peekByteOff p 32
  poke p (AERemoteProcessResolverContext {..}) = do
    pokeByteOff p 0 aeRemoteProcessResolverContextVersion
    pokeByteOff p 8 aeRemoteProcessResolverContextInfo
    pokeByteOff p 16 aeRemoteProcessResolverContextRetain
    pokeByteOff p 24 aeRemoteProcessResolverContextRelease
    pokeByteOff p 32 aeRemoteProcessResolverContextCopyDescription

{-# NOINLINE aeRemoteProcessResolverContextStructType #-}
aeRemoteProcessResolverContextStructType :: Ptr CType
aeRemoteProcessResolverContextStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_slong, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer]

argAERemoteProcessResolverContext :: AERemoteProcessResolverContext -> Arg
argAERemoteProcessResolverContext = mkStorableArg aeRemoteProcessResolverContextStructType

retAERemoteProcessResolverContext :: RetType AERemoteProcessResolverContext
retAERemoteProcessResolverContext = mkStorableRetType aeRemoteProcessResolverContextStructType

instance ObjCArgument AERemoteProcessResolverContext where
  withObjCArg x k = k (argAERemoteProcessResolverContext x)

instance ObjCReturn AERemoteProcessResolverContext where
  type RawReturn AERemoteProcessResolverContext = AERemoteProcessResolverContext
  objcRetType = retAERemoteProcessResolverContext
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data AIFFLoop = AIFFLoop
  { aiffLoopPlayMode :: !CShort
  , aiffLoopBeginLoop :: !CShort
  , aiffLoopEndLoop :: !CShort
  } deriving (Eq, Show)

instance Storable AIFFLoop where
  sizeOf    _ = 6
  alignment _ = 2
  peek p = AIFFLoop <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
  poke p (AIFFLoop {..}) = do
    pokeByteOff p 0 aiffLoopPlayMode
    pokeByteOff p 2 aiffLoopBeginLoop
    pokeByteOff p 4 aiffLoopEndLoop

{-# NOINLINE aiffLoopStructType #-}
aiffLoopStructType :: Ptr CType
aiffLoopStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16, ffi_type_sint16, ffi_type_sint16]

argAIFFLoop :: AIFFLoop -> Arg
argAIFFLoop = mkStorableArg aiffLoopStructType

retAIFFLoop :: RetType AIFFLoop
retAIFFLoop = mkStorableRetType aiffLoopStructType

instance ObjCArgument AIFFLoop where
  withObjCArg x k = k (argAIFFLoop x)

instance ObjCReturn AIFFLoop where
  type RawReturn AIFFLoop = AIFFLoop
  objcRetType = retAIFFLoop
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data AppleEvent = AppleEvent
  { appleEventDescriptorType :: !CUInt
  , appleEventDataHandle :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable AppleEvent where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = AppleEvent <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (AppleEvent {..}) = do
    pokeByteOff p 0 appleEventDescriptorType
    pokeByteOff p 8 appleEventDataHandle

{-# NOINLINE appleEventStructType #-}
appleEventStructType :: Ptr CType
appleEventStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_pointer]

argAppleEvent :: AppleEvent -> Arg
argAppleEvent = mkStorableArg appleEventStructType

retAppleEvent :: RetType AppleEvent
retAppleEvent = mkStorableRetType appleEventStructType

instance ObjCArgument AppleEvent where
  withObjCArg x k = k (argAppleEvent x)

instance ObjCReturn AppleEvent where
  type RawReturn AppleEvent = AppleEvent
  objcRetType = retAppleEvent
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data BTNodeDescriptor = BTNodeDescriptor
  { btNodeDescriptorFLink :: !CUInt
  , btNodeDescriptorBLink :: !CUInt
  , btNodeDescriptorKind :: !CSChar
  , btNodeDescriptorHeight :: !CUChar
  , btNodeDescriptorNumRecords :: !CUShort
  , btNodeDescriptorReserved :: !CUShort
  } deriving (Eq, Show)

instance Storable BTNodeDescriptor where
  sizeOf    _ = 16
  alignment _ = 4
  peek p = BTNodeDescriptor <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 9
    <*> peekByteOff p 10
    <*> peekByteOff p 12
  poke p (BTNodeDescriptor {..}) = do
    pokeByteOff p 0 btNodeDescriptorFLink
    pokeByteOff p 4 btNodeDescriptorBLink
    pokeByteOff p 8 btNodeDescriptorKind
    pokeByteOff p 9 btNodeDescriptorHeight
    pokeByteOff p 10 btNodeDescriptorNumRecords
    pokeByteOff p 12 btNodeDescriptorReserved

{-# NOINLINE btNodeDescriptorStructType #-}
btNodeDescriptorStructType :: Ptr CType
btNodeDescriptorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_sint8, ffi_type_uint8, ffi_type_uint16, ffi_type_uint16]

argBTNodeDescriptor :: BTNodeDescriptor -> Arg
argBTNodeDescriptor = mkStorableArg btNodeDescriptorStructType

retBTNodeDescriptor :: RetType BTNodeDescriptor
retBTNodeDescriptor = mkStorableRetType btNodeDescriptorStructType

instance ObjCArgument BTNodeDescriptor where
  withObjCArg x k = k (argBTNodeDescriptor x)

instance ObjCReturn BTNodeDescriptor where
  type RawReturn BTNodeDescriptor = BTNodeDescriptor
  objcRetType = retBTNodeDescriptor
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data BigEndianFixed = BigEndianFixed
  { bigEndianFixedBigEndianValue :: !CInt
  } deriving (Eq, Show)

instance Storable BigEndianFixed where
  sizeOf    _ = 4
  alignment _ = 4
  peek p = BigEndianFixed <$> peekByteOff p 0
  poke p (BigEndianFixed {..}) =
    pokeByteOff p 0 bigEndianFixedBigEndianValue

{-# NOINLINE bigEndianFixedStructType #-}
bigEndianFixedStructType :: Ptr CType
bigEndianFixedStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint]

argBigEndianFixed :: BigEndianFixed -> Arg
argBigEndianFixed = mkStorableArg bigEndianFixedStructType

retBigEndianFixed :: RetType BigEndianFixed
retBigEndianFixed = mkStorableRetType bigEndianFixedStructType

instance ObjCArgument BigEndianFixed where
  withObjCArg x k = k (argBigEndianFixed x)

instance ObjCReturn BigEndianFixed where
  type RawReturn BigEndianFixed = BigEndianFixed
  objcRetType = retBigEndianFixed
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data BigEndianLong = BigEndianLong
  { bigEndianLongBigEndianValue :: !CLong
  } deriving (Eq, Show)

instance Storable BigEndianLong where
  sizeOf    _ = 8
  alignment _ = 8
  peek p = BigEndianLong <$> peekByteOff p 0
  poke p (BigEndianLong {..}) =
    pokeByteOff p 0 bigEndianLongBigEndianValue

{-# NOINLINE bigEndianLongStructType #-}
bigEndianLongStructType :: Ptr CType
bigEndianLongStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_slong]

argBigEndianLong :: BigEndianLong -> Arg
argBigEndianLong = mkStorableArg bigEndianLongStructType

retBigEndianLong :: RetType BigEndianLong
retBigEndianLong = mkStorableRetType bigEndianLongStructType

instance ObjCArgument BigEndianLong where
  withObjCArg x k = k (argBigEndianLong x)

instance ObjCReturn BigEndianLong where
  type RawReturn BigEndianLong = BigEndianLong
  objcRetType = retBigEndianLong
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data BigEndianOSType = BigEndianOSType
  { bigEndianOSTypeBigEndianValue :: !CUInt
  } deriving (Eq, Show)

instance Storable BigEndianOSType where
  sizeOf    _ = 4
  alignment _ = 4
  peek p = BigEndianOSType <$> peekByteOff p 0
  poke p (BigEndianOSType {..}) =
    pokeByteOff p 0 bigEndianOSTypeBigEndianValue

{-# NOINLINE bigEndianOSTypeStructType #-}
bigEndianOSTypeStructType :: Ptr CType
bigEndianOSTypeStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint]

argBigEndianOSType :: BigEndianOSType -> Arg
argBigEndianOSType = mkStorableArg bigEndianOSTypeStructType

retBigEndianOSType :: RetType BigEndianOSType
retBigEndianOSType = mkStorableRetType bigEndianOSTypeStructType

instance ObjCArgument BigEndianOSType where
  withObjCArg x k = k (argBigEndianOSType x)

instance ObjCReturn BigEndianOSType where
  type RawReturn BigEndianOSType = BigEndianOSType
  objcRetType = retBigEndianOSType
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data BigEndianShort = BigEndianShort
  { bigEndianShortBigEndianValue :: !CShort
  } deriving (Eq, Show)

instance Storable BigEndianShort where
  sizeOf    _ = 2
  alignment _ = 2
  peek p = BigEndianShort <$> peekByteOff p 0
  poke p (BigEndianShort {..}) =
    pokeByteOff p 0 bigEndianShortBigEndianValue

{-# NOINLINE bigEndianShortStructType #-}
bigEndianShortStructType :: Ptr CType
bigEndianShortStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16]

argBigEndianShort :: BigEndianShort -> Arg
argBigEndianShort = mkStorableArg bigEndianShortStructType

retBigEndianShort :: RetType BigEndianShort
retBigEndianShort = mkStorableRetType bigEndianShortStructType

instance ObjCArgument BigEndianShort where
  withObjCArg x k = k (argBigEndianShort x)

instance ObjCReturn BigEndianShort where
  type RawReturn BigEndianShort = BigEndianShort
  objcRetType = retBigEndianShort
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data BigEndianUInt32 = BigEndianUInt32
  { bigEndianUInt32BigEndianValue :: !CUInt
  } deriving (Eq, Show)

instance Storable BigEndianUInt32 where
  sizeOf    _ = 4
  alignment _ = 4
  peek p = BigEndianUInt32 <$> peekByteOff p 0
  poke p (BigEndianUInt32 {..}) =
    pokeByteOff p 0 bigEndianUInt32BigEndianValue

{-# NOINLINE bigEndianUInt32StructType #-}
bigEndianUInt32StructType :: Ptr CType
bigEndianUInt32StructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint]

argBigEndianUInt32 :: BigEndianUInt32 -> Arg
argBigEndianUInt32 = mkStorableArg bigEndianUInt32StructType

retBigEndianUInt32 :: RetType BigEndianUInt32
retBigEndianUInt32 = mkStorableRetType bigEndianUInt32StructType

instance ObjCArgument BigEndianUInt32 where
  withObjCArg x k = k (argBigEndianUInt32 x)

instance ObjCReturn BigEndianUInt32 where
  type RawReturn BigEndianUInt32 = BigEndianUInt32
  objcRetType = retBigEndianUInt32
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data BigEndianUnsignedFixed = BigEndianUnsignedFixed
  { bigEndianUnsignedFixedBigEndianValue :: !CUInt
  } deriving (Eq, Show)

instance Storable BigEndianUnsignedFixed where
  sizeOf    _ = 4
  alignment _ = 4
  peek p = BigEndianUnsignedFixed <$> peekByteOff p 0
  poke p (BigEndianUnsignedFixed {..}) =
    pokeByteOff p 0 bigEndianUnsignedFixedBigEndianValue

{-# NOINLINE bigEndianUnsignedFixedStructType #-}
bigEndianUnsignedFixedStructType :: Ptr CType
bigEndianUnsignedFixedStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint]

argBigEndianUnsignedFixed :: BigEndianUnsignedFixed -> Arg
argBigEndianUnsignedFixed = mkStorableArg bigEndianUnsignedFixedStructType

retBigEndianUnsignedFixed :: RetType BigEndianUnsignedFixed
retBigEndianUnsignedFixed = mkStorableRetType bigEndianUnsignedFixedStructType

instance ObjCArgument BigEndianUnsignedFixed where
  withObjCArg x k = k (argBigEndianUnsignedFixed x)

instance ObjCReturn BigEndianUnsignedFixed where
  type RawReturn BigEndianUnsignedFixed = BigEndianUnsignedFixed
  objcRetType = retBigEndianUnsignedFixed
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data BigEndianUnsignedLong = BigEndianUnsignedLong
  { bigEndianUnsignedLongBigEndianValue :: !CULong
  } deriving (Eq, Show)

instance Storable BigEndianUnsignedLong where
  sizeOf    _ = 8
  alignment _ = 8
  peek p = BigEndianUnsignedLong <$> peekByteOff p 0
  poke p (BigEndianUnsignedLong {..}) =
    pokeByteOff p 0 bigEndianUnsignedLongBigEndianValue

{-# NOINLINE bigEndianUnsignedLongStructType #-}
bigEndianUnsignedLongStructType :: Ptr CType
bigEndianUnsignedLongStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_ulong]

argBigEndianUnsignedLong :: BigEndianUnsignedLong -> Arg
argBigEndianUnsignedLong = mkStorableArg bigEndianUnsignedLongStructType

retBigEndianUnsignedLong :: RetType BigEndianUnsignedLong
retBigEndianUnsignedLong = mkStorableRetType bigEndianUnsignedLongStructType

instance ObjCArgument BigEndianUnsignedLong where
  withObjCArg x k = k (argBigEndianUnsignedLong x)

instance ObjCReturn BigEndianUnsignedLong where
  type RawReturn BigEndianUnsignedLong = BigEndianUnsignedLong
  objcRetType = retBigEndianUnsignedLong
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data BigEndianUnsignedShort = BigEndianUnsignedShort
  { bigEndianUnsignedShortBigEndianValue :: !CUShort
  } deriving (Eq, Show)

instance Storable BigEndianUnsignedShort where
  sizeOf    _ = 2
  alignment _ = 2
  peek p = BigEndianUnsignedShort <$> peekByteOff p 0
  poke p (BigEndianUnsignedShort {..}) =
    pokeByteOff p 0 bigEndianUnsignedShortBigEndianValue

{-# NOINLINE bigEndianUnsignedShortStructType #-}
bigEndianUnsignedShortStructType :: Ptr CType
bigEndianUnsignedShortStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16]

argBigEndianUnsignedShort :: BigEndianUnsignedShort -> Arg
argBigEndianUnsignedShort = mkStorableArg bigEndianUnsignedShortStructType

retBigEndianUnsignedShort :: RetType BigEndianUnsignedShort
retBigEndianUnsignedShort = mkStorableRetType bigEndianUnsignedShortStructType

instance ObjCArgument BigEndianUnsignedShort where
  withObjCArg x k = k (argBigEndianUnsignedShort x)

instance ObjCReturn BigEndianUnsignedShort where
  type RawReturn BigEndianUnsignedShort = BigEndianUnsignedShort
  objcRetType = retBigEndianUnsignedShort
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data CSIdentityClientContext = CSIdentityClientContext
  { csIdentityClientContextVersion :: !CLong
  , csIdentityClientContextInfo :: !(Ptr ())
  , csIdentityClientContextRetain :: !(Ptr ())
  , csIdentityClientContextRelease :: !(Ptr ())
  , csIdentityClientContextCopyDescription :: !(Ptr ())
  , csIdentityClientContextStatusUpdated :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable CSIdentityClientContext where
  sizeOf    _ = 48
  alignment _ = 8
  peek p = CSIdentityClientContext <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 24
    <*> peekByteOff p 32
    <*> peekByteOff p 40
  poke p (CSIdentityClientContext {..}) = do
    pokeByteOff p 0 csIdentityClientContextVersion
    pokeByteOff p 8 csIdentityClientContextInfo
    pokeByteOff p 16 csIdentityClientContextRetain
    pokeByteOff p 24 csIdentityClientContextRelease
    pokeByteOff p 32 csIdentityClientContextCopyDescription
    pokeByteOff p 40 csIdentityClientContextStatusUpdated

{-# NOINLINE csIdentityClientContextStructType #-}
csIdentityClientContextStructType :: Ptr CType
csIdentityClientContextStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_slong, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer]

argCSIdentityClientContext :: CSIdentityClientContext -> Arg
argCSIdentityClientContext = mkStorableArg csIdentityClientContextStructType

retCSIdentityClientContext :: RetType CSIdentityClientContext
retCSIdentityClientContext = mkStorableRetType csIdentityClientContextStructType

instance ObjCArgument CSIdentityClientContext where
  withObjCArg x k = k (argCSIdentityClientContext x)

instance ObjCReturn CSIdentityClientContext where
  type RawReturn CSIdentityClientContext = CSIdentityClientContext
  objcRetType = retCSIdentityClientContext
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data CSIdentityQueryClientContext = CSIdentityQueryClientContext
  { csIdentityQueryClientContextVersion :: !CLong
  , csIdentityQueryClientContextInfo :: !(Ptr ())
  , csIdentityQueryClientContextRetainInfo :: !(Ptr ())
  , csIdentityQueryClientContextReleaseInfo :: !(Ptr ())
  , csIdentityQueryClientContextCopyInfoDescription :: !(Ptr ())
  , csIdentityQueryClientContextReceiveEvent :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable CSIdentityQueryClientContext where
  sizeOf    _ = 48
  alignment _ = 8
  peek p = CSIdentityQueryClientContext <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 24
    <*> peekByteOff p 32
    <*> peekByteOff p 40
  poke p (CSIdentityQueryClientContext {..}) = do
    pokeByteOff p 0 csIdentityQueryClientContextVersion
    pokeByteOff p 8 csIdentityQueryClientContextInfo
    pokeByteOff p 16 csIdentityQueryClientContextRetainInfo
    pokeByteOff p 24 csIdentityQueryClientContextReleaseInfo
    pokeByteOff p 32 csIdentityQueryClientContextCopyInfoDescription
    pokeByteOff p 40 csIdentityQueryClientContextReceiveEvent

{-# NOINLINE csIdentityQueryClientContextStructType #-}
csIdentityQueryClientContextStructType :: Ptr CType
csIdentityQueryClientContextStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_slong, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer]

argCSIdentityQueryClientContext :: CSIdentityQueryClientContext -> Arg
argCSIdentityQueryClientContext = mkStorableArg csIdentityQueryClientContextStructType

retCSIdentityQueryClientContext :: RetType CSIdentityQueryClientContext
retCSIdentityQueryClientContext = mkStorableRetType csIdentityQueryClientContextStructType

instance ObjCArgument CSIdentityQueryClientContext where
  withObjCArg x k = k (argCSIdentityQueryClientContext x)

instance ObjCReturn CSIdentityQueryClientContext where
  type RawReturn CSIdentityQueryClientContext = CSIdentityQueryClientContext
  objcRetType = retCSIdentityQueryClientContext
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data ChunkHeader = ChunkHeader
  { chunkHeaderCkID :: !CUInt
  , chunkHeaderCkSize :: !CInt
  } deriving (Eq, Show)

instance Storable ChunkHeader where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = ChunkHeader <$> peekByteOff p 0
    <*> peekByteOff p 4
  poke p (ChunkHeader {..}) = do
    pokeByteOff p 0 chunkHeaderCkID
    pokeByteOff p 4 chunkHeaderCkSize

{-# NOINLINE chunkHeaderStructType #-}
chunkHeaderStructType :: Ptr CType
chunkHeaderStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_sint]

argChunkHeader :: ChunkHeader -> Arg
argChunkHeader = mkStorableArg chunkHeaderStructType

retChunkHeader :: RetType ChunkHeader
retChunkHeader = mkStorableRetType chunkHeaderStructType

instance ObjCArgument ChunkHeader where
  withObjCArg x k = k (argChunkHeader x)

instance ObjCReturn ChunkHeader where
  type RawReturn ChunkHeader = ChunkHeader
  objcRetType = retChunkHeader
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data CommonChunk = CommonChunk
  { commonChunkCkID :: !CUInt
  , commonChunkCkSize :: !CInt
  , commonChunkNumChannels :: !CShort
  , commonChunkNumSampleFrames :: !CUInt
  , commonChunkSampleSize :: !CShort
  , commonChunkSampleRate :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable CommonChunk where
  sizeOf    _ = 32
  alignment _ = 8
  peek p = CommonChunk <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
    <*> peekByteOff p 16
    <*> peekByteOff p 24
  poke p (CommonChunk {..}) = do
    pokeByteOff p 0 commonChunkCkID
    pokeByteOff p 4 commonChunkCkSize
    pokeByteOff p 8 commonChunkNumChannels
    pokeByteOff p 12 commonChunkNumSampleFrames
    pokeByteOff p 16 commonChunkSampleSize
    pokeByteOff p 24 commonChunkSampleRate

{-# NOINLINE commonChunkStructType #-}
commonChunkStructType :: Ptr CType
commonChunkStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_sint, ffi_type_sint16, ffi_type_uint, ffi_type_sint16, ffi_type_pointer]

argCommonChunk :: CommonChunk -> Arg
argCommonChunk = mkStorableArg commonChunkStructType

retCommonChunk :: RetType CommonChunk
retCommonChunk = mkStorableRetType commonChunkStructType

instance ObjCArgument CommonChunk where
  withObjCArg x k = k (argCommonChunk x)

instance ObjCReturn CommonChunk where
  type RawReturn CommonChunk = CommonChunk
  objcRetType = retCommonChunk
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data ComponentDescription = ComponentDescription
  { componentDescriptionComponentType :: !CUInt
  , componentDescriptionComponentSubType :: !CUInt
  , componentDescriptionComponentManufacturer :: !CUInt
  , componentDescriptionComponentFlags :: !CUInt
  , componentDescriptionComponentFlagsMask :: !CUInt
  } deriving (Eq, Show)

instance Storable ComponentDescription where
  sizeOf    _ = 20
  alignment _ = 4
  peek p = ComponentDescription <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
    <*> peekByteOff p 16
  poke p (ComponentDescription {..}) = do
    pokeByteOff p 0 componentDescriptionComponentType
    pokeByteOff p 4 componentDescriptionComponentSubType
    pokeByteOff p 8 componentDescriptionComponentManufacturer
    pokeByteOff p 12 componentDescriptionComponentFlags
    pokeByteOff p 16 componentDescriptionComponentFlagsMask

{-# NOINLINE componentDescriptionStructType #-}
componentDescriptionStructType :: Ptr CType
componentDescriptionStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint]

argComponentDescription :: ComponentDescription -> Arg
argComponentDescription = mkStorableArg componentDescriptionStructType

retComponentDescription :: RetType ComponentDescription
retComponentDescription = mkStorableRetType componentDescriptionStructType

instance ObjCArgument ComponentDescription where
  withObjCArg x k = k (argComponentDescription x)

instance ObjCReturn ComponentDescription where
  type RawReturn ComponentDescription = ComponentDescription
  objcRetType = retComponentDescription
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data ComponentMPWorkFunctionHeaderRecord = ComponentMPWorkFunctionHeaderRecord
  { componentMPWorkFunctionHeaderRecordHeaderSize :: !CUInt
  , componentMPWorkFunctionHeaderRecordRecordSize :: !CUInt
  , componentMPWorkFunctionHeaderRecordWorkFlags :: !CUInt
  , componentMPWorkFunctionHeaderRecordProcessorCount :: !CUShort
  , componentMPWorkFunctionHeaderRecordUnused :: !CUChar
  , componentMPWorkFunctionHeaderRecordIsRunning :: !CUChar
  } deriving (Eq, Show)

instance Storable ComponentMPWorkFunctionHeaderRecord where
  sizeOf    _ = 16
  alignment _ = 4
  peek p = ComponentMPWorkFunctionHeaderRecord <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
    <*> peekByteOff p 14
    <*> peekByteOff p 15
  poke p (ComponentMPWorkFunctionHeaderRecord {..}) = do
    pokeByteOff p 0 componentMPWorkFunctionHeaderRecordHeaderSize
    pokeByteOff p 4 componentMPWorkFunctionHeaderRecordRecordSize
    pokeByteOff p 8 componentMPWorkFunctionHeaderRecordWorkFlags
    pokeByteOff p 12 componentMPWorkFunctionHeaderRecordProcessorCount
    pokeByteOff p 14 componentMPWorkFunctionHeaderRecordUnused
    pokeByteOff p 15 componentMPWorkFunctionHeaderRecordIsRunning

{-# NOINLINE componentMPWorkFunctionHeaderRecordStructType #-}
componentMPWorkFunctionHeaderRecordStructType :: Ptr CType
componentMPWorkFunctionHeaderRecordStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint16, ffi_type_uint8, ffi_type_uint8]

argComponentMPWorkFunctionHeaderRecord :: ComponentMPWorkFunctionHeaderRecord -> Arg
argComponentMPWorkFunctionHeaderRecord = mkStorableArg componentMPWorkFunctionHeaderRecordStructType

retComponentMPWorkFunctionHeaderRecord :: RetType ComponentMPWorkFunctionHeaderRecord
retComponentMPWorkFunctionHeaderRecord = mkStorableRetType componentMPWorkFunctionHeaderRecordStructType

instance ObjCArgument ComponentMPWorkFunctionHeaderRecord where
  withObjCArg x k = k (argComponentMPWorkFunctionHeaderRecord x)

instance ObjCReturn ComponentMPWorkFunctionHeaderRecord where
  type RawReturn ComponentMPWorkFunctionHeaderRecord = ComponentMPWorkFunctionHeaderRecord
  objcRetType = retComponentMPWorkFunctionHeaderRecord
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data ComponentResourceExtension = ComponentResourceExtension
  { componentResourceExtensionComponentVersion :: !CInt
  , componentResourceExtensionComponentRegisterFlags :: !CInt
  , componentResourceExtensionComponentIconFamily :: !CShort
  } deriving (Eq, Show)

instance Storable ComponentResourceExtension where
  sizeOf    _ = 12
  alignment _ = 4
  peek p = ComponentResourceExtension <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (ComponentResourceExtension {..}) = do
    pokeByteOff p 0 componentResourceExtensionComponentVersion
    pokeByteOff p 4 componentResourceExtensionComponentRegisterFlags
    pokeByteOff p 8 componentResourceExtensionComponentIconFamily

{-# NOINLINE componentResourceExtensionStructType #-}
componentResourceExtensionStructType :: Ptr CType
componentResourceExtensionStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_sint, ffi_type_sint16]

argComponentResourceExtension :: ComponentResourceExtension -> Arg
argComponentResourceExtension = mkStorableArg componentResourceExtensionStructType

retComponentResourceExtension :: RetType ComponentResourceExtension
retComponentResourceExtension = mkStorableRetType componentResourceExtensionStructType

instance ObjCArgument ComponentResourceExtension where
  withObjCArg x k = k (argComponentResourceExtension x)

instance ObjCReturn ComponentResourceExtension where
  type RawReturn ComponentResourceExtension = ComponentResourceExtension
  objcRetType = retComponentResourceExtension
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data ContainerChunk = ContainerChunk
  { containerChunkCkID :: !CUInt
  , containerChunkCkSize :: !CInt
  , containerChunkFormType :: !CUInt
  } deriving (Eq, Show)

instance Storable ContainerChunk where
  sizeOf    _ = 12
  alignment _ = 4
  peek p = ContainerChunk <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (ContainerChunk {..}) = do
    pokeByteOff p 0 containerChunkCkID
    pokeByteOff p 4 containerChunkCkSize
    pokeByteOff p 8 containerChunkFormType

{-# NOINLINE containerChunkStructType #-}
containerChunkStructType :: Ptr CType
containerChunkStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_sint, ffi_type_uint]

argContainerChunk :: ContainerChunk -> Arg
argContainerChunk = mkStorableArg containerChunkStructType

retContainerChunk :: RetType ContainerChunk
retContainerChunk = mkStorableRetType containerChunkStructType

instance ObjCArgument ContainerChunk where
  withObjCArg x k = k (argContainerChunk x)

instance ObjCReturn ContainerChunk where
  type RawReturn ContainerChunk = ContainerChunk
  objcRetType = retContainerChunk
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data CustomBadgeResource = CustomBadgeResource
  { customBadgeResourceVersion :: !CShort
  , customBadgeResourceCustomBadgeResourceID :: !CShort
  , customBadgeResourceCustomBadgeType :: !CUInt
  , customBadgeResourceCustomBadgeCreator :: !CUInt
  , customBadgeResourceWindowBadgeType :: !CUInt
  , customBadgeResourceWindowBadgeCreator :: !CUInt
  , customBadgeResourceOverrideType :: !CUInt
  , customBadgeResourceOverrideCreator :: !CUInt
  } deriving (Eq, Show)

instance Storable CustomBadgeResource where
  sizeOf    _ = 28
  alignment _ = 4
  peek p = CustomBadgeResource <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
    <*> peekByteOff p 16
    <*> peekByteOff p 20
    <*> peekByteOff p 24
  poke p (CustomBadgeResource {..}) = do
    pokeByteOff p 0 customBadgeResourceVersion
    pokeByteOff p 2 customBadgeResourceCustomBadgeResourceID
    pokeByteOff p 4 customBadgeResourceCustomBadgeType
    pokeByteOff p 8 customBadgeResourceCustomBadgeCreator
    pokeByteOff p 12 customBadgeResourceWindowBadgeType
    pokeByteOff p 16 customBadgeResourceWindowBadgeCreator
    pokeByteOff p 20 customBadgeResourceOverrideType
    pokeByteOff p 24 customBadgeResourceOverrideCreator

{-# NOINLINE customBadgeResourceStructType #-}
customBadgeResourceStructType :: Ptr CType
customBadgeResourceStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16, ffi_type_sint16, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint]

argCustomBadgeResource :: CustomBadgeResource -> Arg
argCustomBadgeResource = mkStorableArg customBadgeResourceStructType

retCustomBadgeResource :: RetType CustomBadgeResource
retCustomBadgeResource = mkStorableRetType customBadgeResourceStructType

instance ObjCArgument CustomBadgeResource where
  withObjCArg x k = k (argCustomBadgeResource x)

instance ObjCReturn CustomBadgeResource where
  type RawReturn CustomBadgeResource = CustomBadgeResource
  objcRetType = retCustomBadgeResource
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data DateTimeRec = DateTimeRec
  { dateTimeRecYear :: !CShort
  , dateTimeRecMonth :: !CShort
  , dateTimeRecDay :: !CShort
  , dateTimeRecHour :: !CShort
  , dateTimeRecMinute :: !CShort
  , dateTimeRecSecond :: !CShort
  , dateTimeRecDayOfWeek :: !CShort
  } deriving (Eq, Show)

instance Storable DateTimeRec where
  sizeOf    _ = 14
  alignment _ = 2
  peek p = DateTimeRec <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 6
    <*> peekByteOff p 8
    <*> peekByteOff p 10
    <*> peekByteOff p 12
  poke p (DateTimeRec {..}) = do
    pokeByteOff p 0 dateTimeRecYear
    pokeByteOff p 2 dateTimeRecMonth
    pokeByteOff p 4 dateTimeRecDay
    pokeByteOff p 6 dateTimeRecHour
    pokeByteOff p 8 dateTimeRecMinute
    pokeByteOff p 10 dateTimeRecSecond
    pokeByteOff p 12 dateTimeRecDayOfWeek

{-# NOINLINE dateTimeRecStructType #-}
dateTimeRecStructType :: Ptr CType
dateTimeRecStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16]

argDateTimeRec :: DateTimeRec -> Arg
argDateTimeRec = mkStorableArg dateTimeRecStructType

retDateTimeRec :: RetType DateTimeRec
retDateTimeRec = mkStorableRetType dateTimeRecStructType

instance ObjCArgument DateTimeRec where
  withObjCArg x k = k (argDateTimeRec x)

instance ObjCReturn DateTimeRec where
  type RawReturn DateTimeRec = DateTimeRec
  objcRetType = retDateTimeRec
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data FSEventStreamContext = FSEventStreamContext
  { fsEventStreamContextVersion :: !CLong
  , fsEventStreamContextInfo :: !(Ptr ())
  , fsEventStreamContextRetain :: !(Ptr ())
  , fsEventStreamContextRelease :: !(Ptr ())
  , fsEventStreamContextCopyDescription :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable FSEventStreamContext where
  sizeOf    _ = 40
  alignment _ = 8
  peek p = FSEventStreamContext <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 24
    <*> peekByteOff p 32
  poke p (FSEventStreamContext {..}) = do
    pokeByteOff p 0 fsEventStreamContextVersion
    pokeByteOff p 8 fsEventStreamContextInfo
    pokeByteOff p 16 fsEventStreamContextRetain
    pokeByteOff p 24 fsEventStreamContextRelease
    pokeByteOff p 32 fsEventStreamContextCopyDescription

{-# NOINLINE fsEventStreamContextStructType #-}
fsEventStreamContextStructType :: Ptr CType
fsEventStreamContextStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_slong, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer]

argFSEventStreamContext :: FSEventStreamContext -> Arg
argFSEventStreamContext = mkStorableArg fsEventStreamContextStructType

retFSEventStreamContext :: RetType FSEventStreamContext
retFSEventStreamContext = mkStorableRetType fsEventStreamContextStructType

instance ObjCArgument FSEventStreamContext where
  withObjCArg x k = k (argFSEventStreamContext x)

instance ObjCReturn FSEventStreamContext where
  type RawReturn FSEventStreamContext = FSEventStreamContext
  objcRetType = retFSEventStreamContext
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data FSFileOperationClientContext = FSFileOperationClientContext
  { fsFileOperationClientContextVersion :: !CLong
  , fsFileOperationClientContextInfo :: !(Ptr ())
  , fsFileOperationClientContextRetain :: !(Ptr ())
  , fsFileOperationClientContextRelease :: !(Ptr ())
  , fsFileOperationClientContextCopyDescription :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable FSFileOperationClientContext where
  sizeOf    _ = 40
  alignment _ = 8
  peek p = FSFileOperationClientContext <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 24
    <*> peekByteOff p 32
  poke p (FSFileOperationClientContext {..}) = do
    pokeByteOff p 0 fsFileOperationClientContextVersion
    pokeByteOff p 8 fsFileOperationClientContextInfo
    pokeByteOff p 16 fsFileOperationClientContextRetain
    pokeByteOff p 24 fsFileOperationClientContextRelease
    pokeByteOff p 32 fsFileOperationClientContextCopyDescription

{-# NOINLINE fsFileOperationClientContextStructType #-}
fsFileOperationClientContextStructType :: Ptr CType
fsFileOperationClientContextStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_slong, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer]

argFSFileOperationClientContext :: FSFileOperationClientContext -> Arg
argFSFileOperationClientContext = mkStorableArg fsFileOperationClientContextStructType

retFSFileOperationClientContext :: RetType FSFileOperationClientContext
retFSFileOperationClientContext = mkStorableRetType fsFileOperationClientContextStructType

instance ObjCArgument FSFileOperationClientContext where
  withObjCArg x k = k (argFSFileOperationClientContext x)

instance ObjCReturn FSFileOperationClientContext where
  type RawReturn FSFileOperationClientContext = FSFileOperationClientContext
  objcRetType = retFSFileOperationClientContext
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data FSForkInfo = FSForkInfo
  { fsForkInfoFlags :: !CUChar
  , fsForkInfoPermissions :: !CSChar
  , fsForkInfoVolume :: !CShort
  , fsForkInfoReserved2 :: !CUInt
  , fsForkInfoNodeID :: !CUInt
  , fsForkInfoForkID :: !CUInt
  , fsForkInfoCurrentPosition :: !CULong
  , fsForkInfoLogicalEOF :: !CULong
  , fsForkInfoPhysicalEOF :: !CULong
  , fsForkInfoProcess :: !CULong
  } deriving (Eq, Show)

instance Storable FSForkInfo where
  sizeOf    _ = 48
  alignment _ = 8
  peek p = FSForkInfo <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
    <*> peekByteOff p 16
    <*> peekByteOff p 24
    <*> peekByteOff p 32
    <*> peekByteOff p 40
  poke p (FSForkInfo {..}) = do
    pokeByteOff p 0 fsForkInfoFlags
    pokeByteOff p 1 fsForkInfoPermissions
    pokeByteOff p 2 fsForkInfoVolume
    pokeByteOff p 4 fsForkInfoReserved2
    pokeByteOff p 8 fsForkInfoNodeID
    pokeByteOff p 12 fsForkInfoForkID
    pokeByteOff p 16 fsForkInfoCurrentPosition
    pokeByteOff p 24 fsForkInfoLogicalEOF
    pokeByteOff p 32 fsForkInfoPhysicalEOF
    pokeByteOff p 40 fsForkInfoProcess

{-# NOINLINE fsForkInfoStructType #-}
fsForkInfoStructType :: Ptr CType
fsForkInfoStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_sint8, ffi_type_sint16, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_ulong, ffi_type_ulong, ffi_type_ulong, ffi_type_ulong]

argFSForkInfo :: FSForkInfo -> Arg
argFSForkInfo = mkStorableArg fsForkInfoStructType

retFSForkInfo :: RetType FSForkInfo
retFSForkInfo = mkStorableRetType fsForkInfoStructType

instance ObjCArgument FSForkInfo where
  withObjCArg x k = k (argFSForkInfo x)

instance ObjCReturn FSForkInfo where
  type RawReturn FSForkInfo = FSForkInfo
  objcRetType = retFSForkInfo
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data FSPermissionInfo = FSPermissionInfo
  { fsPermissionInfoUserID :: !CUInt
  , fsPermissionInfoGroupID :: !CUInt
  , fsPermissionInfoReserved1 :: !CUChar
  , fsPermissionInfoUserAccess :: !CUChar
  , fsPermissionInfoMode :: !CUShort
  , fsPermissionInfoFileSec :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable FSPermissionInfo where
  sizeOf    _ = 24
  alignment _ = 8
  peek p = FSPermissionInfo <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 9
    <*> peekByteOff p 10
    <*> peekByteOff p 16
  poke p (FSPermissionInfo {..}) = do
    pokeByteOff p 0 fsPermissionInfoUserID
    pokeByteOff p 4 fsPermissionInfoGroupID
    pokeByteOff p 8 fsPermissionInfoReserved1
    pokeByteOff p 9 fsPermissionInfoUserAccess
    pokeByteOff p 10 fsPermissionInfoMode
    pokeByteOff p 16 fsPermissionInfoFileSec

{-# NOINLINE fsPermissionInfoStructType #-}
fsPermissionInfoStructType :: Ptr CType
fsPermissionInfoStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_uint8, ffi_type_uint8, ffi_type_uint16, ffi_type_pointer]

argFSPermissionInfo :: FSPermissionInfo -> Arg
argFSPermissionInfo = mkStorableArg fsPermissionInfoStructType

retFSPermissionInfo :: RetType FSPermissionInfo
retFSPermissionInfo = mkStorableRetType fsPermissionInfoStructType

instance ObjCArgument FSPermissionInfo where
  withObjCArg x k = k (argFSPermissionInfo x)

instance ObjCReturn FSPermissionInfo where
  type RawReturn FSPermissionInfo = FSPermissionInfo
  objcRetType = retFSPermissionInfo
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data FSRangeLockParam = FSRangeLockParam
  { fsRangeLockParamQLink :: !(Ptr ())
  , fsRangeLockParamQType :: !CShort
  , fsRangeLockParamIoTrap :: !CShort
  , fsRangeLockParamIoCmdAddr :: !(Ptr ())
  , fsRangeLockParamIoCompletion :: !(Ptr ())
  , fsRangeLockParamIoResult :: !CShort
  , fsRangeLockParamForkRefNum :: !CInt
  , fsRangeLockParamRequestCount :: !CULong
  , fsRangeLockParamPositionMode :: !CUShort
  , fsRangeLockParamPositionOffset :: !CLong
  , fsRangeLockParamRangeStart :: !CULong
  } deriving (Eq, Show)

instance Storable FSRangeLockParam where
  sizeOf    _ = 72
  alignment _ = 8
  peek p = FSRangeLockParam <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 10
    <*> peekByteOff p 16
    <*> peekByteOff p 24
    <*> peekByteOff p 32
    <*> peekByteOff p 36
    <*> peekByteOff p 40
    <*> peekByteOff p 48
    <*> peekByteOff p 56
    <*> peekByteOff p 64
  poke p (FSRangeLockParam {..}) = do
    pokeByteOff p 0 fsRangeLockParamQLink
    pokeByteOff p 8 fsRangeLockParamQType
    pokeByteOff p 10 fsRangeLockParamIoTrap
    pokeByteOff p 16 fsRangeLockParamIoCmdAddr
    pokeByteOff p 24 fsRangeLockParamIoCompletion
    pokeByteOff p 32 fsRangeLockParamIoResult
    pokeByteOff p 36 fsRangeLockParamForkRefNum
    pokeByteOff p 40 fsRangeLockParamRequestCount
    pokeByteOff p 48 fsRangeLockParamPositionMode
    pokeByteOff p 56 fsRangeLockParamPositionOffset
    pokeByteOff p 64 fsRangeLockParamRangeStart

{-# NOINLINE fsRangeLockParamStructType #-}
fsRangeLockParamStructType :: Ptr CType
fsRangeLockParamStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer, ffi_type_sint16, ffi_type_sint16, ffi_type_pointer, ffi_type_pointer, ffi_type_sint16, ffi_type_sint, ffi_type_ulong, ffi_type_uint16, ffi_type_slong, ffi_type_ulong]

argFSRangeLockParam :: FSRangeLockParam -> Arg
argFSRangeLockParam = mkStorableArg fsRangeLockParamStructType

retFSRangeLockParam :: RetType FSRangeLockParam
retFSRangeLockParam = mkStorableRetType fsRangeLockParamStructType

instance ObjCArgument FSRangeLockParam where
  withObjCArg x k = k (argFSRangeLockParam x)

instance ObjCReturn FSRangeLockParam where
  type RawReturn FSRangeLockParam = FSRangeLockParam
  objcRetType = retFSRangeLockParam
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data FVector = FVector
  { fVectorStart :: !CShort
  , fVectorLength :: !CShort
  } deriving (Eq, Show)

instance Storable FVector where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = FVector <$> peekByteOff p 0
    <*> peekByteOff p 2
  poke p (FVector {..}) = do
    pokeByteOff p 0 fVectorStart
    pokeByteOff p 2 fVectorLength

{-# NOINLINE fVectorStructType #-}
fVectorStructType :: Ptr CType
fVectorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16, ffi_type_sint16]

argFVector :: FVector -> Arg
argFVector = mkStorableArg fVectorStructType

retFVector :: RetType FVector
retFVector = mkStorableRetType fVectorStructType

instance ObjCArgument FVector where
  withObjCArg x k = k (argFVector x)

instance ObjCReturn FVector where
  type RawReturn FVector = FVector
  objcRetType = retFVector
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data FndrDirInfo = FndrDirInfo
  { fndrDirInfoFrRect :: !(Ptr ())
  , fndrDirInfoFrFlags :: !CUShort
  , fndrDirInfoFrLocation :: !(Ptr ())
  , fndrDirInfoOpaque :: !CShort
  } deriving (Eq, Show)

instance Storable FndrDirInfo where
  sizeOf    _ = 32
  alignment _ = 8
  peek p = FndrDirInfo <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 24
  poke p (FndrDirInfo {..}) = do
    pokeByteOff p 0 fndrDirInfoFrRect
    pokeByteOff p 8 fndrDirInfoFrFlags
    pokeByteOff p 16 fndrDirInfoFrLocation
    pokeByteOff p 24 fndrDirInfoOpaque

{-# NOINLINE fndrDirInfoStructType #-}
fndrDirInfoStructType :: Ptr CType
fndrDirInfoStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer, ffi_type_uint16, ffi_type_pointer, ffi_type_sint16]

argFndrDirInfo :: FndrDirInfo -> Arg
argFndrDirInfo = mkStorableArg fndrDirInfoStructType

retFndrDirInfo :: RetType FndrDirInfo
retFndrDirInfo = mkStorableRetType fndrDirInfoStructType

instance ObjCArgument FndrDirInfo where
  withObjCArg x k = k (argFndrDirInfo x)

instance ObjCReturn FndrDirInfo where
  type RawReturn FndrDirInfo = FndrDirInfo
  objcRetType = retFndrDirInfo
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data FndrFileInfo = FndrFileInfo
  { fndrFileInfoFdType :: !CUInt
  , fndrFileInfoFdCreator :: !CUInt
  , fndrFileInfoFdFlags :: !CUShort
  , fndrFileInfoFdLocation :: !(Ptr ())
  , fndrFileInfoOpaque :: !CShort
  } deriving (Eq, Show)

instance Storable FndrFileInfo where
  sizeOf    _ = 32
  alignment _ = 8
  peek p = FndrFileInfo <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 24
  poke p (FndrFileInfo {..}) = do
    pokeByteOff p 0 fndrFileInfoFdType
    pokeByteOff p 4 fndrFileInfoFdCreator
    pokeByteOff p 8 fndrFileInfoFdFlags
    pokeByteOff p 16 fndrFileInfoFdLocation
    pokeByteOff p 24 fndrFileInfoOpaque

{-# NOINLINE fndrFileInfoStructType #-}
fndrFileInfoStructType :: Ptr CType
fndrFileInfoStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_uint16, ffi_type_pointer, ffi_type_sint16]

argFndrFileInfo :: FndrFileInfo -> Arg
argFndrFileInfo = mkStorableArg fndrFileInfoStructType

retFndrFileInfo :: RetType FndrFileInfo
retFndrFileInfo = mkStorableRetType fndrFileInfoStructType

instance ObjCArgument FndrFileInfo where
  withObjCArg x k = k (argFndrFileInfo x)

instance ObjCReturn FndrFileInfo where
  type RawReturn FndrFileInfo = FndrFileInfo
  objcRetType = retFndrFileInfo
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data FolderRouting = FolderRouting
  { folderRoutingDescSize :: !CLong
  , folderRoutingFileType :: !CUInt
  , folderRoutingRouteFromFolder :: !CUInt
  , folderRoutingRouteToFolder :: !CUInt
  , folderRoutingFlags :: !CUInt
  } deriving (Eq, Show)

instance Storable FolderRouting where
  sizeOf    _ = 24
  alignment _ = 8
  peek p = FolderRouting <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 12
    <*> peekByteOff p 16
    <*> peekByteOff p 20
  poke p (FolderRouting {..}) = do
    pokeByteOff p 0 folderRoutingDescSize
    pokeByteOff p 8 folderRoutingFileType
    pokeByteOff p 12 folderRoutingRouteFromFolder
    pokeByteOff p 16 folderRoutingRouteToFolder
    pokeByteOff p 20 folderRoutingFlags

{-# NOINLINE folderRoutingStructType #-}
folderRoutingStructType :: Ptr CType
folderRoutingStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_slong, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint]

argFolderRouting :: FolderRouting -> Arg
argFolderRouting = mkStorableArg folderRoutingStructType

retFolderRouting :: RetType FolderRouting
retFolderRouting = mkStorableRetType folderRoutingStructType

instance ObjCArgument FolderRouting where
  withObjCArg x k = k (argFolderRouting x)

instance ObjCReturn FolderRouting where
  type RawReturn FolderRouting = FolderRouting
  objcRetType = retFolderRouting
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data FormatVersionChunk = FormatVersionChunk
  { formatVersionChunkCkID :: !CUInt
  , formatVersionChunkCkSize :: !CInt
  , formatVersionChunkTimestamp :: !CUInt
  } deriving (Eq, Show)

instance Storable FormatVersionChunk where
  sizeOf    _ = 12
  alignment _ = 4
  peek p = FormatVersionChunk <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (FormatVersionChunk {..}) = do
    pokeByteOff p 0 formatVersionChunkCkID
    pokeByteOff p 4 formatVersionChunkCkSize
    pokeByteOff p 8 formatVersionChunkTimestamp

{-# NOINLINE formatVersionChunkStructType #-}
formatVersionChunkStructType :: Ptr CType
formatVersionChunkStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_sint, ffi_type_uint]

argFormatVersionChunk :: FormatVersionChunk -> Arg
argFormatVersionChunk = mkStorableArg formatVersionChunkStructType

retFormatVersionChunk :: RetType FormatVersionChunk
retFormatVersionChunk = mkStorableRetType formatVersionChunkStructType

instance ObjCArgument FormatVersionChunk where
  withObjCArg x k = k (argFormatVersionChunk x)

instance ObjCReturn FormatVersionChunk where
  type RawReturn FormatVersionChunk = FormatVersionChunk
  objcRetType = retFormatVersionChunk
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data GetVolParmsInfoBuffer = GetVolParmsInfoBuffer
  { getVolParmsInfoBufferVMVersion :: !CShort
  , getVolParmsInfoBufferVMAttrib :: !CInt
  , getVolParmsInfoBufferVMLocalHand :: !(Ptr ())
  , getVolParmsInfoBufferVMServerAdr :: !CInt
  , getVolParmsInfoBufferVMVolumeGrade :: !CInt
  , getVolParmsInfoBufferVMForeignPrivID :: !CShort
  , getVolParmsInfoBufferVMExtendedAttributes :: !CInt
  , getVolParmsInfoBufferVMDeviceID :: !(Ptr ())
  , getVolParmsInfoBufferVMMaxNameLength :: !CULong
  } deriving (Eq, Show)

instance Storable GetVolParmsInfoBuffer where
  sizeOf    _ = 48
  alignment _ = 8
  peek p = GetVolParmsInfoBuffer <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 20
    <*> peekByteOff p 24
    <*> peekByteOff p 28
    <*> peekByteOff p 32
    <*> peekByteOff p 40
  poke p (GetVolParmsInfoBuffer {..}) = do
    pokeByteOff p 0 getVolParmsInfoBufferVMVersion
    pokeByteOff p 4 getVolParmsInfoBufferVMAttrib
    pokeByteOff p 8 getVolParmsInfoBufferVMLocalHand
    pokeByteOff p 16 getVolParmsInfoBufferVMServerAdr
    pokeByteOff p 20 getVolParmsInfoBufferVMVolumeGrade
    pokeByteOff p 24 getVolParmsInfoBufferVMForeignPrivID
    pokeByteOff p 28 getVolParmsInfoBufferVMExtendedAttributes
    pokeByteOff p 32 getVolParmsInfoBufferVMDeviceID
    pokeByteOff p 40 getVolParmsInfoBufferVMMaxNameLength

{-# NOINLINE getVolParmsInfoBufferStructType #-}
getVolParmsInfoBufferStructType :: Ptr CType
getVolParmsInfoBufferStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16, ffi_type_sint, ffi_type_pointer, ffi_type_sint, ffi_type_sint, ffi_type_sint16, ffi_type_sint, ffi_type_pointer, ffi_type_ulong]

argGetVolParmsInfoBuffer :: GetVolParmsInfoBuffer -> Arg
argGetVolParmsInfoBuffer = mkStorableArg getVolParmsInfoBufferStructType

retGetVolParmsInfoBuffer :: RetType GetVolParmsInfoBuffer
retGetVolParmsInfoBuffer = mkStorableRetType getVolParmsInfoBufferStructType

instance ObjCArgument GetVolParmsInfoBuffer where
  withObjCArg x k = k (argGetVolParmsInfoBuffer x)

instance ObjCReturn GetVolParmsInfoBuffer where
  type RawReturn GetVolParmsInfoBuffer = GetVolParmsInfoBuffer
  objcRetType = retGetVolParmsInfoBuffer
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data HFSExtentDescriptor = HFSExtentDescriptor
  { hfsExtentDescriptorStartBlock :: !CUShort
  , hfsExtentDescriptorBlockCount :: !CUShort
  } deriving (Eq, Show)

instance Storable HFSExtentDescriptor where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = HFSExtentDescriptor <$> peekByteOff p 0
    <*> peekByteOff p 2
  poke p (HFSExtentDescriptor {..}) = do
    pokeByteOff p 0 hfsExtentDescriptorStartBlock
    pokeByteOff p 2 hfsExtentDescriptorBlockCount

{-# NOINLINE hfsExtentDescriptorStructType #-}
hfsExtentDescriptorStructType :: Ptr CType
hfsExtentDescriptorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16]

argHFSExtentDescriptor :: HFSExtentDescriptor -> Arg
argHFSExtentDescriptor = mkStorableArg hfsExtentDescriptorStructType

retHFSExtentDescriptor :: RetType HFSExtentDescriptor
retHFSExtentDescriptor = mkStorableRetType hfsExtentDescriptorStructType

instance ObjCArgument HFSExtentDescriptor where
  withObjCArg x k = k (argHFSExtentDescriptor x)

instance ObjCReturn HFSExtentDescriptor where
  type RawReturn HFSExtentDescriptor = HFSExtentDescriptor
  objcRetType = retHFSExtentDescriptor
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data HFSExtentKey = HFSExtentKey
  { hfsExtentKeyKeyLength :: !CUChar
  , hfsExtentKeyForkType :: !CUChar
  , hfsExtentKeyFileID :: !CUInt
  , hfsExtentKeyStartBlock :: !CUShort
  } deriving (Eq, Show)

instance Storable HFSExtentKey where
  sizeOf    _ = 12
  alignment _ = 4
  peek p = HFSExtentKey <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (HFSExtentKey {..}) = do
    pokeByteOff p 0 hfsExtentKeyKeyLength
    pokeByteOff p 1 hfsExtentKeyForkType
    pokeByteOff p 4 hfsExtentKeyFileID
    pokeByteOff p 8 hfsExtentKeyStartBlock

{-# NOINLINE hfsExtentKeyStructType #-}
hfsExtentKeyStructType :: Ptr CType
hfsExtentKeyStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint, ffi_type_uint16]

argHFSExtentKey :: HFSExtentKey -> Arg
argHFSExtentKey = mkStorableArg hfsExtentKeyStructType

retHFSExtentKey :: RetType HFSExtentKey
retHFSExtentKey = mkStorableRetType hfsExtentKeyStructType

instance ObjCArgument HFSExtentKey where
  withObjCArg x k = k (argHFSExtentKey x)

instance ObjCReturn HFSExtentKey where
  type RawReturn HFSExtentKey = HFSExtentKey
  objcRetType = retHFSExtentKey
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data HFSPlusAttrForkData = HFSPlusAttrForkData
  { hfsPlusAttrForkDataRecordType :: !CUInt
  , hfsPlusAttrForkDataReserved :: !CUInt
  , hfsPlusAttrForkDataTheFork :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable HFSPlusAttrForkData where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = HFSPlusAttrForkData <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (HFSPlusAttrForkData {..}) = do
    pokeByteOff p 0 hfsPlusAttrForkDataRecordType
    pokeByteOff p 4 hfsPlusAttrForkDataReserved
    pokeByteOff p 8 hfsPlusAttrForkDataTheFork

{-# NOINLINE hfsPlusAttrForkDataStructType #-}
hfsPlusAttrForkDataStructType :: Ptr CType
hfsPlusAttrForkDataStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_pointer]

argHFSPlusAttrForkData :: HFSPlusAttrForkData -> Arg
argHFSPlusAttrForkData = mkStorableArg hfsPlusAttrForkDataStructType

retHFSPlusAttrForkData :: RetType HFSPlusAttrForkData
retHFSPlusAttrForkData = mkStorableRetType hfsPlusAttrForkDataStructType

instance ObjCArgument HFSPlusAttrForkData where
  withObjCArg x k = k (argHFSPlusAttrForkData x)

instance ObjCReturn HFSPlusAttrForkData where
  type RawReturn HFSPlusAttrForkData = HFSPlusAttrForkData
  objcRetType = retHFSPlusAttrForkData
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data HFSPlusCatalogFile = HFSPlusCatalogFile
  { hfsPlusCatalogFileRecordType :: !CShort
  , hfsPlusCatalogFileFlags :: !CUShort
  , hfsPlusCatalogFileReserved1 :: !CUInt
  , hfsPlusCatalogFileFileID :: !CUInt
  , hfsPlusCatalogFileCreateDate :: !CUInt
  , hfsPlusCatalogFileContentModDate :: !CUInt
  , hfsPlusCatalogFileAttributeModDate :: !CUInt
  , hfsPlusCatalogFileAccessDate :: !CUInt
  , hfsPlusCatalogFileBackupDate :: !CUInt
  , hfsPlusCatalogFileBsdInfo :: !(Ptr ())
  , hfsPlusCatalogFileUserInfo :: !(Ptr ())
  , hfsPlusCatalogFileFinderInfo :: !(Ptr ())
  , hfsPlusCatalogFileTextEncoding :: !CUInt
  , hfsPlusCatalogFileReserved2 :: !CUInt
  , hfsPlusCatalogFileDataFork :: !(Ptr ())
  , hfsPlusCatalogFileResourceFork :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable HFSPlusCatalogFile where
  sizeOf    _ = 80
  alignment _ = 8
  peek p = HFSPlusCatalogFile <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
    <*> peekByteOff p 16
    <*> peekByteOff p 20
    <*> peekByteOff p 24
    <*> peekByteOff p 28
    <*> peekByteOff p 32
    <*> peekByteOff p 40
    <*> peekByteOff p 48
    <*> peekByteOff p 56
    <*> peekByteOff p 60
    <*> peekByteOff p 64
    <*> peekByteOff p 72
  poke p (HFSPlusCatalogFile {..}) = do
    pokeByteOff p 0 hfsPlusCatalogFileRecordType
    pokeByteOff p 2 hfsPlusCatalogFileFlags
    pokeByteOff p 4 hfsPlusCatalogFileReserved1
    pokeByteOff p 8 hfsPlusCatalogFileFileID
    pokeByteOff p 12 hfsPlusCatalogFileCreateDate
    pokeByteOff p 16 hfsPlusCatalogFileContentModDate
    pokeByteOff p 20 hfsPlusCatalogFileAttributeModDate
    pokeByteOff p 24 hfsPlusCatalogFileAccessDate
    pokeByteOff p 28 hfsPlusCatalogFileBackupDate
    pokeByteOff p 32 hfsPlusCatalogFileBsdInfo
    pokeByteOff p 40 hfsPlusCatalogFileUserInfo
    pokeByteOff p 48 hfsPlusCatalogFileFinderInfo
    pokeByteOff p 56 hfsPlusCatalogFileTextEncoding
    pokeByteOff p 60 hfsPlusCatalogFileReserved2
    pokeByteOff p 64 hfsPlusCatalogFileDataFork
    pokeByteOff p 72 hfsPlusCatalogFileResourceFork

{-# NOINLINE hfsPlusCatalogFileStructType #-}
hfsPlusCatalogFileStructType :: Ptr CType
hfsPlusCatalogFileStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16, ffi_type_uint16, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_uint, ffi_type_uint, ffi_type_pointer, ffi_type_pointer]

argHFSPlusCatalogFile :: HFSPlusCatalogFile -> Arg
argHFSPlusCatalogFile = mkStorableArg hfsPlusCatalogFileStructType

retHFSPlusCatalogFile :: RetType HFSPlusCatalogFile
retHFSPlusCatalogFile = mkStorableRetType hfsPlusCatalogFileStructType

instance ObjCArgument HFSPlusCatalogFile where
  withObjCArg x k = k (argHFSPlusCatalogFile x)

instance ObjCReturn HFSPlusCatalogFile where
  type RawReturn HFSPlusCatalogFile = HFSPlusCatalogFile
  objcRetType = retHFSPlusCatalogFile
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data HFSPlusCatalogFolder = HFSPlusCatalogFolder
  { hfsPlusCatalogFolderRecordType :: !CShort
  , hfsPlusCatalogFolderFlags :: !CUShort
  , hfsPlusCatalogFolderValence :: !CUInt
  , hfsPlusCatalogFolderFolderID :: !CUInt
  , hfsPlusCatalogFolderCreateDate :: !CUInt
  , hfsPlusCatalogFolderContentModDate :: !CUInt
  , hfsPlusCatalogFolderAttributeModDate :: !CUInt
  , hfsPlusCatalogFolderAccessDate :: !CUInt
  , hfsPlusCatalogFolderBackupDate :: !CUInt
  , hfsPlusCatalogFolderBsdInfo :: !(Ptr ())
  , hfsPlusCatalogFolderUserInfo :: !(Ptr ())
  , hfsPlusCatalogFolderFinderInfo :: !(Ptr ())
  , hfsPlusCatalogFolderTextEncoding :: !CUInt
  , hfsPlusCatalogFolderFolderCount :: !CUInt
  } deriving (Eq, Show)

instance Storable HFSPlusCatalogFolder where
  sizeOf    _ = 64
  alignment _ = 8
  peek p = HFSPlusCatalogFolder <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
    <*> peekByteOff p 16
    <*> peekByteOff p 20
    <*> peekByteOff p 24
    <*> peekByteOff p 28
    <*> peekByteOff p 32
    <*> peekByteOff p 40
    <*> peekByteOff p 48
    <*> peekByteOff p 56
    <*> peekByteOff p 60
  poke p (HFSPlusCatalogFolder {..}) = do
    pokeByteOff p 0 hfsPlusCatalogFolderRecordType
    pokeByteOff p 2 hfsPlusCatalogFolderFlags
    pokeByteOff p 4 hfsPlusCatalogFolderValence
    pokeByteOff p 8 hfsPlusCatalogFolderFolderID
    pokeByteOff p 12 hfsPlusCatalogFolderCreateDate
    pokeByteOff p 16 hfsPlusCatalogFolderContentModDate
    pokeByteOff p 20 hfsPlusCatalogFolderAttributeModDate
    pokeByteOff p 24 hfsPlusCatalogFolderAccessDate
    pokeByteOff p 28 hfsPlusCatalogFolderBackupDate
    pokeByteOff p 32 hfsPlusCatalogFolderBsdInfo
    pokeByteOff p 40 hfsPlusCatalogFolderUserInfo
    pokeByteOff p 48 hfsPlusCatalogFolderFinderInfo
    pokeByteOff p 56 hfsPlusCatalogFolderTextEncoding
    pokeByteOff p 60 hfsPlusCatalogFolderFolderCount

{-# NOINLINE hfsPlusCatalogFolderStructType #-}
hfsPlusCatalogFolderStructType :: Ptr CType
hfsPlusCatalogFolderStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16, ffi_type_uint16, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_uint, ffi_type_uint]

argHFSPlusCatalogFolder :: HFSPlusCatalogFolder -> Arg
argHFSPlusCatalogFolder = mkStorableArg hfsPlusCatalogFolderStructType

retHFSPlusCatalogFolder :: RetType HFSPlusCatalogFolder
retHFSPlusCatalogFolder = mkStorableRetType hfsPlusCatalogFolderStructType

instance ObjCArgument HFSPlusCatalogFolder where
  withObjCArg x k = k (argHFSPlusCatalogFolder x)

instance ObjCReturn HFSPlusCatalogFolder where
  type RawReturn HFSPlusCatalogFolder = HFSPlusCatalogFolder
  objcRetType = retHFSPlusCatalogFolder
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data HFSPlusCatalogKey = HFSPlusCatalogKey
  { hfsPlusCatalogKeyKeyLength :: !CUShort
  , hfsPlusCatalogKeyParentID :: !CUInt
  , hfsPlusCatalogKeyNodeName :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable HFSPlusCatalogKey where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = HFSPlusCatalogKey <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (HFSPlusCatalogKey {..}) = do
    pokeByteOff p 0 hfsPlusCatalogKeyKeyLength
    pokeByteOff p 4 hfsPlusCatalogKeyParentID
    pokeByteOff p 8 hfsPlusCatalogKeyNodeName

{-# NOINLINE hfsPlusCatalogKeyStructType #-}
hfsPlusCatalogKeyStructType :: Ptr CType
hfsPlusCatalogKeyStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint, ffi_type_pointer]

argHFSPlusCatalogKey :: HFSPlusCatalogKey -> Arg
argHFSPlusCatalogKey = mkStorableArg hfsPlusCatalogKeyStructType

retHFSPlusCatalogKey :: RetType HFSPlusCatalogKey
retHFSPlusCatalogKey = mkStorableRetType hfsPlusCatalogKeyStructType

instance ObjCArgument HFSPlusCatalogKey where
  withObjCArg x k = k (argHFSPlusCatalogKey x)

instance ObjCReturn HFSPlusCatalogKey where
  type RawReturn HFSPlusCatalogKey = HFSPlusCatalogKey
  objcRetType = retHFSPlusCatalogKey
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data HFSPlusCatalogThread = HFSPlusCatalogThread
  { hfsPlusCatalogThreadRecordType :: !CShort
  , hfsPlusCatalogThreadReserved :: !CShort
  , hfsPlusCatalogThreadParentID :: !CUInt
  , hfsPlusCatalogThreadNodeName :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable HFSPlusCatalogThread where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = HFSPlusCatalogThread <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (HFSPlusCatalogThread {..}) = do
    pokeByteOff p 0 hfsPlusCatalogThreadRecordType
    pokeByteOff p 2 hfsPlusCatalogThreadReserved
    pokeByteOff p 4 hfsPlusCatalogThreadParentID
    pokeByteOff p 8 hfsPlusCatalogThreadNodeName

{-# NOINLINE hfsPlusCatalogThreadStructType #-}
hfsPlusCatalogThreadStructType :: Ptr CType
hfsPlusCatalogThreadStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16, ffi_type_sint16, ffi_type_uint, ffi_type_pointer]

argHFSPlusCatalogThread :: HFSPlusCatalogThread -> Arg
argHFSPlusCatalogThread = mkStorableArg hfsPlusCatalogThreadStructType

retHFSPlusCatalogThread :: RetType HFSPlusCatalogThread
retHFSPlusCatalogThread = mkStorableRetType hfsPlusCatalogThreadStructType

instance ObjCArgument HFSPlusCatalogThread where
  withObjCArg x k = k (argHFSPlusCatalogThread x)

instance ObjCReturn HFSPlusCatalogThread where
  type RawReturn HFSPlusCatalogThread = HFSPlusCatalogThread
  objcRetType = retHFSPlusCatalogThread
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data HFSPlusExtentDescriptor = HFSPlusExtentDescriptor
  { hfsPlusExtentDescriptorStartBlock :: !CUInt
  , hfsPlusExtentDescriptorBlockCount :: !CUInt
  } deriving (Eq, Show)

instance Storable HFSPlusExtentDescriptor where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = HFSPlusExtentDescriptor <$> peekByteOff p 0
    <*> peekByteOff p 4
  poke p (HFSPlusExtentDescriptor {..}) = do
    pokeByteOff p 0 hfsPlusExtentDescriptorStartBlock
    pokeByteOff p 4 hfsPlusExtentDescriptorBlockCount

{-# NOINLINE hfsPlusExtentDescriptorStructType #-}
hfsPlusExtentDescriptorStructType :: Ptr CType
hfsPlusExtentDescriptorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint]

argHFSPlusExtentDescriptor :: HFSPlusExtentDescriptor -> Arg
argHFSPlusExtentDescriptor = mkStorableArg hfsPlusExtentDescriptorStructType

retHFSPlusExtentDescriptor :: RetType HFSPlusExtentDescriptor
retHFSPlusExtentDescriptor = mkStorableRetType hfsPlusExtentDescriptorStructType

instance ObjCArgument HFSPlusExtentDescriptor where
  withObjCArg x k = k (argHFSPlusExtentDescriptor x)

instance ObjCReturn HFSPlusExtentDescriptor where
  type RawReturn HFSPlusExtentDescriptor = HFSPlusExtentDescriptor
  objcRetType = retHFSPlusExtentDescriptor
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data HFSPlusExtentKey = HFSPlusExtentKey
  { hfsPlusExtentKeyKeyLength :: !CUShort
  , hfsPlusExtentKeyForkType :: !CUChar
  , hfsPlusExtentKeyPad :: !CUChar
  , hfsPlusExtentKeyFileID :: !CUInt
  , hfsPlusExtentKeyStartBlock :: !CUInt
  } deriving (Eq, Show)

instance Storable HFSPlusExtentKey where
  sizeOf    _ = 12
  alignment _ = 4
  peek p = HFSPlusExtentKey <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 3
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (HFSPlusExtentKey {..}) = do
    pokeByteOff p 0 hfsPlusExtentKeyKeyLength
    pokeByteOff p 2 hfsPlusExtentKeyForkType
    pokeByteOff p 3 hfsPlusExtentKeyPad
    pokeByteOff p 4 hfsPlusExtentKeyFileID
    pokeByteOff p 8 hfsPlusExtentKeyStartBlock

{-# NOINLINE hfsPlusExtentKeyStructType #-}
hfsPlusExtentKeyStructType :: Ptr CType
hfsPlusExtentKeyStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint8, ffi_type_uint8, ffi_type_uint, ffi_type_uint]

argHFSPlusExtentKey :: HFSPlusExtentKey -> Arg
argHFSPlusExtentKey = mkStorableArg hfsPlusExtentKeyStructType

retHFSPlusExtentKey :: RetType HFSPlusExtentKey
retHFSPlusExtentKey = mkStorableRetType hfsPlusExtentKeyStructType

instance ObjCArgument HFSPlusExtentKey where
  withObjCArg x k = k (argHFSPlusExtentKey x)

instance ObjCReturn HFSPlusExtentKey where
  type RawReturn HFSPlusExtentKey = HFSPlusExtentKey
  objcRetType = retHFSPlusExtentKey
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data Itl4Rec = Itl4Rec
  { itl4RecFlags :: !CShort
  , itl4RecResourceType :: !CInt
  , itl4RecResourceNum :: !CShort
  , itl4RecVersion :: !CShort
  , itl4RecResHeader1 :: !CInt
  , itl4RecResHeader2 :: !CInt
  , itl4RecNumTables :: !CShort
  , itl4RecMapOffset :: !CInt
  , itl4RecStrOffset :: !CInt
  , itl4RecFetchOffset :: !CInt
  , itl4RecUnTokenOffset :: !CInt
  , itl4RecDefPartsOffset :: !CInt
  , itl4RecResOffset6 :: !CInt
  , itl4RecResOffset7 :: !CInt
  , itl4RecResOffset8 :: !CInt
  } deriving (Eq, Show)

instance Storable Itl4Rec where
  sizeOf    _ = 56
  alignment _ = 4
  peek p = Itl4Rec <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 10
    <*> peekByteOff p 12
    <*> peekByteOff p 16
    <*> peekByteOff p 20
    <*> peekByteOff p 24
    <*> peekByteOff p 28
    <*> peekByteOff p 32
    <*> peekByteOff p 36
    <*> peekByteOff p 40
    <*> peekByteOff p 44
    <*> peekByteOff p 48
    <*> peekByteOff p 52
  poke p (Itl4Rec {..}) = do
    pokeByteOff p 0 itl4RecFlags
    pokeByteOff p 4 itl4RecResourceType
    pokeByteOff p 8 itl4RecResourceNum
    pokeByteOff p 10 itl4RecVersion
    pokeByteOff p 12 itl4RecResHeader1
    pokeByteOff p 16 itl4RecResHeader2
    pokeByteOff p 20 itl4RecNumTables
    pokeByteOff p 24 itl4RecMapOffset
    pokeByteOff p 28 itl4RecStrOffset
    pokeByteOff p 32 itl4RecFetchOffset
    pokeByteOff p 36 itl4RecUnTokenOffset
    pokeByteOff p 40 itl4RecDefPartsOffset
    pokeByteOff p 44 itl4RecResOffset6
    pokeByteOff p 48 itl4RecResOffset7
    pokeByteOff p 52 itl4RecResOffset8

{-# NOINLINE itl4RecStructType #-}
itl4RecStructType :: Ptr CType
itl4RecStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16, ffi_type_sint, ffi_type_sint16, ffi_type_sint16, ffi_type_sint, ffi_type_sint, ffi_type_sint16, ffi_type_sint, ffi_type_sint, ffi_type_sint, ffi_type_sint, ffi_type_sint, ffi_type_sint, ffi_type_sint, ffi_type_sint]

argItl4Rec :: Itl4Rec -> Arg
argItl4Rec = mkStorableArg itl4RecStructType

retItl4Rec :: RetType Itl4Rec
retItl4Rec = mkStorableRetType itl4RecStructType

instance ObjCArgument Itl4Rec where
  withObjCArg x k = k (argItl4Rec x)

instance ObjCReturn Itl4Rec where
  type RawReturn Itl4Rec = Itl4Rec
  objcRetType = retItl4Rec
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data ItlbRecord = ItlbRecord
  { itlbRecordItlbNumber :: !CShort
  , itlbRecordItlbDate :: !CShort
  , itlbRecordItlbSort :: !CShort
  , itlbRecordItlbFlags :: !CShort
  , itlbRecordItlbToken :: !CShort
  , itlbRecordItlbEncoding :: !CShort
  , itlbRecordItlbLang :: !CShort
  , itlbRecordItlbNumRep :: !CSChar
  , itlbRecordItlbDateRep :: !CSChar
  , itlbRecordItlbKeys :: !CShort
  , itlbRecordItlbIcon :: !CShort
  } deriving (Eq, Show)

instance Storable ItlbRecord where
  sizeOf    _ = 20
  alignment _ = 2
  peek p = ItlbRecord <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 6
    <*> peekByteOff p 8
    <*> peekByteOff p 10
    <*> peekByteOff p 12
    <*> peekByteOff p 14
    <*> peekByteOff p 15
    <*> peekByteOff p 16
    <*> peekByteOff p 18
  poke p (ItlbRecord {..}) = do
    pokeByteOff p 0 itlbRecordItlbNumber
    pokeByteOff p 2 itlbRecordItlbDate
    pokeByteOff p 4 itlbRecordItlbSort
    pokeByteOff p 6 itlbRecordItlbFlags
    pokeByteOff p 8 itlbRecordItlbToken
    pokeByteOff p 10 itlbRecordItlbEncoding
    pokeByteOff p 12 itlbRecordItlbLang
    pokeByteOff p 14 itlbRecordItlbNumRep
    pokeByteOff p 15 itlbRecordItlbDateRep
    pokeByteOff p 16 itlbRecordItlbKeys
    pokeByteOff p 18 itlbRecordItlbIcon

{-# NOINLINE itlbRecordStructType #-}
itlbRecordStructType :: Ptr CType
itlbRecordStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16, ffi_type_sint8, ffi_type_sint8, ffi_type_sint16, ffi_type_sint16]

argItlbRecord :: ItlbRecord -> Arg
argItlbRecord = mkStorableArg itlbRecordStructType

retItlbRecord :: RetType ItlbRecord
retItlbRecord = mkStorableRetType itlbRecordStructType

instance ObjCArgument ItlbRecord where
  withObjCArg x k = k (argItlbRecord x)

instance ObjCReturn ItlbRecord where
  type RawReturn ItlbRecord = ItlbRecord
  objcRetType = retItlbRecord
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | SecKeychainAttribute
--
-- Contains keychain attributes.     tag A 4-byte attribute tag.     length The length of the buffer pointed to by data.     data A pointer to the attribute data.
data KCAttribute = KCAttribute
  { kcAttributeTag :: !CUInt
  , kcAttributeLength :: !CUInt
  , kcAttributeData :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable KCAttribute where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = KCAttribute <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (KCAttribute {..}) = do
    pokeByteOff p 0 kcAttributeTag
    pokeByteOff p 4 kcAttributeLength
    pokeByteOff p 8 kcAttributeData

{-# NOINLINE kcAttributeStructType #-}
kcAttributeStructType :: Ptr CType
kcAttributeStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_pointer]

argKCAttribute :: KCAttribute -> Arg
argKCAttribute = mkStorableArg kcAttributeStructType

retKCAttribute :: RetType KCAttribute
retKCAttribute = mkStorableRetType kcAttributeStructType

instance ObjCArgument KCAttribute where
  withObjCArg x k = k (argKCAttribute x)

instance ObjCReturn KCAttribute where
  type RawReturn KCAttribute = KCAttribute
  objcRetType = retKCAttribute
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data LSItemInfoRecord = LSItemInfoRecord
  { lsItemInfoRecordFlags :: !LSItemInfoFlags
  , lsItemInfoRecordFiletype :: !CUInt
  , lsItemInfoRecordCreator :: !CUInt
  , lsItemInfoRecordExtension :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable LSItemInfoRecord where
  sizeOf    _ = 24
  alignment _ = 8
  peek p = LSItemInfoRecord <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 16
  poke p (LSItemInfoRecord {..}) = do
    pokeByteOff p 0 lsItemInfoRecordFlags
    pokeByteOff p 4 lsItemInfoRecordFiletype
    pokeByteOff p 8 lsItemInfoRecordCreator
    pokeByteOff p 16 lsItemInfoRecordExtension

{-# NOINLINE lsItemInfoRecordStructType #-}
lsItemInfoRecordStructType :: Ptr CType
lsItemInfoRecordStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_pointer]

argLSItemInfoRecord :: LSItemInfoRecord -> Arg
argLSItemInfoRecord = mkStorableArg lsItemInfoRecordStructType

retLSItemInfoRecord :: RetType LSItemInfoRecord
retLSItemInfoRecord = mkStorableRetType lsItemInfoRecordStructType

instance ObjCArgument LSItemInfoRecord where
  withObjCArg x k = k (argLSItemInfoRecord x)

instance ObjCReturn LSItemInfoRecord where
  type RawReturn LSItemInfoRecord = LSItemInfoRecord
  objcRetType = retLSItemInfoRecord
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data LocalDateTime = LocalDateTime
  { localDateTimeHighSeconds :: !CUShort
  , localDateTimeLowSeconds :: !CUInt
  , localDateTimeFraction :: !CUShort
  } deriving (Eq, Show)

instance Storable LocalDateTime where
  sizeOf    _ = 12
  alignment _ = 4
  peek p = LocalDateTime <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (LocalDateTime {..}) = do
    pokeByteOff p 0 localDateTimeHighSeconds
    pokeByteOff p 4 localDateTimeLowSeconds
    pokeByteOff p 8 localDateTimeFraction

{-# NOINLINE localDateTimeStructType #-}
localDateTimeStructType :: Ptr CType
localDateTimeStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint, ffi_type_uint16]

argLocalDateTime :: LocalDateTime -> Arg
argLocalDateTime = mkStorableArg localDateTimeStructType

retLocalDateTime :: RetType LocalDateTime
retLocalDateTime = mkStorableRetType localDateTimeStructType

instance ObjCArgument LocalDateTime where
  withObjCArg x k = k (argLocalDateTime x)

instance ObjCReturn LocalDateTime where
  type RawReturn LocalDateTime = LocalDateTime
  objcRetType = retLocalDateTime
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data LocaleAndVariant = LocaleAndVariant
  { localeAndVariantLocale :: !(Ptr ())
  , localeAndVariantOpVariant :: !CUInt
  } deriving (Eq, Show)

instance Storable LocaleAndVariant where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = LocaleAndVariant <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (LocaleAndVariant {..}) = do
    pokeByteOff p 0 localeAndVariantLocale
    pokeByteOff p 8 localeAndVariantOpVariant

{-# NOINLINE localeAndVariantStructType #-}
localeAndVariantStructType :: Ptr CType
localeAndVariantStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer, ffi_type_uint]

argLocaleAndVariant :: LocaleAndVariant -> Arg
argLocaleAndVariant = mkStorableArg localeAndVariantStructType

retLocaleAndVariant :: RetType LocaleAndVariant
retLocaleAndVariant = mkStorableRetType localeAndVariantStructType

instance ObjCArgument LocaleAndVariant where
  withObjCArg x k = k (argLocaleAndVariant x)

instance ObjCReturn LocaleAndVariant where
  type RawReturn LocaleAndVariant = LocaleAndVariant
  objcRetType = retLocaleAndVariant
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data MPCriticalRegionInfo = MPCriticalRegionInfo
  { mpCriticalRegionInfoVersion :: !CUInt
  , mpCriticalRegionInfoProcessID :: !(Ptr ())
  , mpCriticalRegionInfoRegionName :: !CUInt
  , mpCriticalRegionInfoNWaiting :: !CULong
  , mpCriticalRegionInfoWaitingTaskID :: !(Ptr ())
  , mpCriticalRegionInfoOwningTask :: !(Ptr ())
  , mpCriticalRegionInfoCount :: !CULong
  } deriving (Eq, Show)

instance Storable MPCriticalRegionInfo where
  sizeOf    _ = 56
  alignment _ = 8
  peek p = MPCriticalRegionInfo <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 24
    <*> peekByteOff p 32
    <*> peekByteOff p 40
    <*> peekByteOff p 48
  poke p (MPCriticalRegionInfo {..}) = do
    pokeByteOff p 0 mpCriticalRegionInfoVersion
    pokeByteOff p 8 mpCriticalRegionInfoProcessID
    pokeByteOff p 16 mpCriticalRegionInfoRegionName
    pokeByteOff p 24 mpCriticalRegionInfoNWaiting
    pokeByteOff p 32 mpCriticalRegionInfoWaitingTaskID
    pokeByteOff p 40 mpCriticalRegionInfoOwningTask
    pokeByteOff p 48 mpCriticalRegionInfoCount

{-# NOINLINE mpCriticalRegionInfoStructType #-}
mpCriticalRegionInfoStructType :: Ptr CType
mpCriticalRegionInfoStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_pointer, ffi_type_uint, ffi_type_ulong, ffi_type_pointer, ffi_type_pointer, ffi_type_ulong]

argMPCriticalRegionInfo :: MPCriticalRegionInfo -> Arg
argMPCriticalRegionInfo = mkStorableArg mpCriticalRegionInfoStructType

retMPCriticalRegionInfo :: RetType MPCriticalRegionInfo
retMPCriticalRegionInfo = mkStorableRetType mpCriticalRegionInfoStructType

instance ObjCArgument MPCriticalRegionInfo where
  withObjCArg x k = k (argMPCriticalRegionInfo x)

instance ObjCReturn MPCriticalRegionInfo where
  type RawReturn MPCriticalRegionInfo = MPCriticalRegionInfo
  objcRetType = retMPCriticalRegionInfo
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data MPEventInfo = MPEventInfo
  { mpEventInfoVersion :: !CUInt
  , mpEventInfoProcessID :: !(Ptr ())
  , mpEventInfoEventName :: !CUInt
  , mpEventInfoNWaiting :: !CULong
  , mpEventInfoWaitingTaskID :: !(Ptr ())
  , mpEventInfoEvents :: !CUInt
  } deriving (Eq, Show)

instance Storable MPEventInfo where
  sizeOf    _ = 48
  alignment _ = 8
  peek p = MPEventInfo <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 24
    <*> peekByteOff p 32
    <*> peekByteOff p 40
  poke p (MPEventInfo {..}) = do
    pokeByteOff p 0 mpEventInfoVersion
    pokeByteOff p 8 mpEventInfoProcessID
    pokeByteOff p 16 mpEventInfoEventName
    pokeByteOff p 24 mpEventInfoNWaiting
    pokeByteOff p 32 mpEventInfoWaitingTaskID
    pokeByteOff p 40 mpEventInfoEvents

{-# NOINLINE mpEventInfoStructType #-}
mpEventInfoStructType :: Ptr CType
mpEventInfoStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_pointer, ffi_type_uint, ffi_type_ulong, ffi_type_pointer, ffi_type_uint]

argMPEventInfo :: MPEventInfo -> Arg
argMPEventInfo = mkStorableArg mpEventInfoStructType

retMPEventInfo :: RetType MPEventInfo
retMPEventInfo = mkStorableRetType mpEventInfoStructType

instance ObjCArgument MPEventInfo where
  withObjCArg x k = k (argMPEventInfo x)

instance ObjCReturn MPEventInfo where
  type RawReturn MPEventInfo = MPEventInfo
  objcRetType = retMPEventInfo
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data MPNotificationInfo = MPNotificationInfo
  { mpNotificationInfoVersion :: !CUInt
  , mpNotificationInfoProcessID :: !(Ptr ())
  , mpNotificationInfoNotificationName :: !CUInt
  , mpNotificationInfoQueueID :: !(Ptr ())
  , mpNotificationInfoP1 :: !(Ptr ())
  , mpNotificationInfoP2 :: !(Ptr ())
  , mpNotificationInfoP3 :: !(Ptr ())
  , mpNotificationInfoEventID :: !(Ptr ())
  , mpNotificationInfoEvents :: !CUInt
  , mpNotificationInfoSemaphoreID :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable MPNotificationInfo where
  sizeOf    _ = 80
  alignment _ = 8
  peek p = MPNotificationInfo <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 24
    <*> peekByteOff p 32
    <*> peekByteOff p 40
    <*> peekByteOff p 48
    <*> peekByteOff p 56
    <*> peekByteOff p 64
    <*> peekByteOff p 72
  poke p (MPNotificationInfo {..}) = do
    pokeByteOff p 0 mpNotificationInfoVersion
    pokeByteOff p 8 mpNotificationInfoProcessID
    pokeByteOff p 16 mpNotificationInfoNotificationName
    pokeByteOff p 24 mpNotificationInfoQueueID
    pokeByteOff p 32 mpNotificationInfoP1
    pokeByteOff p 40 mpNotificationInfoP2
    pokeByteOff p 48 mpNotificationInfoP3
    pokeByteOff p 56 mpNotificationInfoEventID
    pokeByteOff p 64 mpNotificationInfoEvents
    pokeByteOff p 72 mpNotificationInfoSemaphoreID

{-# NOINLINE mpNotificationInfoStructType #-}
mpNotificationInfoStructType :: Ptr CType
mpNotificationInfoStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_pointer, ffi_type_uint, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_uint, ffi_type_pointer]

argMPNotificationInfo :: MPNotificationInfo -> Arg
argMPNotificationInfo = mkStorableArg mpNotificationInfoStructType

retMPNotificationInfo :: RetType MPNotificationInfo
retMPNotificationInfo = mkStorableRetType mpNotificationInfoStructType

instance ObjCArgument MPNotificationInfo where
  withObjCArg x k = k (argMPNotificationInfo x)

instance ObjCReturn MPNotificationInfo where
  type RawReturn MPNotificationInfo = MPNotificationInfo
  objcRetType = retMPNotificationInfo
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data MPQueueInfo = MPQueueInfo
  { mpQueueInfoVersion :: !CUInt
  , mpQueueInfoProcessID :: !(Ptr ())
  , mpQueueInfoQueueName :: !CUInt
  , mpQueueInfoNWaiting :: !CULong
  , mpQueueInfoWaitingTaskID :: !(Ptr ())
  , mpQueueInfoNMessages :: !CULong
  , mpQueueInfoNReserved :: !CULong
  , mpQueueInfoP1 :: !(Ptr ())
  , mpQueueInfoP2 :: !(Ptr ())
  , mpQueueInfoP3 :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable MPQueueInfo where
  sizeOf    _ = 80
  alignment _ = 8
  peek p = MPQueueInfo <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 24
    <*> peekByteOff p 32
    <*> peekByteOff p 40
    <*> peekByteOff p 48
    <*> peekByteOff p 56
    <*> peekByteOff p 64
    <*> peekByteOff p 72
  poke p (MPQueueInfo {..}) = do
    pokeByteOff p 0 mpQueueInfoVersion
    pokeByteOff p 8 mpQueueInfoProcessID
    pokeByteOff p 16 mpQueueInfoQueueName
    pokeByteOff p 24 mpQueueInfoNWaiting
    pokeByteOff p 32 mpQueueInfoWaitingTaskID
    pokeByteOff p 40 mpQueueInfoNMessages
    pokeByteOff p 48 mpQueueInfoNReserved
    pokeByteOff p 56 mpQueueInfoP1
    pokeByteOff p 64 mpQueueInfoP2
    pokeByteOff p 72 mpQueueInfoP3

{-# NOINLINE mpQueueInfoStructType #-}
mpQueueInfoStructType :: Ptr CType
mpQueueInfoStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_pointer, ffi_type_uint, ffi_type_ulong, ffi_type_pointer, ffi_type_ulong, ffi_type_ulong, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer]

argMPQueueInfo :: MPQueueInfo -> Arg
argMPQueueInfo = mkStorableArg mpQueueInfoStructType

retMPQueueInfo :: RetType MPQueueInfo
retMPQueueInfo = mkStorableRetType mpQueueInfoStructType

instance ObjCArgument MPQueueInfo where
  withObjCArg x k = k (argMPQueueInfo x)

instance ObjCReturn MPQueueInfo where
  type RawReturn MPQueueInfo = MPQueueInfo
  objcRetType = retMPQueueInfo
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data MPSemaphoreInfo = MPSemaphoreInfo
  { mpSemaphoreInfoVersion :: !CUInt
  , mpSemaphoreInfoProcessID :: !(Ptr ())
  , mpSemaphoreInfoSemaphoreName :: !CUInt
  , mpSemaphoreInfoNWaiting :: !CULong
  , mpSemaphoreInfoWaitingTaskID :: !(Ptr ())
  , mpSemaphoreInfoMaximum :: !CULong
  , mpSemaphoreInfoCount :: !CULong
  } deriving (Eq, Show)

instance Storable MPSemaphoreInfo where
  sizeOf    _ = 56
  alignment _ = 8
  peek p = MPSemaphoreInfo <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 24
    <*> peekByteOff p 32
    <*> peekByteOff p 40
    <*> peekByteOff p 48
  poke p (MPSemaphoreInfo {..}) = do
    pokeByteOff p 0 mpSemaphoreInfoVersion
    pokeByteOff p 8 mpSemaphoreInfoProcessID
    pokeByteOff p 16 mpSemaphoreInfoSemaphoreName
    pokeByteOff p 24 mpSemaphoreInfoNWaiting
    pokeByteOff p 32 mpSemaphoreInfoWaitingTaskID
    pokeByteOff p 40 mpSemaphoreInfoMaximum
    pokeByteOff p 48 mpSemaphoreInfoCount

{-# NOINLINE mpSemaphoreInfoStructType #-}
mpSemaphoreInfoStructType :: Ptr CType
mpSemaphoreInfoStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_pointer, ffi_type_uint, ffi_type_ulong, ffi_type_pointer, ffi_type_ulong, ffi_type_ulong]

argMPSemaphoreInfo :: MPSemaphoreInfo -> Arg
argMPSemaphoreInfo = mkStorableArg mpSemaphoreInfoStructType

retMPSemaphoreInfo :: RetType MPSemaphoreInfo
retMPSemaphoreInfo = mkStorableRetType mpSemaphoreInfoStructType

instance ObjCArgument MPSemaphoreInfo where
  withObjCArg x k = k (argMPSemaphoreInfo x)

instance ObjCReturn MPSemaphoreInfo where
  type RawReturn MPSemaphoreInfo = MPSemaphoreInfo
  objcRetType = retMPSemaphoreInfo
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data MemoryExceptionInformation = MemoryExceptionInformation
  { memoryExceptionInformationTheArea :: !(Ptr ())
  , memoryExceptionInformationTheAddress :: !(Ptr ())
  , memoryExceptionInformationTheError :: !CInt
  , memoryExceptionInformationTheReference :: !CULong
  } deriving (Eq, Show)

instance Storable MemoryExceptionInformation where
  sizeOf    _ = 32
  alignment _ = 8
  peek p = MemoryExceptionInformation <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 24
  poke p (MemoryExceptionInformation {..}) = do
    pokeByteOff p 0 memoryExceptionInformationTheArea
    pokeByteOff p 8 memoryExceptionInformationTheAddress
    pokeByteOff p 16 memoryExceptionInformationTheError
    pokeByteOff p 24 memoryExceptionInformationTheReference

{-# NOINLINE memoryExceptionInformationStructType #-}
memoryExceptionInformationStructType :: Ptr CType
memoryExceptionInformationStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer, ffi_type_pointer, ffi_type_sint, ffi_type_ulong]

argMemoryExceptionInformation :: MemoryExceptionInformation -> Arg
argMemoryExceptionInformation = mkStorableArg memoryExceptionInformationStructType

retMemoryExceptionInformation :: RetType MemoryExceptionInformation
retMemoryExceptionInformation = mkStorableRetType memoryExceptionInformationStructType

instance ObjCArgument MemoryExceptionInformation where
  withObjCArg x k = k (argMemoryExceptionInformation x)

instance ObjCReturn MemoryExceptionInformation where
  type RawReturn MemoryExceptionInformation = MemoryExceptionInformation
  objcRetType = retMemoryExceptionInformation
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data MixedModeStateRecord = MixedModeStateRecord
  { mixedModeStateRecordState1 :: !CUInt
  , mixedModeStateRecordState2 :: !CUInt
  , mixedModeStateRecordState3 :: !CUInt
  , mixedModeStateRecordState4 :: !CUInt
  } deriving (Eq, Show)

instance Storable MixedModeStateRecord where
  sizeOf    _ = 16
  alignment _ = 4
  peek p = MixedModeStateRecord <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
  poke p (MixedModeStateRecord {..}) = do
    pokeByteOff p 0 mixedModeStateRecordState1
    pokeByteOff p 4 mixedModeStateRecordState2
    pokeByteOff p 8 mixedModeStateRecordState3
    pokeByteOff p 12 mixedModeStateRecordState4

{-# NOINLINE mixedModeStateRecordStructType #-}
mixedModeStateRecordStructType :: Ptr CType
mixedModeStateRecordStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint]

argMixedModeStateRecord :: MixedModeStateRecord -> Arg
argMixedModeStateRecord = mkStorableArg mixedModeStateRecordStructType

retMixedModeStateRecord :: RetType MixedModeStateRecord
retMixedModeStateRecord = mkStorableRetType mixedModeStateRecordStructType

instance ObjCArgument MixedModeStateRecord where
  withObjCArg x k = k (argMixedModeStateRecord x)

instance ObjCReturn MixedModeStateRecord where
  type RawReturn MixedModeStateRecord = MixedModeStateRecord
  objcRetType = retMixedModeStateRecord
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data NItl4Rec = NItl4Rec
  { nItl4RecFlags :: !CShort
  , nItl4RecResourceType :: !CInt
  , nItl4RecResourceNum :: !CShort
  , nItl4RecVersion :: !CShort
  , nItl4RecFormat :: !CShort
  , nItl4RecResHeader :: !CShort
  , nItl4RecResHeader2 :: !CInt
  , nItl4RecNumTables :: !CShort
  , nItl4RecMapOffset :: !CInt
  , nItl4RecStrOffset :: !CInt
  , nItl4RecFetchOffset :: !CInt
  , nItl4RecUnTokenOffset :: !CInt
  , nItl4RecDefPartsOffset :: !CInt
  , nItl4RecWhtSpListOffset :: !CInt
  , nItl4RecResOffset7 :: !CInt
  , nItl4RecResOffset8 :: !CInt
  , nItl4RecResLength1 :: !CShort
  , nItl4RecResLength2 :: !CShort
  , nItl4RecResLength3 :: !CShort
  , nItl4RecUnTokenLength :: !CShort
  , nItl4RecDefPartsLength :: !CShort
  , nItl4RecWhtSpListLength :: !CShort
  , nItl4RecResLength7 :: !CShort
  , nItl4RecResLength8 :: !CShort
  } deriving (Eq, Show)

instance Storable NItl4Rec where
  sizeOf    _ = 72
  alignment _ = 4
  peek p = NItl4Rec <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 10
    <*> peekByteOff p 12
    <*> peekByteOff p 14
    <*> peekByteOff p 16
    <*> peekByteOff p 20
    <*> peekByteOff p 24
    <*> peekByteOff p 28
    <*> peekByteOff p 32
    <*> peekByteOff p 36
    <*> peekByteOff p 40
    <*> peekByteOff p 44
    <*> peekByteOff p 48
    <*> peekByteOff p 52
    <*> peekByteOff p 56
    <*> peekByteOff p 58
    <*> peekByteOff p 60
    <*> peekByteOff p 62
    <*> peekByteOff p 64
    <*> peekByteOff p 66
    <*> peekByteOff p 68
    <*> peekByteOff p 70
  poke p (NItl4Rec {..}) = do
    pokeByteOff p 0 nItl4RecFlags
    pokeByteOff p 4 nItl4RecResourceType
    pokeByteOff p 8 nItl4RecResourceNum
    pokeByteOff p 10 nItl4RecVersion
    pokeByteOff p 12 nItl4RecFormat
    pokeByteOff p 14 nItl4RecResHeader
    pokeByteOff p 16 nItl4RecResHeader2
    pokeByteOff p 20 nItl4RecNumTables
    pokeByteOff p 24 nItl4RecMapOffset
    pokeByteOff p 28 nItl4RecStrOffset
    pokeByteOff p 32 nItl4RecFetchOffset
    pokeByteOff p 36 nItl4RecUnTokenOffset
    pokeByteOff p 40 nItl4RecDefPartsOffset
    pokeByteOff p 44 nItl4RecWhtSpListOffset
    pokeByteOff p 48 nItl4RecResOffset7
    pokeByteOff p 52 nItl4RecResOffset8
    pokeByteOff p 56 nItl4RecResLength1
    pokeByteOff p 58 nItl4RecResLength2
    pokeByteOff p 60 nItl4RecResLength3
    pokeByteOff p 62 nItl4RecUnTokenLength
    pokeByteOff p 64 nItl4RecDefPartsLength
    pokeByteOff p 66 nItl4RecWhtSpListLength
    pokeByteOff p 68 nItl4RecResLength7
    pokeByteOff p 70 nItl4RecResLength8

{-# NOINLINE nItl4RecStructType #-}
nItl4RecStructType :: Ptr CType
nItl4RecStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16, ffi_type_sint, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16, ffi_type_sint, ffi_type_sint16, ffi_type_sint, ffi_type_sint, ffi_type_sint, ffi_type_sint, ffi_type_sint, ffi_type_sint, ffi_type_sint, ffi_type_sint, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16]

argNItl4Rec :: NItl4Rec -> Arg
argNItl4Rec = mkStorableArg nItl4RecStructType

retNItl4Rec :: RetType NItl4Rec
retNItl4Rec = mkStorableRetType nItl4RecStructType

instance ObjCArgument NItl4Rec where
  withObjCArg x k = k (argNItl4Rec x)

instance ObjCReturn NItl4Rec where
  type RawReturn NItl4Rec = NItl4Rec
  objcRetType = retNItl4Rec
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data Nanoseconds = Nanoseconds
  { nanosecondsLo :: !CUInt
  , nanosecondsHi :: !CUInt
  } deriving (Eq, Show)

instance Storable Nanoseconds where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = Nanoseconds <$> peekByteOff p 0
    <*> peekByteOff p 4
  poke p (Nanoseconds {..}) = do
    pokeByteOff p 0 nanosecondsLo
    pokeByteOff p 4 nanosecondsHi

{-# NOINLINE nanosecondsStructType #-}
nanosecondsStructType :: Ptr CType
nanosecondsStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint]

argNanoseconds :: Nanoseconds -> Arg
argNanoseconds = mkStorableArg nanosecondsStructType

retNanoseconds :: RetType Nanoseconds
retNanoseconds = mkStorableRetType nanosecondsStructType

instance ObjCArgument Nanoseconds where
  withObjCArg x k = k (argNanoseconds x)

instance ObjCReturn Nanoseconds where
  type RawReturn Nanoseconds = Nanoseconds
  objcRetType = retNanoseconds
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data OffPair = OffPair
  { offPairOffFirst :: !CShort
  , offPairOffSecond :: !CShort
  } deriving (Eq, Show)

instance Storable OffPair where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = OffPair <$> peekByteOff p 0
    <*> peekByteOff p 2
  poke p (OffPair {..}) = do
    pokeByteOff p 0 offPairOffFirst
    pokeByteOff p 2 offPairOffSecond

{-# NOINLINE offPairStructType #-}
offPairStructType :: Ptr CType
offPairStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16, ffi_type_sint16]

argOffPair :: OffPair -> Arg
argOffPair = mkStorableArg offPairStructType

retOffPair :: RetType OffPair
retOffPair = mkStorableRetType offPairStructType

instance ObjCArgument OffPair where
  withObjCArg x k = k (argOffPair x)

instance ObjCReturn OffPair where
  type RawReturn OffPair = OffPair
  objcRetType = retOffPair
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data PEFContainerHeader = PEFContainerHeader
  { pefContainerHeaderTag1 :: !CUInt
  , pefContainerHeaderTag2 :: !CUInt
  , pefContainerHeaderArchitecture :: !CUInt
  , pefContainerHeaderFormatVersion :: !CUInt
  , pefContainerHeaderDateTimeStamp :: !CUInt
  , pefContainerHeaderOldDefVersion :: !CUInt
  , pefContainerHeaderOldImpVersion :: !CUInt
  , pefContainerHeaderCurrentVersion :: !CUInt
  , pefContainerHeaderSectionCount :: !CUShort
  , pefContainerHeaderInstSectionCount :: !CUShort
  , pefContainerHeaderReservedA :: !CUInt
  } deriving (Eq, Show)

instance Storable PEFContainerHeader where
  sizeOf    _ = 40
  alignment _ = 4
  peek p = PEFContainerHeader <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
    <*> peekByteOff p 16
    <*> peekByteOff p 20
    <*> peekByteOff p 24
    <*> peekByteOff p 28
    <*> peekByteOff p 32
    <*> peekByteOff p 34
    <*> peekByteOff p 36
  poke p (PEFContainerHeader {..}) = do
    pokeByteOff p 0 pefContainerHeaderTag1
    pokeByteOff p 4 pefContainerHeaderTag2
    pokeByteOff p 8 pefContainerHeaderArchitecture
    pokeByteOff p 12 pefContainerHeaderFormatVersion
    pokeByteOff p 16 pefContainerHeaderDateTimeStamp
    pokeByteOff p 20 pefContainerHeaderOldDefVersion
    pokeByteOff p 24 pefContainerHeaderOldImpVersion
    pokeByteOff p 28 pefContainerHeaderCurrentVersion
    pokeByteOff p 32 pefContainerHeaderSectionCount
    pokeByteOff p 34 pefContainerHeaderInstSectionCount
    pokeByteOff p 36 pefContainerHeaderReservedA

{-# NOINLINE pefContainerHeaderStructType #-}
pefContainerHeaderStructType :: Ptr CType
pefContainerHeaderStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint16, ffi_type_uint16, ffi_type_uint]

argPEFContainerHeader :: PEFContainerHeader -> Arg
argPEFContainerHeader = mkStorableArg pefContainerHeaderStructType

retPEFContainerHeader :: RetType PEFContainerHeader
retPEFContainerHeader = mkStorableRetType pefContainerHeaderStructType

instance ObjCArgument PEFContainerHeader where
  withObjCArg x k = k (argPEFContainerHeader x)

instance ObjCReturn PEFContainerHeader where
  type RawReturn PEFContainerHeader = PEFContainerHeader
  objcRetType = retPEFContainerHeader
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data PEFExportedSymbol = PEFExportedSymbol
  { pefExportedSymbolClassAndName :: !CUInt
  , pefExportedSymbolSymbolValue :: !CUInt
  , pefExportedSymbolSectionIndex :: !CShort
  } deriving (Eq, Show)

instance Storable PEFExportedSymbol where
  sizeOf    _ = 12
  alignment _ = 4
  peek p = PEFExportedSymbol <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (PEFExportedSymbol {..}) = do
    pokeByteOff p 0 pefExportedSymbolClassAndName
    pokeByteOff p 4 pefExportedSymbolSymbolValue
    pokeByteOff p 8 pefExportedSymbolSectionIndex

{-# NOINLINE pefExportedSymbolStructType #-}
pefExportedSymbolStructType :: Ptr CType
pefExportedSymbolStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_sint16]

argPEFExportedSymbol :: PEFExportedSymbol -> Arg
argPEFExportedSymbol = mkStorableArg pefExportedSymbolStructType

retPEFExportedSymbol :: RetType PEFExportedSymbol
retPEFExportedSymbol = mkStorableRetType pefExportedSymbolStructType

instance ObjCArgument PEFExportedSymbol where
  withObjCArg x k = k (argPEFExportedSymbol x)

instance ObjCReturn PEFExportedSymbol where
  type RawReturn PEFExportedSymbol = PEFExportedSymbol
  objcRetType = retPEFExportedSymbol
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data PEFExportedSymbolHashSlot = PEFExportedSymbolHashSlot
  { pefExportedSymbolHashSlotCountAndStart :: !CUInt
  } deriving (Eq, Show)

instance Storable PEFExportedSymbolHashSlot where
  sizeOf    _ = 4
  alignment _ = 4
  peek p = PEFExportedSymbolHashSlot <$> peekByteOff p 0
  poke p (PEFExportedSymbolHashSlot {..}) =
    pokeByteOff p 0 pefExportedSymbolHashSlotCountAndStart

{-# NOINLINE pefExportedSymbolHashSlotStructType #-}
pefExportedSymbolHashSlotStructType :: Ptr CType
pefExportedSymbolHashSlotStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint]

argPEFExportedSymbolHashSlot :: PEFExportedSymbolHashSlot -> Arg
argPEFExportedSymbolHashSlot = mkStorableArg pefExportedSymbolHashSlotStructType

retPEFExportedSymbolHashSlot :: RetType PEFExportedSymbolHashSlot
retPEFExportedSymbolHashSlot = mkStorableRetType pefExportedSymbolHashSlotStructType

instance ObjCArgument PEFExportedSymbolHashSlot where
  withObjCArg x k = k (argPEFExportedSymbolHashSlot x)

instance ObjCReturn PEFExportedSymbolHashSlot where
  type RawReturn PEFExportedSymbolHashSlot = PEFExportedSymbolHashSlot
  objcRetType = retPEFExportedSymbolHashSlot
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data PEFImportedLibrary = PEFImportedLibrary
  { pefImportedLibraryNameOffset :: !CUInt
  , pefImportedLibraryOldImpVersion :: !CUInt
  , pefImportedLibraryCurrentVersion :: !CUInt
  , pefImportedLibraryImportedSymbolCount :: !CUInt
  , pefImportedLibraryFirstImportedSymbol :: !CUInt
  , pefImportedLibraryOptions :: !CUChar
  , pefImportedLibraryReservedA :: !CUChar
  , pefImportedLibraryReservedB :: !CUShort
  } deriving (Eq, Show)

instance Storable PEFImportedLibrary where
  sizeOf    _ = 24
  alignment _ = 4
  peek p = PEFImportedLibrary <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
    <*> peekByteOff p 16
    <*> peekByteOff p 20
    <*> peekByteOff p 21
    <*> peekByteOff p 22
  poke p (PEFImportedLibrary {..}) = do
    pokeByteOff p 0 pefImportedLibraryNameOffset
    pokeByteOff p 4 pefImportedLibraryOldImpVersion
    pokeByteOff p 8 pefImportedLibraryCurrentVersion
    pokeByteOff p 12 pefImportedLibraryImportedSymbolCount
    pokeByteOff p 16 pefImportedLibraryFirstImportedSymbol
    pokeByteOff p 20 pefImportedLibraryOptions
    pokeByteOff p 21 pefImportedLibraryReservedA
    pokeByteOff p 22 pefImportedLibraryReservedB

{-# NOINLINE pefImportedLibraryStructType #-}
pefImportedLibraryStructType :: Ptr CType
pefImportedLibraryStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint8, ffi_type_uint8, ffi_type_uint16]

argPEFImportedLibrary :: PEFImportedLibrary -> Arg
argPEFImportedLibrary = mkStorableArg pefImportedLibraryStructType

retPEFImportedLibrary :: RetType PEFImportedLibrary
retPEFImportedLibrary = mkStorableRetType pefImportedLibraryStructType

instance ObjCArgument PEFImportedLibrary where
  withObjCArg x k = k (argPEFImportedLibrary x)

instance ObjCReturn PEFImportedLibrary where
  type RawReturn PEFImportedLibrary = PEFImportedLibrary
  objcRetType = retPEFImportedLibrary
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data PEFImportedSymbol = PEFImportedSymbol
  { pefImportedSymbolClassAndName :: !CUInt
  } deriving (Eq, Show)

instance Storable PEFImportedSymbol where
  sizeOf    _ = 4
  alignment _ = 4
  peek p = PEFImportedSymbol <$> peekByteOff p 0
  poke p (PEFImportedSymbol {..}) =
    pokeByteOff p 0 pefImportedSymbolClassAndName

{-# NOINLINE pefImportedSymbolStructType #-}
pefImportedSymbolStructType :: Ptr CType
pefImportedSymbolStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint]

argPEFImportedSymbol :: PEFImportedSymbol -> Arg
argPEFImportedSymbol = mkStorableArg pefImportedSymbolStructType

retPEFImportedSymbol :: RetType PEFImportedSymbol
retPEFImportedSymbol = mkStorableRetType pefImportedSymbolStructType

instance ObjCArgument PEFImportedSymbol where
  withObjCArg x k = k (argPEFImportedSymbol x)

instance ObjCReturn PEFImportedSymbol where
  type RawReturn PEFImportedSymbol = PEFImportedSymbol
  objcRetType = retPEFImportedSymbol
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data PEFLoaderInfoHeader = PEFLoaderInfoHeader
  { pefLoaderInfoHeaderMainSection :: !CInt
  , pefLoaderInfoHeaderMainOffset :: !CUInt
  , pefLoaderInfoHeaderInitSection :: !CInt
  , pefLoaderInfoHeaderInitOffset :: !CUInt
  , pefLoaderInfoHeaderTermSection :: !CInt
  , pefLoaderInfoHeaderTermOffset :: !CUInt
  , pefLoaderInfoHeaderImportedLibraryCount :: !CUInt
  , pefLoaderInfoHeaderTotalImportedSymbolCount :: !CUInt
  , pefLoaderInfoHeaderRelocSectionCount :: !CUInt
  , pefLoaderInfoHeaderRelocInstrOffset :: !CUInt
  , pefLoaderInfoHeaderLoaderStringsOffset :: !CUInt
  , pefLoaderInfoHeaderExportHashOffset :: !CUInt
  , pefLoaderInfoHeaderExportHashTablePower :: !CUInt
  , pefLoaderInfoHeaderExportedSymbolCount :: !CUInt
  } deriving (Eq, Show)

instance Storable PEFLoaderInfoHeader where
  sizeOf    _ = 56
  alignment _ = 4
  peek p = PEFLoaderInfoHeader <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
    <*> peekByteOff p 16
    <*> peekByteOff p 20
    <*> peekByteOff p 24
    <*> peekByteOff p 28
    <*> peekByteOff p 32
    <*> peekByteOff p 36
    <*> peekByteOff p 40
    <*> peekByteOff p 44
    <*> peekByteOff p 48
    <*> peekByteOff p 52
  poke p (PEFLoaderInfoHeader {..}) = do
    pokeByteOff p 0 pefLoaderInfoHeaderMainSection
    pokeByteOff p 4 pefLoaderInfoHeaderMainOffset
    pokeByteOff p 8 pefLoaderInfoHeaderInitSection
    pokeByteOff p 12 pefLoaderInfoHeaderInitOffset
    pokeByteOff p 16 pefLoaderInfoHeaderTermSection
    pokeByteOff p 20 pefLoaderInfoHeaderTermOffset
    pokeByteOff p 24 pefLoaderInfoHeaderImportedLibraryCount
    pokeByteOff p 28 pefLoaderInfoHeaderTotalImportedSymbolCount
    pokeByteOff p 32 pefLoaderInfoHeaderRelocSectionCount
    pokeByteOff p 36 pefLoaderInfoHeaderRelocInstrOffset
    pokeByteOff p 40 pefLoaderInfoHeaderLoaderStringsOffset
    pokeByteOff p 44 pefLoaderInfoHeaderExportHashOffset
    pokeByteOff p 48 pefLoaderInfoHeaderExportHashTablePower
    pokeByteOff p 52 pefLoaderInfoHeaderExportedSymbolCount

{-# NOINLINE pefLoaderInfoHeaderStructType #-}
pefLoaderInfoHeaderStructType :: Ptr CType
pefLoaderInfoHeaderStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_uint, ffi_type_sint, ffi_type_uint, ffi_type_sint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint]

argPEFLoaderInfoHeader :: PEFLoaderInfoHeader -> Arg
argPEFLoaderInfoHeader = mkStorableArg pefLoaderInfoHeaderStructType

retPEFLoaderInfoHeader :: RetType PEFLoaderInfoHeader
retPEFLoaderInfoHeader = mkStorableRetType pefLoaderInfoHeaderStructType

instance ObjCArgument PEFLoaderInfoHeader where
  withObjCArg x k = k (argPEFLoaderInfoHeader x)

instance ObjCReturn PEFLoaderInfoHeader where
  type RawReturn PEFLoaderInfoHeader = PEFLoaderInfoHeader
  objcRetType = retPEFLoaderInfoHeader
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data PEFLoaderRelocationHeader = PEFLoaderRelocationHeader
  { pefLoaderRelocationHeaderSectionIndex :: !CUShort
  , pefLoaderRelocationHeaderReservedA :: !CUShort
  , pefLoaderRelocationHeaderRelocCount :: !CUInt
  , pefLoaderRelocationHeaderFirstRelocOffset :: !CUInt
  } deriving (Eq, Show)

instance Storable PEFLoaderRelocationHeader where
  sizeOf    _ = 12
  alignment _ = 4
  peek p = PEFLoaderRelocationHeader <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (PEFLoaderRelocationHeader {..}) = do
    pokeByteOff p 0 pefLoaderRelocationHeaderSectionIndex
    pokeByteOff p 2 pefLoaderRelocationHeaderReservedA
    pokeByteOff p 4 pefLoaderRelocationHeaderRelocCount
    pokeByteOff p 8 pefLoaderRelocationHeaderFirstRelocOffset

{-# NOINLINE pefLoaderRelocationHeaderStructType #-}
pefLoaderRelocationHeaderStructType :: Ptr CType
pefLoaderRelocationHeaderStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint, ffi_type_uint]

argPEFLoaderRelocationHeader :: PEFLoaderRelocationHeader -> Arg
argPEFLoaderRelocationHeader = mkStorableArg pefLoaderRelocationHeaderStructType

retPEFLoaderRelocationHeader :: RetType PEFLoaderRelocationHeader
retPEFLoaderRelocationHeader = mkStorableRetType pefLoaderRelocationHeaderStructType

instance ObjCArgument PEFLoaderRelocationHeader where
  withObjCArg x k = k (argPEFLoaderRelocationHeader x)

instance ObjCReturn PEFLoaderRelocationHeader where
  type RawReturn PEFLoaderRelocationHeader = PEFLoaderRelocationHeader
  objcRetType = retPEFLoaderRelocationHeader
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data PEFSectionHeader = PEFSectionHeader
  { pefSectionHeaderNameOffset :: !CInt
  , pefSectionHeaderDefaultAddress :: !CUInt
  , pefSectionHeaderTotalLength :: !CUInt
  , pefSectionHeaderUnpackedLength :: !CUInt
  , pefSectionHeaderContainerLength :: !CUInt
  , pefSectionHeaderContainerOffset :: !CUInt
  , pefSectionHeaderSectionKind :: !CUChar
  , pefSectionHeaderShareKind :: !CUChar
  , pefSectionHeaderAlignment :: !CUChar
  , pefSectionHeaderReservedA :: !CUChar
  } deriving (Eq, Show)

instance Storable PEFSectionHeader where
  sizeOf    _ = 28
  alignment _ = 4
  peek p = PEFSectionHeader <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
    <*> peekByteOff p 16
    <*> peekByteOff p 20
    <*> peekByteOff p 24
    <*> peekByteOff p 25
    <*> peekByteOff p 26
    <*> peekByteOff p 27
  poke p (PEFSectionHeader {..}) = do
    pokeByteOff p 0 pefSectionHeaderNameOffset
    pokeByteOff p 4 pefSectionHeaderDefaultAddress
    pokeByteOff p 8 pefSectionHeaderTotalLength
    pokeByteOff p 12 pefSectionHeaderUnpackedLength
    pokeByteOff p 16 pefSectionHeaderContainerLength
    pokeByteOff p 20 pefSectionHeaderContainerOffset
    pokeByteOff p 24 pefSectionHeaderSectionKind
    pokeByteOff p 25 pefSectionHeaderShareKind
    pokeByteOff p 26 pefSectionHeaderAlignment
    pokeByteOff p 27 pefSectionHeaderReservedA

{-# NOINLINE pefSectionHeaderStructType #-}
pefSectionHeaderStructType :: Ptr CType
pefSectionHeaderStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8]

argPEFSectionHeader :: PEFSectionHeader -> Arg
argPEFSectionHeader = mkStorableArg pefSectionHeaderStructType

retPEFSectionHeader :: RetType PEFSectionHeader
retPEFSectionHeader = mkStorableRetType pefSectionHeaderStructType

instance ObjCArgument PEFSectionHeader where
  withObjCArg x k = k (argPEFSectionHeader x)

instance ObjCReturn PEFSectionHeader where
  type RawReturn PEFSectionHeader = PEFSectionHeader
  objcRetType = retPEFSectionHeader
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data PEFSplitHashWord = PEFSplitHashWord
  { pefSplitHashWordNameLength :: !CUShort
  , pefSplitHashWordHashValue :: !CUShort
  } deriving (Eq, Show)

instance Storable PEFSplitHashWord where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = PEFSplitHashWord <$> peekByteOff p 0
    <*> peekByteOff p 2
  poke p (PEFSplitHashWord {..}) = do
    pokeByteOff p 0 pefSplitHashWordNameLength
    pokeByteOff p 2 pefSplitHashWordHashValue

{-# NOINLINE pefSplitHashWordStructType #-}
pefSplitHashWordStructType :: Ptr CType
pefSplitHashWordStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16]

argPEFSplitHashWord :: PEFSplitHashWord -> Arg
argPEFSplitHashWord = mkStorableArg pefSplitHashWordStructType

retPEFSplitHashWord :: RetType PEFSplitHashWord
retPEFSplitHashWord = mkStorableRetType pefSplitHashWordStructType

instance ObjCArgument PEFSplitHashWord where
  withObjCArg x k = k (argPEFSplitHashWord x)

instance ObjCReturn PEFSplitHashWord where
  type RawReturn PEFSplitHashWord = PEFSplitHashWord
  objcRetType = retPEFSplitHashWord
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data ResourceSpec = ResourceSpec
  { resourceSpecResType :: !CUInt
  , resourceSpecResID :: !CShort
  } deriving (Eq, Show)

instance Storable ResourceSpec where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = ResourceSpec <$> peekByteOff p 0
    <*> peekByteOff p 4
  poke p (ResourceSpec {..}) = do
    pokeByteOff p 0 resourceSpecResType
    pokeByteOff p 4 resourceSpecResID

{-# NOINLINE resourceSpecStructType #-}
resourceSpecStructType :: Ptr CType
resourceSpecStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_sint16]

argResourceSpec :: ResourceSpec -> Arg
argResourceSpec = mkStorableArg resourceSpecStructType

retResourceSpec :: RetType ResourceSpec
retResourceSpec = mkStorableRetType resourceSpecStructType

instance ObjCArgument ResourceSpec where
  withObjCArg x k = k (argResourceSpec x)

instance ObjCReturn ResourceSpec where
  type RawReturn ResourceSpec = ResourceSpec
  objcRetType = retResourceSpec
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data RoutineRecord = RoutineRecord
  { routineRecordProcInfo :: !CULong
  , routineRecordReserved1 :: !CSChar
  , routineRecordISA :: !CSChar
  , routineRecordRoutineFlags :: !CUShort
  , routineRecordProcDescriptor :: !(Ptr ())
  , routineRecordReserved2 :: !CUInt
  , routineRecordSelector :: !CUInt
  } deriving (Eq, Show)

instance Storable RoutineRecord where
  sizeOf    _ = 32
  alignment _ = 8
  peek p = RoutineRecord <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 9
    <*> peekByteOff p 10
    <*> peekByteOff p 16
    <*> peekByteOff p 24
    <*> peekByteOff p 28
  poke p (RoutineRecord {..}) = do
    pokeByteOff p 0 routineRecordProcInfo
    pokeByteOff p 8 routineRecordReserved1
    pokeByteOff p 9 routineRecordISA
    pokeByteOff p 10 routineRecordRoutineFlags
    pokeByteOff p 16 routineRecordProcDescriptor
    pokeByteOff p 24 routineRecordReserved2
    pokeByteOff p 28 routineRecordSelector

{-# NOINLINE routineRecordStructType #-}
routineRecordStructType :: Ptr CType
routineRecordStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_ulong, ffi_type_sint8, ffi_type_sint8, ffi_type_uint16, ffi_type_pointer, ffi_type_uint, ffi_type_uint]

argRoutineRecord :: RoutineRecord -> Arg
argRoutineRecord = mkStorableArg routineRecordStructType

retRoutineRecord :: RetType RoutineRecord
retRoutineRecord = mkStorableRetType routineRecordStructType

instance ObjCArgument RoutineRecord where
  withObjCArg x k = k (argRoutineRecord x)

instance ObjCReturn RoutineRecord where
  type RawReturn RoutineRecord = RoutineRecord
  objcRetType = retRoutineRecord
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data RoutingResourceEntry = RoutingResourceEntry
  { routingResourceEntryCreator :: !CUInt
  , routingResourceEntryFileType :: !CUInt
  , routingResourceEntryTargetFolder :: !CUInt
  , routingResourceEntryDestinationFolder :: !CUInt
  , routingResourceEntryReservedField :: !CUInt
  } deriving (Eq, Show)

instance Storable RoutingResourceEntry where
  sizeOf    _ = 20
  alignment _ = 4
  peek p = RoutingResourceEntry <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
    <*> peekByteOff p 16
  poke p (RoutingResourceEntry {..}) = do
    pokeByteOff p 0 routingResourceEntryCreator
    pokeByteOff p 4 routingResourceEntryFileType
    pokeByteOff p 8 routingResourceEntryTargetFolder
    pokeByteOff p 12 routingResourceEntryDestinationFolder
    pokeByteOff p 16 routingResourceEntryReservedField

{-# NOINLINE routingResourceEntryStructType #-}
routingResourceEntryStructType :: Ptr CType
routingResourceEntryStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint]

argRoutingResourceEntry :: RoutingResourceEntry -> Arg
argRoutingResourceEntry = mkStorableArg routingResourceEntryStructType

retRoutingResourceEntry :: RetType RoutingResourceEntry
retRoutingResourceEntry = mkStorableRetType routingResourceEntryStructType

instance ObjCArgument RoutingResourceEntry where
  withObjCArg x k = k (argRoutingResourceEntry x)

instance ObjCReturn RoutingResourceEntry where
  type RawReturn RoutingResourceEntry = RoutingResourceEntry
  objcRetType = retRoutingResourceEntry
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data RuleBasedTrslRecord = RuleBasedTrslRecord
  { ruleBasedTrslRecordSourceType :: !CShort
  , ruleBasedTrslRecordTargetType :: !CShort
  , ruleBasedTrslRecordFormatNumber :: !CShort
  , ruleBasedTrslRecordPropertyFlag :: !CShort
  , ruleBasedTrslRecordNumberOfRules :: !CShort
  } deriving (Eq, Show)

instance Storable RuleBasedTrslRecord where
  sizeOf    _ = 10
  alignment _ = 2
  peek p = RuleBasedTrslRecord <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 6
    <*> peekByteOff p 8
  poke p (RuleBasedTrslRecord {..}) = do
    pokeByteOff p 0 ruleBasedTrslRecordSourceType
    pokeByteOff p 2 ruleBasedTrslRecordTargetType
    pokeByteOff p 4 ruleBasedTrslRecordFormatNumber
    pokeByteOff p 6 ruleBasedTrslRecordPropertyFlag
    pokeByteOff p 8 ruleBasedTrslRecordNumberOfRules

{-# NOINLINE ruleBasedTrslRecordStructType #-}
ruleBasedTrslRecordStructType :: Ptr CType
ruleBasedTrslRecordStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16]

argRuleBasedTrslRecord :: RuleBasedTrslRecord -> Arg
argRuleBasedTrslRecord = mkStorableArg ruleBasedTrslRecordStructType

retRuleBasedTrslRecord :: RetType RuleBasedTrslRecord
retRuleBasedTrslRecord = mkStorableRetType ruleBasedTrslRecordStructType

instance ObjCArgument RuleBasedTrslRecord where
  withObjCArg x k = k (argRuleBasedTrslRecord x)

instance ObjCReturn RuleBasedTrslRecord where
  type RawReturn RuleBasedTrslRecord = RuleBasedTrslRecord
  objcRetType = retRuleBasedTrslRecord
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data SchedulerInfoRec = SchedulerInfoRec
  { schedulerInfoRecInfoRecSize :: !CUInt
  , schedulerInfoRecCurrentThreadID :: !CULong
  , schedulerInfoRecSuggestedThreadID :: !CULong
  , schedulerInfoRecInterruptedCoopThreadID :: !CULong
  } deriving (Eq, Show)

instance Storable SchedulerInfoRec where
  sizeOf    _ = 32
  alignment _ = 8
  peek p = SchedulerInfoRec <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 24
  poke p (SchedulerInfoRec {..}) = do
    pokeByteOff p 0 schedulerInfoRecInfoRecSize
    pokeByteOff p 8 schedulerInfoRecCurrentThreadID
    pokeByteOff p 16 schedulerInfoRecSuggestedThreadID
    pokeByteOff p 24 schedulerInfoRecInterruptedCoopThreadID

{-# NOINLINE schedulerInfoRecStructType #-}
schedulerInfoRecStructType :: Ptr CType
schedulerInfoRecStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_ulong, ffi_type_ulong, ffi_type_ulong]

argSchedulerInfoRec :: SchedulerInfoRec -> Arg
argSchedulerInfoRec = mkStorableArg schedulerInfoRecStructType

retSchedulerInfoRec :: RetType SchedulerInfoRec
retSchedulerInfoRec = mkStorableRetType schedulerInfoRecStructType

instance ObjCArgument SchedulerInfoRec where
  withObjCArg x k = k (argSchedulerInfoRec x)

instance ObjCReturn SchedulerInfoRec where
  type RawReturn SchedulerInfoRec = SchedulerInfoRec
  objcRetType = retSchedulerInfoRec
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data ScriptCodeRun = ScriptCodeRun
  { scriptCodeRunOffset :: !CULong
  , scriptCodeRunScript :: !CShort
  } deriving (Eq, Show)

instance Storable ScriptCodeRun where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = ScriptCodeRun <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (ScriptCodeRun {..}) = do
    pokeByteOff p 0 scriptCodeRunOffset
    pokeByteOff p 8 scriptCodeRunScript

{-# NOINLINE scriptCodeRunStructType #-}
scriptCodeRunStructType :: Ptr CType
scriptCodeRunStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_ulong, ffi_type_sint16]

argScriptCodeRun :: ScriptCodeRun -> Arg
argScriptCodeRun = mkStorableArg scriptCodeRunStructType

retScriptCodeRun :: RetType ScriptCodeRun
retScriptCodeRun = mkStorableRetType scriptCodeRunStructType

instance ObjCArgument ScriptCodeRun where
  withObjCArg x k = k (argScriptCodeRun x)

instance ObjCReturn ScriptCodeRun where
  type RawReturn ScriptCodeRun = ScriptCodeRun
  objcRetType = retScriptCodeRun
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data SleepQRec = SleepQRec
  { sleepQRecSleepQLink :: !(Ptr ())
  , sleepQRecSleepQType :: !CShort
  , sleepQRecSleepQProc :: !(Ptr ())
  , sleepQRecSleepQFlags :: !CShort
  } deriving (Eq, Show)

instance Storable SleepQRec where
  sizeOf    _ = 32
  alignment _ = 8
  peek p = SleepQRec <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 24
  poke p (SleepQRec {..}) = do
    pokeByteOff p 0 sleepQRecSleepQLink
    pokeByteOff p 8 sleepQRecSleepQType
    pokeByteOff p 16 sleepQRecSleepQProc
    pokeByteOff p 24 sleepQRecSleepQFlags

{-# NOINLINE sleepQRecStructType #-}
sleepQRecStructType :: Ptr CType
sleepQRecStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer, ffi_type_sint16, ffi_type_pointer, ffi_type_sint16]

argSleepQRec :: SleepQRec -> Arg
argSleepQRec = mkStorableArg sleepQRecStructType

retSleepQRec :: RetType SleepQRec
retSleepQRec = mkStorableRetType sleepQRecStructType

instance ObjCArgument SleepQRec where
  withObjCArg x k = k (argSleepQRec x)

instance ObjCReturn SleepQRec where
  type RawReturn SleepQRec = SleepQRec
  objcRetType = retSleepQRec
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data SoundDataChunk = SoundDataChunk
  { soundDataChunkCkID :: !CUInt
  , soundDataChunkCkSize :: !CInt
  , soundDataChunkOffset :: !CUInt
  , soundDataChunkBlockSize :: !CUInt
  } deriving (Eq, Show)

instance Storable SoundDataChunk where
  sizeOf    _ = 16
  alignment _ = 4
  peek p = SoundDataChunk <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
  poke p (SoundDataChunk {..}) = do
    pokeByteOff p 0 soundDataChunkCkID
    pokeByteOff p 4 soundDataChunkCkSize
    pokeByteOff p 8 soundDataChunkOffset
    pokeByteOff p 12 soundDataChunkBlockSize

{-# NOINLINE soundDataChunkStructType #-}
soundDataChunkStructType :: Ptr CType
soundDataChunkStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_sint, ffi_type_uint, ffi_type_uint]

argSoundDataChunk :: SoundDataChunk -> Arg
argSoundDataChunk = mkStorableArg soundDataChunkStructType

retSoundDataChunk :: RetType SoundDataChunk
retSoundDataChunk = mkStorableRetType soundDataChunkStructType

instance ObjCArgument SoundDataChunk where
  withObjCArg x k = k (argSoundDataChunk x)

instance ObjCReturn SoundDataChunk where
  type RawReturn SoundDataChunk = SoundDataChunk
  objcRetType = retSoundDataChunk
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data TECBufferContextRec = TECBufferContextRec
  { tecBufferContextRecTextInputBuffer :: !(Ptr ())
  , tecBufferContextRecTextInputBufferEnd :: !(Ptr ())
  , tecBufferContextRecTextOutputBuffer :: !(Ptr ())
  , tecBufferContextRecTextOutputBufferEnd :: !(Ptr ())
  , tecBufferContextRecEncodingInputBuffer :: !(Ptr ())
  , tecBufferContextRecEncodingInputBufferEnd :: !(Ptr ())
  , tecBufferContextRecEncodingOutputBuffer :: !(Ptr ())
  , tecBufferContextRecEncodingOutputBufferEnd :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable TECBufferContextRec where
  sizeOf    _ = 64
  alignment _ = 8
  peek p = TECBufferContextRec <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 24
    <*> peekByteOff p 32
    <*> peekByteOff p 40
    <*> peekByteOff p 48
    <*> peekByteOff p 56
  poke p (TECBufferContextRec {..}) = do
    pokeByteOff p 0 tecBufferContextRecTextInputBuffer
    pokeByteOff p 8 tecBufferContextRecTextInputBufferEnd
    pokeByteOff p 16 tecBufferContextRecTextOutputBuffer
    pokeByteOff p 24 tecBufferContextRecTextOutputBufferEnd
    pokeByteOff p 32 tecBufferContextRecEncodingInputBuffer
    pokeByteOff p 40 tecBufferContextRecEncodingInputBufferEnd
    pokeByteOff p 48 tecBufferContextRecEncodingOutputBuffer
    pokeByteOff p 56 tecBufferContextRecEncodingOutputBufferEnd

{-# NOINLINE tecBufferContextRecStructType #-}
tecBufferContextRecStructType :: Ptr CType
tecBufferContextRecStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer]

argTECBufferContextRec :: TECBufferContextRec -> Arg
argTECBufferContextRec = mkStorableArg tecBufferContextRecStructType

retTECBufferContextRec :: RetType TECBufferContextRec
retTECBufferContextRec = mkStorableRetType tecBufferContextRecStructType

instance ObjCArgument TECBufferContextRec where
  withObjCArg x k = k (argTECBufferContextRec x)

instance ObjCReturn TECBufferContextRec where
  type RawReturn TECBufferContextRec = TECBufferContextRec
  objcRetType = retTECBufferContextRec
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data TECConversionInfo = TECConversionInfo
  { tecConversionInfoSourceEncoding :: !CUInt
  , tecConversionInfoDestinationEncoding :: !CUInt
  , tecConversionInfoReserved1 :: !CUShort
  , tecConversionInfoReserved2 :: !CUShort
  } deriving (Eq, Show)

instance Storable TECConversionInfo where
  sizeOf    _ = 12
  alignment _ = 4
  peek p = TECConversionInfo <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 10
  poke p (TECConversionInfo {..}) = do
    pokeByteOff p 0 tecConversionInfoSourceEncoding
    pokeByteOff p 4 tecConversionInfoDestinationEncoding
    pokeByteOff p 8 tecConversionInfoReserved1
    pokeByteOff p 10 tecConversionInfoReserved2

{-# NOINLINE tecConversionInfoStructType #-}
tecConversionInfoStructType :: Ptr CType
tecConversionInfoStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_uint16, ffi_type_uint16]

argTECConversionInfo :: TECConversionInfo -> Arg
argTECConversionInfo = mkStorableArg tecConversionInfoStructType

retTECConversionInfo :: RetType TECConversionInfo
retTECConversionInfo = mkStorableRetType tecConversionInfoStructType

instance ObjCArgument TECConversionInfo where
  withObjCArg x k = k (argTECConversionInfo x)

instance ObjCReturn TECConversionInfo where
  type RawReturn TECConversionInfo = TECConversionInfo
  objcRetType = retTECConversionInfo
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data TECInternetNamesRec = TECInternetNamesRec
  { tecInternetNamesRecCount :: !CUInt
  , tecInternetNamesRecInternetNames :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable TECInternetNamesRec where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = TECInternetNamesRec <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (TECInternetNamesRec {..}) = do
    pokeByteOff p 0 tecInternetNamesRecCount
    pokeByteOff p 8 tecInternetNamesRecInternetNames

{-# NOINLINE tecInternetNamesRecStructType #-}
tecInternetNamesRecStructType :: Ptr CType
tecInternetNamesRecStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_pointer]

argTECInternetNamesRec :: TECInternetNamesRec -> Arg
argTECInternetNamesRec = mkStorableArg tecInternetNamesRecStructType

retTECInternetNamesRec :: RetType TECInternetNamesRec
retTECInternetNamesRec = mkStorableRetType tecInternetNamesRecStructType

instance ObjCArgument TECInternetNamesRec where
  withObjCArg x k = k (argTECInternetNamesRec x)

instance ObjCReturn TECInternetNamesRec where
  type RawReturn TECInternetNamesRec = TECInternetNamesRec
  objcRetType = retTECInternetNamesRec
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data TECLocaleListToEncodingListRec = TECLocaleListToEncodingListRec
  { tecLocaleListToEncodingListRecOffset :: !CUInt
  , tecLocaleListToEncodingListRecCount :: !CUInt
  , tecLocaleListToEncodingListRecLocales :: !CShort
  } deriving (Eq, Show)

instance Storable TECLocaleListToEncodingListRec where
  sizeOf    _ = 12
  alignment _ = 4
  peek p = TECLocaleListToEncodingListRec <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (TECLocaleListToEncodingListRec {..}) = do
    pokeByteOff p 0 tecLocaleListToEncodingListRecOffset
    pokeByteOff p 4 tecLocaleListToEncodingListRecCount
    pokeByteOff p 8 tecLocaleListToEncodingListRecLocales

{-# NOINLINE tecLocaleListToEncodingListRecStructType #-}
tecLocaleListToEncodingListRecStructType :: Ptr CType
tecLocaleListToEncodingListRecStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_sint16]

argTECLocaleListToEncodingListRec :: TECLocaleListToEncodingListRec -> Arg
argTECLocaleListToEncodingListRec = mkStorableArg tecLocaleListToEncodingListRecStructType

retTECLocaleListToEncodingListRec :: RetType TECLocaleListToEncodingListRec
retTECLocaleListToEncodingListRec = mkStorableRetType tecLocaleListToEncodingListRecStructType

instance ObjCArgument TECLocaleListToEncodingListRec where
  withObjCArg x k = k (argTECLocaleListToEncodingListRec x)

instance ObjCReturn TECLocaleListToEncodingListRec where
  type RawReturn TECLocaleListToEncodingListRec = TECLocaleListToEncodingListRec
  objcRetType = retTECLocaleListToEncodingListRec
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data TECPluginDispatchTable = TECPluginDispatchTable
  { tecPluginDispatchTableVersion :: !CUInt
  , tecPluginDispatchTableCompatibleVersion :: !CUInt
  , tecPluginDispatchTablePluginID :: !CUInt
  , tecPluginDispatchTablePluginNewEncodingConverter :: !(Ptr ())
  , tecPluginDispatchTablePluginClearContextInfo :: !(Ptr ())
  , tecPluginDispatchTablePluginConvertTextEncoding :: !(Ptr ())
  , tecPluginDispatchTablePluginFlushConversion :: !(Ptr ())
  , tecPluginDispatchTablePluginDisposeEncodingConverter :: !(Ptr ())
  , tecPluginDispatchTablePluginNewEncodingSniffer :: !(Ptr ())
  , tecPluginDispatchTablePluginClearSnifferContextInfo :: !(Ptr ())
  , tecPluginDispatchTablePluginSniffTextEncoding :: !(Ptr ())
  , tecPluginDispatchTablePluginDisposeEncodingSniffer :: !(Ptr ())
  , tecPluginDispatchTablePluginGetCountAvailableTextEncodings :: !(Ptr ())
  , tecPluginDispatchTablePluginGetCountAvailableTextEncodingPairs :: !(Ptr ())
  , tecPluginDispatchTablePluginGetCountDestinationTextEncodings :: !(Ptr ())
  , tecPluginDispatchTablePluginGetCountSubTextEncodings :: !(Ptr ())
  , tecPluginDispatchTablePluginGetCountAvailableSniffers :: !(Ptr ())
  , tecPluginDispatchTablePluginGetCountWebTextEncodings :: !(Ptr ())
  , tecPluginDispatchTablePluginGetCountMailTextEncodings :: !(Ptr ())
  , tecPluginDispatchTablePluginGetTextEncodingInternetName :: !(Ptr ())
  , tecPluginDispatchTablePluginGetTextEncodingFromInternetName :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable TECPluginDispatchTable where
  sizeOf    _ = 160
  alignment _ = 8
  peek p = TECPluginDispatchTable <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 24
    <*> peekByteOff p 32
    <*> peekByteOff p 40
    <*> peekByteOff p 48
    <*> peekByteOff p 56
    <*> peekByteOff p 64
    <*> peekByteOff p 72
    <*> peekByteOff p 80
    <*> peekByteOff p 88
    <*> peekByteOff p 96
    <*> peekByteOff p 104
    <*> peekByteOff p 112
    <*> peekByteOff p 120
    <*> peekByteOff p 128
    <*> peekByteOff p 136
    <*> peekByteOff p 144
    <*> peekByteOff p 152
  poke p (TECPluginDispatchTable {..}) = do
    pokeByteOff p 0 tecPluginDispatchTableVersion
    pokeByteOff p 4 tecPluginDispatchTableCompatibleVersion
    pokeByteOff p 8 tecPluginDispatchTablePluginID
    pokeByteOff p 16 tecPluginDispatchTablePluginNewEncodingConverter
    pokeByteOff p 24 tecPluginDispatchTablePluginClearContextInfo
    pokeByteOff p 32 tecPluginDispatchTablePluginConvertTextEncoding
    pokeByteOff p 40 tecPluginDispatchTablePluginFlushConversion
    pokeByteOff p 48 tecPluginDispatchTablePluginDisposeEncodingConverter
    pokeByteOff p 56 tecPluginDispatchTablePluginNewEncodingSniffer
    pokeByteOff p 64 tecPluginDispatchTablePluginClearSnifferContextInfo
    pokeByteOff p 72 tecPluginDispatchTablePluginSniffTextEncoding
    pokeByteOff p 80 tecPluginDispatchTablePluginDisposeEncodingSniffer
    pokeByteOff p 88 tecPluginDispatchTablePluginGetCountAvailableTextEncodings
    pokeByteOff p 96 tecPluginDispatchTablePluginGetCountAvailableTextEncodingPairs
    pokeByteOff p 104 tecPluginDispatchTablePluginGetCountDestinationTextEncodings
    pokeByteOff p 112 tecPluginDispatchTablePluginGetCountSubTextEncodings
    pokeByteOff p 120 tecPluginDispatchTablePluginGetCountAvailableSniffers
    pokeByteOff p 128 tecPluginDispatchTablePluginGetCountWebTextEncodings
    pokeByteOff p 136 tecPluginDispatchTablePluginGetCountMailTextEncodings
    pokeByteOff p 144 tecPluginDispatchTablePluginGetTextEncodingInternetName
    pokeByteOff p 152 tecPluginDispatchTablePluginGetTextEncodingFromInternetName

{-# NOINLINE tecPluginDispatchTableStructType #-}
tecPluginDispatchTableStructType :: Ptr CType
tecPluginDispatchTableStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer]

argTECPluginDispatchTable :: TECPluginDispatchTable -> Arg
argTECPluginDispatchTable = mkStorableArg tecPluginDispatchTableStructType

retTECPluginDispatchTable :: RetType TECPluginDispatchTable
retTECPluginDispatchTable = mkStorableRetType tecPluginDispatchTableStructType

instance ObjCArgument TECPluginDispatchTable where
  withObjCArg x k = k (argTECPluginDispatchTable x)

instance ObjCReturn TECPluginDispatchTable where
  type RawReturn TECPluginDispatchTable = TECPluginDispatchTable
  objcRetType = retTECPluginDispatchTable
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data TECPluginStateRec = TECPluginStateRec
  { tecPluginStateRecState1 :: !CUChar
  , tecPluginStateRecState2 :: !CUChar
  , tecPluginStateRecState3 :: !CUChar
  , tecPluginStateRecState4 :: !CUChar
  , tecPluginStateRecLongState1 :: !CUInt
  , tecPluginStateRecLongState2 :: !CUInt
  , tecPluginStateRecLongState3 :: !CUInt
  , tecPluginStateRecLongState4 :: !CUInt
  } deriving (Eq, Show)

instance Storable TECPluginStateRec where
  sizeOf    _ = 20
  alignment _ = 4
  peek p = TECPluginStateRec <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
    <*> peekByteOff p 3
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
    <*> peekByteOff p 16
  poke p (TECPluginStateRec {..}) = do
    pokeByteOff p 0 tecPluginStateRecState1
    pokeByteOff p 1 tecPluginStateRecState2
    pokeByteOff p 2 tecPluginStateRecState3
    pokeByteOff p 3 tecPluginStateRecState4
    pokeByteOff p 4 tecPluginStateRecLongState1
    pokeByteOff p 8 tecPluginStateRecLongState2
    pokeByteOff p 12 tecPluginStateRecLongState3
    pokeByteOff p 16 tecPluginStateRecLongState4

{-# NOINLINE tecPluginStateRecStructType #-}
tecPluginStateRecStructType :: Ptr CType
tecPluginStateRecStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint]

argTECPluginStateRec :: TECPluginStateRec -> Arg
argTECPluginStateRec = mkStorableArg tecPluginStateRecStructType

retTECPluginStateRec :: RetType TECPluginStateRec
retTECPluginStateRec = mkStorableRetType tecPluginStateRecStructType

instance ObjCArgument TECPluginStateRec where
  withObjCArg x k = k (argTECPluginStateRec x)

instance ObjCReturn TECPluginStateRec where
  type RawReturn TECPluginStateRec = TECPluginStateRec
  objcRetType = retTECPluginStateRec
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data TMTask = TMTask
  { tmTaskQLink :: !(Ptr ())
  , tmTaskQType :: !CShort
  , tmTaskTmAddr :: !(Ptr ())
  , tmTaskTmCount :: !CLong
  , tmTaskTmWakeUp :: !CLong
  , tmTaskTmReserved :: !CLong
  } deriving (Eq, Show)

instance Storable TMTask where
  sizeOf    _ = 48
  alignment _ = 8
  peek p = TMTask <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 24
    <*> peekByteOff p 32
    <*> peekByteOff p 40
  poke p (TMTask {..}) = do
    pokeByteOff p 0 tmTaskQLink
    pokeByteOff p 8 tmTaskQType
    pokeByteOff p 16 tmTaskTmAddr
    pokeByteOff p 24 tmTaskTmCount
    pokeByteOff p 32 tmTaskTmWakeUp
    pokeByteOff p 40 tmTaskTmReserved

{-# NOINLINE tmTaskStructType #-}
tmTaskStructType :: Ptr CType
tmTaskStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer, ffi_type_sint16, ffi_type_pointer, ffi_type_slong, ffi_type_slong, ffi_type_slong]

argTMTask :: TMTask -> Arg
argTMTask = mkStorableArg tmTaskStructType

retTMTask :: RetType TMTask
retTMTask = mkStorableRetType tmTaskStructType

instance ObjCArgument TMTask where
  withObjCArg x k = k (argTMTask x)

instance ObjCReturn TMTask where
  type RawReturn TMTask = TMTask
  objcRetType = retTMTask
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data TScriptingSizeResource = TScriptingSizeResource
  { tScriptingSizeResourceScriptingSizeFlags :: !CShort
  , tScriptingSizeResourceMinStackSize :: !CUInt
  , tScriptingSizeResourcePreferredStackSize :: !CUInt
  , tScriptingSizeResourceMaxStackSize :: !CUInt
  , tScriptingSizeResourceMinHeapSize :: !CUInt
  , tScriptingSizeResourcePreferredHeapSize :: !CUInt
  , tScriptingSizeResourceMaxHeapSize :: !CUInt
  } deriving (Eq, Show)

instance Storable TScriptingSizeResource where
  sizeOf    _ = 28
  alignment _ = 4
  peek p = TScriptingSizeResource <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
    <*> peekByteOff p 16
    <*> peekByteOff p 20
    <*> peekByteOff p 24
  poke p (TScriptingSizeResource {..}) = do
    pokeByteOff p 0 tScriptingSizeResourceScriptingSizeFlags
    pokeByteOff p 4 tScriptingSizeResourceMinStackSize
    pokeByteOff p 8 tScriptingSizeResourcePreferredStackSize
    pokeByteOff p 12 tScriptingSizeResourceMaxStackSize
    pokeByteOff p 16 tScriptingSizeResourceMinHeapSize
    pokeByteOff p 20 tScriptingSizeResourcePreferredHeapSize
    pokeByteOff p 24 tScriptingSizeResourceMaxHeapSize

{-# NOINLINE tScriptingSizeResourceStructType #-}
tScriptingSizeResourceStructType :: Ptr CType
tScriptingSizeResourceStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint]

argTScriptingSizeResource :: TScriptingSizeResource -> Arg
argTScriptingSizeResource = mkStorableArg tScriptingSizeResourceStructType

retTScriptingSizeResource :: RetType TScriptingSizeResource
retTScriptingSizeResource = mkStorableRetType tScriptingSizeResourceStructType

instance ObjCArgument TScriptingSizeResource where
  withObjCArg x k = k (argTScriptingSizeResource x)

instance ObjCReturn TScriptingSizeResource where
  type RawReturn TScriptingSizeResource = TScriptingSizeResource
  objcRetType = retTScriptingSizeResource
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data TableDirectoryRecord = TableDirectoryRecord
  { tableDirectoryRecordTableSignature :: !CUInt
  , tableDirectoryRecordReserved :: !CUInt
  , tableDirectoryRecordTableStartOffset :: !CUInt
  , tableDirectoryRecordTableSize :: !CUInt
  } deriving (Eq, Show)

instance Storable TableDirectoryRecord where
  sizeOf    _ = 16
  alignment _ = 4
  peek p = TableDirectoryRecord <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
  poke p (TableDirectoryRecord {..}) = do
    pokeByteOff p 0 tableDirectoryRecordTableSignature
    pokeByteOff p 4 tableDirectoryRecordReserved
    pokeByteOff p 8 tableDirectoryRecordTableStartOffset
    pokeByteOff p 12 tableDirectoryRecordTableSize

{-# NOINLINE tableDirectoryRecordStructType #-}
tableDirectoryRecordStructType :: Ptr CType
tableDirectoryRecordStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint]

argTableDirectoryRecord :: TableDirectoryRecord -> Arg
argTableDirectoryRecord = mkStorableArg tableDirectoryRecordStructType

retTableDirectoryRecord :: RetType TableDirectoryRecord
retTableDirectoryRecord = mkStorableRetType tableDirectoryRecordStructType

instance ObjCArgument TableDirectoryRecord where
  withObjCArg x k = k (argTableDirectoryRecord x)

instance ObjCReturn TableDirectoryRecord where
  type RawReturn TableDirectoryRecord = TableDirectoryRecord
  objcRetType = retTableDirectoryRecord
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data TextEncodingRec = TextEncodingRec
  { textEncodingRecBase :: !CUInt
  , textEncodingRecVariant :: !CUInt
  , textEncodingRecFormat :: !CUInt
  } deriving (Eq, Show)

instance Storable TextEncodingRec where
  sizeOf    _ = 12
  alignment _ = 4
  peek p = TextEncodingRec <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (TextEncodingRec {..}) = do
    pokeByteOff p 0 textEncodingRecBase
    pokeByteOff p 4 textEncodingRecVariant
    pokeByteOff p 8 textEncodingRecFormat

{-# NOINLINE textEncodingRecStructType #-}
textEncodingRecStructType :: Ptr CType
textEncodingRecStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_uint]

argTextEncodingRec :: TextEncodingRec -> Arg
argTextEncodingRec = mkStorableArg textEncodingRecStructType

retTextEncodingRec :: RetType TextEncodingRec
retTextEncodingRec = mkStorableRetType textEncodingRecStructType

instance ObjCArgument TextEncodingRec where
  withObjCArg x k = k (argTextEncodingRec x)

instance ObjCReturn TextEncodingRec where
  type RawReturn TextEncodingRec = TextEncodingRec
  objcRetType = retTextEncodingRec
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data TextEncodingRun = TextEncodingRun
  { textEncodingRunOffset :: !CULong
  , textEncodingRunTextEncoding :: !CUInt
  } deriving (Eq, Show)

instance Storable TextEncodingRun where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = TextEncodingRun <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (TextEncodingRun {..}) = do
    pokeByteOff p 0 textEncodingRunOffset
    pokeByteOff p 8 textEncodingRunTextEncoding

{-# NOINLINE textEncodingRunStructType #-}
textEncodingRunStructType :: Ptr CType
textEncodingRunStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_ulong, ffi_type_uint]

argTextEncodingRun :: TextEncodingRun -> Arg
argTextEncodingRun = mkStorableArg textEncodingRunStructType

retTextEncodingRun :: RetType TextEncodingRun
retTextEncodingRun = mkStorableRetType textEncodingRunStructType

instance ObjCArgument TextEncodingRun where
  withObjCArg x k = k (argTextEncodingRun x)

instance ObjCReturn TextEncodingRun where
  type RawReturn TextEncodingRun = TextEncodingRun
  objcRetType = retTextEncodingRun
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data TextRange = TextRange
  { textRangeFStart :: !CInt
  , textRangeFEnd :: !CInt
  , textRangeFHiliteStyle :: !CShort
  } deriving (Eq, Show)

instance Storable TextRange where
  sizeOf    _ = 12
  alignment _ = 4
  peek p = TextRange <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (TextRange {..}) = do
    pokeByteOff p 0 textRangeFStart
    pokeByteOff p 4 textRangeFEnd
    pokeByteOff p 8 textRangeFHiliteStyle

{-# NOINLINE textRangeStructType #-}
textRangeStructType :: Ptr CType
textRangeStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_sint, ffi_type_sint16]

argTextRange :: TextRange -> Arg
argTextRange = mkStorableArg textRangeStructType

retTextRange :: RetType TextRange
retTextRange = mkStorableRetType textRangeStructType

instance ObjCArgument TextRange where
  withObjCArg x k = k (argTextRange x)

instance ObjCReturn TextRange where
  type RawReturn TextRange = TextRange
  objcRetType = retTextRange
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data TokenRec = TokenRec
  { tokenRecTheToken :: !CShort
  , tokenRecPosition :: !(Ptr ())
  , tokenRecLength :: !CLong
  , tokenRecStringPosition :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable TokenRec where
  sizeOf    _ = 32
  alignment _ = 8
  peek p = TokenRec <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 24
  poke p (TokenRec {..}) = do
    pokeByteOff p 0 tokenRecTheToken
    pokeByteOff p 8 tokenRecPosition
    pokeByteOff p 16 tokenRecLength
    pokeByteOff p 24 tokenRecStringPosition

{-# NOINLINE tokenRecStructType #-}
tokenRecStructType :: Ptr CType
tokenRecStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16, ffi_type_pointer, ffi_type_slong, ffi_type_pointer]

argTokenRec :: TokenRec -> Arg
argTokenRec = mkStorableArg tokenRecStructType

retTokenRec :: RetType TokenRec
retTokenRec = mkStorableRetType tokenRecStructType

instance ObjCArgument TokenRec where
  withObjCArg x k = k (argTokenRec x)

instance ObjCReturn TokenRec where
  type RawReturn TokenRec = TokenRec
  objcRetType = retTokenRec
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data UCKeyLayoutFeatureInfo = UCKeyLayoutFeatureInfo
  { ucKeyLayoutFeatureInfoKeyLayoutFeatureInfoFormat :: !CUShort
  , ucKeyLayoutFeatureInfoReserved :: !CUShort
  , ucKeyLayoutFeatureInfoMaxOutputStringLength :: !CUInt
  } deriving (Eq, Show)

instance Storable UCKeyLayoutFeatureInfo where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = UCKeyLayoutFeatureInfo <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
  poke p (UCKeyLayoutFeatureInfo {..}) = do
    pokeByteOff p 0 ucKeyLayoutFeatureInfoKeyLayoutFeatureInfoFormat
    pokeByteOff p 2 ucKeyLayoutFeatureInfoReserved
    pokeByteOff p 4 ucKeyLayoutFeatureInfoMaxOutputStringLength

{-# NOINLINE ucKeyLayoutFeatureInfoStructType #-}
ucKeyLayoutFeatureInfoStructType :: Ptr CType
ucKeyLayoutFeatureInfoStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint]

argUCKeyLayoutFeatureInfo :: UCKeyLayoutFeatureInfo -> Arg
argUCKeyLayoutFeatureInfo = mkStorableArg ucKeyLayoutFeatureInfoStructType

retUCKeyLayoutFeatureInfo :: RetType UCKeyLayoutFeatureInfo
retUCKeyLayoutFeatureInfo = mkStorableRetType ucKeyLayoutFeatureInfoStructType

instance ObjCArgument UCKeyLayoutFeatureInfo where
  withObjCArg x k = k (argUCKeyLayoutFeatureInfo x)

instance ObjCReturn UCKeyLayoutFeatureInfo where
  type RawReturn UCKeyLayoutFeatureInfo = UCKeyLayoutFeatureInfo
  objcRetType = retUCKeyLayoutFeatureInfo
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data UCKeyStateEntryRange = UCKeyStateEntryRange
  { ucKeyStateEntryRangeCurStateStart :: !CUShort
  , ucKeyStateEntryRangeCurStateRange :: !CUChar
  , ucKeyStateEntryRangeDeltaMultiplier :: !CUChar
  , ucKeyStateEntryRangeCharData :: !CUShort
  , ucKeyStateEntryRangeNextState :: !CUShort
  } deriving (Eq, Show)

instance Storable UCKeyStateEntryRange where
  sizeOf    _ = 8
  alignment _ = 2
  peek p = UCKeyStateEntryRange <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 3
    <*> peekByteOff p 4
    <*> peekByteOff p 6
  poke p (UCKeyStateEntryRange {..}) = do
    pokeByteOff p 0 ucKeyStateEntryRangeCurStateStart
    pokeByteOff p 2 ucKeyStateEntryRangeCurStateRange
    pokeByteOff p 3 ucKeyStateEntryRangeDeltaMultiplier
    pokeByteOff p 4 ucKeyStateEntryRangeCharData
    pokeByteOff p 6 ucKeyStateEntryRangeNextState

{-# NOINLINE ucKeyStateEntryRangeStructType #-}
ucKeyStateEntryRangeStructType :: Ptr CType
ucKeyStateEntryRangeStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint8, ffi_type_uint8, ffi_type_uint16, ffi_type_uint16]

argUCKeyStateEntryRange :: UCKeyStateEntryRange -> Arg
argUCKeyStateEntryRange = mkStorableArg ucKeyStateEntryRangeStructType

retUCKeyStateEntryRange :: RetType UCKeyStateEntryRange
retUCKeyStateEntryRange = mkStorableRetType ucKeyStateEntryRangeStructType

instance ObjCArgument UCKeyStateEntryRange where
  withObjCArg x k = k (argUCKeyStateEntryRange x)

instance ObjCReturn UCKeyStateEntryRange where
  type RawReturn UCKeyStateEntryRange = UCKeyStateEntryRange
  objcRetType = retUCKeyStateEntryRange
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data UCKeyStateEntryTerminal = UCKeyStateEntryTerminal
  { ucKeyStateEntryTerminalCurState :: !CUShort
  , ucKeyStateEntryTerminalCharData :: !CUShort
  } deriving (Eq, Show)

instance Storable UCKeyStateEntryTerminal where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = UCKeyStateEntryTerminal <$> peekByteOff p 0
    <*> peekByteOff p 2
  poke p (UCKeyStateEntryTerminal {..}) = do
    pokeByteOff p 0 ucKeyStateEntryTerminalCurState
    pokeByteOff p 2 ucKeyStateEntryTerminalCharData

{-# NOINLINE ucKeyStateEntryTerminalStructType #-}
ucKeyStateEntryTerminalStructType :: Ptr CType
ucKeyStateEntryTerminalStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16]

argUCKeyStateEntryTerminal :: UCKeyStateEntryTerminal -> Arg
argUCKeyStateEntryTerminal = mkStorableArg ucKeyStateEntryTerminalStructType

retUCKeyStateEntryTerminal :: RetType UCKeyStateEntryTerminal
retUCKeyStateEntryTerminal = mkStorableRetType ucKeyStateEntryTerminalStructType

instance ObjCArgument UCKeyStateEntryTerminal where
  withObjCArg x k = k (argUCKeyStateEntryTerminal x)

instance ObjCReturn UCKeyStateEntryTerminal where
  type RawReturn UCKeyStateEntryTerminal = UCKeyStateEntryTerminal
  objcRetType = retUCKeyStateEntryTerminal
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data UCKeyboardTypeHeader = UCKeyboardTypeHeader
  { ucKeyboardTypeHeaderKeyboardTypeFirst :: !CUInt
  , ucKeyboardTypeHeaderKeyboardTypeLast :: !CUInt
  , ucKeyboardTypeHeaderKeyModifiersToTableNumOffset :: !CUInt
  , ucKeyboardTypeHeaderKeyToCharTableIndexOffset :: !CUInt
  , ucKeyboardTypeHeaderKeyStateRecordsIndexOffset :: !CUInt
  , ucKeyboardTypeHeaderKeyStateTerminatorsOffset :: !CUInt
  , ucKeyboardTypeHeaderKeySequenceDataIndexOffset :: !CUInt
  } deriving (Eq, Show)

instance Storable UCKeyboardTypeHeader where
  sizeOf    _ = 28
  alignment _ = 4
  peek p = UCKeyboardTypeHeader <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
    <*> peekByteOff p 16
    <*> peekByteOff p 20
    <*> peekByteOff p 24
  poke p (UCKeyboardTypeHeader {..}) = do
    pokeByteOff p 0 ucKeyboardTypeHeaderKeyboardTypeFirst
    pokeByteOff p 4 ucKeyboardTypeHeaderKeyboardTypeLast
    pokeByteOff p 8 ucKeyboardTypeHeaderKeyModifiersToTableNumOffset
    pokeByteOff p 12 ucKeyboardTypeHeaderKeyToCharTableIndexOffset
    pokeByteOff p 16 ucKeyboardTypeHeaderKeyStateRecordsIndexOffset
    pokeByteOff p 20 ucKeyboardTypeHeaderKeyStateTerminatorsOffset
    pokeByteOff p 24 ucKeyboardTypeHeaderKeySequenceDataIndexOffset

{-# NOINLINE ucKeyboardTypeHeaderStructType #-}
ucKeyboardTypeHeaderStructType :: Ptr CType
ucKeyboardTypeHeaderStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint]

argUCKeyboardTypeHeader :: UCKeyboardTypeHeader -> Arg
argUCKeyboardTypeHeader = mkStorableArg ucKeyboardTypeHeaderStructType

retUCKeyboardTypeHeader :: RetType UCKeyboardTypeHeader
retUCKeyboardTypeHeader = mkStorableRetType ucKeyboardTypeHeaderStructType

instance ObjCArgument UCKeyboardTypeHeader where
  withObjCArg x k = k (argUCKeyboardTypeHeader x)

instance ObjCReturn UCKeyboardTypeHeader where
  type RawReturn UCKeyboardTypeHeader = UCKeyboardTypeHeader
  objcRetType = retUCKeyboardTypeHeader
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data UTCDateTime = UTCDateTime
  { utcDateTimeHighSeconds :: !CUShort
  , utcDateTimeLowSeconds :: !CUInt
  , utcDateTimeFraction :: !CUShort
  } deriving (Eq, Show)

instance Storable UTCDateTime where
  sizeOf    _ = 12
  alignment _ = 4
  peek p = UTCDateTime <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (UTCDateTime {..}) = do
    pokeByteOff p 0 utcDateTimeHighSeconds
    pokeByteOff p 4 utcDateTimeLowSeconds
    pokeByteOff p 8 utcDateTimeFraction

{-# NOINLINE utcDateTimeStructType #-}
utcDateTimeStructType :: Ptr CType
utcDateTimeStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint, ffi_type_uint16]

argUTCDateTime :: UTCDateTime -> Arg
argUTCDateTime = mkStorableArg utcDateTimeStructType

retUTCDateTime :: RetType UTCDateTime
retUTCDateTime = mkStorableRetType utcDateTimeStructType

instance ObjCArgument UTCDateTime where
  withObjCArg x k = k (argUTCDateTime x)

instance ObjCReturn UTCDateTime where
  type RawReturn UTCDateTime = UTCDateTime
  objcRetType = retUTCDateTime
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data UnicodeMapping = UnicodeMapping
  { unicodeMappingUnicodeEncoding :: !CUInt
  , unicodeMappingOtherEncoding :: !CUInt
  , unicodeMappingMappingVersion :: !CInt
  } deriving (Eq, Show)

instance Storable UnicodeMapping where
  sizeOf    _ = 12
  alignment _ = 4
  peek p = UnicodeMapping <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (UnicodeMapping {..}) = do
    pokeByteOff p 0 unicodeMappingUnicodeEncoding
    pokeByteOff p 4 unicodeMappingOtherEncoding
    pokeByteOff p 8 unicodeMappingMappingVersion

{-# NOINLINE unicodeMappingStructType #-}
unicodeMappingStructType :: Ptr CType
unicodeMappingStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_sint]

argUnicodeMapping :: UnicodeMapping -> Arg
argUnicodeMapping = mkStorableArg unicodeMappingStructType

retUnicodeMapping :: RetType UnicodeMapping
retUnicodeMapping = mkStorableRetType unicodeMappingStructType

instance ObjCArgument UnicodeMapping where
  withObjCArg x k = k (argUnicodeMapping x)

instance ObjCReturn UnicodeMapping where
  type RawReturn UnicodeMapping = UnicodeMapping
  objcRetType = retUnicodeMapping
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data VolMountInfoHeader = VolMountInfoHeader
  { volMountInfoHeaderLength :: !CShort
  , volMountInfoHeaderMedia :: !CUInt
  } deriving (Eq, Show)

instance Storable VolMountInfoHeader where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = VolMountInfoHeader <$> peekByteOff p 0
    <*> peekByteOff p 4
  poke p (VolMountInfoHeader {..}) = do
    pokeByteOff p 0 volMountInfoHeaderLength
    pokeByteOff p 4 volMountInfoHeaderMedia

{-# NOINLINE volMountInfoHeaderStructType #-}
volMountInfoHeaderStructType :: Ptr CType
volMountInfoHeaderStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16, ffi_type_uint]

argVolMountInfoHeader :: VolMountInfoHeader -> Arg
argVolMountInfoHeader = mkStorableArg volMountInfoHeaderStructType

retVolMountInfoHeader :: RetType VolMountInfoHeader
retVolMountInfoHeader = mkStorableRetType volMountInfoHeaderStructType

instance ObjCArgument VolMountInfoHeader where
  withObjCArg x k = k (argVolMountInfoHeader x)

instance ObjCReturn VolMountInfoHeader where
  type RawReturn VolMountInfoHeader = VolMountInfoHeader
  objcRetType = retVolMountInfoHeader
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data VolumeMountInfoHeader = VolumeMountInfoHeader
  { volumeMountInfoHeaderLength :: !CShort
  , volumeMountInfoHeaderMedia :: !CUInt
  , volumeMountInfoHeaderFlags :: !CShort
  } deriving (Eq, Show)

instance Storable VolumeMountInfoHeader where
  sizeOf    _ = 12
  alignment _ = 4
  peek p = VolumeMountInfoHeader <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (VolumeMountInfoHeader {..}) = do
    pokeByteOff p 0 volumeMountInfoHeaderLength
    pokeByteOff p 4 volumeMountInfoHeaderMedia
    pokeByteOff p 8 volumeMountInfoHeaderFlags

{-# NOINLINE volumeMountInfoHeaderStructType #-}
volumeMountInfoHeaderStructType :: Ptr CType
volumeMountInfoHeaderStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16, ffi_type_uint, ffi_type_sint16]

argVolumeMountInfoHeader :: VolumeMountInfoHeader -> Arg
argVolumeMountInfoHeader = mkStorableArg volumeMountInfoHeaderStructType

retVolumeMountInfoHeader :: RetType VolumeMountInfoHeader
retVolumeMountInfoHeader = mkStorableRetType volumeMountInfoHeaderStructType

instance ObjCArgument VolumeMountInfoHeader where
  withObjCArg x k = k (argVolumeMountInfoHeader x)

instance ObjCReturn VolumeMountInfoHeader where
  type RawReturn VolumeMountInfoHeader = VolumeMountInfoHeader
  objcRetType = retVolumeMountInfoHeader
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data WSClientContext = WSClientContext
  { wsClientContextVersion :: !CLong
  , wsClientContextInfo :: !(Ptr ())
  , wsClientContextRetain :: !(Ptr ())
  , wsClientContextRelease :: !(Ptr ())
  , wsClientContextCopyDescription :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable WSClientContext where
  sizeOf    _ = 40
  alignment _ = 8
  peek p = WSClientContext <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 24
    <*> peekByteOff p 32
  poke p (WSClientContext {..}) = do
    pokeByteOff p 0 wsClientContextVersion
    pokeByteOff p 8 wsClientContextInfo
    pokeByteOff p 16 wsClientContextRetain
    pokeByteOff p 24 wsClientContextRelease
    pokeByteOff p 32 wsClientContextCopyDescription

{-# NOINLINE wsClientContextStructType #-}
wsClientContextStructType :: Ptr CType
wsClientContextStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_slong, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer]

argWSClientContext :: WSClientContext -> Arg
argWSClientContext = mkStorableArg wsClientContextStructType

retWSClientContext :: RetType WSClientContext
retWSClientContext = mkStorableRetType wsClientContextStructType

instance ObjCArgument WSClientContext where
  withObjCArg x k = k (argWSClientContext x)

instance ObjCReturn WSClientContext where
  type RawReturn WSClientContext = WSClientContext
  objcRetType = retWSClientContext
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data WritingCode = WritingCode
  { writingCodeTheScriptCode :: !CShort
  , writingCodeTheLangCode :: !CShort
  } deriving (Eq, Show)

instance Storable WritingCode where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = WritingCode <$> peekByteOff p 0
    <*> peekByteOff p 2
  poke p (WritingCode {..}) = do
    pokeByteOff p 0 writingCodeTheScriptCode
    pokeByteOff p 2 writingCodeTheLangCode

{-# NOINLINE writingCodeStructType #-}
writingCodeStructType :: Ptr CType
writingCodeStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16, ffi_type_sint16]

argWritingCode :: WritingCode -> Arg
argWritingCode = mkStorableArg writingCodeStructType

retWritingCode :: RetType WritingCode
retWritingCode = mkStorableRetType writingCodeStructType

instance ObjCArgument WritingCode where
  withObjCArg x k = k (argWritingCode x)

instance ObjCReturn WritingCode where
  type RawReturn WritingCode = WritingCode
  objcRetType = retWritingCode
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data XLibContainerHeader = XLibContainerHeader
  { xLibContainerHeaderTag1 :: !CUInt
  , xLibContainerHeaderTag2 :: !CUInt
  , xLibContainerHeaderCurrentFormat :: !CUInt
  , xLibContainerHeaderContainerStringsOffset :: !CUInt
  , xLibContainerHeaderExportHashOffset :: !CUInt
  , xLibContainerHeaderExportKeyOffset :: !CUInt
  , xLibContainerHeaderExportSymbolOffset :: !CUInt
  , xLibContainerHeaderExportNamesOffset :: !CUInt
  , xLibContainerHeaderExportHashTablePower :: !CUInt
  , xLibContainerHeaderExportedSymbolCount :: !CUInt
  , xLibContainerHeaderFragNameOffset :: !CUInt
  , xLibContainerHeaderFragNameLength :: !CUInt
  , xLibContainerHeaderDylibPathOffset :: !CUInt
  , xLibContainerHeaderDylibPathLength :: !CUInt
  , xLibContainerHeaderCpuFamily :: !CUInt
  , xLibContainerHeaderCpuModel :: !CUInt
  , xLibContainerHeaderDateTimeStamp :: !CUInt
  , xLibContainerHeaderCurrentVersion :: !CUInt
  , xLibContainerHeaderOldDefVersion :: !CUInt
  , xLibContainerHeaderOldImpVersion :: !CUInt
  } deriving (Eq, Show)

instance Storable XLibContainerHeader where
  sizeOf    _ = 80
  alignment _ = 4
  peek p = XLibContainerHeader <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
    <*> peekByteOff p 16
    <*> peekByteOff p 20
    <*> peekByteOff p 24
    <*> peekByteOff p 28
    <*> peekByteOff p 32
    <*> peekByteOff p 36
    <*> peekByteOff p 40
    <*> peekByteOff p 44
    <*> peekByteOff p 48
    <*> peekByteOff p 52
    <*> peekByteOff p 56
    <*> peekByteOff p 60
    <*> peekByteOff p 64
    <*> peekByteOff p 68
    <*> peekByteOff p 72
    <*> peekByteOff p 76
  poke p (XLibContainerHeader {..}) = do
    pokeByteOff p 0 xLibContainerHeaderTag1
    pokeByteOff p 4 xLibContainerHeaderTag2
    pokeByteOff p 8 xLibContainerHeaderCurrentFormat
    pokeByteOff p 12 xLibContainerHeaderContainerStringsOffset
    pokeByteOff p 16 xLibContainerHeaderExportHashOffset
    pokeByteOff p 20 xLibContainerHeaderExportKeyOffset
    pokeByteOff p 24 xLibContainerHeaderExportSymbolOffset
    pokeByteOff p 28 xLibContainerHeaderExportNamesOffset
    pokeByteOff p 32 xLibContainerHeaderExportHashTablePower
    pokeByteOff p 36 xLibContainerHeaderExportedSymbolCount
    pokeByteOff p 40 xLibContainerHeaderFragNameOffset
    pokeByteOff p 44 xLibContainerHeaderFragNameLength
    pokeByteOff p 48 xLibContainerHeaderDylibPathOffset
    pokeByteOff p 52 xLibContainerHeaderDylibPathLength
    pokeByteOff p 56 xLibContainerHeaderCpuFamily
    pokeByteOff p 60 xLibContainerHeaderCpuModel
    pokeByteOff p 64 xLibContainerHeaderDateTimeStamp
    pokeByteOff p 68 xLibContainerHeaderCurrentVersion
    pokeByteOff p 72 xLibContainerHeaderOldDefVersion
    pokeByteOff p 76 xLibContainerHeaderOldImpVersion

{-# NOINLINE xLibContainerHeaderStructType #-}
xLibContainerHeaderStructType :: Ptr CType
xLibContainerHeaderStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint]

argXLibContainerHeader :: XLibContainerHeader -> Arg
argXLibContainerHeader = mkStorableArg xLibContainerHeaderStructType

retXLibContainerHeader :: RetType XLibContainerHeader
retXLibContainerHeader = mkStorableRetType xLibContainerHeaderStructType

instance ObjCArgument XLibContainerHeader where
  withObjCArg x k = k (argXLibContainerHeader x)

instance ObjCReturn XLibContainerHeader where
  type RawReturn XLibContainerHeader = XLibContainerHeader
  objcRetType = retXLibContainerHeader
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data XLibExportedSymbol = XLibExportedSymbol
  { xLibExportedSymbolClassAndName :: !CUInt
  , xLibExportedSymbolBpOffset :: !CUInt
  } deriving (Eq, Show)

instance Storable XLibExportedSymbol where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = XLibExportedSymbol <$> peekByteOff p 0
    <*> peekByteOff p 4
  poke p (XLibExportedSymbol {..}) = do
    pokeByteOff p 0 xLibExportedSymbolClassAndName
    pokeByteOff p 4 xLibExportedSymbolBpOffset

{-# NOINLINE xLibExportedSymbolStructType #-}
xLibExportedSymbolStructType :: Ptr CType
xLibExportedSymbolStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint]

argXLibExportedSymbol :: XLibExportedSymbol -> Arg
argXLibExportedSymbol = mkStorableArg xLibExportedSymbolStructType

retXLibExportedSymbol :: RetType XLibExportedSymbol
retXLibExportedSymbol = mkStorableRetType xLibExportedSymbolStructType

instance ObjCArgument XLibExportedSymbol where
  withObjCArg x k = k (argXLibExportedSymbol x)

instance ObjCReturn XLibExportedSymbol where
  type RawReturn XLibExportedSymbol = XLibExportedSymbol
  objcRetType = retXLibExportedSymbol
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data XLibExportedSymbolHashSlot = XLibExportedSymbolHashSlot
  { xLibExportedSymbolHashSlotCountAndStart :: !CUInt
  } deriving (Eq, Show)

instance Storable XLibExportedSymbolHashSlot where
  sizeOf    _ = 4
  alignment _ = 4
  peek p = XLibExportedSymbolHashSlot <$> peekByteOff p 0
  poke p (XLibExportedSymbolHashSlot {..}) =
    pokeByteOff p 0 xLibExportedSymbolHashSlotCountAndStart

{-# NOINLINE xLibExportedSymbolHashSlotStructType #-}
xLibExportedSymbolHashSlotStructType :: Ptr CType
xLibExportedSymbolHashSlotStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint]

argXLibExportedSymbolHashSlot :: XLibExportedSymbolHashSlot -> Arg
argXLibExportedSymbolHashSlot = mkStorableArg xLibExportedSymbolHashSlotStructType

retXLibExportedSymbolHashSlot :: RetType XLibExportedSymbolHashSlot
retXLibExportedSymbolHashSlot = mkStorableRetType xLibExportedSymbolHashSlotStructType

instance ObjCArgument XLibExportedSymbolHashSlot where
  withObjCArg x k = k (argXLibExportedSymbolHashSlot x)

instance ObjCReturn XLibExportedSymbolHashSlot where
  type RawReturn XLibExportedSymbolHashSlot = XLibExportedSymbolHashSlot
  objcRetType = retXLibExportedSymbolHashSlot
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data AEKeyDesc = AEKeyDesc
  { aeKeyDescDescKey :: !CUInt
  , aeKeyDescDescContent :: !AppleEvent
  } deriving (Eq, Show)

instance Storable AEKeyDesc where
  sizeOf    _ = 24
  alignment _ = 8
  peek p = AEKeyDesc <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (AEKeyDesc {..}) = do
    pokeByteOff p 0 aeKeyDescDescKey
    pokeByteOff p 8 aeKeyDescDescContent

{-# NOINLINE aeKeyDescStructType #-}
aeKeyDescStructType :: Ptr CType
aeKeyDescStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, appleEventStructType]

argAEKeyDesc :: AEKeyDesc -> Arg
argAEKeyDesc = mkStorableArg aeKeyDescStructType

retAEKeyDesc :: RetType AEKeyDesc
retAEKeyDesc = mkStorableRetType aeKeyDescStructType

instance ObjCArgument AEKeyDesc where
  withObjCArg x k = k (argAEKeyDesc x)

instance ObjCReturn AEKeyDesc where
  type RawReturn AEKeyDesc = AEKeyDesc
  objcRetType = retAEKeyDesc
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data ComponentPlatformInfo = ComponentPlatformInfo
  { componentPlatformInfoComponentFlags :: !CInt
  , componentPlatformInfoComponent :: !ResourceSpec
  , componentPlatformInfoPlatformType :: !CShort
  } deriving (Eq, Show)

instance Storable ComponentPlatformInfo where
  sizeOf    _ = 16
  alignment _ = 4
  peek p = ComponentPlatformInfo <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 12
  poke p (ComponentPlatformInfo {..}) = do
    pokeByteOff p 0 componentPlatformInfoComponentFlags
    pokeByteOff p 4 componentPlatformInfoComponent
    pokeByteOff p 12 componentPlatformInfoPlatformType

{-# NOINLINE componentPlatformInfoStructType #-}
componentPlatformInfoStructType :: Ptr CType
componentPlatformInfoStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, resourceSpecStructType, ffi_type_sint16]

argComponentPlatformInfo :: ComponentPlatformInfo -> Arg
argComponentPlatformInfo = mkStorableArg componentPlatformInfoStructType

retComponentPlatformInfo :: RetType ComponentPlatformInfo
retComponentPlatformInfo = mkStorableRetType componentPlatformInfoStructType

instance ObjCArgument ComponentPlatformInfo where
  withObjCArg x k = k (argComponentPlatformInfo x)

instance ObjCReturn ComponentPlatformInfo where
  type RawReturn ComponentPlatformInfo = ComponentPlatformInfo
  objcRetType = retComponentPlatformInfo
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data ComponentResource = ComponentResource
  { componentResourceCd :: !ComponentDescription
  , componentResourceComponent :: !ResourceSpec
  , componentResourceComponentName :: !ResourceSpec
  , componentResourceComponentInfo :: !ResourceSpec
  , componentResourceComponentIcon :: !ResourceSpec
  } deriving (Eq, Show)

instance Storable ComponentResource where
  sizeOf    _ = 52
  alignment _ = 4
  peek p = ComponentResource <$> peekByteOff p 0
    <*> peekByteOff p 20
    <*> peekByteOff p 28
    <*> peekByteOff p 36
    <*> peekByteOff p 44
  poke p (ComponentResource {..}) = do
    pokeByteOff p 0 componentResourceCd
    pokeByteOff p 20 componentResourceComponent
    pokeByteOff p 28 componentResourceComponentName
    pokeByteOff p 36 componentResourceComponentInfo
    pokeByteOff p 44 componentResourceComponentIcon

{-# NOINLINE componentResourceStructType #-}
componentResourceStructType :: Ptr CType
componentResourceStructType = unsafePerformIO $ fst <$> newStructCType [componentDescriptionStructType, resourceSpecStructType, resourceSpecStructType, resourceSpecStructType, resourceSpecStructType]

argComponentResource :: ComponentResource -> Arg
argComponentResource = mkStorableArg componentResourceStructType

retComponentResource :: RetType ComponentResource
retComponentResource = mkStorableRetType componentResourceStructType

instance ObjCArgument ComponentResource where
  withObjCArg x k = k (argComponentResource x)

instance ObjCReturn ComponentResource where
  type RawReturn ComponentResource = ComponentResource
  objcRetType = retComponentResource
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data DInfo = DInfo
  { dInfoFrRect :: !Rect
  , dInfoFrFlags :: !CUShort
  , dInfoFrLocation :: !Point
  , dInfoFrView :: !CShort
  } deriving (Eq, Show)

instance Storable DInfo where
  sizeOf    _ = 16
  alignment _ = 2
  peek p = DInfo <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 10
    <*> peekByteOff p 14
  poke p (DInfo {..}) = do
    pokeByteOff p 0 dInfoFrRect
    pokeByteOff p 8 dInfoFrFlags
    pokeByteOff p 10 dInfoFrLocation
    pokeByteOff p 14 dInfoFrView

{-# NOINLINE dInfoStructType #-}
dInfoStructType :: Ptr CType
dInfoStructType = unsafePerformIO $ fst <$> newStructCType [rectStructType, ffi_type_uint16, pointStructType, ffi_type_sint16]

argDInfo :: DInfo -> Arg
argDInfo = mkStorableArg dInfoStructType

retDInfo :: RetType DInfo
retDInfo = mkStorableRetType dInfoStructType

instance ObjCArgument DInfo where
  withObjCArg x k = k (argDInfo x)

instance ObjCReturn DInfo where
  type RawReturn DInfo = DInfo
  objcRetType = retDInfo
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data DXInfo = DXInfo
  { dxInfoFrScroll :: !Point
  , dxInfoFrOpenChain :: !CInt
  , dxInfoFrScript :: !CSChar
  , dxInfoFrXFlags :: !CSChar
  , dxInfoFrComment :: !CShort
  , dxInfoFrPutAway :: !CInt
  } deriving (Eq, Show)

instance Storable DXInfo where
  sizeOf    _ = 16
  alignment _ = 4
  peek p = DXInfo <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 9
    <*> peekByteOff p 10
    <*> peekByteOff p 12
  poke p (DXInfo {..}) = do
    pokeByteOff p 0 dxInfoFrScroll
    pokeByteOff p 4 dxInfoFrOpenChain
    pokeByteOff p 8 dxInfoFrScript
    pokeByteOff p 9 dxInfoFrXFlags
    pokeByteOff p 10 dxInfoFrComment
    pokeByteOff p 12 dxInfoFrPutAway

{-# NOINLINE dxInfoStructType #-}
dxInfoStructType :: Ptr CType
dxInfoStructType = unsafePerformIO $ fst <$> newStructCType [pointStructType, ffi_type_sint, ffi_type_sint8, ffi_type_sint8, ffi_type_sint16, ffi_type_sint]

argDXInfo :: DXInfo -> Arg
argDXInfo = mkStorableArg dxInfoStructType

retDXInfo :: RetType DXInfo
retDXInfo = mkStorableRetType dxInfoStructType

instance ObjCArgument DXInfo where
  withObjCArg x k = k (argDXInfo x)

instance ObjCReturn DXInfo where
  type RawReturn DXInfo = DXInfo
  objcRetType = retDXInfo
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data ExtendedFolderInfo = ExtendedFolderInfo
  { extendedFolderInfoScrollPosition :: !Point
  , extendedFolderInfoReserved1 :: !CInt
  , extendedFolderInfoExtendedFinderFlags :: !CUShort
  , extendedFolderInfoReserved2 :: !CShort
  , extendedFolderInfoPutAwayFolderID :: !CInt
  } deriving (Eq, Show)

instance Storable ExtendedFolderInfo where
  sizeOf    _ = 16
  alignment _ = 4
  peek p = ExtendedFolderInfo <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 10
    <*> peekByteOff p 12
  poke p (ExtendedFolderInfo {..}) = do
    pokeByteOff p 0 extendedFolderInfoScrollPosition
    pokeByteOff p 4 extendedFolderInfoReserved1
    pokeByteOff p 8 extendedFolderInfoExtendedFinderFlags
    pokeByteOff p 10 extendedFolderInfoReserved2
    pokeByteOff p 12 extendedFolderInfoPutAwayFolderID

{-# NOINLINE extendedFolderInfoStructType #-}
extendedFolderInfoStructType :: Ptr CType
extendedFolderInfoStructType = unsafePerformIO $ fst <$> newStructCType [pointStructType, ffi_type_sint, ffi_type_uint16, ffi_type_sint16, ffi_type_sint]

argExtendedFolderInfo :: ExtendedFolderInfo -> Arg
argExtendedFolderInfo = mkStorableArg extendedFolderInfoStructType

retExtendedFolderInfo :: RetType ExtendedFolderInfo
retExtendedFolderInfo = mkStorableRetType extendedFolderInfoStructType

instance ObjCArgument ExtendedFolderInfo where
  withObjCArg x k = k (argExtendedFolderInfo x)

instance ObjCReturn ExtendedFolderInfo where
  type RawReturn ExtendedFolderInfo = ExtendedFolderInfo
  objcRetType = retExtendedFolderInfo
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data FInfo = FInfo
  { fInfoFdType :: !CUInt
  , fInfoFdCreator :: !CUInt
  , fInfoFdFlags :: !CUShort
  , fInfoFdLocation :: !Point
  , fInfoFdFldr :: !CShort
  } deriving (Eq, Show)

instance Storable FInfo where
  sizeOf    _ = 16
  alignment _ = 4
  peek p = FInfo <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 10
    <*> peekByteOff p 14
  poke p (FInfo {..}) = do
    pokeByteOff p 0 fInfoFdType
    pokeByteOff p 4 fInfoFdCreator
    pokeByteOff p 8 fInfoFdFlags
    pokeByteOff p 10 fInfoFdLocation
    pokeByteOff p 14 fInfoFdFldr

{-# NOINLINE fInfoStructType #-}
fInfoStructType :: Ptr CType
fInfoStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_uint16, pointStructType, ffi_type_sint16]

argFInfo :: FInfo -> Arg
argFInfo = mkStorableArg fInfoStructType

retFInfo :: RetType FInfo
retFInfo = mkStorableRetType fInfoStructType

instance ObjCArgument FInfo where
  withObjCArg x k = k (argFInfo x)

instance ObjCReturn FInfo where
  type RawReturn FInfo = FInfo
  objcRetType = retFInfo
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data FSAliasInfo = FSAliasInfo
  { fsAliasInfoVolumeCreateDate :: !UTCDateTime
  , fsAliasInfoTargetCreateDate :: !UTCDateTime
  , fsAliasInfoFileType :: !CUInt
  , fsAliasInfoFileCreator :: !CUInt
  , fsAliasInfoParentDirID :: !CUInt
  , fsAliasInfoNodeID :: !CUInt
  , fsAliasInfoFilesystemID :: !CUShort
  , fsAliasInfoSignature :: !CUShort
  , fsAliasInfoVolumeIsBootVolume :: !CUChar
  , fsAliasInfoVolumeIsAutomounted :: !CUChar
  , fsAliasInfoVolumeIsEjectable :: !CUChar
  , fsAliasInfoVolumeHasPersistentFileIDs :: !CUChar
  , fsAliasInfoIsDirectory :: !CUChar
  } deriving (Eq, Show)

instance Storable FSAliasInfo where
  sizeOf    _ = 52
  alignment _ = 4
  peek p = FSAliasInfo <$> peekByteOff p 0
    <*> peekByteOff p 12
    <*> peekByteOff p 24
    <*> peekByteOff p 28
    <*> peekByteOff p 32
    <*> peekByteOff p 36
    <*> peekByteOff p 40
    <*> peekByteOff p 42
    <*> peekByteOff p 44
    <*> peekByteOff p 45
    <*> peekByteOff p 46
    <*> peekByteOff p 47
    <*> peekByteOff p 48
  poke p (FSAliasInfo {..}) = do
    pokeByteOff p 0 fsAliasInfoVolumeCreateDate
    pokeByteOff p 12 fsAliasInfoTargetCreateDate
    pokeByteOff p 24 fsAliasInfoFileType
    pokeByteOff p 28 fsAliasInfoFileCreator
    pokeByteOff p 32 fsAliasInfoParentDirID
    pokeByteOff p 36 fsAliasInfoNodeID
    pokeByteOff p 40 fsAliasInfoFilesystemID
    pokeByteOff p 42 fsAliasInfoSignature
    pokeByteOff p 44 fsAliasInfoVolumeIsBootVolume
    pokeByteOff p 45 fsAliasInfoVolumeIsAutomounted
    pokeByteOff p 46 fsAliasInfoVolumeIsEjectable
    pokeByteOff p 47 fsAliasInfoVolumeHasPersistentFileIDs
    pokeByteOff p 48 fsAliasInfoIsDirectory

{-# NOINLINE fsAliasInfoStructType #-}
fsAliasInfoStructType :: Ptr CType
fsAliasInfoStructType = unsafePerformIO $ fst <$> newStructCType [utcDateTimeStructType, utcDateTimeStructType, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint16, ffi_type_uint16, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8]

argFSAliasInfo :: FSAliasInfo -> Arg
argFSAliasInfo = mkStorableArg fsAliasInfoStructType

retFSAliasInfo :: RetType FSAliasInfo
retFSAliasInfo = mkStorableRetType fsAliasInfoStructType

instance ObjCArgument FSAliasInfo where
  withObjCArg x k = k (argFSAliasInfo x)

instance ObjCReturn FSAliasInfo where
  type RawReturn FSAliasInfo = FSAliasInfo
  objcRetType = retFSAliasInfo
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data FileInfo = FileInfo
  { fileInfoFileType :: !CUInt
  , fileInfoFileCreator :: !CUInt
  , fileInfoFinderFlags :: !CUShort
  , fileInfoLocation :: !Point
  , fileInfoReservedField :: !CUShort
  } deriving (Eq, Show)

instance Storable FileInfo where
  sizeOf    _ = 16
  alignment _ = 4
  peek p = FileInfo <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 10
    <*> peekByteOff p 14
  poke p (FileInfo {..}) = do
    pokeByteOff p 0 fileInfoFileType
    pokeByteOff p 4 fileInfoFileCreator
    pokeByteOff p 8 fileInfoFinderFlags
    pokeByteOff p 10 fileInfoLocation
    pokeByteOff p 14 fileInfoReservedField

{-# NOINLINE fileInfoStructType #-}
fileInfoStructType :: Ptr CType
fileInfoStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_uint16, pointStructType, ffi_type_uint16]

argFileInfo :: FileInfo -> Arg
argFileInfo = mkStorableArg fileInfoStructType

retFileInfo :: RetType FileInfo
retFileInfo = mkStorableRetType fileInfoStructType

instance ObjCArgument FileInfo where
  withObjCArg x k = k (argFileInfo x)

instance ObjCReturn FileInfo where
  type RawReturn FileInfo = FileInfo
  objcRetType = retFileInfo
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data FolderInfo = FolderInfo
  { folderInfoWindowBounds :: !Rect
  , folderInfoFinderFlags :: !CUShort
  , folderInfoLocation :: !Point
  , folderInfoReservedField :: !CUShort
  } deriving (Eq, Show)

instance Storable FolderInfo where
  sizeOf    _ = 16
  alignment _ = 2
  peek p = FolderInfo <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 10
    <*> peekByteOff p 14
  poke p (FolderInfo {..}) = do
    pokeByteOff p 0 folderInfoWindowBounds
    pokeByteOff p 8 folderInfoFinderFlags
    pokeByteOff p 10 folderInfoLocation
    pokeByteOff p 14 folderInfoReservedField

{-# NOINLINE folderInfoStructType #-}
folderInfoStructType :: Ptr CType
folderInfoStructType = unsafePerformIO $ fst <$> newStructCType [rectStructType, ffi_type_uint16, pointStructType, ffi_type_uint16]

argFolderInfo :: FolderInfo -> Arg
argFolderInfo = mkStorableArg folderInfoStructType

retFolderInfo :: RetType FolderInfo
retFolderInfo = mkStorableRetType folderInfoStructType

instance ObjCArgument FolderInfo where
  withObjCArg x k = k (argFolderInfo x)

instance ObjCReturn FolderInfo where
  type RawReturn FolderInfo = FolderInfo
  objcRetType = retFolderInfo
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data InstrumentChunk = InstrumentChunk
  { instrumentChunkCkID :: !CUInt
  , instrumentChunkCkSize :: !CInt
  , instrumentChunkBaseFrequency :: !CUChar
  , instrumentChunkDetune :: !CUChar
  , instrumentChunkLowFrequency :: !CUChar
  , instrumentChunkHighFrequency :: !CUChar
  , instrumentChunkLowVelocity :: !CUChar
  , instrumentChunkHighVelocity :: !CUChar
  , instrumentChunkGain :: !CShort
  , instrumentChunkSustainLoop :: !AIFFLoop
  , instrumentChunkReleaseLoop :: !AIFFLoop
  } deriving (Eq, Show)

instance Storable InstrumentChunk where
  sizeOf    _ = 28
  alignment _ = 4
  peek p = InstrumentChunk <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 9
    <*> peekByteOff p 10
    <*> peekByteOff p 11
    <*> peekByteOff p 12
    <*> peekByteOff p 13
    <*> peekByteOff p 14
    <*> peekByteOff p 16
    <*> peekByteOff p 22
  poke p (InstrumentChunk {..}) = do
    pokeByteOff p 0 instrumentChunkCkID
    pokeByteOff p 4 instrumentChunkCkSize
    pokeByteOff p 8 instrumentChunkBaseFrequency
    pokeByteOff p 9 instrumentChunkDetune
    pokeByteOff p 10 instrumentChunkLowFrequency
    pokeByteOff p 11 instrumentChunkHighFrequency
    pokeByteOff p 12 instrumentChunkLowVelocity
    pokeByteOff p 13 instrumentChunkHighVelocity
    pokeByteOff p 14 instrumentChunkGain
    pokeByteOff p 16 instrumentChunkSustainLoop
    pokeByteOff p 22 instrumentChunkReleaseLoop

{-# NOINLINE instrumentChunkStructType #-}
instrumentChunkStructType :: Ptr CType
instrumentChunkStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_sint, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_sint16, aiffLoopStructType, aiffLoopStructType]

argInstrumentChunk :: InstrumentChunk -> Arg
argInstrumentChunk = mkStorableArg instrumentChunkStructType

retInstrumentChunk :: RetType InstrumentChunk
retInstrumentChunk = mkStorableRetType instrumentChunkStructType

instance ObjCArgument InstrumentChunk where
  withObjCArg x k = k (argInstrumentChunk x)

instance ObjCReturn InstrumentChunk where
  type RawReturn InstrumentChunk = InstrumentChunk
  objcRetType = retInstrumentChunk
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data ItlbExtRecord = ItlbExtRecord
  { itlbExtRecordBase :: !ItlbRecord
  , itlbExtRecordItlbLocalSize :: !CInt
  , itlbExtRecordItlbMonoFond :: !CShort
  , itlbExtRecordItlbMonoSize :: !CShort
  , itlbExtRecordItlbPrefFond :: !CShort
  , itlbExtRecordItlbPrefSize :: !CShort
  , itlbExtRecordItlbSmallFond :: !CShort
  , itlbExtRecordItlbSmallSize :: !CShort
  , itlbExtRecordItlbSysFond :: !CShort
  , itlbExtRecordItlbSysSize :: !CShort
  , itlbExtRecordItlbAppFond :: !CShort
  , itlbExtRecordItlbAppSize :: !CShort
  , itlbExtRecordItlbHelpFond :: !CShort
  , itlbExtRecordItlbHelpSize :: !CShort
  , itlbExtRecordItlbValidStyles :: !CUChar
  , itlbExtRecordItlbAliasStyle :: !CUChar
  } deriving (Eq, Show)

instance Storable ItlbExtRecord where
  sizeOf    _ = 52
  alignment _ = 4
  peek p = ItlbExtRecord <$> peekByteOff p 0
    <*> peekByteOff p 20
    <*> peekByteOff p 24
    <*> peekByteOff p 26
    <*> peekByteOff p 28
    <*> peekByteOff p 30
    <*> peekByteOff p 32
    <*> peekByteOff p 34
    <*> peekByteOff p 36
    <*> peekByteOff p 38
    <*> peekByteOff p 40
    <*> peekByteOff p 42
    <*> peekByteOff p 44
    <*> peekByteOff p 46
    <*> peekByteOff p 48
    <*> peekByteOff p 49
  poke p (ItlbExtRecord {..}) = do
    pokeByteOff p 0 itlbExtRecordBase
    pokeByteOff p 20 itlbExtRecordItlbLocalSize
    pokeByteOff p 24 itlbExtRecordItlbMonoFond
    pokeByteOff p 26 itlbExtRecordItlbMonoSize
    pokeByteOff p 28 itlbExtRecordItlbPrefFond
    pokeByteOff p 30 itlbExtRecordItlbPrefSize
    pokeByteOff p 32 itlbExtRecordItlbSmallFond
    pokeByteOff p 34 itlbExtRecordItlbSmallSize
    pokeByteOff p 36 itlbExtRecordItlbSysFond
    pokeByteOff p 38 itlbExtRecordItlbSysSize
    pokeByteOff p 40 itlbExtRecordItlbAppFond
    pokeByteOff p 42 itlbExtRecordItlbAppSize
    pokeByteOff p 44 itlbExtRecordItlbHelpFond
    pokeByteOff p 46 itlbExtRecordItlbHelpSize
    pokeByteOff p 48 itlbExtRecordItlbValidStyles
    pokeByteOff p 49 itlbExtRecordItlbAliasStyle

{-# NOINLINE itlbExtRecordStructType #-}
itlbExtRecordStructType :: Ptr CType
itlbExtRecordStructType = unsafePerformIO $ fst <$> newStructCType [itlbRecordStructType, ffi_type_sint, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16, ffi_type_uint8, ffi_type_uint8]

argItlbExtRecord :: ItlbExtRecord -> Arg
argItlbExtRecord = mkStorableArg itlbExtRecordStructType

retItlbExtRecord :: RetType ItlbExtRecord
retItlbExtRecord = mkStorableRetType itlbExtRecordStructType

instance ObjCArgument ItlbExtRecord where
  withObjCArg x k = k (argItlbExtRecord x)

instance ObjCReturn ItlbExtRecord where
  type RawReturn ItlbExtRecord = ItlbExtRecord
  objcRetType = retItlbExtRecord
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data MPTaskInfo = MPTaskInfo
  { mpTaskInfoVersion :: !CUInt
  , mpTaskInfoName :: !CUInt
  , mpTaskInfoQueueName :: !CUInt
  , mpTaskInfoRunState :: !CUShort
  , mpTaskInfoLastCPU :: !CUShort
  , mpTaskInfoWeight :: !CUInt
  , mpTaskInfoProcessID :: !(Ptr ())
  , mpTaskInfoCpuTime :: !AbsoluteTime
  , mpTaskInfoSchedTime :: !AbsoluteTime
  , mpTaskInfoCreationTime :: !AbsoluteTime
  , mpTaskInfoCodePageFaults :: !CULong
  , mpTaskInfoDataPageFaults :: !CULong
  , mpTaskInfoPreemptions :: !CULong
  , mpTaskInfoCpuID :: !(Ptr ())
  , mpTaskInfoBlockedObject :: !(Ptr ())
  , mpTaskInfoSpaceID :: !(Ptr ())
  , mpTaskInfoStackBase :: !(Ptr ())
  , mpTaskInfoStackLimit :: !(Ptr ())
  , mpTaskInfoStackCurr :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable MPTaskInfo where
  sizeOf    _ = 128
  alignment _ = 8
  peek p = MPTaskInfo <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
    <*> peekByteOff p 14
    <*> peekByteOff p 16
    <*> peekByteOff p 24
    <*> peekByteOff p 32
    <*> peekByteOff p 40
    <*> peekByteOff p 48
    <*> peekByteOff p 56
    <*> peekByteOff p 64
    <*> peekByteOff p 72
    <*> peekByteOff p 80
    <*> peekByteOff p 88
    <*> peekByteOff p 96
    <*> peekByteOff p 104
    <*> peekByteOff p 112
    <*> peekByteOff p 120
  poke p (MPTaskInfo {..}) = do
    pokeByteOff p 0 mpTaskInfoVersion
    pokeByteOff p 4 mpTaskInfoName
    pokeByteOff p 8 mpTaskInfoQueueName
    pokeByteOff p 12 mpTaskInfoRunState
    pokeByteOff p 14 mpTaskInfoLastCPU
    pokeByteOff p 16 mpTaskInfoWeight
    pokeByteOff p 24 mpTaskInfoProcessID
    pokeByteOff p 32 mpTaskInfoCpuTime
    pokeByteOff p 40 mpTaskInfoSchedTime
    pokeByteOff p 48 mpTaskInfoCreationTime
    pokeByteOff p 56 mpTaskInfoCodePageFaults
    pokeByteOff p 64 mpTaskInfoDataPageFaults
    pokeByteOff p 72 mpTaskInfoPreemptions
    pokeByteOff p 80 mpTaskInfoCpuID
    pokeByteOff p 88 mpTaskInfoBlockedObject
    pokeByteOff p 96 mpTaskInfoSpaceID
    pokeByteOff p 104 mpTaskInfoStackBase
    pokeByteOff p 112 mpTaskInfoStackLimit
    pokeByteOff p 120 mpTaskInfoStackCurr

{-# NOINLINE mpTaskInfoStructType #-}
mpTaskInfoStructType :: Ptr CType
mpTaskInfoStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint16, ffi_type_uint16, ffi_type_uint, ffi_type_pointer, absoluteTimeStructType, absoluteTimeStructType, absoluteTimeStructType, ffi_type_ulong, ffi_type_ulong, ffi_type_ulong, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer]

argMPTaskInfo :: MPTaskInfo -> Arg
argMPTaskInfo = mkStorableArg mpTaskInfoStructType

retMPTaskInfo :: RetType MPTaskInfo
retMPTaskInfo = mkStorableRetType mpTaskInfoStructType

instance ObjCArgument MPTaskInfo where
  withObjCArg x k = k (argMPTaskInfo x)

instance ObjCReturn MPTaskInfo where
  type RawReturn MPTaskInfo = MPTaskInfo
  objcRetType = retMPTaskInfo
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data MPTaskInfoVersion2 = MPTaskInfoVersion2
  { mpTaskInfoVersion2Version :: !CUInt
  , mpTaskInfoVersion2Name :: !CUInt
  , mpTaskInfoVersion2QueueName :: !CUInt
  , mpTaskInfoVersion2RunState :: !CUShort
  , mpTaskInfoVersion2LastCPU :: !CUShort
  , mpTaskInfoVersion2Weight :: !CUInt
  , mpTaskInfoVersion2ProcessID :: !(Ptr ())
  , mpTaskInfoVersion2CpuTime :: !AbsoluteTime
  , mpTaskInfoVersion2SchedTime :: !AbsoluteTime
  , mpTaskInfoVersion2CreationTime :: !AbsoluteTime
  , mpTaskInfoVersion2CodePageFaults :: !CULong
  , mpTaskInfoVersion2DataPageFaults :: !CULong
  , mpTaskInfoVersion2Preemptions :: !CULong
  , mpTaskInfoVersion2CpuID :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable MPTaskInfoVersion2 where
  sizeOf    _ = 88
  alignment _ = 8
  peek p = MPTaskInfoVersion2 <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
    <*> peekByteOff p 14
    <*> peekByteOff p 16
    <*> peekByteOff p 24
    <*> peekByteOff p 32
    <*> peekByteOff p 40
    <*> peekByteOff p 48
    <*> peekByteOff p 56
    <*> peekByteOff p 64
    <*> peekByteOff p 72
    <*> peekByteOff p 80
  poke p (MPTaskInfoVersion2 {..}) = do
    pokeByteOff p 0 mpTaskInfoVersion2Version
    pokeByteOff p 4 mpTaskInfoVersion2Name
    pokeByteOff p 8 mpTaskInfoVersion2QueueName
    pokeByteOff p 12 mpTaskInfoVersion2RunState
    pokeByteOff p 14 mpTaskInfoVersion2LastCPU
    pokeByteOff p 16 mpTaskInfoVersion2Weight
    pokeByteOff p 24 mpTaskInfoVersion2ProcessID
    pokeByteOff p 32 mpTaskInfoVersion2CpuTime
    pokeByteOff p 40 mpTaskInfoVersion2SchedTime
    pokeByteOff p 48 mpTaskInfoVersion2CreationTime
    pokeByteOff p 56 mpTaskInfoVersion2CodePageFaults
    pokeByteOff p 64 mpTaskInfoVersion2DataPageFaults
    pokeByteOff p 72 mpTaskInfoVersion2Preemptions
    pokeByteOff p 80 mpTaskInfoVersion2CpuID

{-# NOINLINE mpTaskInfoVersion2StructType #-}
mpTaskInfoVersion2StructType :: Ptr CType
mpTaskInfoVersion2StructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint16, ffi_type_uint16, ffi_type_uint, ffi_type_pointer, absoluteTimeStructType, absoluteTimeStructType, absoluteTimeStructType, ffi_type_ulong, ffi_type_ulong, ffi_type_ulong, ffi_type_pointer]

argMPTaskInfoVersion2 :: MPTaskInfoVersion2 -> Arg
argMPTaskInfoVersion2 = mkStorableArg mpTaskInfoVersion2StructType

retMPTaskInfoVersion2 :: RetType MPTaskInfoVersion2
retMPTaskInfoVersion2 = mkStorableRetType mpTaskInfoVersion2StructType

instance ObjCArgument MPTaskInfoVersion2 where
  withObjCArg x k = k (argMPTaskInfoVersion2 x)

instance ObjCReturn MPTaskInfoVersion2 where
  type RawReturn MPTaskInfoVersion2 = MPTaskInfoVersion2
  objcRetType = retMPTaskInfoVersion2
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data MachineInformationPowerPC = MachineInformationPowerPC
  { machineInformationPowerPCCTR :: !Nanoseconds
  , machineInformationPowerPCLR :: !Nanoseconds
  , machineInformationPowerPCPC :: !Nanoseconds
  , machineInformationPowerPCCRRegister :: !CULong
  , machineInformationPowerPCXER :: !CULong
  , machineInformationPowerPCMSR :: !CULong
  , machineInformationPowerPCMQ :: !CULong
  , machineInformationPowerPCExceptKind :: !CULong
  , machineInformationPowerPCDSISR :: !CULong
  , machineInformationPowerPCDAR :: !Nanoseconds
  , machineInformationPowerPCReserved :: !Nanoseconds
  } deriving (Eq, Show)

instance Storable MachineInformationPowerPC where
  sizeOf    _ = 88
  alignment _ = 8
  peek p = MachineInformationPowerPC <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 24
    <*> peekByteOff p 32
    <*> peekByteOff p 40
    <*> peekByteOff p 48
    <*> peekByteOff p 56
    <*> peekByteOff p 64
    <*> peekByteOff p 72
    <*> peekByteOff p 80
  poke p (MachineInformationPowerPC {..}) = do
    pokeByteOff p 0 machineInformationPowerPCCTR
    pokeByteOff p 8 machineInformationPowerPCLR
    pokeByteOff p 16 machineInformationPowerPCPC
    pokeByteOff p 24 machineInformationPowerPCCRRegister
    pokeByteOff p 32 machineInformationPowerPCXER
    pokeByteOff p 40 machineInformationPowerPCMSR
    pokeByteOff p 48 machineInformationPowerPCMQ
    pokeByteOff p 56 machineInformationPowerPCExceptKind
    pokeByteOff p 64 machineInformationPowerPCDSISR
    pokeByteOff p 72 machineInformationPowerPCDAR
    pokeByteOff p 80 machineInformationPowerPCReserved

{-# NOINLINE machineInformationPowerPCStructType #-}
machineInformationPowerPCStructType :: Ptr CType
machineInformationPowerPCStructType = unsafePerformIO $ fst <$> newStructCType [nanosecondsStructType, nanosecondsStructType, nanosecondsStructType, ffi_type_ulong, ffi_type_ulong, ffi_type_ulong, ffi_type_ulong, ffi_type_ulong, ffi_type_ulong, nanosecondsStructType, nanosecondsStructType]

argMachineInformationPowerPC :: MachineInformationPowerPC -> Arg
argMachineInformationPowerPC = mkStorableArg machineInformationPowerPCStructType

retMachineInformationPowerPC :: RetType MachineInformationPowerPC
retMachineInformationPowerPC = mkStorableRetType machineInformationPowerPCStructType

instance ObjCArgument MachineInformationPowerPC where
  withObjCArg x k = k (argMachineInformationPowerPC x)

instance ObjCReturn MachineInformationPowerPC where
  type RawReturn MachineInformationPowerPC = MachineInformationPowerPC
  objcRetType = retMachineInformationPowerPC
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data RegisterInformationPowerPC = RegisterInformationPowerPC
  { registerInformationPowerPCR0 :: !Nanoseconds
  , registerInformationPowerPCR1 :: !Nanoseconds
  , registerInformationPowerPCR2 :: !Nanoseconds
  , registerInformationPowerPCR3 :: !Nanoseconds
  , registerInformationPowerPCR4 :: !Nanoseconds
  , registerInformationPowerPCR5 :: !Nanoseconds
  , registerInformationPowerPCR6 :: !Nanoseconds
  , registerInformationPowerPCR7 :: !Nanoseconds
  , registerInformationPowerPCR8 :: !Nanoseconds
  , registerInformationPowerPCR9 :: !Nanoseconds
  , registerInformationPowerPCR10 :: !Nanoseconds
  , registerInformationPowerPCR11 :: !Nanoseconds
  , registerInformationPowerPCR12 :: !Nanoseconds
  , registerInformationPowerPCR13 :: !Nanoseconds
  , registerInformationPowerPCR14 :: !Nanoseconds
  , registerInformationPowerPCR15 :: !Nanoseconds
  , registerInformationPowerPCR16 :: !Nanoseconds
  , registerInformationPowerPCR17 :: !Nanoseconds
  , registerInformationPowerPCR18 :: !Nanoseconds
  , registerInformationPowerPCR19 :: !Nanoseconds
  , registerInformationPowerPCR20 :: !Nanoseconds
  , registerInformationPowerPCR21 :: !Nanoseconds
  , registerInformationPowerPCR22 :: !Nanoseconds
  , registerInformationPowerPCR23 :: !Nanoseconds
  , registerInformationPowerPCR24 :: !Nanoseconds
  , registerInformationPowerPCR25 :: !Nanoseconds
  , registerInformationPowerPCR26 :: !Nanoseconds
  , registerInformationPowerPCR27 :: !Nanoseconds
  , registerInformationPowerPCR28 :: !Nanoseconds
  , registerInformationPowerPCR29 :: !Nanoseconds
  , registerInformationPowerPCR30 :: !Nanoseconds
  , registerInformationPowerPCR31 :: !Nanoseconds
  } deriving (Eq, Show)

instance Storable RegisterInformationPowerPC where
  sizeOf    _ = 256
  alignment _ = 4
  peek p = RegisterInformationPowerPC <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 24
    <*> peekByteOff p 32
    <*> peekByteOff p 40
    <*> peekByteOff p 48
    <*> peekByteOff p 56
    <*> peekByteOff p 64
    <*> peekByteOff p 72
    <*> peekByteOff p 80
    <*> peekByteOff p 88
    <*> peekByteOff p 96
    <*> peekByteOff p 104
    <*> peekByteOff p 112
    <*> peekByteOff p 120
    <*> peekByteOff p 128
    <*> peekByteOff p 136
    <*> peekByteOff p 144
    <*> peekByteOff p 152
    <*> peekByteOff p 160
    <*> peekByteOff p 168
    <*> peekByteOff p 176
    <*> peekByteOff p 184
    <*> peekByteOff p 192
    <*> peekByteOff p 200
    <*> peekByteOff p 208
    <*> peekByteOff p 216
    <*> peekByteOff p 224
    <*> peekByteOff p 232
    <*> peekByteOff p 240
    <*> peekByteOff p 248
  poke p (RegisterInformationPowerPC {..}) = do
    pokeByteOff p 0 registerInformationPowerPCR0
    pokeByteOff p 8 registerInformationPowerPCR1
    pokeByteOff p 16 registerInformationPowerPCR2
    pokeByteOff p 24 registerInformationPowerPCR3
    pokeByteOff p 32 registerInformationPowerPCR4
    pokeByteOff p 40 registerInformationPowerPCR5
    pokeByteOff p 48 registerInformationPowerPCR6
    pokeByteOff p 56 registerInformationPowerPCR7
    pokeByteOff p 64 registerInformationPowerPCR8
    pokeByteOff p 72 registerInformationPowerPCR9
    pokeByteOff p 80 registerInformationPowerPCR10
    pokeByteOff p 88 registerInformationPowerPCR11
    pokeByteOff p 96 registerInformationPowerPCR12
    pokeByteOff p 104 registerInformationPowerPCR13
    pokeByteOff p 112 registerInformationPowerPCR14
    pokeByteOff p 120 registerInformationPowerPCR15
    pokeByteOff p 128 registerInformationPowerPCR16
    pokeByteOff p 136 registerInformationPowerPCR17
    pokeByteOff p 144 registerInformationPowerPCR18
    pokeByteOff p 152 registerInformationPowerPCR19
    pokeByteOff p 160 registerInformationPowerPCR20
    pokeByteOff p 168 registerInformationPowerPCR21
    pokeByteOff p 176 registerInformationPowerPCR22
    pokeByteOff p 184 registerInformationPowerPCR23
    pokeByteOff p 192 registerInformationPowerPCR24
    pokeByteOff p 200 registerInformationPowerPCR25
    pokeByteOff p 208 registerInformationPowerPCR26
    pokeByteOff p 216 registerInformationPowerPCR27
    pokeByteOff p 224 registerInformationPowerPCR28
    pokeByteOff p 232 registerInformationPowerPCR29
    pokeByteOff p 240 registerInformationPowerPCR30
    pokeByteOff p 248 registerInformationPowerPCR31

{-# NOINLINE registerInformationPowerPCStructType #-}
registerInformationPowerPCStructType :: Ptr CType
registerInformationPowerPCStructType = unsafePerformIO $ fst <$> newStructCType [nanosecondsStructType, nanosecondsStructType, nanosecondsStructType, nanosecondsStructType, nanosecondsStructType, nanosecondsStructType, nanosecondsStructType, nanosecondsStructType, nanosecondsStructType, nanosecondsStructType, nanosecondsStructType, nanosecondsStructType, nanosecondsStructType, nanosecondsStructType, nanosecondsStructType, nanosecondsStructType, nanosecondsStructType, nanosecondsStructType, nanosecondsStructType, nanosecondsStructType, nanosecondsStructType, nanosecondsStructType, nanosecondsStructType, nanosecondsStructType, nanosecondsStructType, nanosecondsStructType, nanosecondsStructType, nanosecondsStructType, nanosecondsStructType, nanosecondsStructType, nanosecondsStructType, nanosecondsStructType]

argRegisterInformationPowerPC :: RegisterInformationPowerPC -> Arg
argRegisterInformationPowerPC = mkStorableArg registerInformationPowerPCStructType

retRegisterInformationPowerPC :: RetType RegisterInformationPowerPC
retRegisterInformationPowerPC = mkStorableRetType registerInformationPowerPCStructType

instance ObjCArgument RegisterInformationPowerPC where
  withObjCArg x k = k (argRegisterInformationPowerPC x)

instance ObjCReturn RegisterInformationPowerPC where
  type RawReturn RegisterInformationPowerPC = RegisterInformationPowerPC
  objcRetType = retRegisterInformationPowerPC
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data TECConverterContextRec = TECConverterContextRec
  { tecConverterContextRecPluginRec :: !(Ptr ())
  , tecConverterContextRecSourceEncoding :: !CUInt
  , tecConverterContextRecDestEncoding :: !CUInt
  , tecConverterContextRecReserved1 :: !CUInt
  , tecConverterContextRecReserved2 :: !CUInt
  , tecConverterContextRecBufferContext :: !TECBufferContextRec
  , tecConverterContextRecContextRefCon :: !(Ptr ())
  , tecConverterContextRecConversionProc :: !(Ptr ())
  , tecConverterContextRecFlushProc :: !(Ptr ())
  , tecConverterContextRecClearContextInfoProc :: !(Ptr ())
  , tecConverterContextRecOptions1 :: !CUInt
  , tecConverterContextRecOptions2 :: !CUInt
  , tecConverterContextRecPluginState :: !TECPluginStateRec
  } deriving (Eq, Show)

instance Storable TECConverterContextRec where
  sizeOf    _ = 152
  alignment _ = 8
  peek p = TECConverterContextRec <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 12
    <*> peekByteOff p 16
    <*> peekByteOff p 20
    <*> peekByteOff p 24
    <*> peekByteOff p 88
    <*> peekByteOff p 96
    <*> peekByteOff p 104
    <*> peekByteOff p 112
    <*> peekByteOff p 120
    <*> peekByteOff p 124
    <*> peekByteOff p 128
  poke p (TECConverterContextRec {..}) = do
    pokeByteOff p 0 tecConverterContextRecPluginRec
    pokeByteOff p 8 tecConverterContextRecSourceEncoding
    pokeByteOff p 12 tecConverterContextRecDestEncoding
    pokeByteOff p 16 tecConverterContextRecReserved1
    pokeByteOff p 20 tecConverterContextRecReserved2
    pokeByteOff p 24 tecConverterContextRecBufferContext
    pokeByteOff p 88 tecConverterContextRecContextRefCon
    pokeByteOff p 96 tecConverterContextRecConversionProc
    pokeByteOff p 104 tecConverterContextRecFlushProc
    pokeByteOff p 112 tecConverterContextRecClearContextInfoProc
    pokeByteOff p 120 tecConverterContextRecOptions1
    pokeByteOff p 124 tecConverterContextRecOptions2
    pokeByteOff p 128 tecConverterContextRecPluginState

{-# NOINLINE tecConverterContextRecStructType #-}
tecConverterContextRecStructType :: Ptr CType
tecConverterContextRecStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, tecBufferContextRecStructType, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_uint, ffi_type_uint, tecPluginStateRecStructType]

argTECConverterContextRec :: TECConverterContextRec -> Arg
argTECConverterContextRec = mkStorableArg tecConverterContextRecStructType

retTECConverterContextRec :: RetType TECConverterContextRec
retTECConverterContextRec = mkStorableRetType tecConverterContextRecStructType

instance ObjCArgument TECConverterContextRec where
  withObjCArg x k = k (argTECConverterContextRec x)

instance ObjCReturn TECConverterContextRec where
  type RawReturn TECConverterContextRec = TECConverterContextRec
  objcRetType = retTECConverterContextRec
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data TECEncodingPairRec = TECEncodingPairRec
  { tecEncodingPairRecSource :: !TextEncodingRec
  , tecEncodingPairRecDest :: !TextEncodingRec
  } deriving (Eq, Show)

instance Storable TECEncodingPairRec where
  sizeOf    _ = 24
  alignment _ = 4
  peek p = TECEncodingPairRec <$> peekByteOff p 0
    <*> peekByteOff p 12
  poke p (TECEncodingPairRec {..}) = do
    pokeByteOff p 0 tecEncodingPairRecSource
    pokeByteOff p 12 tecEncodingPairRecDest

{-# NOINLINE tecEncodingPairRecStructType #-}
tecEncodingPairRecStructType :: Ptr CType
tecEncodingPairRecStructType = unsafePerformIO $ fst <$> newStructCType [textEncodingRecStructType, textEncodingRecStructType]

argTECEncodingPairRec :: TECEncodingPairRec -> Arg
argTECEncodingPairRec = mkStorableArg tecEncodingPairRecStructType

retTECEncodingPairRec :: RetType TECEncodingPairRec
retTECEncodingPairRec = mkStorableRetType tecEncodingPairRecStructType

instance ObjCArgument TECEncodingPairRec where
  withObjCArg x k = k (argTECEncodingPairRec x)

instance ObjCReturn TECEncodingPairRec where
  type RawReturn TECEncodingPairRec = TECEncodingPairRec
  objcRetType = retTECEncodingPairRec
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data TECEncodingsListRec = TECEncodingsListRec
  { tecEncodingsListRecCount :: !CUInt
  , tecEncodingsListRecEncodings :: !TextEncodingRec
  } deriving (Eq, Show)

instance Storable TECEncodingsListRec where
  sizeOf    _ = 16
  alignment _ = 4
  peek p = TECEncodingsListRec <$> peekByteOff p 0
    <*> peekByteOff p 4
  poke p (TECEncodingsListRec {..}) = do
    pokeByteOff p 0 tecEncodingsListRecCount
    pokeByteOff p 4 tecEncodingsListRecEncodings

{-# NOINLINE tecEncodingsListRecStructType #-}
tecEncodingsListRecStructType :: Ptr CType
tecEncodingsListRecStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, textEncodingRecStructType]

argTECEncodingsListRec :: TECEncodingsListRec -> Arg
argTECEncodingsListRec = mkStorableArg tecEncodingsListRecStructType

retTECEncodingsListRec :: RetType TECEncodingsListRec
retTECEncodingsListRec = mkStorableRetType tecEncodingsListRecStructType

instance ObjCArgument TECEncodingsListRec where
  withObjCArg x k = k (argTECEncodingsListRec x)

instance ObjCReturn TECEncodingsListRec where
  type RawReturn TECEncodingsListRec = TECEncodingsListRec
  objcRetType = retTECEncodingsListRec
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data TECLocaleToEncodingsListRec = TECLocaleToEncodingsListRec
  { tecLocaleToEncodingsListRecCount :: !CUInt
  , tecLocaleToEncodingsListRecLocaleListToEncodingList :: !TECLocaleListToEncodingListRec
  } deriving (Eq, Show)

instance Storable TECLocaleToEncodingsListRec where
  sizeOf    _ = 16
  alignment _ = 4
  peek p = TECLocaleToEncodingsListRec <$> peekByteOff p 0
    <*> peekByteOff p 4
  poke p (TECLocaleToEncodingsListRec {..}) = do
    pokeByteOff p 0 tecLocaleToEncodingsListRecCount
    pokeByteOff p 4 tecLocaleToEncodingsListRecLocaleListToEncodingList

{-# NOINLINE tecLocaleToEncodingsListRecStructType #-}
tecLocaleToEncodingsListRecStructType :: Ptr CType
tecLocaleToEncodingsListRecStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, tecLocaleListToEncodingListRecStructType]

argTECLocaleToEncodingsListRec :: TECLocaleToEncodingsListRec -> Arg
argTECLocaleToEncodingsListRec = mkStorableArg tecLocaleToEncodingsListRecStructType

retTECLocaleToEncodingsListRec :: RetType TECLocaleToEncodingsListRec
retTECLocaleToEncodingsListRec = mkStorableRetType tecLocaleToEncodingsListRecStructType

instance ObjCArgument TECLocaleToEncodingsListRec where
  withObjCArg x k = k (argTECLocaleToEncodingsListRec x)

instance ObjCReturn TECLocaleToEncodingsListRec where
  type RawReturn TECLocaleToEncodingsListRec = TECLocaleToEncodingsListRec
  objcRetType = retTECLocaleToEncodingsListRec
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data TECSnifferContextRec = TECSnifferContextRec
  { tecSnifferContextRecPluginRec :: !(Ptr ())
  , tecSnifferContextRecEncoding :: !CUInt
  , tecSnifferContextRecMaxErrors :: !CULong
  , tecSnifferContextRecMaxFeatures :: !CULong
  , tecSnifferContextRecTextInputBuffer :: !(Ptr ())
  , tecSnifferContextRecTextInputBufferEnd :: !(Ptr ())
  , tecSnifferContextRecNumFeatures :: !CULong
  , tecSnifferContextRecNumErrors :: !CULong
  , tecSnifferContextRecContextRefCon :: !(Ptr ())
  , tecSnifferContextRecSniffProc :: !(Ptr ())
  , tecSnifferContextRecClearContextInfoProc :: !(Ptr ())
  , tecSnifferContextRecPluginState :: !TECPluginStateRec
  } deriving (Eq, Show)

instance Storable TECSnifferContextRec where
  sizeOf    _ = 112
  alignment _ = 8
  peek p = TECSnifferContextRec <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 24
    <*> peekByteOff p 32
    <*> peekByteOff p 40
    <*> peekByteOff p 48
    <*> peekByteOff p 56
    <*> peekByteOff p 64
    <*> peekByteOff p 72
    <*> peekByteOff p 80
    <*> peekByteOff p 88
  poke p (TECSnifferContextRec {..}) = do
    pokeByteOff p 0 tecSnifferContextRecPluginRec
    pokeByteOff p 8 tecSnifferContextRecEncoding
    pokeByteOff p 16 tecSnifferContextRecMaxErrors
    pokeByteOff p 24 tecSnifferContextRecMaxFeatures
    pokeByteOff p 32 tecSnifferContextRecTextInputBuffer
    pokeByteOff p 40 tecSnifferContextRecTextInputBufferEnd
    pokeByteOff p 48 tecSnifferContextRecNumFeatures
    pokeByteOff p 56 tecSnifferContextRecNumErrors
    pokeByteOff p 64 tecSnifferContextRecContextRefCon
    pokeByteOff p 72 tecSnifferContextRecSniffProc
    pokeByteOff p 80 tecSnifferContextRecClearContextInfoProc
    pokeByteOff p 88 tecSnifferContextRecPluginState

{-# NOINLINE tecSnifferContextRecStructType #-}
tecSnifferContextRecStructType :: Ptr CType
tecSnifferContextRecStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer, ffi_type_uint, ffi_type_ulong, ffi_type_ulong, ffi_type_pointer, ffi_type_pointer, ffi_type_ulong, ffi_type_ulong, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, tecPluginStateRecStructType]

argTECSnifferContextRec :: TECSnifferContextRec -> Arg
argTECSnifferContextRec = mkStorableArg tecSnifferContextRecStructType

retTECSnifferContextRec :: RetType TECSnifferContextRec
retTECSnifferContextRec = mkStorableRetType tecSnifferContextRecStructType

instance ObjCArgument TECSnifferContextRec where
  withObjCArg x k = k (argTECSnifferContextRec x)

instance ObjCReturn TECSnifferContextRec where
  type RawReturn TECSnifferContextRec = TECSnifferContextRec
  objcRetType = retTECSnifferContextRec
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data TECSubTextEncodingRec = TECSubTextEncodingRec
  { tecSubTextEncodingRecOffset :: !CUInt
  , tecSubTextEncodingRecSearchEncoding :: !TextEncodingRec
  , tecSubTextEncodingRecCount :: !CUInt
  , tecSubTextEncodingRecSubEncodings :: !TextEncodingRec
  } deriving (Eq, Show)

instance Storable TECSubTextEncodingRec where
  sizeOf    _ = 32
  alignment _ = 4
  peek p = TECSubTextEncodingRec <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 16
    <*> peekByteOff p 20
  poke p (TECSubTextEncodingRec {..}) = do
    pokeByteOff p 0 tecSubTextEncodingRecOffset
    pokeByteOff p 4 tecSubTextEncodingRecSearchEncoding
    pokeByteOff p 16 tecSubTextEncodingRecCount
    pokeByteOff p 20 tecSubTextEncodingRecSubEncodings

{-# NOINLINE tecSubTextEncodingRecStructType #-}
tecSubTextEncodingRecStructType :: Ptr CType
tecSubTextEncodingRecStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, textEncodingRecStructType, ffi_type_uint, textEncodingRecStructType]

argTECSubTextEncodingRec :: TECSubTextEncodingRec -> Arg
argTECSubTextEncodingRec = mkStorableArg tecSubTextEncodingRecStructType

retTECSubTextEncodingRec :: RetType TECSubTextEncodingRec
retTECSubTextEncodingRec = mkStorableRetType tecSubTextEncodingRecStructType

instance ObjCArgument TECSubTextEncodingRec where
  withObjCArg x k = k (argTECSubTextEncodingRec x)

instance ObjCReturn TECSubTextEncodingRec where
  type RawReturn TECSubTextEncodingRec = TECSubTextEncodingRec
  objcRetType = retTECSubTextEncodingRec
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data ComponentAliasResource = ComponentAliasResource
  { componentAliasResourceCr :: !ComponentResource
  , componentAliasResourceAliasCD :: !ComponentDescription
  } deriving (Eq, Show)

instance Storable ComponentAliasResource where
  sizeOf    _ = 72
  alignment _ = 4
  peek p = ComponentAliasResource <$> peekByteOff p 0
    <*> peekByteOff p 52
  poke p (ComponentAliasResource {..}) = do
    pokeByteOff p 0 componentAliasResourceCr
    pokeByteOff p 52 componentAliasResourceAliasCD

{-# NOINLINE componentAliasResourceStructType #-}
componentAliasResourceStructType :: Ptr CType
componentAliasResourceStructType = unsafePerformIO $ fst <$> newStructCType [componentResourceStructType, componentDescriptionStructType]

argComponentAliasResource :: ComponentAliasResource -> Arg
argComponentAliasResource = mkStorableArg componentAliasResourceStructType

retComponentAliasResource :: RetType ComponentAliasResource
retComponentAliasResource = mkStorableRetType componentAliasResourceStructType

instance ObjCArgument ComponentAliasResource where
  withObjCArg x k = k (argComponentAliasResource x)

instance ObjCReturn ComponentAliasResource where
  type RawReturn ComponentAliasResource = ComponentAliasResource
  objcRetType = retComponentAliasResource
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data TECEncodingPairs = TECEncodingPairs
  { tecEncodingPairsEncodingPair :: !TECEncodingPairRec
  , tecEncodingPairsFlags :: !CUInt
  , tecEncodingPairsSpeed :: !CUInt
  } deriving (Eq, Show)

instance Storable TECEncodingPairs where
  sizeOf    _ = 32
  alignment _ = 4
  peek p = TECEncodingPairs <$> peekByteOff p 0
    <*> peekByteOff p 24
    <*> peekByteOff p 28
  poke p (TECEncodingPairs {..}) = do
    pokeByteOff p 0 tecEncodingPairsEncodingPair
    pokeByteOff p 24 tecEncodingPairsFlags
    pokeByteOff p 28 tecEncodingPairsSpeed

{-# NOINLINE tecEncodingPairsStructType #-}
tecEncodingPairsStructType :: Ptr CType
tecEncodingPairsStructType = unsafePerformIO $ fst <$> newStructCType [tecEncodingPairRecStructType, ffi_type_uint, ffi_type_uint]

argTECEncodingPairs :: TECEncodingPairs -> Arg
argTECEncodingPairs = mkStorableArg tecEncodingPairsStructType

retTECEncodingPairs :: RetType TECEncodingPairs
retTECEncodingPairs = mkStorableRetType tecEncodingPairsStructType

instance ObjCArgument TECEncodingPairs where
  withObjCArg x k = k (argTECEncodingPairs x)

instance ObjCReturn TECEncodingPairs where
  type RawReturn TECEncodingPairs = TECEncodingPairs
  objcRetType = retTECEncodingPairs
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data TECSubTextEncodingsRec = TECSubTextEncodingsRec
  { tecSubTextEncodingsRecCount :: !CUInt
  , tecSubTextEncodingsRecSubTextEncodingRec :: !TECSubTextEncodingRec
  } deriving (Eq, Show)

instance Storable TECSubTextEncodingsRec where
  sizeOf    _ = 36
  alignment _ = 4
  peek p = TECSubTextEncodingsRec <$> peekByteOff p 0
    <*> peekByteOff p 4
  poke p (TECSubTextEncodingsRec {..}) = do
    pokeByteOff p 0 tecSubTextEncodingsRecCount
    pokeByteOff p 4 tecSubTextEncodingsRecSubTextEncodingRec

{-# NOINLINE tecSubTextEncodingsRecStructType #-}
tecSubTextEncodingsRecStructType :: Ptr CType
tecSubTextEncodingsRecStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, tecSubTextEncodingRecStructType]

argTECSubTextEncodingsRec :: TECSubTextEncodingsRec -> Arg
argTECSubTextEncodingsRec = mkStorableArg tecSubTextEncodingsRecStructType

retTECSubTextEncodingsRec :: RetType TECSubTextEncodingsRec
retTECSubTextEncodingsRec = mkStorableRetType tecSubTextEncodingsRecStructType

instance ObjCArgument TECSubTextEncodingsRec where
  withObjCArg x k = k (argTECSubTextEncodingsRec x)

instance ObjCReturn TECSubTextEncodingsRec where
  type RawReturn TECSubTextEncodingsRec = TECSubTextEncodingsRec
  objcRetType = retTECSubTextEncodingsRec
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data TECEncodingPairsRec = TECEncodingPairsRec
  { tecEncodingPairsRecCount :: !CUInt
  , tecEncodingPairsRecEncodingPairs :: !TECEncodingPairs
  } deriving (Eq, Show)

instance Storable TECEncodingPairsRec where
  sizeOf    _ = 36
  alignment _ = 4
  peek p = TECEncodingPairsRec <$> peekByteOff p 0
    <*> peekByteOff p 4
  poke p (TECEncodingPairsRec {..}) = do
    pokeByteOff p 0 tecEncodingPairsRecCount
    pokeByteOff p 4 tecEncodingPairsRecEncodingPairs

{-# NOINLINE tecEncodingPairsRecStructType #-}
tecEncodingPairsRecStructType :: Ptr CType
tecEncodingPairsRecStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, tecEncodingPairsStructType]

argTECEncodingPairsRec :: TECEncodingPairsRec -> Arg
argTECEncodingPairsRec = mkStorableArg tecEncodingPairsRecStructType

retTECEncodingPairsRec :: RetType TECEncodingPairsRec
retTECEncodingPairsRec = mkStorableRetType tecEncodingPairsRecStructType

instance ObjCArgument TECEncodingPairsRec where
  withObjCArg x k = k (argTECEncodingPairsRec x)

instance ObjCReturn TECEncodingPairsRec where
  type RawReturn TECEncodingPairsRec = TECEncodingPairsRec
  objcRetType = retTECEncodingPairsRec
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure
