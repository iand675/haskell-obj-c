{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TypeFamilies #-}

-- | Struct types for this framework.
--
-- Generated by objc-codegen. Do not edit.
module ObjC.CoreText.Internal.Structs where

import Foreign.Ptr (Ptr, FunPtr)
import Foreign.Storable (Storable(..))
import Foreign.C.Types
import Foreign.LibFFI.Base (Arg, RetType, mkStorableArg, mkStorableRetType, newStructCType)
import Foreign.LibFFI.FFITypes
import Foreign.LibFFI.Internal (CType)
import System.IO.Unsafe (unsafePerformIO)
import ObjC.Runtime.Message (ObjCArgument(..), ObjCReturn(..), MsgSendVariant(..))
import ObjC.CoreText.Internal.Enums

data ALMXGlyphEntry = ALMXGlyphEntry
  { almxGlyphEntryGlyphIndexOffset :: !CShort
  , almxGlyphEntryHorizontalAdvance :: !CShort
  , almxGlyphEntryXOffsetToHOrigin :: !CShort
  , almxGlyphEntryVerticalAdvance :: !CShort
  , almxGlyphEntryYOffsetToVOrigin :: !CShort
  } deriving (Eq, Show)

instance Storable ALMXGlyphEntry where
  sizeOf    _ = 10
  alignment _ = 2
  peek p = ALMXGlyphEntry <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 6
    <*> peekByteOff p 8
  poke p (ALMXGlyphEntry {..}) = do
    pokeByteOff p 0 almxGlyphEntryGlyphIndexOffset
    pokeByteOff p 2 almxGlyphEntryHorizontalAdvance
    pokeByteOff p 4 almxGlyphEntryXOffsetToHOrigin
    pokeByteOff p 6 almxGlyphEntryVerticalAdvance
    pokeByteOff p 8 almxGlyphEntryYOffsetToVOrigin

{-# NOINLINE almxGlyphEntryStructType #-}
almxGlyphEntryStructType :: Ptr CType
almxGlyphEntryStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16]

argALMXGlyphEntry :: ALMXGlyphEntry -> Arg
argALMXGlyphEntry = mkStorableArg almxGlyphEntryStructType

retALMXGlyphEntry :: RetType ALMXGlyphEntry
retALMXGlyphEntry = mkStorableRetType almxGlyphEntryStructType

instance ObjCArgument ALMXGlyphEntry where
  withObjCArg x k = k (argALMXGlyphEntry x)

instance ObjCReturn ALMXGlyphEntry where
  type RawReturn ALMXGlyphEntry = ALMXGlyphEntry
  objcRetType = retALMXGlyphEntry
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data ALMXHeader = ALMXHeader
  { almxHeaderVersion :: !CInt
  , almxHeaderFlags :: !CUShort
  , almxHeaderNMasters :: !CUShort
  , almxHeaderFirstGlyph :: !CUShort
  , almxHeaderLastGlyph :: !CUShort
  , almxHeaderLookup :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable ALMXHeader where
  sizeOf    _ = 24
  alignment _ = 8
  peek p = ALMXHeader <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 6
    <*> peekByteOff p 8
    <*> peekByteOff p 10
    <*> peekByteOff p 16
  poke p (ALMXHeader {..}) = do
    pokeByteOff p 0 almxHeaderVersion
    pokeByteOff p 4 almxHeaderFlags
    pokeByteOff p 6 almxHeaderNMasters
    pokeByteOff p 8 almxHeaderFirstGlyph
    pokeByteOff p 10 almxHeaderLastGlyph
    pokeByteOff p 16 almxHeaderLookup

{-# NOINLINE almxHeaderStructType #-}
almxHeaderStructType :: Ptr CType
almxHeaderStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16, ffi_type_pointer]

argALMXHeader :: ALMXHeader -> Arg
argALMXHeader = mkStorableArg almxHeaderStructType

retALMXHeader :: RetType ALMXHeader
retALMXHeader = mkStorableRetType almxHeaderStructType

instance ObjCArgument ALMXHeader where
  withObjCArg x k = k (argALMXHeader x)

instance ObjCReturn ALMXHeader where
  type RawReturn ALMXHeader = ALMXHeader
  objcRetType = retALMXHeader
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data AnchorPoint = AnchorPoint
  { anchorPointX :: !CShort
  , anchorPointY :: !CShort
  } deriving (Eq, Show)

instance Storable AnchorPoint where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = AnchorPoint <$> peekByteOff p 0
    <*> peekByteOff p 2
  poke p (AnchorPoint {..}) = do
    pokeByteOff p 0 anchorPointX
    pokeByteOff p 2 anchorPointY

{-# NOINLINE anchorPointStructType #-}
anchorPointStructType :: Ptr CType
anchorPointStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16, ffi_type_sint16]

argAnchorPoint :: AnchorPoint -> Arg
argAnchorPoint = mkStorableArg anchorPointStructType

retAnchorPoint :: RetType AnchorPoint
retAnchorPoint = mkStorableRetType anchorPointStructType

instance ObjCArgument AnchorPoint where
  withObjCArg x k = k (argAnchorPoint x)

instance ObjCReturn AnchorPoint where
  type RawReturn AnchorPoint = AnchorPoint
  objcRetType = retAnchorPoint
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data AnkrTable = AnkrTable
  { ankrTableVersion :: !CUShort
  , ankrTableFlags :: !CUShort
  , ankrTableLookupTableOffset :: !CUInt
  , ankrTableAnchorPointTableOffset :: !CUInt
  } deriving (Eq, Show)

instance Storable AnkrTable where
  sizeOf    _ = 12
  alignment _ = 4
  peek p = AnkrTable <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (AnkrTable {..}) = do
    pokeByteOff p 0 ankrTableVersion
    pokeByteOff p 2 ankrTableFlags
    pokeByteOff p 4 ankrTableLookupTableOffset
    pokeByteOff p 8 ankrTableAnchorPointTableOffset

{-# NOINLINE ankrTableStructType #-}
ankrTableStructType :: Ptr CType
ankrTableStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint, ffi_type_uint]

argAnkrTable :: AnkrTable -> Arg
argAnkrTable = mkStorableArg ankrTableStructType

retAnkrTable :: RetType AnkrTable
retAnkrTable = mkStorableRetType ankrTableStructType

instance ObjCArgument AnkrTable where
  withObjCArg x k = k (argAnkrTable x)

instance ObjCReturn AnkrTable where
  type RawReturn AnkrTable = AnkrTable
  objcRetType = retAnkrTable
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | CTParagraphStyleSetting
--
-- This structure is used to alter the paragraph style.
--
-- spec                The specifier of the setting.
--
-- valueSize                The size of the value pointed to by the "value" field. This                must match the size of the value required by the                CTParagraphStyleSpecifier set in the "spec" field.
--
-- value                A reference to the value of the setting specified by the                "spec" field. The value must be in the proper range for the                spec value. The value must also be at least valueSize.
data CTParagraphStyleSetting = CTParagraphStyleSetting
  { ctParagraphStyleSettingSpec :: !CTParagraphStyleSpecifier
  , ctParagraphStyleSettingValueSize :: !CULong
  , ctParagraphStyleSettingValue :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable CTParagraphStyleSetting where
  sizeOf    _ = 24
  alignment _ = 8
  peek p = CTParagraphStyleSetting <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
  poke p (CTParagraphStyleSetting {..}) = do
    pokeByteOff p 0 ctParagraphStyleSettingSpec
    pokeByteOff p 8 ctParagraphStyleSettingValueSize
    pokeByteOff p 16 ctParagraphStyleSettingValue

{-# NOINLINE ctParagraphStyleSettingStructType #-}
ctParagraphStyleSettingStructType :: Ptr CType
ctParagraphStyleSettingStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_ulong, ffi_type_pointer]

argCTParagraphStyleSetting :: CTParagraphStyleSetting -> Arg
argCTParagraphStyleSetting = mkStorableArg ctParagraphStyleSettingStructType

retCTParagraphStyleSetting :: RetType CTParagraphStyleSetting
retCTParagraphStyleSetting = mkStorableRetType ctParagraphStyleSettingStructType

instance ObjCArgument CTParagraphStyleSetting where
  withObjCArg x k = k (argCTParagraphStyleSetting x)

instance ObjCReturn CTParagraphStyleSetting where
  type RawReturn CTParagraphStyleSetting = CTParagraphStyleSetting
  objcRetType = retCTParagraphStyleSetting
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data FontVariation = FontVariation
  { fontVariationName :: !CUInt
  , fontVariationValue :: !CInt
  } deriving (Eq, Show)

instance Storable FontVariation where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = FontVariation <$> peekByteOff p 0
    <*> peekByteOff p 4
  poke p (FontVariation {..}) = do
    pokeByteOff p 0 fontVariationName
    pokeByteOff p 4 fontVariationValue

{-# NOINLINE fontVariationStructType #-}
fontVariationStructType :: Ptr CType
fontVariationStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_sint]

argFontVariation :: FontVariation -> Arg
argFontVariation = mkStorableArg fontVariationStructType

retFontVariation :: RetType FontVariation
retFontVariation = mkStorableRetType fontVariationStructType

instance ObjCArgument FontVariation where
  withObjCArg x k = k (argFontVariation x)

instance ObjCReturn FontVariation where
  type RawReturn FontVariation = FontVariation
  objcRetType = retFontVariation
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data JustDirectionTable = JustDirectionTable
  { justDirectionTableJustClass :: !CUShort
  , justDirectionTableWidthDeltaClusters :: !CUShort
  , justDirectionTablePostcomp :: !CUShort
  , justDirectionTableLookup :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable JustDirectionTable where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = JustDirectionTable <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (JustDirectionTable {..}) = do
    pokeByteOff p 0 justDirectionTableJustClass
    pokeByteOff p 2 justDirectionTableWidthDeltaClusters
    pokeByteOff p 4 justDirectionTablePostcomp
    pokeByteOff p 8 justDirectionTableLookup

{-# NOINLINE justDirectionTableStructType #-}
justDirectionTableStructType :: Ptr CType
justDirectionTableStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint16, ffi_type_pointer]

argJustDirectionTable :: JustDirectionTable -> Arg
argJustDirectionTable = mkStorableArg justDirectionTableStructType

retJustDirectionTable :: RetType JustDirectionTable
retJustDirectionTable = mkStorableRetType justDirectionTableStructType

instance ObjCArgument JustDirectionTable where
  withObjCArg x k = k (argJustDirectionTable x)

instance ObjCReturn JustDirectionTable where
  type RawReturn JustDirectionTable = JustDirectionTable
  objcRetType = retJustDirectionTable
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data JustPCActionSubrecord = JustPCActionSubrecord
  { justPCActionSubrecordTheClass :: !CUShort
  , justPCActionSubrecordTheType :: !CUShort
  , justPCActionSubrecordLength :: !CUInt
  , justPCActionSubrecordData :: !CUInt
  } deriving (Eq, Show)

instance Storable JustPCActionSubrecord where
  sizeOf    _ = 12
  alignment _ = 4
  peek p = JustPCActionSubrecord <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (JustPCActionSubrecord {..}) = do
    pokeByteOff p 0 justPCActionSubrecordTheClass
    pokeByteOff p 2 justPCActionSubrecordTheType
    pokeByteOff p 4 justPCActionSubrecordLength
    pokeByteOff p 8 justPCActionSubrecordData

{-# NOINLINE justPCActionSubrecordStructType #-}
justPCActionSubrecordStructType :: Ptr CType
justPCActionSubrecordStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint, ffi_type_uint]

argJustPCActionSubrecord :: JustPCActionSubrecord -> Arg
argJustPCActionSubrecord = mkStorableArg justPCActionSubrecordStructType

retJustPCActionSubrecord :: RetType JustPCActionSubrecord
retJustPCActionSubrecord = mkStorableRetType justPCActionSubrecordStructType

instance ObjCArgument JustPCActionSubrecord where
  withObjCArg x k = k (argJustPCActionSubrecord x)

instance ObjCReturn JustPCActionSubrecord where
  type RawReturn JustPCActionSubrecord = JustPCActionSubrecord
  objcRetType = retJustPCActionSubrecord
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data JustPCConditionalAddAction = JustPCConditionalAddAction
  { justPCConditionalAddActionSubstThreshold :: !CInt
  , justPCConditionalAddActionAddGlyph :: !CUShort
  , justPCConditionalAddActionSubstGlyph :: !CUShort
  } deriving (Eq, Show)

instance Storable JustPCConditionalAddAction where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = JustPCConditionalAddAction <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 6
  poke p (JustPCConditionalAddAction {..}) = do
    pokeByteOff p 0 justPCConditionalAddActionSubstThreshold
    pokeByteOff p 4 justPCConditionalAddActionAddGlyph
    pokeByteOff p 6 justPCConditionalAddActionSubstGlyph

{-# NOINLINE justPCConditionalAddActionStructType #-}
justPCConditionalAddActionStructType :: Ptr CType
justPCConditionalAddActionStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_uint16, ffi_type_uint16]

argJustPCConditionalAddAction :: JustPCConditionalAddAction -> Arg
argJustPCConditionalAddAction = mkStorableArg justPCConditionalAddActionStructType

retJustPCConditionalAddAction :: RetType JustPCConditionalAddAction
retJustPCConditionalAddAction = mkStorableRetType justPCConditionalAddActionStructType

instance ObjCArgument JustPCConditionalAddAction where
  withObjCArg x k = k (argJustPCConditionalAddAction x)

instance ObjCReturn JustPCConditionalAddAction where
  type RawReturn JustPCConditionalAddAction = JustPCConditionalAddAction
  objcRetType = retJustPCConditionalAddAction
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data JustPCDuctilityAction = JustPCDuctilityAction
  { justPCDuctilityActionDuctilityAxis :: !CUInt
  , justPCDuctilityActionMinimumLimit :: !CInt
  , justPCDuctilityActionNoStretchValue :: !CInt
  , justPCDuctilityActionMaximumLimit :: !CInt
  } deriving (Eq, Show)

instance Storable JustPCDuctilityAction where
  sizeOf    _ = 16
  alignment _ = 4
  peek p = JustPCDuctilityAction <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
  poke p (JustPCDuctilityAction {..}) = do
    pokeByteOff p 0 justPCDuctilityActionDuctilityAxis
    pokeByteOff p 4 justPCDuctilityActionMinimumLimit
    pokeByteOff p 8 justPCDuctilityActionNoStretchValue
    pokeByteOff p 12 justPCDuctilityActionMaximumLimit

{-# NOINLINE justPCDuctilityActionStructType #-}
justPCDuctilityActionStructType :: Ptr CType
justPCDuctilityActionStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_sint, ffi_type_sint, ffi_type_sint]

argJustPCDuctilityAction :: JustPCDuctilityAction -> Arg
argJustPCDuctilityAction = mkStorableArg justPCDuctilityActionStructType

retJustPCDuctilityAction :: RetType JustPCDuctilityAction
retJustPCDuctilityAction = mkStorableRetType justPCDuctilityActionStructType

instance ObjCArgument JustPCDuctilityAction where
  withObjCArg x k = k (argJustPCDuctilityAction x)

instance ObjCReturn JustPCDuctilityAction where
  type RawReturn JustPCDuctilityAction = JustPCDuctilityAction
  objcRetType = retJustPCDuctilityAction
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data JustPCGlyphRepeatAddAction = JustPCGlyphRepeatAddAction
  { justPCGlyphRepeatAddActionFlags :: !CUShort
  , justPCGlyphRepeatAddActionGlyph :: !CUShort
  } deriving (Eq, Show)

instance Storable JustPCGlyphRepeatAddAction where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = JustPCGlyphRepeatAddAction <$> peekByteOff p 0
    <*> peekByteOff p 2
  poke p (JustPCGlyphRepeatAddAction {..}) = do
    pokeByteOff p 0 justPCGlyphRepeatAddActionFlags
    pokeByteOff p 2 justPCGlyphRepeatAddActionGlyph

{-# NOINLINE justPCGlyphRepeatAddActionStructType #-}
justPCGlyphRepeatAddActionStructType :: Ptr CType
justPCGlyphRepeatAddActionStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16]

argJustPCGlyphRepeatAddAction :: JustPCGlyphRepeatAddAction -> Arg
argJustPCGlyphRepeatAddAction = mkStorableArg justPCGlyphRepeatAddActionStructType

retJustPCGlyphRepeatAddAction :: RetType JustPCGlyphRepeatAddAction
retJustPCGlyphRepeatAddAction = mkStorableRetType justPCGlyphRepeatAddActionStructType

instance ObjCArgument JustPCGlyphRepeatAddAction where
  withObjCArg x k = k (argJustPCGlyphRepeatAddAction x)

instance ObjCReturn JustPCGlyphRepeatAddAction where
  type RawReturn JustPCGlyphRepeatAddAction = JustPCGlyphRepeatAddAction
  objcRetType = retJustPCGlyphRepeatAddAction
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data JustPostcompTable = JustPostcompTable
  { justPostcompTableLookupTable :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable JustPostcompTable where
  sizeOf    _ = 8
  alignment _ = 8
  peek p = JustPostcompTable <$> peekByteOff p 0
  poke p (JustPostcompTable {..}) =
    pokeByteOff p 0 justPostcompTableLookupTable

{-# NOINLINE justPostcompTableStructType #-}
justPostcompTableStructType :: Ptr CType
justPostcompTableStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer]

argJustPostcompTable :: JustPostcompTable -> Arg
argJustPostcompTable = mkStorableArg justPostcompTableStructType

retJustPostcompTable :: RetType JustPostcompTable
retJustPostcompTable = mkStorableRetType justPostcompTableStructType

instance ObjCArgument JustPostcompTable where
  withObjCArg x k = k (argJustPostcompTable x)

instance ObjCReturn JustPostcompTable where
  type RawReturn JustPostcompTable = JustPostcompTable
  objcRetType = retJustPostcompTable
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data JustTable = JustTable
  { justTableVersion :: !CInt
  , justTableFormat :: !CUShort
  , justTableHorizHeaderOffset :: !CUShort
  , justTableVertHeaderOffset :: !CUShort
  } deriving (Eq, Show)

instance Storable JustTable where
  sizeOf    _ = 12
  alignment _ = 4
  peek p = JustTable <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 6
    <*> peekByteOff p 8
  poke p (JustTable {..}) = do
    pokeByteOff p 0 justTableVersion
    pokeByteOff p 4 justTableFormat
    pokeByteOff p 6 justTableHorizHeaderOffset
    pokeByteOff p 8 justTableVertHeaderOffset

{-# NOINLINE justTableStructType #-}
justTableStructType :: Ptr CType
justTableStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argJustTable :: JustTable -> Arg
argJustTable = mkStorableArg justTableStructType

retJustTable :: RetType JustTable
retJustTable = mkStorableRetType justTableStructType

instance ObjCArgument JustTable where
  withObjCArg x k = k (argJustTable x)

instance ObjCReturn JustTable where
  type RawReturn JustTable = JustTable
  objcRetType = retJustTable
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data JustWidthDeltaEntry = JustWidthDeltaEntry
  { justWidthDeltaEntryJustClass :: !CUInt
  , justWidthDeltaEntryBeforeGrowLimit :: !CInt
  , justWidthDeltaEntryBeforeShrinkLimit :: !CInt
  , justWidthDeltaEntryAfterGrowLimit :: !CInt
  , justWidthDeltaEntryAfterShrinkLimit :: !CInt
  , justWidthDeltaEntryGrowFlags :: !CUShort
  , justWidthDeltaEntryShrinkFlags :: !CUShort
  } deriving (Eq, Show)

instance Storable JustWidthDeltaEntry where
  sizeOf    _ = 24
  alignment _ = 4
  peek p = JustWidthDeltaEntry <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
    <*> peekByteOff p 16
    <*> peekByteOff p 20
    <*> peekByteOff p 22
  poke p (JustWidthDeltaEntry {..}) = do
    pokeByteOff p 0 justWidthDeltaEntryJustClass
    pokeByteOff p 4 justWidthDeltaEntryBeforeGrowLimit
    pokeByteOff p 8 justWidthDeltaEntryBeforeShrinkLimit
    pokeByteOff p 12 justWidthDeltaEntryAfterGrowLimit
    pokeByteOff p 16 justWidthDeltaEntryAfterShrinkLimit
    pokeByteOff p 20 justWidthDeltaEntryGrowFlags
    pokeByteOff p 22 justWidthDeltaEntryShrinkFlags

{-# NOINLINE justWidthDeltaEntryStructType #-}
justWidthDeltaEntryStructType :: Ptr CType
justWidthDeltaEntryStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_sint, ffi_type_sint, ffi_type_sint, ffi_type_sint, ffi_type_uint16, ffi_type_uint16]

argJustWidthDeltaEntry :: JustWidthDeltaEntry -> Arg
argJustWidthDeltaEntry = mkStorableArg justWidthDeltaEntryStructType

retJustWidthDeltaEntry :: RetType JustWidthDeltaEntry
retJustWidthDeltaEntry = mkStorableRetType justWidthDeltaEntryStructType

instance ObjCArgument JustWidthDeltaEntry where
  withObjCArg x k = k (argJustWidthDeltaEntry x)

instance ObjCReturn JustWidthDeltaEntry where
  type RawReturn JustWidthDeltaEntry = JustWidthDeltaEntry
  objcRetType = retJustWidthDeltaEntry
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data KernKerningPair = KernKerningPair
  { kernKerningPairLeft :: !CUShort
  , kernKerningPairRight :: !CUShort
  } deriving (Eq, Show)

instance Storable KernKerningPair where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = KernKerningPair <$> peekByteOff p 0
    <*> peekByteOff p 2
  poke p (KernKerningPair {..}) = do
    pokeByteOff p 0 kernKerningPairLeft
    pokeByteOff p 2 kernKerningPairRight

{-# NOINLINE kernKerningPairStructType #-}
kernKerningPairStructType :: Ptr CType
kernKerningPairStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16]

argKernKerningPair :: KernKerningPair -> Arg
argKernKerningPair = mkStorableArg kernKerningPairStructType

retKernKerningPair :: RetType KernKerningPair
retKernKerningPair = mkStorableRetType kernKerningPairStructType

instance ObjCArgument KernKerningPair where
  withObjCArg x k = k (argKernKerningPair x)

instance ObjCReturn KernKerningPair where
  type RawReturn KernKerningPair = KernKerningPair
  objcRetType = retKernKerningPair
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data KernStateEntry = KernStateEntry
  { kernStateEntryNewState :: !CUShort
  , kernStateEntryFlags :: !CUShort
  } deriving (Eq, Show)

instance Storable KernStateEntry where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = KernStateEntry <$> peekByteOff p 0
    <*> peekByteOff p 2
  poke p (KernStateEntry {..}) = do
    pokeByteOff p 0 kernStateEntryNewState
    pokeByteOff p 2 kernStateEntryFlags

{-# NOINLINE kernStateEntryStructType #-}
kernStateEntryStructType :: Ptr CType
kernStateEntryStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16]

argKernStateEntry :: KernStateEntry -> Arg
argKernStateEntry = mkStorableArg kernStateEntryStructType

retKernStateEntry :: RetType KernStateEntry
retKernStateEntry = mkStorableRetType kernStateEntryStructType

instance ObjCArgument KernStateEntry where
  withObjCArg x k = k (argKernStateEntry x)

instance ObjCReturn KernStateEntry where
  type RawReturn KernStateEntry = KernStateEntry
  objcRetType = retKernStateEntry
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data KerxAnchorPointAction = KerxAnchorPointAction
  { kerxAnchorPointActionMarkAnchorPoint :: !CUShort
  , kerxAnchorPointActionCurrAnchorPoint :: !CUShort
  } deriving (Eq, Show)

instance Storable KerxAnchorPointAction where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = KerxAnchorPointAction <$> peekByteOff p 0
    <*> peekByteOff p 2
  poke p (KerxAnchorPointAction {..}) = do
    pokeByteOff p 0 kerxAnchorPointActionMarkAnchorPoint
    pokeByteOff p 2 kerxAnchorPointActionCurrAnchorPoint

{-# NOINLINE kerxAnchorPointActionStructType #-}
kerxAnchorPointActionStructType :: Ptr CType
kerxAnchorPointActionStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16]

argKerxAnchorPointAction :: KerxAnchorPointAction -> Arg
argKerxAnchorPointAction = mkStorableArg kerxAnchorPointActionStructType

retKerxAnchorPointAction :: RetType KerxAnchorPointAction
retKerxAnchorPointAction = mkStorableRetType kerxAnchorPointActionStructType

instance ObjCArgument KerxAnchorPointAction where
  withObjCArg x k = k (argKerxAnchorPointAction x)

instance ObjCReturn KerxAnchorPointAction where
  type RawReturn KerxAnchorPointAction = KerxAnchorPointAction
  objcRetType = retKerxAnchorPointAction
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data KerxControlPointAction = KerxControlPointAction
  { kerxControlPointActionMarkControlPoint :: !CUShort
  , kerxControlPointActionCurrControlPoint :: !CUShort
  } deriving (Eq, Show)

instance Storable KerxControlPointAction where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = KerxControlPointAction <$> peekByteOff p 0
    <*> peekByteOff p 2
  poke p (KerxControlPointAction {..}) = do
    pokeByteOff p 0 kerxControlPointActionMarkControlPoint
    pokeByteOff p 2 kerxControlPointActionCurrControlPoint

{-# NOINLINE kerxControlPointActionStructType #-}
kerxControlPointActionStructType :: Ptr CType
kerxControlPointActionStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16]

argKerxControlPointAction :: KerxControlPointAction -> Arg
argKerxControlPointAction = mkStorableArg kerxControlPointActionStructType

retKerxControlPointAction :: RetType KerxControlPointAction
retKerxControlPointAction = mkStorableRetType kerxControlPointActionStructType

instance ObjCArgument KerxControlPointAction where
  withObjCArg x k = k (argKerxControlPointAction x)

instance ObjCReturn KerxControlPointAction where
  type RawReturn KerxControlPointAction = KerxControlPointAction
  objcRetType = retKerxControlPointAction
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data KerxControlPointEntry = KerxControlPointEntry
  { kerxControlPointEntryNewState :: !CUShort
  , kerxControlPointEntryFlags :: !CUShort
  , kerxControlPointEntryActionIndex :: !CUShort
  } deriving (Eq, Show)

instance Storable KerxControlPointEntry where
  sizeOf    _ = 6
  alignment _ = 2
  peek p = KerxControlPointEntry <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
  poke p (KerxControlPointEntry {..}) = do
    pokeByteOff p 0 kerxControlPointEntryNewState
    pokeByteOff p 2 kerxControlPointEntryFlags
    pokeByteOff p 4 kerxControlPointEntryActionIndex

{-# NOINLINE kerxControlPointEntryStructType #-}
kerxControlPointEntryStructType :: Ptr CType
kerxControlPointEntryStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argKerxControlPointEntry :: KerxControlPointEntry -> Arg
argKerxControlPointEntry = mkStorableArg kerxControlPointEntryStructType

retKerxControlPointEntry :: RetType KerxControlPointEntry
retKerxControlPointEntry = mkStorableRetType kerxControlPointEntryStructType

instance ObjCArgument KerxControlPointEntry where
  withObjCArg x k = k (argKerxControlPointEntry x)

instance ObjCReturn KerxControlPointEntry where
  type RawReturn KerxControlPointEntry = KerxControlPointEntry
  objcRetType = retKerxControlPointEntry
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data KerxCoordinateAction = KerxCoordinateAction
  { kerxCoordinateActionMarkX :: !CUShort
  , kerxCoordinateActionMarkY :: !CUShort
  , kerxCoordinateActionCurrX :: !CUShort
  , kerxCoordinateActionCurrY :: !CUShort
  } deriving (Eq, Show)

instance Storable KerxCoordinateAction where
  sizeOf    _ = 8
  alignment _ = 2
  peek p = KerxCoordinateAction <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 6
  poke p (KerxCoordinateAction {..}) = do
    pokeByteOff p 0 kerxCoordinateActionMarkX
    pokeByteOff p 2 kerxCoordinateActionMarkY
    pokeByteOff p 4 kerxCoordinateActionCurrX
    pokeByteOff p 6 kerxCoordinateActionCurrY

{-# NOINLINE kerxCoordinateActionStructType #-}
kerxCoordinateActionStructType :: Ptr CType
kerxCoordinateActionStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argKerxCoordinateAction :: KerxCoordinateAction -> Arg
argKerxCoordinateAction = mkStorableArg kerxCoordinateActionStructType

retKerxCoordinateAction :: RetType KerxCoordinateAction
retKerxCoordinateAction = mkStorableRetType kerxCoordinateActionStructType

instance ObjCArgument KerxCoordinateAction where
  withObjCArg x k = k (argKerxCoordinateAction x)

instance ObjCReturn KerxCoordinateAction where
  type RawReturn KerxCoordinateAction = KerxCoordinateAction
  objcRetType = retKerxCoordinateAction
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data KerxIndexArrayHeader = KerxIndexArrayHeader
  { kerxIndexArrayHeaderFlags :: !CUInt
  , kerxIndexArrayHeaderRowCount :: !CUShort
  , kerxIndexArrayHeaderColumnCount :: !CUShort
  , kerxIndexArrayHeaderRowIndexTableOffset :: !CUInt
  , kerxIndexArrayHeaderColumnIndexTableOffset :: !CUInt
  , kerxIndexArrayHeaderKerningArrayOffset :: !CUInt
  , kerxIndexArrayHeaderKerningVectorOffset :: !CUInt
  } deriving (Eq, Show)

instance Storable KerxIndexArrayHeader where
  sizeOf    _ = 24
  alignment _ = 4
  peek p = KerxIndexArrayHeader <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 6
    <*> peekByteOff p 8
    <*> peekByteOff p 12
    <*> peekByteOff p 16
    <*> peekByteOff p 20
  poke p (KerxIndexArrayHeader {..}) = do
    pokeByteOff p 0 kerxIndexArrayHeaderFlags
    pokeByteOff p 4 kerxIndexArrayHeaderRowCount
    pokeByteOff p 6 kerxIndexArrayHeaderColumnCount
    pokeByteOff p 8 kerxIndexArrayHeaderRowIndexTableOffset
    pokeByteOff p 12 kerxIndexArrayHeaderColumnIndexTableOffset
    pokeByteOff p 16 kerxIndexArrayHeaderKerningArrayOffset
    pokeByteOff p 20 kerxIndexArrayHeaderKerningVectorOffset

{-# NOINLINE kerxIndexArrayHeaderStructType #-}
kerxIndexArrayHeaderStructType :: Ptr CType
kerxIndexArrayHeaderStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint16, ffi_type_uint16, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint]

argKerxIndexArrayHeader :: KerxIndexArrayHeader -> Arg
argKerxIndexArrayHeader = mkStorableArg kerxIndexArrayHeaderStructType

retKerxIndexArrayHeader :: RetType KerxIndexArrayHeader
retKerxIndexArrayHeader = mkStorableRetType kerxIndexArrayHeaderStructType

instance ObjCArgument KerxIndexArrayHeader where
  withObjCArg x k = k (argKerxIndexArrayHeader x)

instance ObjCReturn KerxIndexArrayHeader where
  type RawReturn KerxIndexArrayHeader = KerxIndexArrayHeader
  objcRetType = retKerxIndexArrayHeader
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data KerxKerningPair = KerxKerningPair
  { kerxKerningPairLeft :: !CUShort
  , kerxKerningPairRight :: !CUShort
  } deriving (Eq, Show)

instance Storable KerxKerningPair where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = KerxKerningPair <$> peekByteOff p 0
    <*> peekByteOff p 2
  poke p (KerxKerningPair {..}) = do
    pokeByteOff p 0 kerxKerningPairLeft
    pokeByteOff p 2 kerxKerningPairRight

{-# NOINLINE kerxKerningPairStructType #-}
kerxKerningPairStructType :: Ptr CType
kerxKerningPairStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16]

argKerxKerningPair :: KerxKerningPair -> Arg
argKerxKerningPair = mkStorableArg kerxKerningPairStructType

retKerxKerningPair :: RetType KerxKerningPair
retKerxKerningPair = mkStorableRetType kerxKerningPairStructType

instance ObjCArgument KerxKerningPair where
  withObjCArg x k = k (argKerxKerningPair x)

instance ObjCReturn KerxKerningPair where
  type RawReturn KerxKerningPair = KerxKerningPair
  objcRetType = retKerxKerningPair
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data KerxStateEntry = KerxStateEntry
  { kerxStateEntryNewState :: !CUShort
  , kerxStateEntryFlags :: !CUShort
  , kerxStateEntryValueIndex :: !CUShort
  } deriving (Eq, Show)

instance Storable KerxStateEntry where
  sizeOf    _ = 6
  alignment _ = 2
  peek p = KerxStateEntry <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
  poke p (KerxStateEntry {..}) = do
    pokeByteOff p 0 kerxStateEntryNewState
    pokeByteOff p 2 kerxStateEntryFlags
    pokeByteOff p 4 kerxStateEntryValueIndex

{-# NOINLINE kerxStateEntryStructType #-}
kerxStateEntryStructType :: Ptr CType
kerxStateEntryStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argKerxStateEntry :: KerxStateEntry -> Arg
argKerxStateEntry = mkStorableArg kerxStateEntryStructType

retKerxStateEntry :: RetType KerxStateEntry
retKerxStateEntry = mkStorableRetType kerxStateEntryStructType

instance ObjCArgument KerxStateEntry where
  withObjCArg x k = k (argKerxStateEntry x)

instance ObjCReturn KerxStateEntry where
  type RawReturn KerxStateEntry = KerxStateEntry
  objcRetType = retKerxStateEntry
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data LcarCaretTable = LcarCaretTable
  { lcarCaretTableVersion :: !CInt
  , lcarCaretTableFormat :: !CUShort
  , lcarCaretTableLookup :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable LcarCaretTable where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = LcarCaretTable <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (LcarCaretTable {..}) = do
    pokeByteOff p 0 lcarCaretTableVersion
    pokeByteOff p 4 lcarCaretTableFormat
    pokeByteOff p 8 lcarCaretTableLookup

{-# NOINLINE lcarCaretTableStructType #-}
lcarCaretTableStructType :: Ptr CType
lcarCaretTableStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_uint16, ffi_type_pointer]

argLcarCaretTable :: LcarCaretTable -> Arg
argLcarCaretTable = mkStorableArg lcarCaretTableStructType

retLcarCaretTable :: RetType LcarCaretTable
retLcarCaretTable = mkStorableRetType lcarCaretTableStructType

instance ObjCArgument LcarCaretTable where
  withObjCArg x k = k (argLcarCaretTable x)

instance ObjCReturn LcarCaretTable where
  type RawReturn LcarCaretTable = LcarCaretTable
  objcRetType = retLcarCaretTable
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data LtagStringRange = LtagStringRange
  { ltagStringRangeOffset :: !CUShort
  , ltagStringRangeLength :: !CUShort
  } deriving (Eq, Show)

instance Storable LtagStringRange where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = LtagStringRange <$> peekByteOff p 0
    <*> peekByteOff p 2
  poke p (LtagStringRange {..}) = do
    pokeByteOff p 0 ltagStringRangeOffset
    pokeByteOff p 2 ltagStringRangeLength

{-# NOINLINE ltagStringRangeStructType #-}
ltagStringRangeStructType :: Ptr CType
ltagStringRangeStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16]

argLtagStringRange :: LtagStringRange -> Arg
argLtagStringRange = mkStorableArg ltagStringRangeStructType

retLtagStringRange :: RetType LtagStringRange
retLtagStringRange = mkStorableRetType ltagStringRangeStructType

instance ObjCArgument LtagStringRange where
  withObjCArg x k = k (argLtagStringRange x)

instance ObjCReturn LtagStringRange where
  type RawReturn LtagStringRange = LtagStringRange
  objcRetType = retLtagStringRange
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data MortFeatureEntry = MortFeatureEntry
  { mortFeatureEntryFeatureType :: !CUShort
  , mortFeatureEntryFeatureSelector :: !CUShort
  , mortFeatureEntryEnableFlags :: !CUInt
  , mortFeatureEntryDisableFlags :: !CUInt
  } deriving (Eq, Show)

instance Storable MortFeatureEntry where
  sizeOf    _ = 12
  alignment _ = 4
  peek p = MortFeatureEntry <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (MortFeatureEntry {..}) = do
    pokeByteOff p 0 mortFeatureEntryFeatureType
    pokeByteOff p 2 mortFeatureEntryFeatureSelector
    pokeByteOff p 4 mortFeatureEntryEnableFlags
    pokeByteOff p 8 mortFeatureEntryDisableFlags

{-# NOINLINE mortFeatureEntryStructType #-}
mortFeatureEntryStructType :: Ptr CType
mortFeatureEntryStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint, ffi_type_uint]

argMortFeatureEntry :: MortFeatureEntry -> Arg
argMortFeatureEntry = mkStorableArg mortFeatureEntryStructType

retMortFeatureEntry :: RetType MortFeatureEntry
retMortFeatureEntry = mkStorableRetType mortFeatureEntryStructType

instance ObjCArgument MortFeatureEntry where
  withObjCArg x k = k (argMortFeatureEntry x)

instance ObjCReturn MortFeatureEntry where
  type RawReturn MortFeatureEntry = MortFeatureEntry
  objcRetType = retMortFeatureEntry
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data MortSwashSubtable = MortSwashSubtable
  { mortSwashSubtableLookup :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable MortSwashSubtable where
  sizeOf    _ = 8
  alignment _ = 8
  peek p = MortSwashSubtable <$> peekByteOff p 0
  poke p (MortSwashSubtable {..}) =
    pokeByteOff p 0 mortSwashSubtableLookup

{-# NOINLINE mortSwashSubtableStructType #-}
mortSwashSubtableStructType :: Ptr CType
mortSwashSubtableStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer]

argMortSwashSubtable :: MortSwashSubtable -> Arg
argMortSwashSubtable = mkStorableArg mortSwashSubtableStructType

retMortSwashSubtable :: RetType MortSwashSubtable
retMortSwashSubtable = mkStorableRetType mortSwashSubtableStructType

instance ObjCArgument MortSwashSubtable where
  withObjCArg x k = k (argMortSwashSubtable x)

instance ObjCReturn MortSwashSubtable where
  type RawReturn MortSwashSubtable = MortSwashSubtable
  objcRetType = retMortSwashSubtable
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data OpbdSideValues = OpbdSideValues
  { opbdSideValuesLeftSideShift :: !CShort
  , opbdSideValuesTopSideShift :: !CShort
  , opbdSideValuesRightSideShift :: !CShort
  , opbdSideValuesBottomSideShift :: !CShort
  } deriving (Eq, Show)

instance Storable OpbdSideValues where
  sizeOf    _ = 8
  alignment _ = 2
  peek p = OpbdSideValues <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 6
  poke p (OpbdSideValues {..}) = do
    pokeByteOff p 0 opbdSideValuesLeftSideShift
    pokeByteOff p 2 opbdSideValuesTopSideShift
    pokeByteOff p 4 opbdSideValuesRightSideShift
    pokeByteOff p 6 opbdSideValuesBottomSideShift

{-# NOINLINE opbdSideValuesStructType #-}
opbdSideValuesStructType :: Ptr CType
opbdSideValuesStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16]

argOpbdSideValues :: OpbdSideValues -> Arg
argOpbdSideValues = mkStorableArg opbdSideValuesStructType

retOpbdSideValues :: RetType OpbdSideValues
retOpbdSideValues = mkStorableRetType opbdSideValuesStructType

instance ObjCArgument OpbdSideValues where
  withObjCArg x k = k (argOpbdSideValues x)

instance ObjCReturn OpbdSideValues where
  type RawReturn OpbdSideValues = OpbdSideValues
  objcRetType = retOpbdSideValues
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data OpbdTable = OpbdTable
  { opbdTableVersion :: !CInt
  , opbdTableFormat :: !CUShort
  , opbdTableLookupTable :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable OpbdTable where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = OpbdTable <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (OpbdTable {..}) = do
    pokeByteOff p 0 opbdTableVersion
    pokeByteOff p 4 opbdTableFormat
    pokeByteOff p 8 opbdTableLookupTable

{-# NOINLINE opbdTableStructType #-}
opbdTableStructType :: Ptr CType
opbdTableStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_uint16, ffi_type_pointer]

argOpbdTable :: OpbdTable -> Arg
argOpbdTable = mkStorableArg opbdTableStructType

retOpbdTable :: RetType OpbdTable
retOpbdTable = mkStorableRetType opbdTableStructType

instance ObjCArgument OpbdTable where
  withObjCArg x k = k (argOpbdTable x)

instance ObjCReturn OpbdTable where
  type RawReturn OpbdTable = OpbdTable
  objcRetType = retOpbdTable
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data PropLookupSegment = PropLookupSegment
  { propLookupSegmentLastGlyph :: !CUShort
  , propLookupSegmentFirstGlyph :: !CUShort
  , propLookupSegmentValue :: !CUShort
  } deriving (Eq, Show)

instance Storable PropLookupSegment where
  sizeOf    _ = 6
  alignment _ = 2
  peek p = PropLookupSegment <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
  poke p (PropLookupSegment {..}) = do
    pokeByteOff p 0 propLookupSegmentLastGlyph
    pokeByteOff p 2 propLookupSegmentFirstGlyph
    pokeByteOff p 4 propLookupSegmentValue

{-# NOINLINE propLookupSegmentStructType #-}
propLookupSegmentStructType :: Ptr CType
propLookupSegmentStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argPropLookupSegment :: PropLookupSegment -> Arg
argPropLookupSegment = mkStorableArg propLookupSegmentStructType

retPropLookupSegment :: RetType PropLookupSegment
retPropLookupSegment = mkStorableRetType propLookupSegmentStructType

instance ObjCArgument PropLookupSegment where
  withObjCArg x k = k (argPropLookupSegment x)

instance ObjCReturn PropLookupSegment where
  type RawReturn PropLookupSegment = PropLookupSegment
  objcRetType = retPropLookupSegment
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data PropLookupSingle = PropLookupSingle
  { propLookupSingleGlyph :: !CUShort
  , propLookupSingleProps :: !CUShort
  } deriving (Eq, Show)

instance Storable PropLookupSingle where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = PropLookupSingle <$> peekByteOff p 0
    <*> peekByteOff p 2
  poke p (PropLookupSingle {..}) = do
    pokeByteOff p 0 propLookupSingleGlyph
    pokeByteOff p 2 propLookupSingleProps

{-# NOINLINE propLookupSingleStructType #-}
propLookupSingleStructType :: Ptr CType
propLookupSingleStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16]

argPropLookupSingle :: PropLookupSingle -> Arg
argPropLookupSingle = mkStorableArg propLookupSingleStructType

retPropLookupSingle :: RetType PropLookupSingle
retPropLookupSingle = mkStorableRetType propLookupSingleStructType

instance ObjCArgument PropLookupSingle where
  withObjCArg x k = k (argPropLookupSingle x)

instance ObjCReturn PropLookupSingle where
  type RawReturn PropLookupSingle = PropLookupSingle
  objcRetType = retPropLookupSingle
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data PropTable = PropTable
  { propTableVersion :: !CInt
  , propTableFormat :: !CUShort
  , propTableDefaultProps :: !CUShort
  , propTableLookup :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable PropTable where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = PropTable <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 6
    <*> peekByteOff p 8
  poke p (PropTable {..}) = do
    pokeByteOff p 0 propTableVersion
    pokeByteOff p 4 propTableFormat
    pokeByteOff p 6 propTableDefaultProps
    pokeByteOff p 8 propTableLookup

{-# NOINLINE propTableStructType #-}
propTableStructType :: Ptr CType
propTableStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_uint16, ffi_type_uint16, ffi_type_pointer]

argPropTable :: PropTable -> Arg
argPropTable = mkStorableArg propTableStructType

retPropTable :: RetType PropTable
retPropTable = mkStorableRetType propTableStructType

instance ObjCArgument PropTable where
  withObjCArg x k = k (argPropTable x)

instance ObjCReturn PropTable where
  type RawReturn PropTable = PropTable
  objcRetType = retPropTable
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data ROTAGlyphEntry = ROTAGlyphEntry
  { rotaGlyphEntryGlyphIndexOffset :: !CShort
  , rotaGlyphEntryHBaselineOffset :: !CShort
  , rotaGlyphEntryVBaselineOffset :: !CShort
  } deriving (Eq, Show)

instance Storable ROTAGlyphEntry where
  sizeOf    _ = 6
  alignment _ = 2
  peek p = ROTAGlyphEntry <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
  poke p (ROTAGlyphEntry {..}) = do
    pokeByteOff p 0 rotaGlyphEntryGlyphIndexOffset
    pokeByteOff p 2 rotaGlyphEntryHBaselineOffset
    pokeByteOff p 4 rotaGlyphEntryVBaselineOffset

{-# NOINLINE rotaGlyphEntryStructType #-}
rotaGlyphEntryStructType :: Ptr CType
rotaGlyphEntryStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16, ffi_type_sint16, ffi_type_sint16]

argROTAGlyphEntry :: ROTAGlyphEntry -> Arg
argROTAGlyphEntry = mkStorableArg rotaGlyphEntryStructType

retROTAGlyphEntry :: RetType ROTAGlyphEntry
retROTAGlyphEntry = mkStorableRetType rotaGlyphEntryStructType

instance ObjCArgument ROTAGlyphEntry where
  withObjCArg x k = k (argROTAGlyphEntry x)

instance ObjCReturn ROTAGlyphEntry where
  type RawReturn ROTAGlyphEntry = ROTAGlyphEntry
  objcRetType = retROTAGlyphEntry
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data ROTAHeader = ROTAHeader
  { rotaHeaderVersion :: !CInt
  , rotaHeaderFlags :: !CUShort
  , rotaHeaderNMasters :: !CUShort
  , rotaHeaderFirstGlyph :: !CUShort
  , rotaHeaderLastGlyph :: !CUShort
  , rotaHeaderLookup :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable ROTAHeader where
  sizeOf    _ = 24
  alignment _ = 8
  peek p = ROTAHeader <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 6
    <*> peekByteOff p 8
    <*> peekByteOff p 10
    <*> peekByteOff p 16
  poke p (ROTAHeader {..}) = do
    pokeByteOff p 0 rotaHeaderVersion
    pokeByteOff p 4 rotaHeaderFlags
    pokeByteOff p 6 rotaHeaderNMasters
    pokeByteOff p 8 rotaHeaderFirstGlyph
    pokeByteOff p 10 rotaHeaderLastGlyph
    pokeByteOff p 16 rotaHeaderLookup

{-# NOINLINE rotaHeaderStructType #-}
rotaHeaderStructType :: Ptr CType
rotaHeaderStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16, ffi_type_pointer]

argROTAHeader :: ROTAHeader -> Arg
argROTAHeader = mkStorableArg rotaHeaderStructType

retROTAHeader :: RetType ROTAHeader
retROTAHeader = mkStorableRetType rotaHeaderStructType

instance ObjCArgument ROTAHeader where
  withObjCArg x k = k (argROTAHeader x)

instance ObjCReturn ROTAHeader where
  type RawReturn ROTAHeader = ROTAHeader
  objcRetType = retROTAHeader
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data SFNTLookupBinarySearchHeader = SFNTLookupBinarySearchHeader
  { sfntLookupBinarySearchHeaderUnitSize :: !CUShort
  , sfntLookupBinarySearchHeaderNUnits :: !CUShort
  , sfntLookupBinarySearchHeaderSearchRange :: !CUShort
  , sfntLookupBinarySearchHeaderEntrySelector :: !CUShort
  , sfntLookupBinarySearchHeaderRangeShift :: !CUShort
  } deriving (Eq, Show)

instance Storable SFNTLookupBinarySearchHeader where
  sizeOf    _ = 10
  alignment _ = 2
  peek p = SFNTLookupBinarySearchHeader <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 6
    <*> peekByteOff p 8
  poke p (SFNTLookupBinarySearchHeader {..}) = do
    pokeByteOff p 0 sfntLookupBinarySearchHeaderUnitSize
    pokeByteOff p 2 sfntLookupBinarySearchHeaderNUnits
    pokeByteOff p 4 sfntLookupBinarySearchHeaderSearchRange
    pokeByteOff p 6 sfntLookupBinarySearchHeaderEntrySelector
    pokeByteOff p 8 sfntLookupBinarySearchHeaderRangeShift

{-# NOINLINE sfntLookupBinarySearchHeaderStructType #-}
sfntLookupBinarySearchHeaderStructType :: Ptr CType
sfntLookupBinarySearchHeaderStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argSFNTLookupBinarySearchHeader :: SFNTLookupBinarySearchHeader -> Arg
argSFNTLookupBinarySearchHeader = mkStorableArg sfntLookupBinarySearchHeaderStructType

retSFNTLookupBinarySearchHeader :: RetType SFNTLookupBinarySearchHeader
retSFNTLookupBinarySearchHeader = mkStorableRetType sfntLookupBinarySearchHeaderStructType

instance ObjCArgument SFNTLookupBinarySearchHeader where
  withObjCArg x k = k (argSFNTLookupBinarySearchHeader x)

instance ObjCReturn SFNTLookupBinarySearchHeader where
  type RawReturn SFNTLookupBinarySearchHeader = SFNTLookupBinarySearchHeader
  objcRetType = retSFNTLookupBinarySearchHeader
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data STEntryOne = STEntryOne
  { stEntryOneNewState :: !CUShort
  , stEntryOneFlags :: !CUShort
  , stEntryOneOffset1 :: !CUShort
  } deriving (Eq, Show)

instance Storable STEntryOne where
  sizeOf    _ = 6
  alignment _ = 2
  peek p = STEntryOne <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
  poke p (STEntryOne {..}) = do
    pokeByteOff p 0 stEntryOneNewState
    pokeByteOff p 2 stEntryOneFlags
    pokeByteOff p 4 stEntryOneOffset1

{-# NOINLINE stEntryOneStructType #-}
stEntryOneStructType :: Ptr CType
stEntryOneStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argSTEntryOne :: STEntryOne -> Arg
argSTEntryOne = mkStorableArg stEntryOneStructType

retSTEntryOne :: RetType STEntryOne
retSTEntryOne = mkStorableRetType stEntryOneStructType

instance ObjCArgument STEntryOne where
  withObjCArg x k = k (argSTEntryOne x)

instance ObjCReturn STEntryOne where
  type RawReturn STEntryOne = STEntryOne
  objcRetType = retSTEntryOne
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data STEntryTwo = STEntryTwo
  { stEntryTwoNewState :: !CUShort
  , stEntryTwoFlags :: !CUShort
  , stEntryTwoOffset1 :: !CUShort
  , stEntryTwoOffset2 :: !CUShort
  } deriving (Eq, Show)

instance Storable STEntryTwo where
  sizeOf    _ = 8
  alignment _ = 2
  peek p = STEntryTwo <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 6
  poke p (STEntryTwo {..}) = do
    pokeByteOff p 0 stEntryTwoNewState
    pokeByteOff p 2 stEntryTwoFlags
    pokeByteOff p 4 stEntryTwoOffset1
    pokeByteOff p 6 stEntryTwoOffset2

{-# NOINLINE stEntryTwoStructType #-}
stEntryTwoStructType :: Ptr CType
stEntryTwoStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argSTEntryTwo :: STEntryTwo -> Arg
argSTEntryTwo = mkStorableArg stEntryTwoStructType

retSTEntryTwo :: RetType STEntryTwo
retSTEntryTwo = mkStorableRetType stEntryTwoStructType

instance ObjCArgument STEntryTwo where
  withObjCArg x k = k (argSTEntryTwo x)

instance ObjCReturn STEntryTwo where
  type RawReturn STEntryTwo = STEntryTwo
  objcRetType = retSTEntryTwo
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data STEntryZero = STEntryZero
  { stEntryZeroNewState :: !CUShort
  , stEntryZeroFlags :: !CUShort
  } deriving (Eq, Show)

instance Storable STEntryZero where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = STEntryZero <$> peekByteOff p 0
    <*> peekByteOff p 2
  poke p (STEntryZero {..}) = do
    pokeByteOff p 0 stEntryZeroNewState
    pokeByteOff p 2 stEntryZeroFlags

{-# NOINLINE stEntryZeroStructType #-}
stEntryZeroStructType :: Ptr CType
stEntryZeroStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16]

argSTEntryZero :: STEntryZero -> Arg
argSTEntryZero = mkStorableArg stEntryZeroStructType

retSTEntryZero :: RetType STEntryZero
retSTEntryZero = mkStorableRetType stEntryZeroStructType

instance ObjCArgument STEntryZero where
  withObjCArg x k = k (argSTEntryZero x)

instance ObjCReturn STEntryZero where
  type RawReturn STEntryZero = STEntryZero
  objcRetType = retSTEntryZero
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data STHeader = STHeader
  { stHeaderFiller :: !CUChar
  , stHeaderNClasses :: !CUChar
  , stHeaderClassTableOffset :: !CUShort
  , stHeaderStateArrayOffset :: !CUShort
  , stHeaderEntryTableOffset :: !CUShort
  } deriving (Eq, Show)

instance Storable STHeader where
  sizeOf    _ = 8
  alignment _ = 2
  peek p = STHeader <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 6
  poke p (STHeader {..}) = do
    pokeByteOff p 0 stHeaderFiller
    pokeByteOff p 1 stHeaderNClasses
    pokeByteOff p 2 stHeaderClassTableOffset
    pokeByteOff p 4 stHeaderStateArrayOffset
    pokeByteOff p 6 stHeaderEntryTableOffset

{-# NOINLINE stHeaderStructType #-}
stHeaderStructType :: Ptr CType
stHeaderStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argSTHeader :: STHeader -> Arg
argSTHeader = mkStorableArg stHeaderStructType

retSTHeader :: RetType STHeader
retSTHeader = mkStorableRetType stHeaderStructType

instance ObjCArgument STHeader where
  withObjCArg x k = k (argSTHeader x)

instance ObjCReturn STHeader where
  type RawReturn STHeader = STHeader
  objcRetType = retSTHeader
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data STXEntryOne = STXEntryOne
  { stxEntryOneNewState :: !CUShort
  , stxEntryOneFlags :: !CUShort
  , stxEntryOneIndex1 :: !CUShort
  } deriving (Eq, Show)

instance Storable STXEntryOne where
  sizeOf    _ = 6
  alignment _ = 2
  peek p = STXEntryOne <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
  poke p (STXEntryOne {..}) = do
    pokeByteOff p 0 stxEntryOneNewState
    pokeByteOff p 2 stxEntryOneFlags
    pokeByteOff p 4 stxEntryOneIndex1

{-# NOINLINE stxEntryOneStructType #-}
stxEntryOneStructType :: Ptr CType
stxEntryOneStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argSTXEntryOne :: STXEntryOne -> Arg
argSTXEntryOne = mkStorableArg stxEntryOneStructType

retSTXEntryOne :: RetType STXEntryOne
retSTXEntryOne = mkStorableRetType stxEntryOneStructType

instance ObjCArgument STXEntryOne where
  withObjCArg x k = k (argSTXEntryOne x)

instance ObjCReturn STXEntryOne where
  type RawReturn STXEntryOne = STXEntryOne
  objcRetType = retSTXEntryOne
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data STXEntryTwo = STXEntryTwo
  { stxEntryTwoNewState :: !CUShort
  , stxEntryTwoFlags :: !CUShort
  , stxEntryTwoIndex1 :: !CUShort
  , stxEntryTwoIndex2 :: !CUShort
  } deriving (Eq, Show)

instance Storable STXEntryTwo where
  sizeOf    _ = 8
  alignment _ = 2
  peek p = STXEntryTwo <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 6
  poke p (STXEntryTwo {..}) = do
    pokeByteOff p 0 stxEntryTwoNewState
    pokeByteOff p 2 stxEntryTwoFlags
    pokeByteOff p 4 stxEntryTwoIndex1
    pokeByteOff p 6 stxEntryTwoIndex2

{-# NOINLINE stxEntryTwoStructType #-}
stxEntryTwoStructType :: Ptr CType
stxEntryTwoStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argSTXEntryTwo :: STXEntryTwo -> Arg
argSTXEntryTwo = mkStorableArg stxEntryTwoStructType

retSTXEntryTwo :: RetType STXEntryTwo
retSTXEntryTwo = mkStorableRetType stxEntryTwoStructType

instance ObjCArgument STXEntryTwo where
  withObjCArg x k = k (argSTXEntryTwo x)

instance ObjCReturn STXEntryTwo where
  type RawReturn STXEntryTwo = STXEntryTwo
  objcRetType = retSTXEntryTwo
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data STXEntryZero = STXEntryZero
  { stxEntryZeroNewState :: !CUShort
  , stxEntryZeroFlags :: !CUShort
  } deriving (Eq, Show)

instance Storable STXEntryZero where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = STXEntryZero <$> peekByteOff p 0
    <*> peekByteOff p 2
  poke p (STXEntryZero {..}) = do
    pokeByteOff p 0 stxEntryZeroNewState
    pokeByteOff p 2 stxEntryZeroFlags

{-# NOINLINE stxEntryZeroStructType #-}
stxEntryZeroStructType :: Ptr CType
stxEntryZeroStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16]

argSTXEntryZero :: STXEntryZero -> Arg
argSTXEntryZero = mkStorableArg stxEntryZeroStructType

retSTXEntryZero :: RetType STXEntryZero
retSTXEntryZero = mkStorableRetType stxEntryZeroStructType

instance ObjCArgument STXEntryZero where
  withObjCArg x k = k (argSTXEntryZero x)

instance ObjCReturn STXEntryZero where
  type RawReturn STXEntryZero = STXEntryZero
  objcRetType = retSTXEntryZero
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data STXHeader = STXHeader
  { stxHeaderNClasses :: !CUInt
  , stxHeaderClassTableOffset :: !CUInt
  , stxHeaderStateArrayOffset :: !CUInt
  , stxHeaderEntryTableOffset :: !CUInt
  } deriving (Eq, Show)

instance Storable STXHeader where
  sizeOf    _ = 16
  alignment _ = 4
  peek p = STXHeader <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
  poke p (STXHeader {..}) = do
    pokeByteOff p 0 stxHeaderNClasses
    pokeByteOff p 4 stxHeaderClassTableOffset
    pokeByteOff p 8 stxHeaderStateArrayOffset
    pokeByteOff p 12 stxHeaderEntryTableOffset

{-# NOINLINE stxHeaderStructType #-}
stxHeaderStructType :: Ptr CType
stxHeaderStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint]

argSTXHeader :: STXHeader -> Arg
argSTXHeader = mkStorableArg stxHeaderStructType

retSTXHeader :: RetType STXHeader
retSTXHeader = mkStorableRetType stxHeaderStructType

instance ObjCArgument STXHeader where
  withObjCArg x k = k (argSTXHeader x)

instance ObjCReturn STXHeader where
  type RawReturn STXHeader = STXHeader
  objcRetType = retSTXHeader
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data TrakTable = TrakTable
  { trakTableVersion :: !CInt
  , trakTableFormat :: !CUShort
  , trakTableHorizOffset :: !CUShort
  , trakTableVertOffset :: !CUShort
  } deriving (Eq, Show)

instance Storable TrakTable where
  sizeOf    _ = 12
  alignment _ = 4
  peek p = TrakTable <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 6
    <*> peekByteOff p 8
  poke p (TrakTable {..}) = do
    pokeByteOff p 0 trakTableVersion
    pokeByteOff p 4 trakTableFormat
    pokeByteOff p 6 trakTableHorizOffset
    pokeByteOff p 8 trakTableVertOffset

{-# NOINLINE trakTableStructType #-}
trakTableStructType :: Ptr CType
trakTableStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argTrakTable :: TrakTable -> Arg
argTrakTable = mkStorableArg trakTableStructType

retTrakTable :: RetType TrakTable
retTrakTable = mkStorableRetType trakTableStructType

instance ObjCArgument TrakTable where
  withObjCArg x k = k (argTrakTable x)

instance ObjCReturn TrakTable where
  type RawReturn TrakTable = TrakTable
  objcRetType = retTrakTable
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data TrakTableEntry = TrakTableEntry
  { trakTableEntryTrack :: !CInt
  , trakTableEntryNameTableIndex :: !CUShort
  , trakTableEntrySizesOffset :: !CUShort
  } deriving (Eq, Show)

instance Storable TrakTableEntry where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = TrakTableEntry <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 6
  poke p (TrakTableEntry {..}) = do
    pokeByteOff p 0 trakTableEntryTrack
    pokeByteOff p 4 trakTableEntryNameTableIndex
    pokeByteOff p 6 trakTableEntrySizesOffset

{-# NOINLINE trakTableEntryStructType #-}
trakTableEntryStructType :: Ptr CType
trakTableEntryStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_uint16, ffi_type_uint16]

argTrakTableEntry :: TrakTableEntry -> Arg
argTrakTableEntry = mkStorableArg trakTableEntryStructType

retTrakTableEntry :: RetType TrakTableEntry
retTrakTableEntry = mkStorableRetType trakTableEntryStructType

instance ObjCArgument TrakTableEntry where
  withObjCArg x k = k (argTrakTableEntry x)

instance ObjCReturn TrakTableEntry where
  type RawReturn TrakTableEntry = TrakTableEntry
  objcRetType = retTrakTableEntry
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data KernOrderedListEntry = KernOrderedListEntry
  { kernOrderedListEntryPair :: !KernKerningPair
  , kernOrderedListEntryValue :: !CShort
  } deriving (Eq, Show)

instance Storable KernOrderedListEntry where
  sizeOf    _ = 6
  alignment _ = 2
  peek p = KernOrderedListEntry <$> peekByteOff p 0
    <*> peekByteOff p 4
  poke p (KernOrderedListEntry {..}) = do
    pokeByteOff p 0 kernOrderedListEntryPair
    pokeByteOff p 4 kernOrderedListEntryValue

{-# NOINLINE kernOrderedListEntryStructType #-}
kernOrderedListEntryStructType :: Ptr CType
kernOrderedListEntryStructType = unsafePerformIO $ fst <$> newStructCType [kernKerningPairStructType, ffi_type_sint16]

argKernOrderedListEntry :: KernOrderedListEntry -> Arg
argKernOrderedListEntry = mkStorableArg kernOrderedListEntryStructType

retKernOrderedListEntry :: RetType KernOrderedListEntry
retKernOrderedListEntry = mkStorableRetType kernOrderedListEntryStructType

instance ObjCArgument KernOrderedListEntry where
  withObjCArg x k = k (argKernOrderedListEntry x)

instance ObjCReturn KernOrderedListEntry where
  type RawReturn KernOrderedListEntry = KernOrderedListEntry
  objcRetType = retKernOrderedListEntry
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data KerxOrderedListEntry = KerxOrderedListEntry
  { kerxOrderedListEntryPair :: !KerxKerningPair
  , kerxOrderedListEntryValue :: !CShort
  } deriving (Eq, Show)

instance Storable KerxOrderedListEntry where
  sizeOf    _ = 6
  alignment _ = 2
  peek p = KerxOrderedListEntry <$> peekByteOff p 0
    <*> peekByteOff p 4
  poke p (KerxOrderedListEntry {..}) = do
    pokeByteOff p 0 kerxOrderedListEntryPair
    pokeByteOff p 4 kerxOrderedListEntryValue

{-# NOINLINE kerxOrderedListEntryStructType #-}
kerxOrderedListEntryStructType :: Ptr CType
kerxOrderedListEntryStructType = unsafePerformIO $ fst <$> newStructCType [kerxKerningPairStructType, ffi_type_sint16]

argKerxOrderedListEntry :: KerxOrderedListEntry -> Arg
argKerxOrderedListEntry = mkStorableArg kerxOrderedListEntryStructType

retKerxOrderedListEntry :: RetType KerxOrderedListEntry
retKerxOrderedListEntry = mkStorableRetType kerxOrderedListEntryStructType

instance ObjCArgument KerxOrderedListEntry where
  withObjCArg x k = k (argKerxOrderedListEntry x)

instance ObjCReturn KerxOrderedListEntry where
  type RawReturn KerxOrderedListEntry = KerxOrderedListEntry
  objcRetType = retKerxOrderedListEntry
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data MortContextualSubtable = MortContextualSubtable
  { mortContextualSubtableHeader :: !STHeader
  , mortContextualSubtableSubstitutionTableOffset :: !CUShort
  } deriving (Eq, Show)

instance Storable MortContextualSubtable where
  sizeOf    _ = 10
  alignment _ = 2
  peek p = MortContextualSubtable <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (MortContextualSubtable {..}) = do
    pokeByteOff p 0 mortContextualSubtableHeader
    pokeByteOff p 8 mortContextualSubtableSubstitutionTableOffset

{-# NOINLINE mortContextualSubtableStructType #-}
mortContextualSubtableStructType :: Ptr CType
mortContextualSubtableStructType = unsafePerformIO $ fst <$> newStructCType [stHeaderStructType, ffi_type_uint16]

argMortContextualSubtable :: MortContextualSubtable -> Arg
argMortContextualSubtable = mkStorableArg mortContextualSubtableStructType

retMortContextualSubtable :: RetType MortContextualSubtable
retMortContextualSubtable = mkStorableRetType mortContextualSubtableStructType

instance ObjCArgument MortContextualSubtable where
  withObjCArg x k = k (argMortContextualSubtable x)

instance ObjCReturn MortContextualSubtable where
  type RawReturn MortContextualSubtable = MortContextualSubtable
  objcRetType = retMortContextualSubtable
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data MortInsertionSubtable = MortInsertionSubtable
  { mortInsertionSubtableHeader :: !STHeader
  } deriving (Eq, Show)

instance Storable MortInsertionSubtable where
  sizeOf    _ = 8
  alignment _ = 2
  peek p = MortInsertionSubtable <$> peekByteOff p 0
  poke p (MortInsertionSubtable {..}) =
    pokeByteOff p 0 mortInsertionSubtableHeader

{-# NOINLINE mortInsertionSubtableStructType #-}
mortInsertionSubtableStructType :: Ptr CType
mortInsertionSubtableStructType = unsafePerformIO $ fst <$> newStructCType [stHeaderStructType]

argMortInsertionSubtable :: MortInsertionSubtable -> Arg
argMortInsertionSubtable = mkStorableArg mortInsertionSubtableStructType

retMortInsertionSubtable :: RetType MortInsertionSubtable
retMortInsertionSubtable = mkStorableRetType mortInsertionSubtableStructType

instance ObjCArgument MortInsertionSubtable where
  withObjCArg x k = k (argMortInsertionSubtable x)

instance ObjCReturn MortInsertionSubtable where
  type RawReturn MortInsertionSubtable = MortInsertionSubtable
  objcRetType = retMortInsertionSubtable
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data MortLigatureSubtable = MortLigatureSubtable
  { mortLigatureSubtableHeader :: !STHeader
  , mortLigatureSubtableLigatureActionTableOffset :: !CUShort
  , mortLigatureSubtableComponentTableOffset :: !CUShort
  , mortLigatureSubtableLigatureTableOffset :: !CUShort
  } deriving (Eq, Show)

instance Storable MortLigatureSubtable where
  sizeOf    _ = 14
  alignment _ = 2
  peek p = MortLigatureSubtable <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 10
    <*> peekByteOff p 12
  poke p (MortLigatureSubtable {..}) = do
    pokeByteOff p 0 mortLigatureSubtableHeader
    pokeByteOff p 8 mortLigatureSubtableLigatureActionTableOffset
    pokeByteOff p 10 mortLigatureSubtableComponentTableOffset
    pokeByteOff p 12 mortLigatureSubtableLigatureTableOffset

{-# NOINLINE mortLigatureSubtableStructType #-}
mortLigatureSubtableStructType :: Ptr CType
mortLigatureSubtableStructType = unsafePerformIO $ fst <$> newStructCType [stHeaderStructType, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argMortLigatureSubtable :: MortLigatureSubtable -> Arg
argMortLigatureSubtable = mkStorableArg mortLigatureSubtableStructType

retMortLigatureSubtable :: RetType MortLigatureSubtable
retMortLigatureSubtable = mkStorableRetType mortLigatureSubtableStructType

instance ObjCArgument MortLigatureSubtable where
  withObjCArg x k = k (argMortLigatureSubtable x)

instance ObjCReturn MortLigatureSubtable where
  type RawReturn MortLigatureSubtable = MortLigatureSubtable
  objcRetType = retMortLigatureSubtable
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data MortRearrangementSubtable = MortRearrangementSubtable
  { mortRearrangementSubtableHeader :: !STHeader
  } deriving (Eq, Show)

instance Storable MortRearrangementSubtable where
  sizeOf    _ = 8
  alignment _ = 2
  peek p = MortRearrangementSubtable <$> peekByteOff p 0
  poke p (MortRearrangementSubtable {..}) =
    pokeByteOff p 0 mortRearrangementSubtableHeader

{-# NOINLINE mortRearrangementSubtableStructType #-}
mortRearrangementSubtableStructType :: Ptr CType
mortRearrangementSubtableStructType = unsafePerformIO $ fst <$> newStructCType [stHeaderStructType]

argMortRearrangementSubtable :: MortRearrangementSubtable -> Arg
argMortRearrangementSubtable = mkStorableArg mortRearrangementSubtableStructType

retMortRearrangementSubtable :: RetType MortRearrangementSubtable
retMortRearrangementSubtable = mkStorableRetType mortRearrangementSubtableStructType

instance ObjCArgument MortRearrangementSubtable where
  withObjCArg x k = k (argMortRearrangementSubtable x)

instance ObjCReturn MortRearrangementSubtable where
  type RawReturn MortRearrangementSubtable = MortRearrangementSubtable
  objcRetType = retMortRearrangementSubtable
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data MorxContextualSubtable = MorxContextualSubtable
  { morxContextualSubtableHeader :: !STXHeader
  , morxContextualSubtableSubstitutionTableOffset :: !CUInt
  } deriving (Eq, Show)

instance Storable MorxContextualSubtable where
  sizeOf    _ = 20
  alignment _ = 4
  peek p = MorxContextualSubtable <$> peekByteOff p 0
    <*> peekByteOff p 16
  poke p (MorxContextualSubtable {..}) = do
    pokeByteOff p 0 morxContextualSubtableHeader
    pokeByteOff p 16 morxContextualSubtableSubstitutionTableOffset

{-# NOINLINE morxContextualSubtableStructType #-}
morxContextualSubtableStructType :: Ptr CType
morxContextualSubtableStructType = unsafePerformIO $ fst <$> newStructCType [stxHeaderStructType, ffi_type_uint]

argMorxContextualSubtable :: MorxContextualSubtable -> Arg
argMorxContextualSubtable = mkStorableArg morxContextualSubtableStructType

retMorxContextualSubtable :: RetType MorxContextualSubtable
retMorxContextualSubtable = mkStorableRetType morxContextualSubtableStructType

instance ObjCArgument MorxContextualSubtable where
  withObjCArg x k = k (argMorxContextualSubtable x)

instance ObjCReturn MorxContextualSubtable where
  type RawReturn MorxContextualSubtable = MorxContextualSubtable
  objcRetType = retMorxContextualSubtable
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data MorxInsertionSubtable = MorxInsertionSubtable
  { morxInsertionSubtableHeader :: !STXHeader
  , morxInsertionSubtableInsertionGlyphTableOffset :: !CUInt
  } deriving (Eq, Show)

instance Storable MorxInsertionSubtable where
  sizeOf    _ = 20
  alignment _ = 4
  peek p = MorxInsertionSubtable <$> peekByteOff p 0
    <*> peekByteOff p 16
  poke p (MorxInsertionSubtable {..}) = do
    pokeByteOff p 0 morxInsertionSubtableHeader
    pokeByteOff p 16 morxInsertionSubtableInsertionGlyphTableOffset

{-# NOINLINE morxInsertionSubtableStructType #-}
morxInsertionSubtableStructType :: Ptr CType
morxInsertionSubtableStructType = unsafePerformIO $ fst <$> newStructCType [stxHeaderStructType, ffi_type_uint]

argMorxInsertionSubtable :: MorxInsertionSubtable -> Arg
argMorxInsertionSubtable = mkStorableArg morxInsertionSubtableStructType

retMorxInsertionSubtable :: RetType MorxInsertionSubtable
retMorxInsertionSubtable = mkStorableRetType morxInsertionSubtableStructType

instance ObjCArgument MorxInsertionSubtable where
  withObjCArg x k = k (argMorxInsertionSubtable x)

instance ObjCReturn MorxInsertionSubtable where
  type RawReturn MorxInsertionSubtable = MorxInsertionSubtable
  objcRetType = retMorxInsertionSubtable
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data MorxLigatureSubtable = MorxLigatureSubtable
  { morxLigatureSubtableHeader :: !STXHeader
  , morxLigatureSubtableLigatureActionTableOffset :: !CUInt
  , morxLigatureSubtableComponentTableOffset :: !CUInt
  , morxLigatureSubtableLigatureTableOffset :: !CUInt
  } deriving (Eq, Show)

instance Storable MorxLigatureSubtable where
  sizeOf    _ = 28
  alignment _ = 4
  peek p = MorxLigatureSubtable <$> peekByteOff p 0
    <*> peekByteOff p 16
    <*> peekByteOff p 20
    <*> peekByteOff p 24
  poke p (MorxLigatureSubtable {..}) = do
    pokeByteOff p 0 morxLigatureSubtableHeader
    pokeByteOff p 16 morxLigatureSubtableLigatureActionTableOffset
    pokeByteOff p 20 morxLigatureSubtableComponentTableOffset
    pokeByteOff p 24 morxLigatureSubtableLigatureTableOffset

{-# NOINLINE morxLigatureSubtableStructType #-}
morxLigatureSubtableStructType :: Ptr CType
morxLigatureSubtableStructType = unsafePerformIO $ fst <$> newStructCType [stxHeaderStructType, ffi_type_uint, ffi_type_uint, ffi_type_uint]

argMorxLigatureSubtable :: MorxLigatureSubtable -> Arg
argMorxLigatureSubtable = mkStorableArg morxLigatureSubtableStructType

retMorxLigatureSubtable :: RetType MorxLigatureSubtable
retMorxLigatureSubtable = mkStorableRetType morxLigatureSubtableStructType

instance ObjCArgument MorxLigatureSubtable where
  withObjCArg x k = k (argMorxLigatureSubtable x)

instance ObjCReturn MorxLigatureSubtable where
  type RawReturn MorxLigatureSubtable = MorxLigatureSubtable
  objcRetType = retMorxLigatureSubtable
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data MorxRearrangementSubtable = MorxRearrangementSubtable
  { morxRearrangementSubtableHeader :: !STXHeader
  } deriving (Eq, Show)

instance Storable MorxRearrangementSubtable where
  sizeOf    _ = 16
  alignment _ = 4
  peek p = MorxRearrangementSubtable <$> peekByteOff p 0
  poke p (MorxRearrangementSubtable {..}) =
    pokeByteOff p 0 morxRearrangementSubtableHeader

{-# NOINLINE morxRearrangementSubtableStructType #-}
morxRearrangementSubtableStructType :: Ptr CType
morxRearrangementSubtableStructType = unsafePerformIO $ fst <$> newStructCType [stxHeaderStructType]

argMorxRearrangementSubtable :: MorxRearrangementSubtable -> Arg
argMorxRearrangementSubtable = mkStorableArg morxRearrangementSubtableStructType

retMorxRearrangementSubtable :: RetType MorxRearrangementSubtable
retMorxRearrangementSubtable = mkStorableRetType morxRearrangementSubtableStructType

instance ObjCArgument MorxRearrangementSubtable where
  withObjCArg x k = k (argMorxRearrangementSubtable x)

instance ObjCReturn MorxRearrangementSubtable where
  type RawReturn MorxRearrangementSubtable = MorxRearrangementSubtable
  objcRetType = retMorxRearrangementSubtable
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure
