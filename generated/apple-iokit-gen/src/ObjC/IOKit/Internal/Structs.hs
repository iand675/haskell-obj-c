{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TypeFamilies #-}

-- | Struct types for this framework.
--
-- Generated by objc-codegen. Do not edit.
module ObjC.IOKit.Internal.Structs where

import Foreign.Ptr (Ptr, FunPtr)
import Foreign.Storable (Storable(..))
import Foreign.C.Types
import Foreign.LibFFI.Base (Arg, RetType, mkStorableArg, mkStorableRetType, newStructCType)
import Foreign.LibFFI.FFITypes
import Foreign.LibFFI.Internal (CType)
import System.IO.Unsafe (unsafePerformIO)
import ObjC.Runtime.Message (ObjCArgument(..), ObjCReturn(..), MsgSendVariant(..))

-- | IOColorEntry
--
-- A structure defining one entry of a color lookup table.
--
-- This structure is used by IOFramebuffer to define an entry of a color lookup table.  index Number of pixels visible per row.  red Value of red component 0-65535.  green Value of green component 0-65535.  blue Value of blue component 0-65535.
data IOColorEntry = IOColorEntry
  { ioColorEntryIndex :: !CUShort
  , ioColorEntryRed :: !CUShort
  , ioColorEntryGreen :: !CUShort
  , ioColorEntryBlue :: !CUShort
  } deriving (Eq, Show)

instance Storable IOColorEntry where
  sizeOf    _ = 8
  alignment _ = 2
  peek p = IOColorEntry <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 6
  poke p (IOColorEntry {..}) = do
    pokeByteOff p 0 ioColorEntryIndex
    pokeByteOff p 2 ioColorEntryRed
    pokeByteOff p 4 ioColorEntryGreen
    pokeByteOff p 6 ioColorEntryBlue

{-# NOINLINE ioColorEntryStructType #-}
ioColorEntryStructType :: Ptr CType
ioColorEntryStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argIOColorEntry :: IOColorEntry -> Arg
argIOColorEntry = mkStorableArg ioColorEntryStructType

retIOColorEntry :: RetType IOColorEntry
retIOColorEntry = mkStorableRetType ioColorEntryStructType

instance ObjCArgument IOColorEntry where
  withObjCArg x k = k (argIOColorEntry x)

instance ObjCReturn IOColorEntry where
  type RawReturn IOColorEntry = IOColorEntry
  objcRetType = retIOColorEntry
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | / Display mode timing information
data IODetailedTimingInformationV1 = IODetailedTimingInformationV1
  { ioDetailedTimingInformationV1PixelClock :: !CUInt
  , ioDetailedTimingInformationV1HorizontalActive :: !CUInt
  , ioDetailedTimingInformationV1HorizontalBlanking :: !CUInt
  , ioDetailedTimingInformationV1HorizontalBorder :: !CUInt
  , ioDetailedTimingInformationV1HorizontalSyncOffset :: !CUInt
  , ioDetailedTimingInformationV1HorizontalSyncWidth :: !CUInt
  , ioDetailedTimingInformationV1VerticalActive :: !CUInt
  , ioDetailedTimingInformationV1VerticalBlanking :: !CUInt
  , ioDetailedTimingInformationV1VerticalBorder :: !CUInt
  , ioDetailedTimingInformationV1VerticalSyncOffset :: !CUInt
  , ioDetailedTimingInformationV1VerticalSyncWidth :: !CUInt
  } deriving (Eq, Show)

instance Storable IODetailedTimingInformationV1 where
  sizeOf    _ = 44
  alignment _ = 4
  peek p = IODetailedTimingInformationV1 <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
    <*> peekByteOff p 16
    <*> peekByteOff p 20
    <*> peekByteOff p 24
    <*> peekByteOff p 28
    <*> peekByteOff p 32
    <*> peekByteOff p 36
    <*> peekByteOff p 40
  poke p (IODetailedTimingInformationV1 {..}) = do
    pokeByteOff p 0 ioDetailedTimingInformationV1PixelClock
    pokeByteOff p 4 ioDetailedTimingInformationV1HorizontalActive
    pokeByteOff p 8 ioDetailedTimingInformationV1HorizontalBlanking
    pokeByteOff p 12 ioDetailedTimingInformationV1HorizontalBorder
    pokeByteOff p 16 ioDetailedTimingInformationV1HorizontalSyncOffset
    pokeByteOff p 20 ioDetailedTimingInformationV1HorizontalSyncWidth
    pokeByteOff p 24 ioDetailedTimingInformationV1VerticalActive
    pokeByteOff p 28 ioDetailedTimingInformationV1VerticalBlanking
    pokeByteOff p 32 ioDetailedTimingInformationV1VerticalBorder
    pokeByteOff p 36 ioDetailedTimingInformationV1VerticalSyncOffset
    pokeByteOff p 40 ioDetailedTimingInformationV1VerticalSyncWidth

{-# NOINLINE ioDetailedTimingInformationV1StructType #-}
ioDetailedTimingInformationV1StructType :: Ptr CType
ioDetailedTimingInformationV1StructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint]

argIODetailedTimingInformationV1 :: IODetailedTimingInformationV1 -> Arg
argIODetailedTimingInformationV1 = mkStorableArg ioDetailedTimingInformationV1StructType

retIODetailedTimingInformationV1 :: RetType IODetailedTimingInformationV1
retIODetailedTimingInformationV1 = mkStorableRetType ioDetailedTimingInformationV1StructType

instance ObjCArgument IODetailedTimingInformationV1 where
  withObjCArg x k = k (argIODetailedTimingInformationV1 x)

instance ObjCReturn IODetailedTimingInformationV1 where
  type RawReturn IODetailedTimingInformationV1 = IODetailedTimingInformationV1
  objcRetType = retIODetailedTimingInformationV1
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data IOFBDisplayModeDescription = IOFBDisplayModeDescription
  { iofbDisplayModeDescriptionInfo :: !(Ptr ())
  , iofbDisplayModeDescriptionTimingInfo :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable IOFBDisplayModeDescription where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = IOFBDisplayModeDescription <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (IOFBDisplayModeDescription {..}) = do
    pokeByteOff p 0 iofbDisplayModeDescriptionInfo
    pokeByteOff p 8 iofbDisplayModeDescriptionTimingInfo

{-# NOINLINE iofbDisplayModeDescriptionStructType #-}
iofbDisplayModeDescriptionStructType :: Ptr CType
iofbDisplayModeDescriptionStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer, ffi_type_pointer]

argIOFBDisplayModeDescription :: IOFBDisplayModeDescription -> Arg
argIOFBDisplayModeDescription = mkStorableArg iofbDisplayModeDescriptionStructType

retIOFBDisplayModeDescription :: RetType IOFBDisplayModeDescription
retIOFBDisplayModeDescription = mkStorableRetType iofbDisplayModeDescriptionStructType

instance ObjCArgument IOFBDisplayModeDescription where
  withObjCArg x k = k (argIOFBDisplayModeDescription x)

instance ObjCReturn IOFBDisplayModeDescription where
  type RawReturn IOFBDisplayModeDescription = IOFBDisplayModeDescription
  objcRetType = retIOFBDisplayModeDescription
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data IOFixedPoint32 = IOFixedPoint32
  { ioFixedPoint32X :: !CInt
  , ioFixedPoint32Y :: !CInt
  } deriving (Eq, Show)

instance Storable IOFixedPoint32 where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = IOFixedPoint32 <$> peekByteOff p 0
    <*> peekByteOff p 4
  poke p (IOFixedPoint32 {..}) = do
    pokeByteOff p 0 ioFixedPoint32X
    pokeByteOff p 4 ioFixedPoint32Y

{-# NOINLINE ioFixedPoint32StructType #-}
ioFixedPoint32StructType :: Ptr CType
ioFixedPoint32StructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_sint]

argIOFixedPoint32 :: IOFixedPoint32 -> Arg
argIOFixedPoint32 = mkStorableArg ioFixedPoint32StructType

retIOFixedPoint32 :: RetType IOFixedPoint32
retIOFixedPoint32 = mkStorableRetType ioFixedPoint32StructType

instance ObjCArgument IOFixedPoint32 where
  withObjCArg x k = k (argIOFixedPoint32 x)

instance ObjCReturn IOFixedPoint32 where
  type RawReturn IOFixedPoint32 = IOFixedPoint32
  objcRetType = retIOFixedPoint32
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data IOGBounds = IOGBounds
  { iogBoundsMinx :: !CShort
  , iogBoundsMaxx :: !CShort
  , iogBoundsMiny :: !CShort
  , iogBoundsMaxy :: !CShort
  } deriving (Eq, Show)

instance Storable IOGBounds where
  sizeOf    _ = 8
  alignment _ = 2
  peek p = IOGBounds <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 6
  poke p (IOGBounds {..}) = do
    pokeByteOff p 0 iogBoundsMinx
    pokeByteOff p 2 iogBoundsMaxx
    pokeByteOff p 4 iogBoundsMiny
    pokeByteOff p 6 iogBoundsMaxy

{-# NOINLINE iogBoundsStructType #-}
iogBoundsStructType :: Ptr CType
iogBoundsStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16]

argIOGBounds :: IOGBounds -> Arg
argIOGBounds = mkStorableArg iogBoundsStructType

retIOGBounds :: RetType IOGBounds
retIOGBounds = mkStorableRetType iogBoundsStructType

instance ObjCArgument IOGBounds where
  withObjCArg x k = k (argIOGBounds x)

instance ObjCReturn IOGBounds where
  type RawReturn IOGBounds = IOGBounds
  objcRetType = retIOGBounds
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data IOGPoint = IOGPoint
  { iogPointX :: !CShort
  , iogPointY :: !CShort
  } deriving (Eq, Show)

instance Storable IOGPoint where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = IOGPoint <$> peekByteOff p 0
    <*> peekByteOff p 2
  poke p (IOGPoint {..}) = do
    pokeByteOff p 0 iogPointX
    pokeByteOff p 2 iogPointY

{-# NOINLINE iogPointStructType #-}
iogPointStructType :: Ptr CType
iogPointStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16, ffi_type_sint16]

argIOGPoint :: IOGPoint -> Arg
argIOGPoint = mkStorableArg iogPointStructType

retIOGPoint :: RetType IOGPoint
retIOGPoint = mkStorableRetType iogPointStructType

instance ObjCArgument IOGPoint where
  withObjCArg x k = k (argIOGPoint x)

instance ObjCReturn IOGPoint where
  type RawReturn IOGPoint = IOGPoint
  objcRetType = retIOGPoint
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data IOGSize = IOGSize
  { iogSizeWidth :: !CShort
  , iogSizeHeight :: !CShort
  } deriving (Eq, Show)

instance Storable IOGSize where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = IOGSize <$> peekByteOff p 0
    <*> peekByteOff p 2
  poke p (IOGSize {..}) = do
    pokeByteOff p 0 iogSizeWidth
    pokeByteOff p 2 iogSizeHeight

{-# NOINLINE iogSizeStructType #-}
iogSizeStructType :: Ptr CType
iogSizeStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16, ffi_type_sint16]

argIOGSize :: IOGSize -> Arg
argIOGSize = mkStorableArg iogSizeStructType

retIOGSize :: RetType IOGSize
retIOGSize = mkStorableRetType iogSizeStructType

instance ObjCArgument IOGSize where
  withObjCArg x k = k (argIOGSize x)

instance ObjCReturn IOGSize where
  type RawReturn IOGSize = IOGSize
  objcRetType = retIOGSize
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | IOHIDCompletion
--
-- Struct specifying action to perform when set/get report completes.
--
-- target
--
-- The target to pass to the action function.
--
-- action
--
-- The function to call.
--
-- parameter
--
-- The parameter to pass to the action function.
data IOHIDCompletion = IOHIDCompletion
  { iohidCompletionTarget :: !(Ptr ())
  , iohidCompletionAction :: !(Ptr ())
  , iohidCompletionParameter :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable IOHIDCompletion where
  sizeOf    _ = 24
  alignment _ = 8
  peek p = IOHIDCompletion <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
  poke p (IOHIDCompletion {..}) = do
    pokeByteOff p 0 iohidCompletionTarget
    pokeByteOff p 8 iohidCompletionAction
    pokeByteOff p 16 iohidCompletionParameter

{-# NOINLINE iohidCompletionStructType #-}
iohidCompletionStructType :: Ptr CType
iohidCompletionStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer, ffi_type_pointer, ffi_type_pointer]

argIOHIDCompletion :: IOHIDCompletion -> Arg
argIOHIDCompletion = mkStorableArg iohidCompletionStructType

retIOHIDCompletion :: RetType IOHIDCompletion
retIOHIDCompletion = mkStorableRetType iohidCompletionStructType

instance ObjCArgument IOHIDCompletion where
  withObjCArg x k = k (argIOHIDCompletion x)

instance ObjCReturn IOHIDCompletion where
  type RawReturn IOHIDCompletion = IOHIDCompletion
  objcRetType = retIOHIDCompletion
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | IOUSBBOSDescriptor
--
-- USB BOS descriptor. See the USB Specification at             http://www.usb.org.             USB 3.0 9.6.2: Binary Device Object Store (BOS)
data IOUSBBOSDescriptor = IOUSBBOSDescriptor
  { iousbbosDescriptorBLength :: !CUChar
  , iousbbosDescriptorBDescriptorType :: !CUChar
  , iousbbosDescriptorWTotalLength :: !CUShort
  , iousbbosDescriptorBNumDeviceCaps :: !CUChar
  } deriving (Eq, Show)

instance Storable IOUSBBOSDescriptor where
  sizeOf    _ = 6
  alignment _ = 2
  peek p = IOUSBBOSDescriptor <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
    <*> peekByteOff p 4
  poke p (IOUSBBOSDescriptor {..}) = do
    pokeByteOff p 0 iousbbosDescriptorBLength
    pokeByteOff p 1 iousbbosDescriptorBDescriptorType
    pokeByteOff p 2 iousbbosDescriptorWTotalLength
    pokeByteOff p 4 iousbbosDescriptorBNumDeviceCaps

{-# NOINLINE iousbbosDescriptorStructType #-}
iousbbosDescriptorStructType :: Ptr CType
iousbbosDescriptorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint16, ffi_type_uint8]

argIOUSBBOSDescriptor :: IOUSBBOSDescriptor -> Arg
argIOUSBBOSDescriptor = mkStorableArg iousbbosDescriptorStructType

retIOUSBBOSDescriptor :: RetType IOUSBBOSDescriptor
retIOUSBBOSDescriptor = mkStorableRetType iousbbosDescriptorStructType

instance ObjCArgument IOUSBBOSDescriptor where
  withObjCArg x k = k (argIOUSBBOSDescriptor x)

instance ObjCReturn IOUSBBOSDescriptor where
  type RawReturn IOUSBBOSDescriptor = IOUSBBOSDescriptor
  objcRetType = retIOUSBBOSDescriptor
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | IOUSBConfigurationDescHeader
--
-- Header of a IOUSBConfigurationDescriptor.  Used to get the total length of the descriptor.             USB 2.0 9.6.3: Configuration
data IOUSBConfigurationDescHeader = IOUSBConfigurationDescHeader
  { iousbConfigurationDescHeaderBLength :: !CUChar
  , iousbConfigurationDescHeaderBDescriptorType :: !CUChar
  , iousbConfigurationDescHeaderWTotalLength :: !CUShort
  } deriving (Eq, Show)

instance Storable IOUSBConfigurationDescHeader where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = IOUSBConfigurationDescHeader <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
  poke p (IOUSBConfigurationDescHeader {..}) = do
    pokeByteOff p 0 iousbConfigurationDescHeaderBLength
    pokeByteOff p 1 iousbConfigurationDescHeaderBDescriptorType
    pokeByteOff p 2 iousbConfigurationDescHeaderWTotalLength

{-# NOINLINE iousbConfigurationDescHeaderStructType #-}
iousbConfigurationDescHeaderStructType :: Ptr CType
iousbConfigurationDescHeaderStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint16]

argIOUSBConfigurationDescHeader :: IOUSBConfigurationDescHeader -> Arg
argIOUSBConfigurationDescHeader = mkStorableArg iousbConfigurationDescHeaderStructType

retIOUSBConfigurationDescHeader :: RetType IOUSBConfigurationDescHeader
retIOUSBConfigurationDescHeader = mkStorableRetType iousbConfigurationDescHeaderStructType

instance ObjCArgument IOUSBConfigurationDescHeader where
  withObjCArg x k = k (argIOUSBConfigurationDescHeader x)

instance ObjCReturn IOUSBConfigurationDescHeader where
  type RawReturn IOUSBConfigurationDescHeader = IOUSBConfigurationDescHeader
  objcRetType = retIOUSBConfigurationDescHeader
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | IOUSBConfigurationDescriptor
--
-- Standard USB Configuration Descriptor.  It is variable length, so this only specifies             the known fields.  We use the wTotalLength field to read the whole descriptor.             See the USB Specification at http://www.usb.org.             USB 2.0 9.6.3: Configuration
data IOUSBConfigurationDescriptor = IOUSBConfigurationDescriptor
  { iousbConfigurationDescriptorBLength :: !CUChar
  , iousbConfigurationDescriptorBDescriptorType :: !CUChar
  , iousbConfigurationDescriptorWTotalLength :: !CUShort
  , iousbConfigurationDescriptorBNumInterfaces :: !CUChar
  , iousbConfigurationDescriptorBConfigurationValue :: !CUChar
  , iousbConfigurationDescriptorIConfiguration :: !CUChar
  , iousbConfigurationDescriptorBmAttributes :: !CUChar
  , iousbConfigurationDescriptorMaxPower :: !CUChar
  } deriving (Eq, Show)

instance Storable IOUSBConfigurationDescriptor where
  sizeOf    _ = 10
  alignment _ = 2
  peek p = IOUSBConfigurationDescriptor <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 5
    <*> peekByteOff p 6
    <*> peekByteOff p 7
    <*> peekByteOff p 8
  poke p (IOUSBConfigurationDescriptor {..}) = do
    pokeByteOff p 0 iousbConfigurationDescriptorBLength
    pokeByteOff p 1 iousbConfigurationDescriptorBDescriptorType
    pokeByteOff p 2 iousbConfigurationDescriptorWTotalLength
    pokeByteOff p 4 iousbConfigurationDescriptorBNumInterfaces
    pokeByteOff p 5 iousbConfigurationDescriptorBConfigurationValue
    pokeByteOff p 6 iousbConfigurationDescriptorIConfiguration
    pokeByteOff p 7 iousbConfigurationDescriptorBmAttributes
    pokeByteOff p 8 iousbConfigurationDescriptorMaxPower

{-# NOINLINE iousbConfigurationDescriptorStructType #-}
iousbConfigurationDescriptorStructType :: Ptr CType
iousbConfigurationDescriptorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint16, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8]

argIOUSBConfigurationDescriptor :: IOUSBConfigurationDescriptor -> Arg
argIOUSBConfigurationDescriptor = mkStorableArg iousbConfigurationDescriptorStructType

retIOUSBConfigurationDescriptor :: RetType IOUSBConfigurationDescriptor
retIOUSBConfigurationDescriptor = mkStorableRetType iousbConfigurationDescriptorStructType

instance ObjCArgument IOUSBConfigurationDescriptor where
  withObjCArg x k = k (argIOUSBConfigurationDescriptor x)

instance ObjCReturn IOUSBConfigurationDescriptor where
  type RawReturn IOUSBConfigurationDescriptor = IOUSBConfigurationDescriptor
  objcRetType = retIOUSBConfigurationDescriptor
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | IOUSBDFUDescriptor
--
-- USB Device Firmware Update Descriptor. See the USB Device Firmware Update             Specification at http://www.usb.org.
data IOUSBDFUDescriptor = IOUSBDFUDescriptor
  { iousbdfuDescriptorBLength :: !CUChar
  , iousbdfuDescriptorBDescriptorType :: !CUChar
  , iousbdfuDescriptorBmAttributes :: !CUChar
  , iousbdfuDescriptorWDetachTimeout :: !CUShort
  , iousbdfuDescriptorWTransferSize :: !CUShort
  } deriving (Eq, Show)

instance Storable IOUSBDFUDescriptor where
  sizeOf    _ = 8
  alignment _ = 2
  peek p = IOUSBDFUDescriptor <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 6
  poke p (IOUSBDFUDescriptor {..}) = do
    pokeByteOff p 0 iousbdfuDescriptorBLength
    pokeByteOff p 1 iousbdfuDescriptorBDescriptorType
    pokeByteOff p 2 iousbdfuDescriptorBmAttributes
    pokeByteOff p 4 iousbdfuDescriptorWDetachTimeout
    pokeByteOff p 6 iousbdfuDescriptorWTransferSize

{-# NOINLINE iousbdfuDescriptorStructType #-}
iousbdfuDescriptorStructType :: Ptr CType
iousbdfuDescriptorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint16, ffi_type_uint16]

argIOUSBDFUDescriptor :: IOUSBDFUDescriptor -> Arg
argIOUSBDFUDescriptor = mkStorableArg iousbdfuDescriptorStructType

retIOUSBDFUDescriptor :: RetType IOUSBDFUDescriptor
retIOUSBDFUDescriptor = mkStorableRetType iousbdfuDescriptorStructType

instance ObjCArgument IOUSBDFUDescriptor where
  withObjCArg x k = k (argIOUSBDFUDescriptor x)

instance ObjCReturn IOUSBDFUDescriptor where
  type RawReturn IOUSBDFUDescriptor = IOUSBDFUDescriptor
  objcRetType = retIOUSBDFUDescriptor
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | IOUSBDescriptorHeader
--
-- Base descriptor defined by USB 2.0 9.5
--
-- IOUSBDescriptorDefinitions declares structs to represent a variety of USB standard              descriptors.
data IOUSBDescriptor = IOUSBDescriptor
  { iousbDescriptorBLength :: !CUChar
  , iousbDescriptorBDescriptorType :: !CUChar
  } deriving (Eq, Show)

instance Storable IOUSBDescriptor where
  sizeOf    _ = 2
  alignment _ = 1
  peek p = IOUSBDescriptor <$> peekByteOff p 0
    <*> peekByteOff p 1
  poke p (IOUSBDescriptor {..}) = do
    pokeByteOff p 0 iousbDescriptorBLength
    pokeByteOff p 1 iousbDescriptorBDescriptorType

{-# NOINLINE iousbDescriptorStructType #-}
iousbDescriptorStructType :: Ptr CType
iousbDescriptorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8]

argIOUSBDescriptor :: IOUSBDescriptor -> Arg
argIOUSBDescriptor = mkStorableArg iousbDescriptorStructType

retIOUSBDescriptor :: RetType IOUSBDescriptor
retIOUSBDescriptor = mkStorableRetType iousbDescriptorStructType

instance ObjCArgument IOUSBDescriptor where
  withObjCArg x k = k (argIOUSBDescriptor x)

instance ObjCReturn IOUSBDescriptor where
  type RawReturn IOUSBDescriptor = IOUSBDescriptor
  objcRetType = retIOUSBDescriptor
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | IOUSBDescriptorHeader
--
-- Base descriptor defined by USB 2.0 9.5
--
-- IOUSBDescriptorDefinitions declares structs to represent a variety of USB standard              descriptors.
data IOUSBDescriptorHeader = IOUSBDescriptorHeader
  { iousbDescriptorHeaderBLength :: !CUChar
  , iousbDescriptorHeaderBDescriptorType :: !CUChar
  } deriving (Eq, Show)

instance Storable IOUSBDescriptorHeader where
  sizeOf    _ = 2
  alignment _ = 1
  peek p = IOUSBDescriptorHeader <$> peekByteOff p 0
    <*> peekByteOff p 1
  poke p (IOUSBDescriptorHeader {..}) = do
    pokeByteOff p 0 iousbDescriptorHeaderBLength
    pokeByteOff p 1 iousbDescriptorHeaderBDescriptorType

{-# NOINLINE iousbDescriptorHeaderStructType #-}
iousbDescriptorHeaderStructType :: Ptr CType
iousbDescriptorHeaderStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8]

argIOUSBDescriptorHeader :: IOUSBDescriptorHeader -> Arg
argIOUSBDescriptorHeader = mkStorableArg iousbDescriptorHeaderStructType

retIOUSBDescriptorHeader :: RetType IOUSBDescriptorHeader
retIOUSBDescriptorHeader = mkStorableRetType iousbDescriptorHeaderStructType

instance ObjCArgument IOUSBDescriptorHeader where
  withObjCArg x k = k (argIOUSBDescriptorHeader x)

instance ObjCReturn IOUSBDescriptorHeader where
  type RawReturn IOUSBDescriptorHeader = IOUSBDescriptorHeader
  objcRetType = retIOUSBDescriptorHeader
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | IOUSBDeviceCapabilityBillboardAltConfig
--
-- Device Capability Billboard Alternate Setting Info.             USB Billboard 3.1.6.2: Billboard Capability Descriptor V1.1 and 1.21+
data IOUSBDeviceCapabilityBillboardAltConfig = IOUSBDeviceCapabilityBillboardAltConfig
  { iousbDeviceCapabilityBillboardAltConfigWSVID :: !CUShort
  , iousbDeviceCapabilityBillboardAltConfigBAltenateMode :: !CUChar
  , iousbDeviceCapabilityBillboardAltConfigIAlternateModeString :: !CUChar
  } deriving (Eq, Show)

instance Storable IOUSBDeviceCapabilityBillboardAltConfig where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = IOUSBDeviceCapabilityBillboardAltConfig <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 3
  poke p (IOUSBDeviceCapabilityBillboardAltConfig {..}) = do
    pokeByteOff p 0 iousbDeviceCapabilityBillboardAltConfigWSVID
    pokeByteOff p 2 iousbDeviceCapabilityBillboardAltConfigBAltenateMode
    pokeByteOff p 3 iousbDeviceCapabilityBillboardAltConfigIAlternateModeString

{-# NOINLINE iousbDeviceCapabilityBillboardAltConfigStructType #-}
iousbDeviceCapabilityBillboardAltConfigStructType :: Ptr CType
iousbDeviceCapabilityBillboardAltConfigStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint8, ffi_type_uint8]

argIOUSBDeviceCapabilityBillboardAltConfig :: IOUSBDeviceCapabilityBillboardAltConfig -> Arg
argIOUSBDeviceCapabilityBillboardAltConfig = mkStorableArg iousbDeviceCapabilityBillboardAltConfigStructType

retIOUSBDeviceCapabilityBillboardAltConfig :: RetType IOUSBDeviceCapabilityBillboardAltConfig
retIOUSBDeviceCapabilityBillboardAltConfig = mkStorableRetType iousbDeviceCapabilityBillboardAltConfigStructType

instance ObjCArgument IOUSBDeviceCapabilityBillboardAltConfig where
  withObjCArg x k = k (argIOUSBDeviceCapabilityBillboardAltConfig x)

instance ObjCReturn IOUSBDeviceCapabilityBillboardAltConfig where
  type RawReturn IOUSBDeviceCapabilityBillboardAltConfig = IOUSBDeviceCapabilityBillboardAltConfig
  objcRetType = retIOUSBDeviceCapabilityBillboardAltConfig
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | IOUSBDeviceCapabilityBillboardAltConfig
--
-- Device Capability Billboard Alternate Setting Info.             USB Billboard 3.1.6.2: Billboard Capability Descriptor V1.2
data IOUSBDeviceCapabilityBillboardAltConfigCompatibility = IOUSBDeviceCapabilityBillboardAltConfigCompatibility
  { iousbDeviceCapabilityBillboardAltConfigCompatibilityWSVID :: !CUShort
  , iousbDeviceCapabilityBillboardAltConfigCompatibilityDwAlternateMode :: !CUInt
  , iousbDeviceCapabilityBillboardAltConfigCompatibilityIAlternateModeString :: !CUChar
  } deriving (Eq, Show)

instance Storable IOUSBDeviceCapabilityBillboardAltConfigCompatibility where
  sizeOf    _ = 12
  alignment _ = 4
  peek p = IOUSBDeviceCapabilityBillboardAltConfigCompatibility <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (IOUSBDeviceCapabilityBillboardAltConfigCompatibility {..}) = do
    pokeByteOff p 0 iousbDeviceCapabilityBillboardAltConfigCompatibilityWSVID
    pokeByteOff p 4 iousbDeviceCapabilityBillboardAltConfigCompatibilityDwAlternateMode
    pokeByteOff p 8 iousbDeviceCapabilityBillboardAltConfigCompatibilityIAlternateModeString

{-# NOINLINE iousbDeviceCapabilityBillboardAltConfigCompatibilityStructType #-}
iousbDeviceCapabilityBillboardAltConfigCompatibilityStructType :: Ptr CType
iousbDeviceCapabilityBillboardAltConfigCompatibilityStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint, ffi_type_uint8]

argIOUSBDeviceCapabilityBillboardAltConfigCompatibility :: IOUSBDeviceCapabilityBillboardAltConfigCompatibility -> Arg
argIOUSBDeviceCapabilityBillboardAltConfigCompatibility = mkStorableArg iousbDeviceCapabilityBillboardAltConfigCompatibilityStructType

retIOUSBDeviceCapabilityBillboardAltConfigCompatibility :: RetType IOUSBDeviceCapabilityBillboardAltConfigCompatibility
retIOUSBDeviceCapabilityBillboardAltConfigCompatibility = mkStorableRetType iousbDeviceCapabilityBillboardAltConfigCompatibilityStructType

instance ObjCArgument IOUSBDeviceCapabilityBillboardAltConfigCompatibility where
  withObjCArg x k = k (argIOUSBDeviceCapabilityBillboardAltConfigCompatibility x)

instance ObjCReturn IOUSBDeviceCapabilityBillboardAltConfigCompatibility where
  type RawReturn IOUSBDeviceCapabilityBillboardAltConfigCompatibility = IOUSBDeviceCapabilityBillboardAltConfigCompatibility
  objcRetType = retIOUSBDeviceCapabilityBillboardAltConfigCompatibility
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | IOUSBDeviceCapabilityBillboardAltMode
--
-- Device Capability Billboard Alternate mode.             USB Billboard 3.1.6.3: Billboard Capability Descriptor V1.21
data IOUSBDeviceCapabilityBillboardAltMode = IOUSBDeviceCapabilityBillboardAltMode
  { iousbDeviceCapabilityBillboardAltModeBLength :: !CUChar
  , iousbDeviceCapabilityBillboardAltModeBDescriptorType :: !CUChar
  , iousbDeviceCapabilityBillboardAltModeBDevCapabilityType :: !CUChar
  , iousbDeviceCapabilityBillboardAltModeBIndex :: !CUChar
  , iousbDeviceCapabilityBillboardAltModeDwAlternateModeVdo :: !CUShort
  } deriving (Eq, Show)

instance Storable IOUSBDeviceCapabilityBillboardAltMode where
  sizeOf    _ = 6
  alignment _ = 2
  peek p = IOUSBDeviceCapabilityBillboardAltMode <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
    <*> peekByteOff p 3
    <*> peekByteOff p 4
  poke p (IOUSBDeviceCapabilityBillboardAltMode {..}) = do
    pokeByteOff p 0 iousbDeviceCapabilityBillboardAltModeBLength
    pokeByteOff p 1 iousbDeviceCapabilityBillboardAltModeBDescriptorType
    pokeByteOff p 2 iousbDeviceCapabilityBillboardAltModeBDevCapabilityType
    pokeByteOff p 3 iousbDeviceCapabilityBillboardAltModeBIndex
    pokeByteOff p 4 iousbDeviceCapabilityBillboardAltModeDwAlternateModeVdo

{-# NOINLINE iousbDeviceCapabilityBillboardAltModeStructType #-}
iousbDeviceCapabilityBillboardAltModeStructType :: Ptr CType
iousbDeviceCapabilityBillboardAltModeStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint16]

argIOUSBDeviceCapabilityBillboardAltMode :: IOUSBDeviceCapabilityBillboardAltMode -> Arg
argIOUSBDeviceCapabilityBillboardAltMode = mkStorableArg iousbDeviceCapabilityBillboardAltModeStructType

retIOUSBDeviceCapabilityBillboardAltMode :: RetType IOUSBDeviceCapabilityBillboardAltMode
retIOUSBDeviceCapabilityBillboardAltMode = mkStorableRetType iousbDeviceCapabilityBillboardAltModeStructType

instance ObjCArgument IOUSBDeviceCapabilityBillboardAltMode where
  withObjCArg x k = k (argIOUSBDeviceCapabilityBillboardAltMode x)

instance ObjCReturn IOUSBDeviceCapabilityBillboardAltMode where
  type RawReturn IOUSBDeviceCapabilityBillboardAltMode = IOUSBDeviceCapabilityBillboardAltMode
  objcRetType = retIOUSBDeviceCapabilityBillboardAltMode
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | IOUSBDeviceCapabilityDescriptorHeader
--
-- Device Capability descriptor.  See the USB Specification at             http://www.usb.org.             USB 3.0 9.6.2: Binary Device Object Store (BOS)
data IOUSBDeviceCapabilityDescriptorHeader = IOUSBDeviceCapabilityDescriptorHeader
  { iousbDeviceCapabilityDescriptorHeaderBLength :: !CUChar
  , iousbDeviceCapabilityDescriptorHeaderBDescriptorType :: !CUChar
  , iousbDeviceCapabilityDescriptorHeaderBDevCapabilityType :: !CUChar
  } deriving (Eq, Show)

instance Storable IOUSBDeviceCapabilityDescriptorHeader where
  sizeOf    _ = 3
  alignment _ = 1
  peek p = IOUSBDeviceCapabilityDescriptorHeader <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
  poke p (IOUSBDeviceCapabilityDescriptorHeader {..}) = do
    pokeByteOff p 0 iousbDeviceCapabilityDescriptorHeaderBLength
    pokeByteOff p 1 iousbDeviceCapabilityDescriptorHeaderBDescriptorType
    pokeByteOff p 2 iousbDeviceCapabilityDescriptorHeaderBDevCapabilityType

{-# NOINLINE iousbDeviceCapabilityDescriptorHeaderStructType #-}
iousbDeviceCapabilityDescriptorHeaderStructType :: Ptr CType
iousbDeviceCapabilityDescriptorHeaderStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint8]

argIOUSBDeviceCapabilityDescriptorHeader :: IOUSBDeviceCapabilityDescriptorHeader -> Arg
argIOUSBDeviceCapabilityDescriptorHeader = mkStorableArg iousbDeviceCapabilityDescriptorHeaderStructType

retIOUSBDeviceCapabilityDescriptorHeader :: RetType IOUSBDeviceCapabilityDescriptorHeader
retIOUSBDeviceCapabilityDescriptorHeader = mkStorableRetType iousbDeviceCapabilityDescriptorHeaderStructType

instance ObjCArgument IOUSBDeviceCapabilityDescriptorHeader where
  withObjCArg x k = k (argIOUSBDeviceCapabilityDescriptorHeader x)

instance ObjCReturn IOUSBDeviceCapabilityDescriptorHeader where
  type RawReturn IOUSBDeviceCapabilityDescriptorHeader = IOUSBDeviceCapabilityDescriptorHeader
  objcRetType = retIOUSBDeviceCapabilityDescriptorHeader
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | IOUSBDeviceCapabilitySuperSpeedUSB
--
-- Device Capability SuperSpeed USB. USB 3.0 9.6.2.2: SuperSpeed USB Device Capability
data IOUSBDeviceCapabilitySuperSpeedUSB = IOUSBDeviceCapabilitySuperSpeedUSB
  { iousbDeviceCapabilitySuperSpeedUSBBLength :: !CUChar
  , iousbDeviceCapabilitySuperSpeedUSBBDescriptorType :: !CUChar
  , iousbDeviceCapabilitySuperSpeedUSBBDevCapabilityType :: !CUChar
  , iousbDeviceCapabilitySuperSpeedUSBBmAttributes :: !CUChar
  , iousbDeviceCapabilitySuperSpeedUSBWSpeedsSupported :: !CUShort
  , iousbDeviceCapabilitySuperSpeedUSBBFunctionalitySupport :: !CUChar
  , iousbDeviceCapabilitySuperSpeedUSBBU1DevExitLat :: !CUChar
  , iousbDeviceCapabilitySuperSpeedUSBWU2DevExitLat :: !CUShort
  } deriving (Eq, Show)

instance Storable IOUSBDeviceCapabilitySuperSpeedUSB where
  sizeOf    _ = 10
  alignment _ = 2
  peek p = IOUSBDeviceCapabilitySuperSpeedUSB <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
    <*> peekByteOff p 3
    <*> peekByteOff p 4
    <*> peekByteOff p 6
    <*> peekByteOff p 7
    <*> peekByteOff p 8
  poke p (IOUSBDeviceCapabilitySuperSpeedUSB {..}) = do
    pokeByteOff p 0 iousbDeviceCapabilitySuperSpeedUSBBLength
    pokeByteOff p 1 iousbDeviceCapabilitySuperSpeedUSBBDescriptorType
    pokeByteOff p 2 iousbDeviceCapabilitySuperSpeedUSBBDevCapabilityType
    pokeByteOff p 3 iousbDeviceCapabilitySuperSpeedUSBBmAttributes
    pokeByteOff p 4 iousbDeviceCapabilitySuperSpeedUSBWSpeedsSupported
    pokeByteOff p 6 iousbDeviceCapabilitySuperSpeedUSBBFunctionalitySupport
    pokeByteOff p 7 iousbDeviceCapabilitySuperSpeedUSBBU1DevExitLat
    pokeByteOff p 8 iousbDeviceCapabilitySuperSpeedUSBWU2DevExitLat

{-# NOINLINE iousbDeviceCapabilitySuperSpeedUSBStructType #-}
iousbDeviceCapabilitySuperSpeedUSBStructType :: Ptr CType
iousbDeviceCapabilitySuperSpeedUSBStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint16, ffi_type_uint8, ffi_type_uint8, ffi_type_uint16]

argIOUSBDeviceCapabilitySuperSpeedUSB :: IOUSBDeviceCapabilitySuperSpeedUSB -> Arg
argIOUSBDeviceCapabilitySuperSpeedUSB = mkStorableArg iousbDeviceCapabilitySuperSpeedUSBStructType

retIOUSBDeviceCapabilitySuperSpeedUSB :: RetType IOUSBDeviceCapabilitySuperSpeedUSB
retIOUSBDeviceCapabilitySuperSpeedUSB = mkStorableRetType iousbDeviceCapabilitySuperSpeedUSBStructType

instance ObjCArgument IOUSBDeviceCapabilitySuperSpeedUSB where
  withObjCArg x k = k (argIOUSBDeviceCapabilitySuperSpeedUSB x)

instance ObjCReturn IOUSBDeviceCapabilitySuperSpeedUSB where
  type RawReturn IOUSBDeviceCapabilitySuperSpeedUSB = IOUSBDeviceCapabilitySuperSpeedUSB
  objcRetType = retIOUSBDeviceCapabilitySuperSpeedUSB
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | IOUSBDeviceCapabilityUSB2Extension
--
-- Device Capability USB 2.0 Extension.             USB 3.0 9.6.2.1: USB 2.0 Extension
data IOUSBDeviceCapabilityUSB2Extension = IOUSBDeviceCapabilityUSB2Extension
  { iousbDeviceCapabilityUSB2ExtensionBLength :: !CUChar
  , iousbDeviceCapabilityUSB2ExtensionBDescriptorType :: !CUChar
  , iousbDeviceCapabilityUSB2ExtensionBDevCapabilityType :: !CUChar
  , iousbDeviceCapabilityUSB2ExtensionBmAttributes :: !CUInt
  } deriving (Eq, Show)

instance Storable IOUSBDeviceCapabilityUSB2Extension where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = IOUSBDeviceCapabilityUSB2Extension <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
    <*> peekByteOff p 4
  poke p (IOUSBDeviceCapabilityUSB2Extension {..}) = do
    pokeByteOff p 0 iousbDeviceCapabilityUSB2ExtensionBLength
    pokeByteOff p 1 iousbDeviceCapabilityUSB2ExtensionBDescriptorType
    pokeByteOff p 2 iousbDeviceCapabilityUSB2ExtensionBDevCapabilityType
    pokeByteOff p 4 iousbDeviceCapabilityUSB2ExtensionBmAttributes

{-# NOINLINE iousbDeviceCapabilityUSB2ExtensionStructType #-}
iousbDeviceCapabilityUSB2ExtensionStructType :: Ptr CType
iousbDeviceCapabilityUSB2ExtensionStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint]

argIOUSBDeviceCapabilityUSB2Extension :: IOUSBDeviceCapabilityUSB2Extension -> Arg
argIOUSBDeviceCapabilityUSB2Extension = mkStorableArg iousbDeviceCapabilityUSB2ExtensionStructType

retIOUSBDeviceCapabilityUSB2Extension :: RetType IOUSBDeviceCapabilityUSB2Extension
retIOUSBDeviceCapabilityUSB2Extension = mkStorableRetType iousbDeviceCapabilityUSB2ExtensionStructType

instance ObjCArgument IOUSBDeviceCapabilityUSB2Extension where
  withObjCArg x k = k (argIOUSBDeviceCapabilityUSB2Extension x)

instance ObjCReturn IOUSBDeviceCapabilityUSB2Extension where
  type RawReturn IOUSBDeviceCapabilityUSB2Extension = IOUSBDeviceCapabilityUSB2Extension
  objcRetType = retIOUSBDeviceCapabilityUSB2Extension
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | IOUSBDeviceDescriptor
--
-- Descriptor for a USB Device.             See the USB Specification at http://www.usb.org.
data IOUSBDeviceDescriptor = IOUSBDeviceDescriptor
  { iousbDeviceDescriptorBLength :: !CUChar
  , iousbDeviceDescriptorBDescriptorType :: !CUChar
  , iousbDeviceDescriptorBcdUSB :: !CUShort
  , iousbDeviceDescriptorBDeviceClass :: !CUChar
  , iousbDeviceDescriptorBDeviceSubClass :: !CUChar
  , iousbDeviceDescriptorBDeviceProtocol :: !CUChar
  , iousbDeviceDescriptorBMaxPacketSize0 :: !CUChar
  , iousbDeviceDescriptorIdVendor :: !CUShort
  , iousbDeviceDescriptorIdProduct :: !CUShort
  , iousbDeviceDescriptorBcdDevice :: !CUShort
  , iousbDeviceDescriptorIManufacturer :: !CUChar
  , iousbDeviceDescriptorIProduct :: !CUChar
  , iousbDeviceDescriptorISerialNumber :: !CUChar
  , iousbDeviceDescriptorBNumConfigurations :: !CUChar
  } deriving (Eq, Show)

instance Storable IOUSBDeviceDescriptor where
  sizeOf    _ = 18
  alignment _ = 2
  peek p = IOUSBDeviceDescriptor <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 5
    <*> peekByteOff p 6
    <*> peekByteOff p 7
    <*> peekByteOff p 8
    <*> peekByteOff p 10
    <*> peekByteOff p 12
    <*> peekByteOff p 14
    <*> peekByteOff p 15
    <*> peekByteOff p 16
    <*> peekByteOff p 17
  poke p (IOUSBDeviceDescriptor {..}) = do
    pokeByteOff p 0 iousbDeviceDescriptorBLength
    pokeByteOff p 1 iousbDeviceDescriptorBDescriptorType
    pokeByteOff p 2 iousbDeviceDescriptorBcdUSB
    pokeByteOff p 4 iousbDeviceDescriptorBDeviceClass
    pokeByteOff p 5 iousbDeviceDescriptorBDeviceSubClass
    pokeByteOff p 6 iousbDeviceDescriptorBDeviceProtocol
    pokeByteOff p 7 iousbDeviceDescriptorBMaxPacketSize0
    pokeByteOff p 8 iousbDeviceDescriptorIdVendor
    pokeByteOff p 10 iousbDeviceDescriptorIdProduct
    pokeByteOff p 12 iousbDeviceDescriptorBcdDevice
    pokeByteOff p 14 iousbDeviceDescriptorIManufacturer
    pokeByteOff p 15 iousbDeviceDescriptorIProduct
    pokeByteOff p 16 iousbDeviceDescriptorISerialNumber
    pokeByteOff p 17 iousbDeviceDescriptorBNumConfigurations

{-# NOINLINE iousbDeviceDescriptorStructType #-}
iousbDeviceDescriptorStructType :: Ptr CType
iousbDeviceDescriptorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint16, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8]

argIOUSBDeviceDescriptor :: IOUSBDeviceDescriptor -> Arg
argIOUSBDeviceDescriptor = mkStorableArg iousbDeviceDescriptorStructType

retIOUSBDeviceDescriptor :: RetType IOUSBDeviceDescriptor
retIOUSBDeviceDescriptor = mkStorableRetType iousbDeviceDescriptorStructType

instance ObjCArgument IOUSBDeviceDescriptor where
  withObjCArg x k = k (argIOUSBDeviceDescriptor x)

instance ObjCReturn IOUSBDeviceDescriptor where
  type RawReturn IOUSBDeviceDescriptor = IOUSBDeviceDescriptor
  objcRetType = retIOUSBDeviceDescriptor
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | IOUSBDeviceQualifierDescriptor
--
-- USB Device Qualifier Descriptor.             See the USB Specification at http://www.usb.org.             USB 2.0 9.6.2: Device Qualifier
data IOUSBDeviceQualifierDescriptor = IOUSBDeviceQualifierDescriptor
  { iousbDeviceQualifierDescriptorBLength :: !CUChar
  , iousbDeviceQualifierDescriptorBDescriptorType :: !CUChar
  , iousbDeviceQualifierDescriptorBcdUSB :: !CUShort
  , iousbDeviceQualifierDescriptorBDeviceClass :: !CUChar
  , iousbDeviceQualifierDescriptorBDeviceSubClass :: !CUChar
  , iousbDeviceQualifierDescriptorBDeviceProtocol :: !CUChar
  , iousbDeviceQualifierDescriptorBMaxPacketSize0 :: !CUChar
  , iousbDeviceQualifierDescriptorBNumConfigurations :: !CUChar
  , iousbDeviceQualifierDescriptorBReserved :: !CUChar
  } deriving (Eq, Show)

instance Storable IOUSBDeviceQualifierDescriptor where
  sizeOf    _ = 10
  alignment _ = 2
  peek p = IOUSBDeviceQualifierDescriptor <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 5
    <*> peekByteOff p 6
    <*> peekByteOff p 7
    <*> peekByteOff p 8
    <*> peekByteOff p 9
  poke p (IOUSBDeviceQualifierDescriptor {..}) = do
    pokeByteOff p 0 iousbDeviceQualifierDescriptorBLength
    pokeByteOff p 1 iousbDeviceQualifierDescriptorBDescriptorType
    pokeByteOff p 2 iousbDeviceQualifierDescriptorBcdUSB
    pokeByteOff p 4 iousbDeviceQualifierDescriptorBDeviceClass
    pokeByteOff p 5 iousbDeviceQualifierDescriptorBDeviceSubClass
    pokeByteOff p 6 iousbDeviceQualifierDescriptorBDeviceProtocol
    pokeByteOff p 7 iousbDeviceQualifierDescriptorBMaxPacketSize0
    pokeByteOff p 8 iousbDeviceQualifierDescriptorBNumConfigurations
    pokeByteOff p 9 iousbDeviceQualifierDescriptorBReserved

{-# NOINLINE iousbDeviceQualifierDescriptorStructType #-}
iousbDeviceQualifierDescriptorStructType :: Ptr CType
iousbDeviceQualifierDescriptorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint16, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8]

argIOUSBDeviceQualifierDescriptor :: IOUSBDeviceQualifierDescriptor -> Arg
argIOUSBDeviceQualifierDescriptor = mkStorableArg iousbDeviceQualifierDescriptorStructType

retIOUSBDeviceQualifierDescriptor :: RetType IOUSBDeviceQualifierDescriptor
retIOUSBDeviceQualifierDescriptor = mkStorableRetType iousbDeviceQualifierDescriptorStructType

instance ObjCArgument IOUSBDeviceQualifierDescriptor where
  withObjCArg x k = k (argIOUSBDeviceQualifierDescriptor x)

instance ObjCReturn IOUSBDeviceQualifierDescriptor where
  type RawReturn IOUSBDeviceQualifierDescriptor = IOUSBDeviceQualifierDescriptor
  objcRetType = retIOUSBDeviceQualifierDescriptor
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | IOUSBDeviceRequest
--
-- Standard device request.             See the USB Specification at http://www.usb.org.             USB 2.0 9.3: USB Device Requests
data IOUSBDeviceRequest = IOUSBDeviceRequest
  { iousbDeviceRequestBmRequestType :: !CUChar
  , iousbDeviceRequestBRequest :: !CUChar
  , iousbDeviceRequestWValue :: !CUShort
  , iousbDeviceRequestWIndex :: !CUShort
  , iousbDeviceRequestWLength :: !CUShort
  } deriving (Eq, Show)

instance Storable IOUSBDeviceRequest where
  sizeOf    _ = 8
  alignment _ = 2
  peek p = IOUSBDeviceRequest <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 6
  poke p (IOUSBDeviceRequest {..}) = do
    pokeByteOff p 0 iousbDeviceRequestBmRequestType
    pokeByteOff p 1 iousbDeviceRequestBRequest
    pokeByteOff p 2 iousbDeviceRequestWValue
    pokeByteOff p 4 iousbDeviceRequestWIndex
    pokeByteOff p 6 iousbDeviceRequestWLength

{-# NOINLINE iousbDeviceRequestStructType #-}
iousbDeviceRequestStructType :: Ptr CType
iousbDeviceRequestStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argIOUSBDeviceRequest :: IOUSBDeviceRequest -> Arg
argIOUSBDeviceRequest = mkStorableArg iousbDeviceRequestStructType

retIOUSBDeviceRequest :: RetType IOUSBDeviceRequest
retIOUSBDeviceRequest = mkStorableRetType iousbDeviceRequestStructType

instance ObjCArgument IOUSBDeviceRequest where
  withObjCArg x k = k (argIOUSBDeviceRequest x)

instance ObjCReturn IOUSBDeviceRequest where
  type RawReturn IOUSBDeviceRequest = IOUSBDeviceRequest
  objcRetType = retIOUSBDeviceRequest
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | IOUSBDeviceRequestSetSELData
--
-- See the USB Specification at http://www.usb.org.             USB 3.0 9.4.12: Set SEL Standard Device Request
data IOUSBDeviceRequestSetSELData = IOUSBDeviceRequestSetSELData
  { iousbDeviceRequestSetSELDataU1Sel :: !CUChar
  , iousbDeviceRequestSetSELDataU1Pel :: !CUChar
  , iousbDeviceRequestSetSELDataU2Sel :: !CUShort
  , iousbDeviceRequestSetSELDataU2Pel :: !CUShort
  } deriving (Eq, Show)

instance Storable IOUSBDeviceRequestSetSELData where
  sizeOf    _ = 6
  alignment _ = 2
  peek p = IOUSBDeviceRequestSetSELData <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
    <*> peekByteOff p 4
  poke p (IOUSBDeviceRequestSetSELData {..}) = do
    pokeByteOff p 0 iousbDeviceRequestSetSELDataU1Sel
    pokeByteOff p 1 iousbDeviceRequestSetSELDataU1Pel
    pokeByteOff p 2 iousbDeviceRequestSetSELDataU2Sel
    pokeByteOff p 4 iousbDeviceRequestSetSELDataU2Pel

{-# NOINLINE iousbDeviceRequestSetSELDataStructType #-}
iousbDeviceRequestSetSELDataStructType :: Ptr CType
iousbDeviceRequestSetSELDataStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint16, ffi_type_uint16]

argIOUSBDeviceRequestSetSELData :: IOUSBDeviceRequestSetSELData -> Arg
argIOUSBDeviceRequestSetSELData = mkStorableArg iousbDeviceRequestSetSELDataStructType

retIOUSBDeviceRequestSetSELData :: RetType IOUSBDeviceRequestSetSELData
retIOUSBDeviceRequestSetSELData = mkStorableRetType iousbDeviceRequestSetSELDataStructType

instance ObjCArgument IOUSBDeviceRequestSetSELData where
  withObjCArg x k = k (argIOUSBDeviceRequestSetSELData x)

instance ObjCReturn IOUSBDeviceRequestSetSELData where
  type RawReturn IOUSBDeviceRequestSetSELData = IOUSBDeviceRequestSetSELData
  objcRetType = retIOUSBDeviceRequestSetSELData
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | IOUSBEndpointDescriptor
--
-- Descriptor for a USB Endpoint.  See the USB Specification at             http://www.usb.org.             USB 2.0 9.6.6: Endpoint
data IOUSBEndpointDescriptor = IOUSBEndpointDescriptor
  { iousbEndpointDescriptorBLength :: !CUChar
  , iousbEndpointDescriptorBDescriptorType :: !CUChar
  , iousbEndpointDescriptorBEndpointAddress :: !CUChar
  , iousbEndpointDescriptorBmAttributes :: !CUChar
  , iousbEndpointDescriptorWMaxPacketSize :: !CUShort
  , iousbEndpointDescriptorBInterval :: !CUChar
  } deriving (Eq, Show)

instance Storable IOUSBEndpointDescriptor where
  sizeOf    _ = 8
  alignment _ = 2
  peek p = IOUSBEndpointDescriptor <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
    <*> peekByteOff p 3
    <*> peekByteOff p 4
    <*> peekByteOff p 6
  poke p (IOUSBEndpointDescriptor {..}) = do
    pokeByteOff p 0 iousbEndpointDescriptorBLength
    pokeByteOff p 1 iousbEndpointDescriptorBDescriptorType
    pokeByteOff p 2 iousbEndpointDescriptorBEndpointAddress
    pokeByteOff p 3 iousbEndpointDescriptorBmAttributes
    pokeByteOff p 4 iousbEndpointDescriptorWMaxPacketSize
    pokeByteOff p 6 iousbEndpointDescriptorBInterval

{-# NOINLINE iousbEndpointDescriptorStructType #-}
iousbEndpointDescriptorStructType :: Ptr CType
iousbEndpointDescriptorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint16, ffi_type_uint8]

argIOUSBEndpointDescriptor :: IOUSBEndpointDescriptor -> Arg
argIOUSBEndpointDescriptor = mkStorableArg iousbEndpointDescriptorStructType

retIOUSBEndpointDescriptor :: RetType IOUSBEndpointDescriptor
retIOUSBEndpointDescriptor = mkStorableRetType iousbEndpointDescriptorStructType

instance ObjCArgument IOUSBEndpointDescriptor where
  withObjCArg x k = k (argIOUSBEndpointDescriptor x)

instance ObjCReturn IOUSBEndpointDescriptor where
  type RawReturn IOUSBEndpointDescriptor = IOUSBEndpointDescriptor
  objcRetType = retIOUSBEndpointDescriptor
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | IOUSBHIDDescriptor
--
-- USB HID Descriptor.  See the USB HID Specification at             http://www.usb.org.
data IOUSBHIDDescriptor = IOUSBHIDDescriptor
  { iousbhidDescriptorDescLen :: !CUChar
  , iousbhidDescriptorDescType :: !CUChar
  , iousbhidDescriptorDescVersNum :: !CUShort
  , iousbhidDescriptorHidCountryCode :: !CUChar
  , iousbhidDescriptorHidNumDescriptors :: !CUChar
  , iousbhidDescriptorHidDescriptorType :: !CUChar
  , iousbhidDescriptorHidDescriptorLengthLo :: !CUChar
  , iousbhidDescriptorHidDescriptorLengthHi :: !CUChar
  } deriving (Eq, Show)

instance Storable IOUSBHIDDescriptor where
  sizeOf    _ = 10
  alignment _ = 2
  peek p = IOUSBHIDDescriptor <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 5
    <*> peekByteOff p 6
    <*> peekByteOff p 7
    <*> peekByteOff p 8
  poke p (IOUSBHIDDescriptor {..}) = do
    pokeByteOff p 0 iousbhidDescriptorDescLen
    pokeByteOff p 1 iousbhidDescriptorDescType
    pokeByteOff p 2 iousbhidDescriptorDescVersNum
    pokeByteOff p 4 iousbhidDescriptorHidCountryCode
    pokeByteOff p 5 iousbhidDescriptorHidNumDescriptors
    pokeByteOff p 6 iousbhidDescriptorHidDescriptorType
    pokeByteOff p 7 iousbhidDescriptorHidDescriptorLengthLo
    pokeByteOff p 8 iousbhidDescriptorHidDescriptorLengthHi

{-# NOINLINE iousbhidDescriptorStructType #-}
iousbhidDescriptorStructType :: Ptr CType
iousbhidDescriptorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint16, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8]

argIOUSBHIDDescriptor :: IOUSBHIDDescriptor -> Arg
argIOUSBHIDDescriptor = mkStorableArg iousbhidDescriptorStructType

retIOUSBHIDDescriptor :: RetType IOUSBHIDDescriptor
retIOUSBHIDDescriptor = mkStorableRetType iousbhidDescriptorStructType

instance ObjCArgument IOUSBHIDDescriptor where
  withObjCArg x k = k (argIOUSBHIDDescriptor x)

instance ObjCReturn IOUSBHIDDescriptor where
  type RawReturn IOUSBHIDDescriptor = IOUSBHIDDescriptor
  objcRetType = retIOUSBHIDDescriptor
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | IOUSBHIDReportDesc
--
-- USB HID Report Descriptor header.  See the USB HID Specification at             http://www.usb.org.
data IOUSBHIDReportDesc = IOUSBHIDReportDesc
  { iousbhidReportDescHidDescriptorType :: !CUChar
  , iousbhidReportDescHidDescriptorLengthLo :: !CUChar
  , iousbhidReportDescHidDescriptorLengthHi :: !CUChar
  } deriving (Eq, Show)

instance Storable IOUSBHIDReportDesc where
  sizeOf    _ = 3
  alignment _ = 1
  peek p = IOUSBHIDReportDesc <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
  poke p (IOUSBHIDReportDesc {..}) = do
    pokeByteOff p 0 iousbhidReportDescHidDescriptorType
    pokeByteOff p 1 iousbhidReportDescHidDescriptorLengthLo
    pokeByteOff p 2 iousbhidReportDescHidDescriptorLengthHi

{-# NOINLINE iousbhidReportDescStructType #-}
iousbhidReportDescStructType :: Ptr CType
iousbhidReportDescStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint8]

argIOUSBHIDReportDesc :: IOUSBHIDReportDesc -> Arg
argIOUSBHIDReportDesc = mkStorableArg iousbhidReportDescStructType

retIOUSBHIDReportDesc :: RetType IOUSBHIDReportDesc
retIOUSBHIDReportDesc = mkStorableRetType iousbhidReportDescStructType

instance ObjCArgument IOUSBHIDReportDesc where
  withObjCArg x k = k (argIOUSBHIDReportDesc x)

instance ObjCReturn IOUSBHIDReportDesc where
  type RawReturn IOUSBHIDReportDesc = IOUSBHIDReportDesc
  objcRetType = retIOUSBHIDReportDesc
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | IOUSBInterfaceAssociationDescriptor
--
-- USB Inerface Association Descriptor.  ECN to the USB 2.0 Spec.             See the USB Specification at http://www.usb.org.             USB 3.0 9.6.4: Interface Association
data IOUSBInterfaceAssociationDescriptor = IOUSBInterfaceAssociationDescriptor
  { iousbInterfaceAssociationDescriptorBLength :: !CUChar
  , iousbInterfaceAssociationDescriptorBDescriptorType :: !CUChar
  , iousbInterfaceAssociationDescriptorBFirstInterface :: !CUChar
  , iousbInterfaceAssociationDescriptorBInterfaceCount :: !CUChar
  , iousbInterfaceAssociationDescriptorBFunctionClass :: !CUChar
  , iousbInterfaceAssociationDescriptorBFunctionSubClass :: !CUChar
  , iousbInterfaceAssociationDescriptorBFunctionProtocol :: !CUChar
  , iousbInterfaceAssociationDescriptorIFunction :: !CUChar
  } deriving (Eq, Show)

instance Storable IOUSBInterfaceAssociationDescriptor where
  sizeOf    _ = 8
  alignment _ = 1
  peek p = IOUSBInterfaceAssociationDescriptor <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
    <*> peekByteOff p 3
    <*> peekByteOff p 4
    <*> peekByteOff p 5
    <*> peekByteOff p 6
    <*> peekByteOff p 7
  poke p (IOUSBInterfaceAssociationDescriptor {..}) = do
    pokeByteOff p 0 iousbInterfaceAssociationDescriptorBLength
    pokeByteOff p 1 iousbInterfaceAssociationDescriptorBDescriptorType
    pokeByteOff p 2 iousbInterfaceAssociationDescriptorBFirstInterface
    pokeByteOff p 3 iousbInterfaceAssociationDescriptorBInterfaceCount
    pokeByteOff p 4 iousbInterfaceAssociationDescriptorBFunctionClass
    pokeByteOff p 5 iousbInterfaceAssociationDescriptorBFunctionSubClass
    pokeByteOff p 6 iousbInterfaceAssociationDescriptorBFunctionProtocol
    pokeByteOff p 7 iousbInterfaceAssociationDescriptorIFunction

{-# NOINLINE iousbInterfaceAssociationDescriptorStructType #-}
iousbInterfaceAssociationDescriptorStructType :: Ptr CType
iousbInterfaceAssociationDescriptorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8]

argIOUSBInterfaceAssociationDescriptor :: IOUSBInterfaceAssociationDescriptor -> Arg
argIOUSBInterfaceAssociationDescriptor = mkStorableArg iousbInterfaceAssociationDescriptorStructType

retIOUSBInterfaceAssociationDescriptor :: RetType IOUSBInterfaceAssociationDescriptor
retIOUSBInterfaceAssociationDescriptor = mkStorableRetType iousbInterfaceAssociationDescriptorStructType

instance ObjCArgument IOUSBInterfaceAssociationDescriptor where
  withObjCArg x k = k (argIOUSBInterfaceAssociationDescriptor x)

instance ObjCReturn IOUSBInterfaceAssociationDescriptor where
  type RawReturn IOUSBInterfaceAssociationDescriptor = IOUSBInterfaceAssociationDescriptor
  objcRetType = retIOUSBInterfaceAssociationDescriptor
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | IOUSBInterfaceDescriptor
--
-- Descriptor for a USB Interface.  See the USB Specification at             http://www.usb.org.             USB 2.0 9.6.5: Interface
data IOUSBInterfaceDescriptor = IOUSBInterfaceDescriptor
  { iousbInterfaceDescriptorBLength :: !CUChar
  , iousbInterfaceDescriptorBDescriptorType :: !CUChar
  , iousbInterfaceDescriptorBInterfaceNumber :: !CUChar
  , iousbInterfaceDescriptorBAlternateSetting :: !CUChar
  , iousbInterfaceDescriptorBNumEndpoints :: !CUChar
  , iousbInterfaceDescriptorBInterfaceClass :: !CUChar
  , iousbInterfaceDescriptorBInterfaceSubClass :: !CUChar
  , iousbInterfaceDescriptorBInterfaceProtocol :: !CUChar
  , iousbInterfaceDescriptorIInterface :: !CUChar
  } deriving (Eq, Show)

instance Storable IOUSBInterfaceDescriptor where
  sizeOf    _ = 9
  alignment _ = 1
  peek p = IOUSBInterfaceDescriptor <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
    <*> peekByteOff p 3
    <*> peekByteOff p 4
    <*> peekByteOff p 5
    <*> peekByteOff p 6
    <*> peekByteOff p 7
    <*> peekByteOff p 8
  poke p (IOUSBInterfaceDescriptor {..}) = do
    pokeByteOff p 0 iousbInterfaceDescriptorBLength
    pokeByteOff p 1 iousbInterfaceDescriptorBDescriptorType
    pokeByteOff p 2 iousbInterfaceDescriptorBInterfaceNumber
    pokeByteOff p 3 iousbInterfaceDescriptorBAlternateSetting
    pokeByteOff p 4 iousbInterfaceDescriptorBNumEndpoints
    pokeByteOff p 5 iousbInterfaceDescriptorBInterfaceClass
    pokeByteOff p 6 iousbInterfaceDescriptorBInterfaceSubClass
    pokeByteOff p 7 iousbInterfaceDescriptorBInterfaceProtocol
    pokeByteOff p 8 iousbInterfaceDescriptorIInterface

{-# NOINLINE iousbInterfaceDescriptorStructType #-}
iousbInterfaceDescriptorStructType :: Ptr CType
iousbInterfaceDescriptorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8]

argIOUSBInterfaceDescriptor :: IOUSBInterfaceDescriptor -> Arg
argIOUSBInterfaceDescriptor = mkStorableArg iousbInterfaceDescriptorStructType

retIOUSBInterfaceDescriptor :: RetType IOUSBInterfaceDescriptor
retIOUSBInterfaceDescriptor = mkStorableRetType iousbInterfaceDescriptorStructType

instance ObjCArgument IOUSBInterfaceDescriptor where
  withObjCArg x k = k (argIOUSBInterfaceDescriptor x)

instance ObjCReturn IOUSBInterfaceDescriptor where
  type RawReturn IOUSBInterfaceDescriptor = IOUSBInterfaceDescriptor
  objcRetType = retIOUSBInterfaceDescriptor
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | IOUSBSuperSpeedEndpointCompanionDescriptor
--
-- Descriptor for a SuperSpeed USB Endpoint Companion.             See the USB Specification at http://www.usb.org.             USB 3.1 9.6.7: SuperSpeed Endpoint Companion
data IOUSBSuperSpeedEndpointCompanionDescriptor = IOUSBSuperSpeedEndpointCompanionDescriptor
  { iousbSuperSpeedEndpointCompanionDescriptorBLength :: !CUChar
  , iousbSuperSpeedEndpointCompanionDescriptorBDescriptorType :: !CUChar
  , iousbSuperSpeedEndpointCompanionDescriptorBMaxBurst :: !CUChar
  , iousbSuperSpeedEndpointCompanionDescriptorBmAttributes :: !CUChar
  , iousbSuperSpeedEndpointCompanionDescriptorWBytesPerInterval :: !CUShort
  } deriving (Eq, Show)

instance Storable IOUSBSuperSpeedEndpointCompanionDescriptor where
  sizeOf    _ = 6
  alignment _ = 2
  peek p = IOUSBSuperSpeedEndpointCompanionDescriptor <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
    <*> peekByteOff p 3
    <*> peekByteOff p 4
  poke p (IOUSBSuperSpeedEndpointCompanionDescriptor {..}) = do
    pokeByteOff p 0 iousbSuperSpeedEndpointCompanionDescriptorBLength
    pokeByteOff p 1 iousbSuperSpeedEndpointCompanionDescriptorBDescriptorType
    pokeByteOff p 2 iousbSuperSpeedEndpointCompanionDescriptorBMaxBurst
    pokeByteOff p 3 iousbSuperSpeedEndpointCompanionDescriptorBmAttributes
    pokeByteOff p 4 iousbSuperSpeedEndpointCompanionDescriptorWBytesPerInterval

{-# NOINLINE iousbSuperSpeedEndpointCompanionDescriptorStructType #-}
iousbSuperSpeedEndpointCompanionDescriptorStructType :: Ptr CType
iousbSuperSpeedEndpointCompanionDescriptorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint16]

argIOUSBSuperSpeedEndpointCompanionDescriptor :: IOUSBSuperSpeedEndpointCompanionDescriptor -> Arg
argIOUSBSuperSpeedEndpointCompanionDescriptor = mkStorableArg iousbSuperSpeedEndpointCompanionDescriptorStructType

retIOUSBSuperSpeedEndpointCompanionDescriptor :: RetType IOUSBSuperSpeedEndpointCompanionDescriptor
retIOUSBSuperSpeedEndpointCompanionDescriptor = mkStorableRetType iousbSuperSpeedEndpointCompanionDescriptorStructType

instance ObjCArgument IOUSBSuperSpeedEndpointCompanionDescriptor where
  withObjCArg x k = k (argIOUSBSuperSpeedEndpointCompanionDescriptor x)

instance ObjCReturn IOUSBSuperSpeedEndpointCompanionDescriptor where
  type RawReturn IOUSBSuperSpeedEndpointCompanionDescriptor = IOUSBSuperSpeedEndpointCompanionDescriptor
  objcRetType = retIOUSBSuperSpeedEndpointCompanionDescriptor
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | IOUSBSuperSpeedHubDescriptor
--
-- Descriptor for a Super Speed USB hub.             See the USB Specification at http://www.usb.org.             USB 3.0 10.13.2.1: SuperSpeed Hub Descriptor
data IOUSBSuperSpeedHubDescriptor = IOUSBSuperSpeedHubDescriptor
  { iousbSuperSpeedHubDescriptorBLength :: !CUChar
  , iousbSuperSpeedHubDescriptorBDescriptorType :: !CUChar
  , iousbSuperSpeedHubDescriptorBNumberPorts :: !CUChar
  , iousbSuperSpeedHubDescriptorWHubCharacteristics :: !CUShort
  , iousbSuperSpeedHubDescriptorBPowerOnToPowerGood :: !CUChar
  , iousbSuperSpeedHubDescriptorBHubControllerCurrent :: !CUChar
  , iousbSuperSpeedHubDescriptorBHubDecodeLatency :: !CUChar
  , iousbSuperSpeedHubDescriptorWHubDelay :: !CUShort
  , iousbSuperSpeedHubDescriptorDeviceRemovable :: !CUShort
  } deriving (Eq, Show)

instance Storable IOUSBSuperSpeedHubDescriptor where
  sizeOf    _ = 14
  alignment _ = 2
  peek p = IOUSBSuperSpeedHubDescriptor <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 6
    <*> peekByteOff p 7
    <*> peekByteOff p 8
    <*> peekByteOff p 10
    <*> peekByteOff p 12
  poke p (IOUSBSuperSpeedHubDescriptor {..}) = do
    pokeByteOff p 0 iousbSuperSpeedHubDescriptorBLength
    pokeByteOff p 1 iousbSuperSpeedHubDescriptorBDescriptorType
    pokeByteOff p 2 iousbSuperSpeedHubDescriptorBNumberPorts
    pokeByteOff p 4 iousbSuperSpeedHubDescriptorWHubCharacteristics
    pokeByteOff p 6 iousbSuperSpeedHubDescriptorBPowerOnToPowerGood
    pokeByteOff p 7 iousbSuperSpeedHubDescriptorBHubControllerCurrent
    pokeByteOff p 8 iousbSuperSpeedHubDescriptorBHubDecodeLatency
    pokeByteOff p 10 iousbSuperSpeedHubDescriptorWHubDelay
    pokeByteOff p 12 iousbSuperSpeedHubDescriptorDeviceRemovable

{-# NOINLINE iousbSuperSpeedHubDescriptorStructType #-}
iousbSuperSpeedHubDescriptorStructType :: Ptr CType
iousbSuperSpeedHubDescriptorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint16, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint16, ffi_type_uint16]

argIOUSBSuperSpeedHubDescriptor :: IOUSBSuperSpeedHubDescriptor -> Arg
argIOUSBSuperSpeedHubDescriptor = mkStorableArg iousbSuperSpeedHubDescriptorStructType

retIOUSBSuperSpeedHubDescriptor :: RetType IOUSBSuperSpeedHubDescriptor
retIOUSBSuperSpeedHubDescriptor = mkStorableRetType iousbSuperSpeedHubDescriptorStructType

instance ObjCArgument IOUSBSuperSpeedHubDescriptor where
  withObjCArg x k = k (argIOUSBSuperSpeedHubDescriptor x)

instance ObjCReturn IOUSBSuperSpeedHubDescriptor where
  type RawReturn IOUSBSuperSpeedHubDescriptor = IOUSBSuperSpeedHubDescriptor
  objcRetType = retIOUSBSuperSpeedHubDescriptor
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | IOUSBSuperSpeedPlusIsochronousEndpointCompanionDescriptor
--
-- Descriptor for a SuperSpeedPlus Isochronout USB Endpoint Companion.             See the USB Specification at http://www.usb.org.             USB 3.1 9.6.8: SuperSpeedPlus Isochronous Endpoint Companion
data IOUSBSuperSpeedPlusIsochronousEndpointCompanionDescriptor = IOUSBSuperSpeedPlusIsochronousEndpointCompanionDescriptor
  { iousbSuperSpeedPlusIsochronousEndpointCompanionDescriptorBLength :: !CUChar
  , iousbSuperSpeedPlusIsochronousEndpointCompanionDescriptorBDescriptorType :: !CUChar
  , iousbSuperSpeedPlusIsochronousEndpointCompanionDescriptorWReserved :: !CUShort
  , iousbSuperSpeedPlusIsochronousEndpointCompanionDescriptorDwBytesPerInterval :: !CUInt
  } deriving (Eq, Show)

instance Storable IOUSBSuperSpeedPlusIsochronousEndpointCompanionDescriptor where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = IOUSBSuperSpeedPlusIsochronousEndpointCompanionDescriptor <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
    <*> peekByteOff p 4
  poke p (IOUSBSuperSpeedPlusIsochronousEndpointCompanionDescriptor {..}) = do
    pokeByteOff p 0 iousbSuperSpeedPlusIsochronousEndpointCompanionDescriptorBLength
    pokeByteOff p 1 iousbSuperSpeedPlusIsochronousEndpointCompanionDescriptorBDescriptorType
    pokeByteOff p 2 iousbSuperSpeedPlusIsochronousEndpointCompanionDescriptorWReserved
    pokeByteOff p 4 iousbSuperSpeedPlusIsochronousEndpointCompanionDescriptorDwBytesPerInterval

{-# NOINLINE iousbSuperSpeedPlusIsochronousEndpointCompanionDescriptorStructType #-}
iousbSuperSpeedPlusIsochronousEndpointCompanionDescriptorStructType :: Ptr CType
iousbSuperSpeedPlusIsochronousEndpointCompanionDescriptorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint16, ffi_type_uint]

argIOUSBSuperSpeedPlusIsochronousEndpointCompanionDescriptor :: IOUSBSuperSpeedPlusIsochronousEndpointCompanionDescriptor -> Arg
argIOUSBSuperSpeedPlusIsochronousEndpointCompanionDescriptor = mkStorableArg iousbSuperSpeedPlusIsochronousEndpointCompanionDescriptorStructType

retIOUSBSuperSpeedPlusIsochronousEndpointCompanionDescriptor :: RetType IOUSBSuperSpeedPlusIsochronousEndpointCompanionDescriptor
retIOUSBSuperSpeedPlusIsochronousEndpointCompanionDescriptor = mkStorableRetType iousbSuperSpeedPlusIsochronousEndpointCompanionDescriptorStructType

instance ObjCArgument IOUSBSuperSpeedPlusIsochronousEndpointCompanionDescriptor where
  withObjCArg x k = k (argIOUSBSuperSpeedPlusIsochronousEndpointCompanionDescriptor x)

instance ObjCReturn IOUSBSuperSpeedPlusIsochronousEndpointCompanionDescriptor where
  type RawReturn IOUSBSuperSpeedPlusIsochronousEndpointCompanionDescriptor = IOUSBSuperSpeedPlusIsochronousEndpointCompanionDescriptor
  objcRetType = retIOUSBSuperSpeedPlusIsochronousEndpointCompanionDescriptor
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data NXEvent = NXEvent
  { nxEventType :: !CInt
  , nxEventLocation :: !(Ptr ())
  , nxEventTime :: !CULong
  , nxEventFlags :: !CInt
  , nxEventWindow :: !CUInt
  , nxEventService_id :: !CULong
  , nxEventExt_pid :: !CInt
  , nxEventData :: !CInt
  } deriving (Eq, Show)

instance Storable NXEvent where
  sizeOf    _ = 48
  alignment _ = 8
  peek p = NXEvent <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 24
    <*> peekByteOff p 28
    <*> peekByteOff p 32
    <*> peekByteOff p 40
    <*> peekByteOff p 44
  poke p (NXEvent {..}) = do
    pokeByteOff p 0 nxEventType
    pokeByteOff p 8 nxEventLocation
    pokeByteOff p 16 nxEventTime
    pokeByteOff p 24 nxEventFlags
    pokeByteOff p 28 nxEventWindow
    pokeByteOff p 32 nxEventService_id
    pokeByteOff p 40 nxEventExt_pid
    pokeByteOff p 44 nxEventData

{-# NOINLINE nxEventStructType #-}
nxEventStructType :: Ptr CType
nxEventStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_pointer, ffi_type_ulong, ffi_type_sint, ffi_type_uint, ffi_type_ulong, ffi_type_sint, ffi_type_sint]

argNXEvent :: NXEvent -> Arg
argNXEvent = mkStorableArg nxEventStructType

retNXEvent :: RetType NXEvent
retNXEvent = mkStorableRetType nxEventStructType

instance ObjCArgument NXEvent where
  withObjCArg x k = k (argNXEvent x)

instance ObjCReturn NXEvent where
  type RawReturn NXEvent = NXEvent
  objcRetType = retNXEvent
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data NXEventExt = NXEventExt
  { nxEventExtPayload :: !(Ptr ())
  , nxEventExtExtension :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable NXEventExt where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = NXEventExt <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (NXEventExt {..}) = do
    pokeByteOff p 0 nxEventExtPayload
    pokeByteOff p 8 nxEventExtExtension

{-# NOINLINE nxEventExtStructType #-}
nxEventExtStructType :: Ptr CType
nxEventExtStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer, ffi_type_pointer]

argNXEventExt :: NXEventExt -> Arg
argNXEventExt = mkStorableArg nxEventExtStructType

retNXEventExt :: RetType NXEventExt
retNXEventExt = mkStorableRetType nxEventExtStructType

instance ObjCArgument NXEventExt where
  withObjCArg x k = k (argNXEventExt x)

instance ObjCReturn NXEventExt where
  type RawReturn NXEventExt = NXEventExt
  objcRetType = retNXEventExt
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data NXKeyMapping = NXKeyMapping
  { nxKeyMappingSize :: !CInt
  , nxKeyMappingMapping :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable NXKeyMapping where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = NXKeyMapping <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (NXKeyMapping {..}) = do
    pokeByteOff p 0 nxKeyMappingSize
    pokeByteOff p 8 nxKeyMappingMapping

{-# NOINLINE nxKeyMappingStructType #-}
nxKeyMappingStructType :: Ptr CType
nxKeyMappingStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_pointer]

argNXKeyMapping :: NXKeyMapping -> Arg
argNXKeyMapping = mkStorableArg nxKeyMappingStructType

retNXKeyMapping :: RetType NXKeyMapping
retNXKeyMapping = mkStorableRetType nxKeyMappingStructType

instance ObjCArgument NXKeyMapping where
  withObjCArg x k = k (argNXKeyMapping x)

instance ObjCReturn NXKeyMapping where
  type RawReturn NXKeyMapping = NXKeyMapping
  objcRetType = retNXKeyMapping
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data NXPoint = NXPoint
  { nxPointX :: !CFloat
  , nxPointY :: !CFloat
  } deriving (Eq, Show)

instance Storable NXPoint where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = NXPoint <$> peekByteOff p 0
    <*> peekByteOff p 4
  poke p (NXPoint {..}) = do
    pokeByteOff p 0 nxPointX
    pokeByteOff p 4 nxPointY

{-# NOINLINE nxPointStructType #-}
nxPointStructType :: Ptr CType
nxPointStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_float, ffi_type_float]

argNXPoint :: NXPoint -> Arg
argNXPoint = mkStorableArg nxPointStructType

retNXPoint :: RetType NXPoint
retNXPoint = mkStorableRetType nxPointStructType

instance ObjCArgument NXPoint where
  withObjCArg x k = k (argNXPoint x)

instance ObjCReturn NXPoint where
  type RawReturn NXPoint = NXPoint
  objcRetType = retNXPoint
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data NXSize = NXSize
  { nxSizeWidth :: !CFloat
  , nxSizeHeight :: !CFloat
  } deriving (Eq, Show)

instance Storable NXSize where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = NXSize <$> peekByteOff p 0
    <*> peekByteOff p 4
  poke p (NXSize {..}) = do
    pokeByteOff p 0 nxSizeWidth
    pokeByteOff p 4 nxSizeHeight

{-# NOINLINE nxSizeStructType #-}
nxSizeStructType :: Ptr CType
nxSizeStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_float, ffi_type_float]

argNXSize :: NXSize -> Arg
argNXSize = mkStorableArg nxSizeStructType

retNXSize :: RetType NXSize
retNXSize = mkStorableRetType nxSizeStructType

instance ObjCArgument NXSize where
  withObjCArg x k = k (argNXSize x)

instance ObjCReturn NXSize where
  type RawReturn NXSize = NXSize
  objcRetType = retNXSize
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data NXTabletPointData = NXTabletPointData
  { nxTabletPointDataX :: !CInt
  , nxTabletPointDataY :: !CInt
  , nxTabletPointDataZ :: !CInt
  , nxTabletPointDataButtons :: !CUShort
  , nxTabletPointDataPressure :: !CUShort
  , nxTabletPointDataTilt :: !(Ptr ())
  , nxTabletPointDataRotation :: !CUShort
  , nxTabletPointDataTangentialPressure :: !CShort
  , nxTabletPointDataDeviceID :: !CUShort
  , nxTabletPointDataVendor1 :: !CShort
  , nxTabletPointDataVendor2 :: !CShort
  , nxTabletPointDataVendor3 :: !CShort
  } deriving (Eq, Show)

instance Storable NXTabletPointData where
  sizeOf    _ = 40
  alignment _ = 8
  peek p = NXTabletPointData <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
    <*> peekByteOff p 14
    <*> peekByteOff p 16
    <*> peekByteOff p 24
    <*> peekByteOff p 26
    <*> peekByteOff p 28
    <*> peekByteOff p 30
    <*> peekByteOff p 32
    <*> peekByteOff p 34
  poke p (NXTabletPointData {..}) = do
    pokeByteOff p 0 nxTabletPointDataX
    pokeByteOff p 4 nxTabletPointDataY
    pokeByteOff p 8 nxTabletPointDataZ
    pokeByteOff p 12 nxTabletPointDataButtons
    pokeByteOff p 14 nxTabletPointDataPressure
    pokeByteOff p 16 nxTabletPointDataTilt
    pokeByteOff p 24 nxTabletPointDataRotation
    pokeByteOff p 26 nxTabletPointDataTangentialPressure
    pokeByteOff p 28 nxTabletPointDataDeviceID
    pokeByteOff p 30 nxTabletPointDataVendor1
    pokeByteOff p 32 nxTabletPointDataVendor2
    pokeByteOff p 34 nxTabletPointDataVendor3

{-# NOINLINE nxTabletPointDataStructType #-}
nxTabletPointDataStructType :: Ptr CType
nxTabletPointDataStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_sint, ffi_type_sint, ffi_type_uint16, ffi_type_uint16, ffi_type_pointer, ffi_type_uint16, ffi_type_sint16, ffi_type_uint16, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16]

argNXTabletPointData :: NXTabletPointData -> Arg
argNXTabletPointData = mkStorableArg nxTabletPointDataStructType

retNXTabletPointData :: RetType NXTabletPointData
retNXTabletPointData = mkStorableRetType nxTabletPointDataStructType

instance ObjCArgument NXTabletPointData where
  withObjCArg x k = k (argNXTabletPointData x)

instance ObjCReturn NXTabletPointData where
  type RawReturn NXTabletPointData = NXTabletPointData
  objcRetType = retNXTabletPointData
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data NXTabletProximityData = NXTabletProximityData
  { nxTabletProximityDataVendorID :: !CUShort
  , nxTabletProximityDataTabletID :: !CUShort
  , nxTabletProximityDataPointerID :: !CUShort
  , nxTabletProximityDataDeviceID :: !CUShort
  , nxTabletProximityDataSystemTabletID :: !CUShort
  , nxTabletProximityDataVendorPointerType :: !CUShort
  , nxTabletProximityDataPointerSerialNumber :: !CUInt
  , nxTabletProximityDataUniqueID :: !CULong
  , nxTabletProximityDataCapabilityMask :: !CUInt
  , nxTabletProximityDataPointerType :: !CUChar
  , nxTabletProximityDataEnterProximity :: !CUChar
  , nxTabletProximityDataReserved1 :: !CShort
  } deriving (Eq, Show)

instance Storable NXTabletProximityData where
  sizeOf    _ = 32
  alignment _ = 8
  peek p = NXTabletProximityData <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 6
    <*> peekByteOff p 8
    <*> peekByteOff p 10
    <*> peekByteOff p 12
    <*> peekByteOff p 16
    <*> peekByteOff p 24
    <*> peekByteOff p 28
    <*> peekByteOff p 29
    <*> peekByteOff p 30
  poke p (NXTabletProximityData {..}) = do
    pokeByteOff p 0 nxTabletProximityDataVendorID
    pokeByteOff p 2 nxTabletProximityDataTabletID
    pokeByteOff p 4 nxTabletProximityDataPointerID
    pokeByteOff p 6 nxTabletProximityDataDeviceID
    pokeByteOff p 8 nxTabletProximityDataSystemTabletID
    pokeByteOff p 10 nxTabletProximityDataVendorPointerType
    pokeByteOff p 12 nxTabletProximityDataPointerSerialNumber
    pokeByteOff p 16 nxTabletProximityDataUniqueID
    pokeByteOff p 24 nxTabletProximityDataCapabilityMask
    pokeByteOff p 28 nxTabletProximityDataPointerType
    pokeByteOff p 29 nxTabletProximityDataEnterProximity
    pokeByteOff p 30 nxTabletProximityDataReserved1

{-# NOINLINE nxTabletProximityDataStructType #-}
nxTabletProximityDataStructType :: Ptr CType
nxTabletProximityDataStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16, ffi_type_uint, ffi_type_ulong, ffi_type_uint, ffi_type_uint8, ffi_type_uint8, ffi_type_sint16]

argNXTabletProximityData :: NXTabletProximityData -> Arg
argNXTabletProximityData = mkStorableArg nxTabletProximityDataStructType

retNXTabletProximityData :: RetType NXTabletProximityData
retNXTabletProximityData = mkStorableRetType nxTabletProximityDataStructType

instance ObjCArgument NXTabletProximityData where
  withObjCArg x k = k (argNXTabletProximityData x)

instance ObjCReturn NXTabletProximityData where
  type RawReturn NXTabletProximityData = NXTabletProximityData
  objcRetType = retNXTabletProximityData
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

-- | UASPipeDescriptor
--
-- Structure used to specify the Mass Storage Specific UAS pipe usage descriptor
data UASPipeDescriptor = UASPipeDescriptor
  { uasPipeDescriptorBLength :: !CUChar
  , uasPipeDescriptorBDescriptorType :: !CUChar
  , uasPipeDescriptorBPipeID :: !CUChar
  , uasPipeDescriptorBReserved :: !CUChar
  } deriving (Eq, Show)

instance Storable UASPipeDescriptor where
  sizeOf    _ = 4
  alignment _ = 1
  peek p = UASPipeDescriptor <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
    <*> peekByteOff p 3
  poke p (UASPipeDescriptor {..}) = do
    pokeByteOff p 0 uasPipeDescriptorBLength
    pokeByteOff p 1 uasPipeDescriptorBDescriptorType
    pokeByteOff p 2 uasPipeDescriptorBPipeID
    pokeByteOff p 3 uasPipeDescriptorBReserved

{-# NOINLINE uasPipeDescriptorStructType #-}
uasPipeDescriptorStructType :: Ptr CType
uasPipeDescriptorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8]

argUASPipeDescriptor :: UASPipeDescriptor -> Arg
argUASPipeDescriptor = mkStorableArg uasPipeDescriptorStructType

retUASPipeDescriptor :: RetType UASPipeDescriptor
retUASPipeDescriptor = mkStorableRetType uasPipeDescriptorStructType

instance ObjCArgument UASPipeDescriptor where
  withObjCArg x k = k (argUASPipeDescriptor x)

instance ObjCReturn UASPipeDescriptor where
  type RawReturn UASPipeDescriptor = UASPipeDescriptor
  objcRetType = retUASPipeDescriptor
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure
