{-# LANGUAGE PatternSynonyms #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE FlexibleContexts #-}

-- | The optimized representation of a compute graph of operations and tensors.
--
-- An MPSGraph is a symbolic representation of operations to be utilized to execute compute graphs on a device.
--
-- Generated bindings for @MPSGraph@.
module ObjC.MetalPerformanceShadersGraph.MPSGraph
  ( MPSGraph
  , IsMPSGraph(..)
  , new
  , init_
  , compileWithDevice_feeds_targetTensors_targetOperations_compilationDescriptor
  , runWithFeeds_targetTensors_targetOperations
  , runWithMTLCommandQueue_feeds_targetTensors_targetOperations
  , runWithMTLCommandQueue_feeds_targetOperations_resultsDictionary
  , runAsyncWithFeeds_targetTensors_targetOperations_executionDescriptor
  , runAsyncWithMTLCommandQueue_feeds_targetTensors_targetOperations_executionDescriptor
  , runAsyncWithMTLCommandQueue_feeds_targetOperations_resultsDictionary_executionDescriptor
  , encodeToCommandBuffer_feeds_targetTensors_targetOperations_executionDescriptor
  , encodeToCommandBuffer_feeds_targetOperations_resultsDictionary_executionDescriptor
  , topKWithGradientTensor_source_k_name
  , topKWithGradientTensor_source_axis_k_name
  , bottomKWithGradientTensor_source_axis_k_name
  , topKWithGradientTensor_source_kTensor_name
  , topKWithGradientTensor_source_axisTensor_kTensor_name
  , bottomKWithGradientTensor_source_axisTensor_kTensor_name
  , topKWithSourceTensor_k_name
  , topKWithSourceTensor_kTensor_name
  , topKWithSourceTensor_axis_k_name
  , bottomKWithSourceTensor_axis_k_name
  , topKWithSourceTensor_axisTensor_kTensor_name
  , bottomKWithSourceTensor_axisTensor_kTensor_name
  , reshapeTensor_withShape_name
  , reshapeTensor_withShapeTensor_name
  , transposeTensor_dimension_withDimension_name
  , transposeTensor_permutation_name
  , sliceTensor_dimension_start_length_name
  , sliceTensor_starts_ends_strides_name
  , sliceTensor_starts_ends_strides_startMask_endMask_squeezeMask_name
  , sliceTensor_startTensor_endTensor_strideTensor_startMask_endMask_squeezeMask_name
  , sliceTensor_startTensor_sizeTensor_squeezeMask_name
  , sliceGradientTensor_fwdInShapeTensor_starts_ends_strides_name
  , sliceGradientTensor_fwdInShapeTensor_startTensor_endTensor_strideTensor_startMask_endMask_squeezeMask_name
  , sliceGradientTensor_fwdInShapeTensor_startTensor_sizeTensor_squeezeMask_name
  , sliceGradientTensor_fwdInShapeTensor_starts_ends_strides_startMask_endMask_squeezeMask_name
  , sliceUpdateDataTensor_updateTensor_startsTensor_endsTensor_stridesTensor_startMask_endMask_squeezeMask_name
  , sliceUpdateDataTensor_updateTensor_starts_ends_strides_startMask_endMask_squeezeMask_name
  , sliceUpdateDataTensor_updateTensor_startsTensor_endsTensor_stridesTensor_name
  , sliceUpdateDataTensor_updateTensor_starts_ends_strides_name
  , concatTensor_withTensor_dimension_name
  , concatTensors_dimension_name
  , concatTensors_dimension_interleave_name
  , tileTensor_withMultiplier_name
  , tileGradientWithIncomingGradientTensor_sourceTensor_withMultiplier_name
  , padTensor_withPaddingMode_leftPadding_rightPadding_constantValue_name
  , padGradientWithIncomingGradientTensor_sourceTensor_paddingMode_leftPadding_rightPadding_name
  , spaceToDepth2DTensor_widthAxis_heightAxis_depthAxis_blockSize_usePixelShuffleOrder_name
  , spaceToDepth2DTensor_widthAxisTensor_heightAxisTensor_depthAxisTensor_blockSize_usePixelShuffleOrder_name
  , depthToSpace2DTensor_widthAxis_heightAxis_depthAxis_blockSize_usePixelShuffleOrder_name
  , depthToSpace2DTensor_widthAxisTensor_heightAxisTensor_depthAxisTensor_blockSize_usePixelShuffleOrder_name
  , spaceToBatchTensor_spatialAxes_batchAxis_blockDimensions_usePixelShuffleOrder_name
  , spaceToBatchTensor_spatialAxesTensor_batchAxisTensor_blockDimensionsTensor_usePixelShuffleOrder_name
  , batchToSpaceTensor_spatialAxes_batchAxis_blockDimensions_usePixelShuffleOrder_name
  , batchToSpaceTensor_spatialAxesTensor_batchAxisTensor_blockDimensionsTensor_usePixelShuffleOrder_name
  , reverseTensor_axesTensor_name
  , reverseTensor_axes_name
  , reverseTensor_name
  , flatten2DTensor_axis_name
  , flatten2DTensor_axisTensor_name
  , broadcastTensor_toShape_name
  , broadcastTensor_toShapeTensor_name
  , shapeOfTensor_name
  , castTensor_toType_name
  , reinterpretCastTensor_toType_name
  , stackTensors_axis_name
  , splitTensor_splitSizes_axis_name
  , splitTensor_splitSizesTensor_axis_name
  , splitTensor_numSplits_axis_name
  , squeezeTensor_name
  , squeezeTensor_axis_name
  , squeezeTensor_axes_name
  , squeezeTensor_axesTensor_name
  , expandDimsOfTensor_axis_name
  , expandDimsOfTensor_axes_name
  , expandDimsOfTensor_axesTensor_name
  , coordinateAlongAxis_withShape_name
  , coordinateAlongAxisTensor_withShape_name
  , coordinateAlongAxis_withShapeTensor_name
  , coordinateAlongAxisTensor_withShapeTensor_name
  , stencilWithSourceTensor_weightsTensor_descriptor_name
  , sparseTensorWithType_tensors_shape_dataType_name
  , sparseTensorWithDescriptor_tensors_shape_name
  , sortWithTensor_axis_descending_name
  , sortWithTensor_axisTensor_descending_name
  , sortWithTensor_axis_name
  , sortWithTensor_axisTensor_name
  , argSortWithTensor_axis_descending_name
  , argSortWithTensor_axisTensor_descending_name
  , argSortWithTensor_axis_name
  , argSortWithTensor_axisTensor_name
  , scatterAlongAxis_withUpdatesTensor_indicesTensor_shape_mode_name
  , scatterAlongAxisTensor_withUpdatesTensor_indicesTensor_shape_mode_name
  , scatterAlongAxis_withDataTensor_updatesTensor_indicesTensor_mode_name
  , scatterAlongAxisTensor_withDataTensor_updatesTensor_indicesTensor_mode_name
  , scatterWithUpdatesTensor_indicesTensor_shape_axis_mode_name
  , scatterWithDataTensor_updatesTensor_indicesTensor_axis_mode_name
  , scatterNDWithUpdatesTensor_indicesTensor_shape_batchDimensions_mode_name
  , scatterNDWithUpdatesTensor_indicesTensor_shape_batchDimensions_name
  , scatterNDWithDataTensor_updatesTensor_indicesTensor_batchDimensions_mode_name
  , sampleGridWithSourceTensor_coordinateTensor_layout_normalizeCoordinates_relativeCoordinates_alignCorners_paddingMode_samplingMode_constantValue_name
  , sampleGridWithSourceTensor_coordinateTensor_layout_normalizeCoordinates_relativeCoordinates_alignCorners_paddingMode_nearestRoundingMode_constantValue_name
  , singleGateRNNWithSourceTensor_recurrentWeight_inputWeight_bias_initState_mask_descriptor_name
  , singleGateRNNWithSourceTensor_recurrentWeight_inputWeight_bias_initState_descriptor_name
  , singleGateRNNWithSourceTensor_recurrentWeight_initState_descriptor_name
  , singleGateRNNGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_stateGradient_inputWeight_bias_initState_mask_descriptor_name
  , singleGateRNNGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_inputWeight_bias_initState_mask_descriptor_name
  , singleGateRNNGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_inputWeight_bias_initState_descriptor_name
  , singleGateRNNGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_initState_descriptor_name
  , lstmWithSourceTensor_recurrentWeight_inputWeight_bias_initState_initCell_mask_peephole_descriptor_name
  , lstmWithSourceTensor_recurrentWeight_inputWeight_bias_initState_initCell_descriptor_name
  , lstmWithSourceTensor_recurrentWeight_initState_initCell_descriptor_name
  , lstmGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_cellOutputFwd_stateGradient_cellGradient_inputWeight_bias_initState_initCell_mask_peephole_descriptor_name
  , lstmGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_cellOutputFwd_inputWeight_bias_initState_initCell_mask_descriptor_name
  , lstmGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_cellOutputFwd_inputWeight_bias_initState_initCell_descriptor_name
  , lstmGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_cellOutputFwd_descriptor_name
  , gruWithSourceTensor_recurrentWeight_inputWeight_bias_initState_mask_secondaryBias_descriptor_name
  , gruWithSourceTensor_recurrentWeight_inputWeight_bias_initState_descriptor_name
  , gruWithSourceTensor_recurrentWeight_inputWeight_bias_descriptor_name
  , gruGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_outputFwd_stateGradient_inputWeight_bias_initState_mask_secondaryBias_descriptor_name
  , gruGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_outputFwd_inputWeight_bias_initState_descriptor_name
  , gruGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_outputFwd_inputWeight_bias_descriptor_name
  , resizeTensor_size_mode_centerResult_alignCorners_layout_name
  , resizeTensor_sizeTensor_mode_centerResult_alignCorners_layout_name
  , resizeTensor_sizeTensor_mode_centerResult_alignCorners_name
  , resizeNearestWithTensor_sizeTensor_nearestRoundingMode_centerResult_alignCorners_layout_name
  , resizeNearestWithTensor_sizeTensor_nearestRoundingMode_centerResult_alignCorners_name
  , resizeBilinearWithTensor_sizeTensor_centerResult_alignCorners_layout_name
  , resizeBilinearWithTensor_sizeTensor_centerResult_alignCorners_name
  , resizeTensor_sizeTensor_scaleOffsetTensor_mode_layout_name
  , resizeTensor_sizeTensor_scaleTensor_offsetTensor_mode_name
  , resizeNearestWithTensor_sizeTensor_scaleOffsetTensor_nearestRoundingMode_layout_name
  , resizeNearestWithTensor_sizeTensor_scaleTensor_offsetTensor_nearestRoundingMode_name
  , resizeBilinearWithTensor_sizeTensor_scaleOffsetTensor_layout_name
  , resizeBilinearWithTensor_sizeTensor_scaleTensor_offsetTensor_name
  , resizeWithGradientTensor_input_mode_centerResult_alignCorners_layout_name
  , resizeNearestWithGradientTensor_input_nearestRoundingMode_centerResult_alignCorners_layout_name
  , resizeBilinearWithGradientTensor_input_centerResult_alignCorners_layout_name
  , resizeWithGradientTensor_input_scaleOffsetTensor_mode_layout_name
  , resizeWithGradientTensor_input_scaleTensor_offsetTensor_mode_name
  , resizeNearestWithGradientTensor_input_scaleOffsetTensor_nearestRoundingMode_layout_name
  , resizeNearestWithGradientTensor_input_scaleTensor_offsetTensor_nearestRoundingMode_name
  , resizeBilinearWithGradientTensor_input_scaleOffsetTensor_layout_name
  , resizeBilinearWithGradientTensor_input_scaleTensor_offsetTensor_name
  , reductionSumWithTensor_axis_name
  , reductionSumWithTensor_axes_name
  , reductionMaximumWithTensor_axis_name
  , reductionMaximumWithTensor_axes_name
  , reductionMinimumWithTensor_axis_name
  , reductionMinimumWithTensor_axes_name
  , reductionMaximumPropagateNaNWithTensor_axis_name
  , reductionMaximumPropagateNaNWithTensor_axes_name
  , reductionMinimumPropagateNaNWithTensor_axis_name
  , reductionMinimumPropagateNaNWithTensor_axes_name
  , reductionProductWithTensor_axis_name
  , reductionProductWithTensor_axes_name
  , reductionArgMaximumWithTensor_axis_name
  , reductionArgMinimumWithTensor_axis_name
  , reductionAndWithTensor_axis_name
  , reductionAndWithTensor_axes_name
  , reductionOrWithTensor_axis_name
  , reductionOrWithTensor_axes_name
  , randomPhiloxStateTensorWithSeed_name
  , randomPhiloxStateTensorWithCounterLow_counterHigh_key_name
  , randomTensorWithShape_descriptor_name
  , randomTensorWithShapeTensor_descriptor_name
  , randomTensorWithShape_descriptor_seed_name
  , randomTensorWithShapeTensor_descriptor_seed_name
  , randomTensorWithShape_descriptor_stateTensor_name
  , randomTensorWithShapeTensor_descriptor_stateTensor_name
  , randomUniformTensorWithShape_name
  , randomUniformTensorWithShapeTensor_name
  , randomUniformTensorWithShape_seed_name
  , randomUniformTensorWithShapeTensor_seed_name
  , randomUniformTensorWithShape_stateTensor_name
  , randomUniformTensorWithShapeTensor_stateTensor_name
  , dropoutTensor_rate_name
  , dropoutTensor_rateTensor_name
  , quantizeTensor_scale_zeroPoint_dataType_name
  , dequantizeTensor_scale_zeroPoint_dataType_name
  , quantizeTensor_scaleTensor_zeroPoint_dataType_axis_name
  , dequantizeTensor_scaleTensor_zeroPoint_dataType_axis_name
  , quantizeTensor_scaleTensor_zeroPointTensor_dataType_axis_name
  , dequantizeTensor_scaleTensor_zeroPointTensor_dataType_axis_name
  , dequantizeTensor_scaleTensor_zeroPointTensor_dataType_name
  , dequantizeTensor_scaleTensor_dataType_name
  , dequantizeTensor_LUTTensor_name
  , dequantizeTensor_LUTTensor_axis_name
  , maxPooling2DWithSourceTensor_descriptor_name
  , maxPooling2DReturnIndicesWithSourceTensor_descriptor_name
  , maxPooling2DGradientWithGradientTensor_sourceTensor_descriptor_name
  , maxPooling2DGradientWithGradientTensor_indicesTensor_outputShape_descriptor_name
  , maxPooling2DGradientWithGradientTensor_indicesTensor_outputShapeTensor_descriptor_name
  , avgPooling2DWithSourceTensor_descriptor_name
  , avgPooling2DGradientWithGradientTensor_sourceTensor_descriptor_name
  , maxPooling4DWithSourceTensor_descriptor_name
  , maxPooling4DReturnIndicesWithSourceTensor_descriptor_name
  , maxPooling4DGradientWithGradientTensor_sourceTensor_descriptor_name
  , maxPooling4DGradientWithGradientTensor_indicesTensor_outputShape_descriptor_name
  , maxPooling4DGradientWithGradientTensor_indicesTensor_outputShapeTensor_descriptor_name
  , avgPooling4DWithSourceTensor_descriptor_name
  , avgPooling4DGradientWithGradientTensor_sourceTensor_descriptor_name
  , l2NormPooling4DWithSourceTensor_descriptor_name
  , l2NormPooling4DGradientWithGradientTensor_sourceTensor_descriptor_name
  , stochasticGradientDescentWithLearningRateTensor_valuesTensor_gradientTensor_name
  , applyStochasticGradientDescentWithLearningRateTensor_variable_gradientTensor_name
  , adamWithLearningRateTensor_beta1Tensor_beta2Tensor_epsilonTensor_beta1PowerTensor_beta2PowerTensor_valuesTensor_momentumTensor_velocityTensor_maximumVelocityTensor_gradientTensor_name
  , adamWithCurrentLearningRateTensor_beta1Tensor_beta2Tensor_epsilonTensor_valuesTensor_momentumTensor_velocityTensor_maximumVelocityTensor_gradientTensor_name
  , oneHotWithIndicesTensor_depth_axis_dataType_onValue_offValue_name
  , oneHotWithIndicesTensor_depth_dataType_onValue_offValue_name
  , oneHotWithIndicesTensor_depth_axis_dataType_name
  , oneHotWithIndicesTensor_depth_axis_name
  , oneHotWithIndicesTensor_depth_dataType_name
  , oneHotWithIndicesTensor_depth_name
  , meanOfTensor_axes_name
  , varianceOfTensor_meanTensor_axes_name
  , varianceOfTensor_axes_name
  , normalizationWithTensor_meanTensor_varianceTensor_gammaTensor_betaTensor_epsilon_name
  , normalizationGammaGradientWithIncomingGradientTensor_sourceTensor_meanTensor_varianceTensor_reductionAxes_epsilon_name
  , normalizationBetaGradientWithIncomingGradientTensor_sourceTensor_reductionAxes_name
  , normalizationGradientWithIncomingGradientTensor_sourceTensor_meanTensor_varianceTensor_gammaTensor_gammaGradientTensor_betaGradientTensor_reductionAxes_epsilon_name
  , nonZeroIndicesOfTensor_name
  , nonMaximumSuppressionWithBoxesTensor_scoresTensor_IOUThreshold_scoreThreshold_perClassSuppression_coordinateMode_name
  , nonMaximumSuppressionWithBoxesTensor_scoresTensor_classIndicesTensor_IOUThreshold_scoreThreshold_perClassSuppression_coordinateMode_name
  , placeholderWithShape_dataType_name
  , placeholderWithShape_name
  , constantWithData_shape_dataType
  , constantWithScalar_dataType
  , constantWithScalar_shape_dataType
  , constantWithRealPart_imaginaryPart
  , constantWithRealPart_imaginaryPart_dataType
  , constantWithRealPart_imaginaryPart_shape_dataType
  , variableWithData_shape_dataType_name
  , variableFromTensorWithTensor_name
  , readVariable_name
  , assignVariable_withValueOfTensor_name
  , matrixMultiplicationWithPrimaryTensor_secondaryTensor_name
  , hammingDistanceWithPrimaryTensor_secondaryTensor_resultDataType_name
  , scaledDotProductAttentionWithQueryTensor_keyTensor_valueTensor_maskTensor_scale_name
  , scaledDotProductAttentionWithQueryTensor_keyTensor_valueTensor_scale_name
  , inverseOfTensor_name
  , softMaxCrossEntropyWithSourceTensor_labelsTensor_axis_reductionType_name
  , softMaxCrossEntropyGradientWithIncomingGradientTensor_sourceTensor_labelsTensor_axis_reductionType_name
  , bandPartWithTensor_numLower_numUpper_name
  , bandPartWithTensor_numLowerTensor_numUpperTensor_name
  , imToColWithSourceTensor_descriptor_name
  , colToImWithSourceTensor_outputShape_descriptor_name
  , gatherAlongAxis_withUpdatesTensor_indicesTensor_name
  , gatherAlongAxisTensor_withUpdatesTensor_indicesTensor_name
  , gatherWithUpdatesTensor_indicesTensor_axis_batchDimensions_name
  , gatherNDWithUpdatesTensor_indicesTensor_batchDimensions_name
  , fastFourierTransformWithTensor_axes_descriptor_name
  , fastFourierTransformWithTensor_axesTensor_descriptor_name
  , realToHermiteanFFTWithTensor_axes_descriptor_name
  , realToHermiteanFFTWithTensor_axesTensor_descriptor_name
  , hermiteanToRealFFTWithTensor_axes_descriptor_name
  , hermiteanToRealFFTWithTensor_axesTensor_descriptor_name
  , depthwiseConvolution2DWithSourceTensor_weightsTensor_descriptor_name
  , depthwiseConvolution2DDataGradientWithIncomingGradientTensor_weightsTensor_outputShape_descriptor_name
  , depthwiseConvolution2DWeightsGradientWithIncomingGradientTensor_sourceTensor_outputShape_descriptor_name
  , depthwiseConvolution3DWithSourceTensor_weightsTensor_descriptor_name
  , depthwiseConvolution3DDataGradientWithIncomingGradientTensor_weightsTensor_outputShape_descriptor_name
  , depthwiseConvolution3DWeightsGradientWithIncomingGradientTensor_sourceTensor_outputShape_descriptor_name
  , cumulativeSumWithTensor_axis_exclusive_reverse_name
  , cumulativeSumWithTensor_axisTensor_exclusive_reverse_name
  , cumulativeSumWithTensor_axis_name
  , cumulativeSumWithTensor_axisTensor_name
  , cumulativeProductWithTensor_axis_exclusive_reverse_name
  , cumulativeProductWithTensor_axisTensor_exclusive_reverse_name
  , cumulativeProductWithTensor_axis_name
  , cumulativeProductWithTensor_axisTensor_name
  , cumulativeMinimumWithTensor_axis_exclusive_reverse_name
  , cumulativeMinimumWithTensor_axisTensor_exclusive_reverse_name
  , cumulativeMinimumWithTensor_axis_name
  , cumulativeMinimumWithTensor_axisTensor_name
  , cumulativeMaximumWithTensor_axis_exclusive_reverse_name
  , cumulativeMaximumWithTensor_axisTensor_exclusive_reverse_name
  , cumulativeMaximumWithTensor_axis_name
  , cumulativeMaximumWithTensor_axisTensor_name
  , controlDependencyWithOperations_dependentBlock_name
  , ifWithPredicateTensor_thenBlock_elseBlock_name
  , whileWithInitialInputs_before_after_name
  , forLoopWithLowerBound_upperBound_step_initialBodyArguments_body_name
  , forLoopWithNumberOfIterations_initialBodyArguments_body_name
  , convolutionTranspose2DWithSourceTensor_weightsTensor_outputShape_descriptor_name
  , convolutionTranspose2DWithSourceTensor_weightsTensor_outputShapeTensor_descriptor_name
  , convolutionTranspose2DDataGradientWithIncomingGradientTensor_weightsTensor_outputShape_forwardConvolutionDescriptor_name
  , convolutionTranspose2DDataGradientWithIncomingGradientTensor_weightsTensor_outputShapeTensor_forwardConvolutionDescriptor_name
  , convolutionTranspose2DWeightsGradientWithIncomingGradientTensor_sourceTensor_outputShape_forwardConvolutionDescriptor_name
  , convolutionTranspose2DWeightsGradientWithIncomingGradientTensor_sourceTensor_outputShapeTensor_forwardConvolutionDescriptor_name
  , convolution2DWithSourceTensor_weightsTensor_descriptor_name
  , convolution2DDataGradientWithIncomingGradientTensor_weightsTensor_outputShape_forwardConvolutionDescriptor_name
  , convolution2DDataGradientWithIncomingGradientTensor_weightsTensor_outputShapeTensor_forwardConvolutionDescriptor_name
  , convolution2DWeightsGradientWithIncomingGradientTensor_sourceTensor_outputShape_forwardConvolutionDescriptor_name
  , convolution2DWeightsGradientWithIncomingGradientTensor_sourceTensor_outputShapeTensor_forwardConvolutionDescriptor_name
  , convolution3DWithSourceTensor_weightsTensor_descriptor_name
  , convolution3DDataGradientWithIncomingGradientTensor_weightsTensor_outputShape_forwardConvolutionDescriptor_name
  , convolution3DDataGradientWithIncomingGradientTensor_weightsTensor_outputShapeTensor_forwardConvolutionDescriptor_name
  , convolution3DWeightsGradientWithIncomingGradientTensor_sourceTensor_outputShape_forwardConvolutionDescriptor_name
  , convolution3DWeightsGradientWithIncomingGradientTensor_sourceTensor_outputShapeTensor_forwardConvolutionDescriptor_name
  , callSymbolName_inputTensors_outputTypes_name
  , identityWithTensor_name
  , exponentWithTensor_name
  , exponentBase2WithTensor_name
  , exponentBase10WithTensor_name
  , logarithmWithTensor_name
  , logarithmBase2WithTensor_name
  , logarithmBase10WithTensor_name
  , squareWithTensor_name
  , squareRootWithTensor_name
  , reciprocalSquareRootWithTensor_name
  , reverseSquareRootWithTensor_name
  , reciprocalWithTensor_name
  , absoluteWithTensor_name
  , absoluteSquareWithTensor_name
  , negativeWithTensor_name
  , signWithTensor_name
  , signbitWithTensor_name
  , ceilWithTensor_name
  , floorWithTensor_name
  , roundWithTensor_name
  , rintWithTensor_name
  , sinWithTensor_name
  , cosWithTensor_name
  , tanWithTensor_name
  , sinhWithTensor_name
  , coshWithTensor_name
  , tanhWithTensor_name
  , asinWithTensor_name
  , acosWithTensor_name
  , atanWithTensor_name
  , asinhWithTensor_name
  , acoshWithTensor_name
  , atanhWithTensor_name
  , notWithTensor_name
  , isInfiniteWithTensor_name
  , isFiniteWithTensor_name
  , isNaNWithTensor_name
  , erfWithTensor_name
  , truncateWithTensor_name
  , bitwiseNOTWithTensor_name
  , bitwisePopulationCountWithTensor_name
  , conjugateWithTensor_name
  , additionWithPrimaryTensor_secondaryTensor_name
  , subtractionWithPrimaryTensor_secondaryTensor_name
  , multiplicationWithPrimaryTensor_secondaryTensor_name
  , divisionWithPrimaryTensor_secondaryTensor_name
  , moduloWithPrimaryTensor_secondaryTensor_name
  , powerWithPrimaryTensor_secondaryTensor_name
  , minimumWithPrimaryTensor_secondaryTensor_name
  , maximumWithPrimaryTensor_secondaryTensor_name
  , minimumWithNaNPropagationWithPrimaryTensor_secondaryTensor_name
  , maximumWithNaNPropagationWithPrimaryTensor_secondaryTensor_name
  , equalWithPrimaryTensor_secondaryTensor_name
  , notEqualWithPrimaryTensor_secondaryTensor_name
  , lessThanWithPrimaryTensor_secondaryTensor_name
  , lessThanOrEqualToWithPrimaryTensor_secondaryTensor_name
  , greaterThanWithPrimaryTensor_secondaryTensor_name
  , greaterThanOrEqualToWithPrimaryTensor_secondaryTensor_name
  , logicalANDWithPrimaryTensor_secondaryTensor_name
  , logicalORWithPrimaryTensor_secondaryTensor_name
  , logicalNANDWithPrimaryTensor_secondaryTensor_name
  , logicalNORWithPrimaryTensor_secondaryTensor_name
  , logicalXORWithPrimaryTensor_secondaryTensor_name
  , logicalXNORWithPrimaryTensor_secondaryTensor_name
  , atan2WithPrimaryTensor_secondaryTensor_name
  , bitwiseANDWithPrimaryTensor_secondaryTensor_name
  , bitwiseORWithPrimaryTensor_secondaryTensor_name
  , bitwiseXORWithPrimaryTensor_secondaryTensor_name
  , bitwiseLeftShiftWithPrimaryTensor_secondaryTensor_name
  , bitwiseRightShiftWithPrimaryTensor_secondaryTensor_name
  , selectWithPredicateTensor_truePredicateTensor_falsePredicateTensor_name
  , clampWithTensor_minValueTensor_maxValueTensor_name
  , divisionNoNaNWithPrimaryTensor_secondaryTensor_name
  , floorModuloWithPrimaryTensor_secondaryTensor_name
  , realPartOfTensor_name
  , imaginaryPartOfTensor_name
  , complexTensorWithRealTensor_imaginaryTensor_name
  , reLUWithTensor_name
  , reLUGradientWithIncomingGradient_sourceTensor_name
  , sigmoidWithTensor_name
  , sigmoidGradientWithIncomingGradient_sourceTensor_name
  , softMaxWithTensor_axis_name
  , softMaxGradientWithIncomingGradient_sourceTensor_axis_name
  , leakyReLUWithTensor_alpha_name
  , leakyReLUWithTensor_alphaTensor_name
  , leakyReLUGradientWithIncomingGradient_sourceTensor_alphaTensor_name
  , gradientForPrimaryTensor_withTensors_name
  , options
  , setOptions
  , placeholderTensors
  , newSelector
  , initSelector
  , compileWithDevice_feeds_targetTensors_targetOperations_compilationDescriptorSelector
  , runWithFeeds_targetTensors_targetOperationsSelector
  , runWithMTLCommandQueue_feeds_targetTensors_targetOperationsSelector
  , runWithMTLCommandQueue_feeds_targetOperations_resultsDictionarySelector
  , runAsyncWithFeeds_targetTensors_targetOperations_executionDescriptorSelector
  , runAsyncWithMTLCommandQueue_feeds_targetTensors_targetOperations_executionDescriptorSelector
  , runAsyncWithMTLCommandQueue_feeds_targetOperations_resultsDictionary_executionDescriptorSelector
  , encodeToCommandBuffer_feeds_targetTensors_targetOperations_executionDescriptorSelector
  , encodeToCommandBuffer_feeds_targetOperations_resultsDictionary_executionDescriptorSelector
  , topKWithGradientTensor_source_k_nameSelector
  , topKWithGradientTensor_source_axis_k_nameSelector
  , bottomKWithGradientTensor_source_axis_k_nameSelector
  , topKWithGradientTensor_source_kTensor_nameSelector
  , topKWithGradientTensor_source_axisTensor_kTensor_nameSelector
  , bottomKWithGradientTensor_source_axisTensor_kTensor_nameSelector
  , topKWithSourceTensor_k_nameSelector
  , topKWithSourceTensor_kTensor_nameSelector
  , topKWithSourceTensor_axis_k_nameSelector
  , bottomKWithSourceTensor_axis_k_nameSelector
  , topKWithSourceTensor_axisTensor_kTensor_nameSelector
  , bottomKWithSourceTensor_axisTensor_kTensor_nameSelector
  , reshapeTensor_withShape_nameSelector
  , reshapeTensor_withShapeTensor_nameSelector
  , transposeTensor_dimension_withDimension_nameSelector
  , transposeTensor_permutation_nameSelector
  , sliceTensor_dimension_start_length_nameSelector
  , sliceTensor_starts_ends_strides_nameSelector
  , sliceTensor_starts_ends_strides_startMask_endMask_squeezeMask_nameSelector
  , sliceTensor_startTensor_endTensor_strideTensor_startMask_endMask_squeezeMask_nameSelector
  , sliceTensor_startTensor_sizeTensor_squeezeMask_nameSelector
  , sliceGradientTensor_fwdInShapeTensor_starts_ends_strides_nameSelector
  , sliceGradientTensor_fwdInShapeTensor_startTensor_endTensor_strideTensor_startMask_endMask_squeezeMask_nameSelector
  , sliceGradientTensor_fwdInShapeTensor_startTensor_sizeTensor_squeezeMask_nameSelector
  , sliceGradientTensor_fwdInShapeTensor_starts_ends_strides_startMask_endMask_squeezeMask_nameSelector
  , sliceUpdateDataTensor_updateTensor_startsTensor_endsTensor_stridesTensor_startMask_endMask_squeezeMask_nameSelector
  , sliceUpdateDataTensor_updateTensor_starts_ends_strides_startMask_endMask_squeezeMask_nameSelector
  , sliceUpdateDataTensor_updateTensor_startsTensor_endsTensor_stridesTensor_nameSelector
  , sliceUpdateDataTensor_updateTensor_starts_ends_strides_nameSelector
  , concatTensor_withTensor_dimension_nameSelector
  , concatTensors_dimension_nameSelector
  , concatTensors_dimension_interleave_nameSelector
  , tileTensor_withMultiplier_nameSelector
  , tileGradientWithIncomingGradientTensor_sourceTensor_withMultiplier_nameSelector
  , padTensor_withPaddingMode_leftPadding_rightPadding_constantValue_nameSelector
  , padGradientWithIncomingGradientTensor_sourceTensor_paddingMode_leftPadding_rightPadding_nameSelector
  , spaceToDepth2DTensor_widthAxis_heightAxis_depthAxis_blockSize_usePixelShuffleOrder_nameSelector
  , spaceToDepth2DTensor_widthAxisTensor_heightAxisTensor_depthAxisTensor_blockSize_usePixelShuffleOrder_nameSelector
  , depthToSpace2DTensor_widthAxis_heightAxis_depthAxis_blockSize_usePixelShuffleOrder_nameSelector
  , depthToSpace2DTensor_widthAxisTensor_heightAxisTensor_depthAxisTensor_blockSize_usePixelShuffleOrder_nameSelector
  , spaceToBatchTensor_spatialAxes_batchAxis_blockDimensions_usePixelShuffleOrder_nameSelector
  , spaceToBatchTensor_spatialAxesTensor_batchAxisTensor_blockDimensionsTensor_usePixelShuffleOrder_nameSelector
  , batchToSpaceTensor_spatialAxes_batchAxis_blockDimensions_usePixelShuffleOrder_nameSelector
  , batchToSpaceTensor_spatialAxesTensor_batchAxisTensor_blockDimensionsTensor_usePixelShuffleOrder_nameSelector
  , reverseTensor_axesTensor_nameSelector
  , reverseTensor_axes_nameSelector
  , reverseTensor_nameSelector
  , flatten2DTensor_axis_nameSelector
  , flatten2DTensor_axisTensor_nameSelector
  , broadcastTensor_toShape_nameSelector
  , broadcastTensor_toShapeTensor_nameSelector
  , shapeOfTensor_nameSelector
  , castTensor_toType_nameSelector
  , reinterpretCastTensor_toType_nameSelector
  , stackTensors_axis_nameSelector
  , splitTensor_splitSizes_axis_nameSelector
  , splitTensor_splitSizesTensor_axis_nameSelector
  , splitTensor_numSplits_axis_nameSelector
  , squeezeTensor_nameSelector
  , squeezeTensor_axis_nameSelector
  , squeezeTensor_axes_nameSelector
  , squeezeTensor_axesTensor_nameSelector
  , expandDimsOfTensor_axis_nameSelector
  , expandDimsOfTensor_axes_nameSelector
  , expandDimsOfTensor_axesTensor_nameSelector
  , coordinateAlongAxis_withShape_nameSelector
  , coordinateAlongAxisTensor_withShape_nameSelector
  , coordinateAlongAxis_withShapeTensor_nameSelector
  , coordinateAlongAxisTensor_withShapeTensor_nameSelector
  , stencilWithSourceTensor_weightsTensor_descriptor_nameSelector
  , sparseTensorWithType_tensors_shape_dataType_nameSelector
  , sparseTensorWithDescriptor_tensors_shape_nameSelector
  , sortWithTensor_axis_descending_nameSelector
  , sortWithTensor_axisTensor_descending_nameSelector
  , sortWithTensor_axis_nameSelector
  , sortWithTensor_axisTensor_nameSelector
  , argSortWithTensor_axis_descending_nameSelector
  , argSortWithTensor_axisTensor_descending_nameSelector
  , argSortWithTensor_axis_nameSelector
  , argSortWithTensor_axisTensor_nameSelector
  , scatterAlongAxis_withUpdatesTensor_indicesTensor_shape_mode_nameSelector
  , scatterAlongAxisTensor_withUpdatesTensor_indicesTensor_shape_mode_nameSelector
  , scatterAlongAxis_withDataTensor_updatesTensor_indicesTensor_mode_nameSelector
  , scatterAlongAxisTensor_withDataTensor_updatesTensor_indicesTensor_mode_nameSelector
  , scatterWithUpdatesTensor_indicesTensor_shape_axis_mode_nameSelector
  , scatterWithDataTensor_updatesTensor_indicesTensor_axis_mode_nameSelector
  , scatterNDWithUpdatesTensor_indicesTensor_shape_batchDimensions_mode_nameSelector
  , scatterNDWithUpdatesTensor_indicesTensor_shape_batchDimensions_nameSelector
  , scatterNDWithDataTensor_updatesTensor_indicesTensor_batchDimensions_mode_nameSelector
  , sampleGridWithSourceTensor_coordinateTensor_layout_normalizeCoordinates_relativeCoordinates_alignCorners_paddingMode_samplingMode_constantValue_nameSelector
  , sampleGridWithSourceTensor_coordinateTensor_layout_normalizeCoordinates_relativeCoordinates_alignCorners_paddingMode_nearestRoundingMode_constantValue_nameSelector
  , singleGateRNNWithSourceTensor_recurrentWeight_inputWeight_bias_initState_mask_descriptor_nameSelector
  , singleGateRNNWithSourceTensor_recurrentWeight_inputWeight_bias_initState_descriptor_nameSelector
  , singleGateRNNWithSourceTensor_recurrentWeight_initState_descriptor_nameSelector
  , singleGateRNNGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_stateGradient_inputWeight_bias_initState_mask_descriptor_nameSelector
  , singleGateRNNGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_inputWeight_bias_initState_mask_descriptor_nameSelector
  , singleGateRNNGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_inputWeight_bias_initState_descriptor_nameSelector
  , singleGateRNNGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_initState_descriptor_nameSelector
  , lstmWithSourceTensor_recurrentWeight_inputWeight_bias_initState_initCell_mask_peephole_descriptor_nameSelector
  , lstmWithSourceTensor_recurrentWeight_inputWeight_bias_initState_initCell_descriptor_nameSelector
  , lstmWithSourceTensor_recurrentWeight_initState_initCell_descriptor_nameSelector
  , lstmGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_cellOutputFwd_stateGradient_cellGradient_inputWeight_bias_initState_initCell_mask_peephole_descriptor_nameSelector
  , lstmGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_cellOutputFwd_inputWeight_bias_initState_initCell_mask_descriptor_nameSelector
  , lstmGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_cellOutputFwd_inputWeight_bias_initState_initCell_descriptor_nameSelector
  , lstmGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_cellOutputFwd_descriptor_nameSelector
  , gruWithSourceTensor_recurrentWeight_inputWeight_bias_initState_mask_secondaryBias_descriptor_nameSelector
  , gruWithSourceTensor_recurrentWeight_inputWeight_bias_initState_descriptor_nameSelector
  , gruWithSourceTensor_recurrentWeight_inputWeight_bias_descriptor_nameSelector
  , gruGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_outputFwd_stateGradient_inputWeight_bias_initState_mask_secondaryBias_descriptor_nameSelector
  , gruGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_outputFwd_inputWeight_bias_initState_descriptor_nameSelector
  , gruGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_outputFwd_inputWeight_bias_descriptor_nameSelector
  , resizeTensor_size_mode_centerResult_alignCorners_layout_nameSelector
  , resizeTensor_sizeTensor_mode_centerResult_alignCorners_layout_nameSelector
  , resizeTensor_sizeTensor_mode_centerResult_alignCorners_nameSelector
  , resizeNearestWithTensor_sizeTensor_nearestRoundingMode_centerResult_alignCorners_layout_nameSelector
  , resizeNearestWithTensor_sizeTensor_nearestRoundingMode_centerResult_alignCorners_nameSelector
  , resizeBilinearWithTensor_sizeTensor_centerResult_alignCorners_layout_nameSelector
  , resizeBilinearWithTensor_sizeTensor_centerResult_alignCorners_nameSelector
  , resizeTensor_sizeTensor_scaleOffsetTensor_mode_layout_nameSelector
  , resizeTensor_sizeTensor_scaleTensor_offsetTensor_mode_nameSelector
  , resizeNearestWithTensor_sizeTensor_scaleOffsetTensor_nearestRoundingMode_layout_nameSelector
  , resizeNearestWithTensor_sizeTensor_scaleTensor_offsetTensor_nearestRoundingMode_nameSelector
  , resizeBilinearWithTensor_sizeTensor_scaleOffsetTensor_layout_nameSelector
  , resizeBilinearWithTensor_sizeTensor_scaleTensor_offsetTensor_nameSelector
  , resizeWithGradientTensor_input_mode_centerResult_alignCorners_layout_nameSelector
  , resizeNearestWithGradientTensor_input_nearestRoundingMode_centerResult_alignCorners_layout_nameSelector
  , resizeBilinearWithGradientTensor_input_centerResult_alignCorners_layout_nameSelector
  , resizeWithGradientTensor_input_scaleOffsetTensor_mode_layout_nameSelector
  , resizeWithGradientTensor_input_scaleTensor_offsetTensor_mode_nameSelector
  , resizeNearestWithGradientTensor_input_scaleOffsetTensor_nearestRoundingMode_layout_nameSelector
  , resizeNearestWithGradientTensor_input_scaleTensor_offsetTensor_nearestRoundingMode_nameSelector
  , resizeBilinearWithGradientTensor_input_scaleOffsetTensor_layout_nameSelector
  , resizeBilinearWithGradientTensor_input_scaleTensor_offsetTensor_nameSelector
  , reductionSumWithTensor_axis_nameSelector
  , reductionSumWithTensor_axes_nameSelector
  , reductionMaximumWithTensor_axis_nameSelector
  , reductionMaximumWithTensor_axes_nameSelector
  , reductionMinimumWithTensor_axis_nameSelector
  , reductionMinimumWithTensor_axes_nameSelector
  , reductionMaximumPropagateNaNWithTensor_axis_nameSelector
  , reductionMaximumPropagateNaNWithTensor_axes_nameSelector
  , reductionMinimumPropagateNaNWithTensor_axis_nameSelector
  , reductionMinimumPropagateNaNWithTensor_axes_nameSelector
  , reductionProductWithTensor_axis_nameSelector
  , reductionProductWithTensor_axes_nameSelector
  , reductionArgMaximumWithTensor_axis_nameSelector
  , reductionArgMinimumWithTensor_axis_nameSelector
  , reductionAndWithTensor_axis_nameSelector
  , reductionAndWithTensor_axes_nameSelector
  , reductionOrWithTensor_axis_nameSelector
  , reductionOrWithTensor_axes_nameSelector
  , randomPhiloxStateTensorWithSeed_nameSelector
  , randomPhiloxStateTensorWithCounterLow_counterHigh_key_nameSelector
  , randomTensorWithShape_descriptor_nameSelector
  , randomTensorWithShapeTensor_descriptor_nameSelector
  , randomTensorWithShape_descriptor_seed_nameSelector
  , randomTensorWithShapeTensor_descriptor_seed_nameSelector
  , randomTensorWithShape_descriptor_stateTensor_nameSelector
  , randomTensorWithShapeTensor_descriptor_stateTensor_nameSelector
  , randomUniformTensorWithShape_nameSelector
  , randomUniformTensorWithShapeTensor_nameSelector
  , randomUniformTensorWithShape_seed_nameSelector
  , randomUniformTensorWithShapeTensor_seed_nameSelector
  , randomUniformTensorWithShape_stateTensor_nameSelector
  , randomUniformTensorWithShapeTensor_stateTensor_nameSelector
  , dropoutTensor_rate_nameSelector
  , dropoutTensor_rateTensor_nameSelector
  , quantizeTensor_scale_zeroPoint_dataType_nameSelector
  , dequantizeTensor_scale_zeroPoint_dataType_nameSelector
  , quantizeTensor_scaleTensor_zeroPoint_dataType_axis_nameSelector
  , dequantizeTensor_scaleTensor_zeroPoint_dataType_axis_nameSelector
  , quantizeTensor_scaleTensor_zeroPointTensor_dataType_axis_nameSelector
  , dequantizeTensor_scaleTensor_zeroPointTensor_dataType_axis_nameSelector
  , dequantizeTensor_scaleTensor_zeroPointTensor_dataType_nameSelector
  , dequantizeTensor_scaleTensor_dataType_nameSelector
  , dequantizeTensor_LUTTensor_nameSelector
  , dequantizeTensor_LUTTensor_axis_nameSelector
  , maxPooling2DWithSourceTensor_descriptor_nameSelector
  , maxPooling2DReturnIndicesWithSourceTensor_descriptor_nameSelector
  , maxPooling2DGradientWithGradientTensor_sourceTensor_descriptor_nameSelector
  , maxPooling2DGradientWithGradientTensor_indicesTensor_outputShape_descriptor_nameSelector
  , maxPooling2DGradientWithGradientTensor_indicesTensor_outputShapeTensor_descriptor_nameSelector
  , avgPooling2DWithSourceTensor_descriptor_nameSelector
  , avgPooling2DGradientWithGradientTensor_sourceTensor_descriptor_nameSelector
  , maxPooling4DWithSourceTensor_descriptor_nameSelector
  , maxPooling4DReturnIndicesWithSourceTensor_descriptor_nameSelector
  , maxPooling4DGradientWithGradientTensor_sourceTensor_descriptor_nameSelector
  , maxPooling4DGradientWithGradientTensor_indicesTensor_outputShape_descriptor_nameSelector
  , maxPooling4DGradientWithGradientTensor_indicesTensor_outputShapeTensor_descriptor_nameSelector
  , avgPooling4DWithSourceTensor_descriptor_nameSelector
  , avgPooling4DGradientWithGradientTensor_sourceTensor_descriptor_nameSelector
  , l2NormPooling4DWithSourceTensor_descriptor_nameSelector
  , l2NormPooling4DGradientWithGradientTensor_sourceTensor_descriptor_nameSelector
  , stochasticGradientDescentWithLearningRateTensor_valuesTensor_gradientTensor_nameSelector
  , applyStochasticGradientDescentWithLearningRateTensor_variable_gradientTensor_nameSelector
  , adamWithLearningRateTensor_beta1Tensor_beta2Tensor_epsilonTensor_beta1PowerTensor_beta2PowerTensor_valuesTensor_momentumTensor_velocityTensor_maximumVelocityTensor_gradientTensor_nameSelector
  , adamWithCurrentLearningRateTensor_beta1Tensor_beta2Tensor_epsilonTensor_valuesTensor_momentumTensor_velocityTensor_maximumVelocityTensor_gradientTensor_nameSelector
  , oneHotWithIndicesTensor_depth_axis_dataType_onValue_offValue_nameSelector
  , oneHotWithIndicesTensor_depth_dataType_onValue_offValue_nameSelector
  , oneHotWithIndicesTensor_depth_axis_dataType_nameSelector
  , oneHotWithIndicesTensor_depth_axis_nameSelector
  , oneHotWithIndicesTensor_depth_dataType_nameSelector
  , oneHotWithIndicesTensor_depth_nameSelector
  , meanOfTensor_axes_nameSelector
  , varianceOfTensor_meanTensor_axes_nameSelector
  , varianceOfTensor_axes_nameSelector
  , normalizationWithTensor_meanTensor_varianceTensor_gammaTensor_betaTensor_epsilon_nameSelector
  , normalizationGammaGradientWithIncomingGradientTensor_sourceTensor_meanTensor_varianceTensor_reductionAxes_epsilon_nameSelector
  , normalizationBetaGradientWithIncomingGradientTensor_sourceTensor_reductionAxes_nameSelector
  , normalizationGradientWithIncomingGradientTensor_sourceTensor_meanTensor_varianceTensor_gammaTensor_gammaGradientTensor_betaGradientTensor_reductionAxes_epsilon_nameSelector
  , nonZeroIndicesOfTensor_nameSelector
  , nonMaximumSuppressionWithBoxesTensor_scoresTensor_IOUThreshold_scoreThreshold_perClassSuppression_coordinateMode_nameSelector
  , nonMaximumSuppressionWithBoxesTensor_scoresTensor_classIndicesTensor_IOUThreshold_scoreThreshold_perClassSuppression_coordinateMode_nameSelector
  , placeholderWithShape_dataType_nameSelector
  , placeholderWithShape_nameSelector
  , constantWithData_shape_dataTypeSelector
  , constantWithScalar_dataTypeSelector
  , constantWithScalar_shape_dataTypeSelector
  , constantWithRealPart_imaginaryPartSelector
  , constantWithRealPart_imaginaryPart_dataTypeSelector
  , constantWithRealPart_imaginaryPart_shape_dataTypeSelector
  , variableWithData_shape_dataType_nameSelector
  , variableFromTensorWithTensor_nameSelector
  , readVariable_nameSelector
  , assignVariable_withValueOfTensor_nameSelector
  , matrixMultiplicationWithPrimaryTensor_secondaryTensor_nameSelector
  , hammingDistanceWithPrimaryTensor_secondaryTensor_resultDataType_nameSelector
  , scaledDotProductAttentionWithQueryTensor_keyTensor_valueTensor_maskTensor_scale_nameSelector
  , scaledDotProductAttentionWithQueryTensor_keyTensor_valueTensor_scale_nameSelector
  , inverseOfTensor_nameSelector
  , softMaxCrossEntropyWithSourceTensor_labelsTensor_axis_reductionType_nameSelector
  , softMaxCrossEntropyGradientWithIncomingGradientTensor_sourceTensor_labelsTensor_axis_reductionType_nameSelector
  , bandPartWithTensor_numLower_numUpper_nameSelector
  , bandPartWithTensor_numLowerTensor_numUpperTensor_nameSelector
  , imToColWithSourceTensor_descriptor_nameSelector
  , colToImWithSourceTensor_outputShape_descriptor_nameSelector
  , gatherAlongAxis_withUpdatesTensor_indicesTensor_nameSelector
  , gatherAlongAxisTensor_withUpdatesTensor_indicesTensor_nameSelector
  , gatherWithUpdatesTensor_indicesTensor_axis_batchDimensions_nameSelector
  , gatherNDWithUpdatesTensor_indicesTensor_batchDimensions_nameSelector
  , fastFourierTransformWithTensor_axes_descriptor_nameSelector
  , fastFourierTransformWithTensor_axesTensor_descriptor_nameSelector
  , realToHermiteanFFTWithTensor_axes_descriptor_nameSelector
  , realToHermiteanFFTWithTensor_axesTensor_descriptor_nameSelector
  , hermiteanToRealFFTWithTensor_axes_descriptor_nameSelector
  , hermiteanToRealFFTWithTensor_axesTensor_descriptor_nameSelector
  , depthwiseConvolution2DWithSourceTensor_weightsTensor_descriptor_nameSelector
  , depthwiseConvolution2DDataGradientWithIncomingGradientTensor_weightsTensor_outputShape_descriptor_nameSelector
  , depthwiseConvolution2DWeightsGradientWithIncomingGradientTensor_sourceTensor_outputShape_descriptor_nameSelector
  , depthwiseConvolution3DWithSourceTensor_weightsTensor_descriptor_nameSelector
  , depthwiseConvolution3DDataGradientWithIncomingGradientTensor_weightsTensor_outputShape_descriptor_nameSelector
  , depthwiseConvolution3DWeightsGradientWithIncomingGradientTensor_sourceTensor_outputShape_descriptor_nameSelector
  , cumulativeSumWithTensor_axis_exclusive_reverse_nameSelector
  , cumulativeSumWithTensor_axisTensor_exclusive_reverse_nameSelector
  , cumulativeSumWithTensor_axis_nameSelector
  , cumulativeSumWithTensor_axisTensor_nameSelector
  , cumulativeProductWithTensor_axis_exclusive_reverse_nameSelector
  , cumulativeProductWithTensor_axisTensor_exclusive_reverse_nameSelector
  , cumulativeProductWithTensor_axis_nameSelector
  , cumulativeProductWithTensor_axisTensor_nameSelector
  , cumulativeMinimumWithTensor_axis_exclusive_reverse_nameSelector
  , cumulativeMinimumWithTensor_axisTensor_exclusive_reverse_nameSelector
  , cumulativeMinimumWithTensor_axis_nameSelector
  , cumulativeMinimumWithTensor_axisTensor_nameSelector
  , cumulativeMaximumWithTensor_axis_exclusive_reverse_nameSelector
  , cumulativeMaximumWithTensor_axisTensor_exclusive_reverse_nameSelector
  , cumulativeMaximumWithTensor_axis_nameSelector
  , cumulativeMaximumWithTensor_axisTensor_nameSelector
  , controlDependencyWithOperations_dependentBlock_nameSelector
  , ifWithPredicateTensor_thenBlock_elseBlock_nameSelector
  , whileWithInitialInputs_before_after_nameSelector
  , forLoopWithLowerBound_upperBound_step_initialBodyArguments_body_nameSelector
  , forLoopWithNumberOfIterations_initialBodyArguments_body_nameSelector
  , convolutionTranspose2DWithSourceTensor_weightsTensor_outputShape_descriptor_nameSelector
  , convolutionTranspose2DWithSourceTensor_weightsTensor_outputShapeTensor_descriptor_nameSelector
  , convolutionTranspose2DDataGradientWithIncomingGradientTensor_weightsTensor_outputShape_forwardConvolutionDescriptor_nameSelector
  , convolutionTranspose2DDataGradientWithIncomingGradientTensor_weightsTensor_outputShapeTensor_forwardConvolutionDescriptor_nameSelector
  , convolutionTranspose2DWeightsGradientWithIncomingGradientTensor_sourceTensor_outputShape_forwardConvolutionDescriptor_nameSelector
  , convolutionTranspose2DWeightsGradientWithIncomingGradientTensor_sourceTensor_outputShapeTensor_forwardConvolutionDescriptor_nameSelector
  , convolution2DWithSourceTensor_weightsTensor_descriptor_nameSelector
  , convolution2DDataGradientWithIncomingGradientTensor_weightsTensor_outputShape_forwardConvolutionDescriptor_nameSelector
  , convolution2DDataGradientWithIncomingGradientTensor_weightsTensor_outputShapeTensor_forwardConvolutionDescriptor_nameSelector
  , convolution2DWeightsGradientWithIncomingGradientTensor_sourceTensor_outputShape_forwardConvolutionDescriptor_nameSelector
  , convolution2DWeightsGradientWithIncomingGradientTensor_sourceTensor_outputShapeTensor_forwardConvolutionDescriptor_nameSelector
  , convolution3DWithSourceTensor_weightsTensor_descriptor_nameSelector
  , convolution3DDataGradientWithIncomingGradientTensor_weightsTensor_outputShape_forwardConvolutionDescriptor_nameSelector
  , convolution3DDataGradientWithIncomingGradientTensor_weightsTensor_outputShapeTensor_forwardConvolutionDescriptor_nameSelector
  , convolution3DWeightsGradientWithIncomingGradientTensor_sourceTensor_outputShape_forwardConvolutionDescriptor_nameSelector
  , convolution3DWeightsGradientWithIncomingGradientTensor_sourceTensor_outputShapeTensor_forwardConvolutionDescriptor_nameSelector
  , callSymbolName_inputTensors_outputTypes_nameSelector
  , identityWithTensor_nameSelector
  , exponentWithTensor_nameSelector
  , exponentBase2WithTensor_nameSelector
  , exponentBase10WithTensor_nameSelector
  , logarithmWithTensor_nameSelector
  , logarithmBase2WithTensor_nameSelector
  , logarithmBase10WithTensor_nameSelector
  , squareWithTensor_nameSelector
  , squareRootWithTensor_nameSelector
  , reciprocalSquareRootWithTensor_nameSelector
  , reverseSquareRootWithTensor_nameSelector
  , reciprocalWithTensor_nameSelector
  , absoluteWithTensor_nameSelector
  , absoluteSquareWithTensor_nameSelector
  , negativeWithTensor_nameSelector
  , signWithTensor_nameSelector
  , signbitWithTensor_nameSelector
  , ceilWithTensor_nameSelector
  , floorWithTensor_nameSelector
  , roundWithTensor_nameSelector
  , rintWithTensor_nameSelector
  , sinWithTensor_nameSelector
  , cosWithTensor_nameSelector
  , tanWithTensor_nameSelector
  , sinhWithTensor_nameSelector
  , coshWithTensor_nameSelector
  , tanhWithTensor_nameSelector
  , asinWithTensor_nameSelector
  , acosWithTensor_nameSelector
  , atanWithTensor_nameSelector
  , asinhWithTensor_nameSelector
  , acoshWithTensor_nameSelector
  , atanhWithTensor_nameSelector
  , notWithTensor_nameSelector
  , isInfiniteWithTensor_nameSelector
  , isFiniteWithTensor_nameSelector
  , isNaNWithTensor_nameSelector
  , erfWithTensor_nameSelector
  , truncateWithTensor_nameSelector
  , bitwiseNOTWithTensor_nameSelector
  , bitwisePopulationCountWithTensor_nameSelector
  , conjugateWithTensor_nameSelector
  , additionWithPrimaryTensor_secondaryTensor_nameSelector
  , subtractionWithPrimaryTensor_secondaryTensor_nameSelector
  , multiplicationWithPrimaryTensor_secondaryTensor_nameSelector
  , divisionWithPrimaryTensor_secondaryTensor_nameSelector
  , moduloWithPrimaryTensor_secondaryTensor_nameSelector
  , powerWithPrimaryTensor_secondaryTensor_nameSelector
  , minimumWithPrimaryTensor_secondaryTensor_nameSelector
  , maximumWithPrimaryTensor_secondaryTensor_nameSelector
  , minimumWithNaNPropagationWithPrimaryTensor_secondaryTensor_nameSelector
  , maximumWithNaNPropagationWithPrimaryTensor_secondaryTensor_nameSelector
  , equalWithPrimaryTensor_secondaryTensor_nameSelector
  , notEqualWithPrimaryTensor_secondaryTensor_nameSelector
  , lessThanWithPrimaryTensor_secondaryTensor_nameSelector
  , lessThanOrEqualToWithPrimaryTensor_secondaryTensor_nameSelector
  , greaterThanWithPrimaryTensor_secondaryTensor_nameSelector
  , greaterThanOrEqualToWithPrimaryTensor_secondaryTensor_nameSelector
  , logicalANDWithPrimaryTensor_secondaryTensor_nameSelector
  , logicalORWithPrimaryTensor_secondaryTensor_nameSelector
  , logicalNANDWithPrimaryTensor_secondaryTensor_nameSelector
  , logicalNORWithPrimaryTensor_secondaryTensor_nameSelector
  , logicalXORWithPrimaryTensor_secondaryTensor_nameSelector
  , logicalXNORWithPrimaryTensor_secondaryTensor_nameSelector
  , atan2WithPrimaryTensor_secondaryTensor_nameSelector
  , bitwiseANDWithPrimaryTensor_secondaryTensor_nameSelector
  , bitwiseORWithPrimaryTensor_secondaryTensor_nameSelector
  , bitwiseXORWithPrimaryTensor_secondaryTensor_nameSelector
  , bitwiseLeftShiftWithPrimaryTensor_secondaryTensor_nameSelector
  , bitwiseRightShiftWithPrimaryTensor_secondaryTensor_nameSelector
  , selectWithPredicateTensor_truePredicateTensor_falsePredicateTensor_nameSelector
  , clampWithTensor_minValueTensor_maxValueTensor_nameSelector
  , divisionNoNaNWithPrimaryTensor_secondaryTensor_nameSelector
  , floorModuloWithPrimaryTensor_secondaryTensor_nameSelector
  , realPartOfTensor_nameSelector
  , imaginaryPartOfTensor_nameSelector
  , complexTensorWithRealTensor_imaginaryTensor_nameSelector
  , reLUWithTensor_nameSelector
  , reLUGradientWithIncomingGradient_sourceTensor_nameSelector
  , sigmoidWithTensor_nameSelector
  , sigmoidGradientWithIncomingGradient_sourceTensor_nameSelector
  , softMaxWithTensor_axis_nameSelector
  , softMaxGradientWithIncomingGradient_sourceTensor_axis_nameSelector
  , leakyReLUWithTensor_alpha_nameSelector
  , leakyReLUWithTensor_alphaTensor_nameSelector
  , leakyReLUGradientWithIncomingGradient_sourceTensor_alphaTensor_nameSelector
  , gradientForPrimaryTensor_withTensors_nameSelector
  , optionsSelector
  , setOptionsSelector
  , placeholderTensorsSelector

  -- * Enum types
  , MPSDataType(MPSDataType)
  , pattern MPSDataTypeInvalid
  , pattern MPSDataTypeFloatBit
  , pattern MPSDataTypeFloat32
  , pattern MPSDataTypeFloat16
  , pattern MPSDataTypeComplexBit
  , pattern MPSDataTypeComplexFloat32
  , pattern MPSDataTypeComplexFloat16
  , pattern MPSDataTypeSignedBit
  , pattern MPSDataTypeIntBit
  , pattern MPSDataTypeInt2
  , pattern MPSDataTypeInt4
  , pattern MPSDataTypeInt8
  , pattern MPSDataTypeInt16
  , pattern MPSDataTypeInt32
  , pattern MPSDataTypeInt64
  , pattern MPSDataTypeUInt2
  , pattern MPSDataTypeUInt4
  , pattern MPSDataTypeUInt8
  , pattern MPSDataTypeUInt16
  , pattern MPSDataTypeUInt32
  , pattern MPSDataTypeUInt64
  , pattern MPSDataTypeAlternateEncodingBit
  , pattern MPSDataTypeBool
  , pattern MPSDataTypeBFloat16
  , pattern MPSDataTypeNormalizedBit
  , pattern MPSDataTypeUnorm1
  , pattern MPSDataTypeUnorm8
  , MPSGraphLossReductionType(MPSGraphLossReductionType)
  , pattern MPSGraphLossReductionTypeNone
  , pattern MPSGraphLossReductionTypeAxis
  , pattern MPSGraphLossReductionTypeSum
  , pattern MPSGraphLossReductionTypeMean
  , MPSGraphNonMaximumSuppressionCoordinateMode(MPSGraphNonMaximumSuppressionCoordinateMode)
  , pattern MPSGraphNonMaximumSuppressionCoordinateModeCornersHeightFirst
  , pattern MPSGraphNonMaximumSuppressionCoordinateModeCornersWidthFirst
  , pattern MPSGraphNonMaximumSuppressionCoordinateModeCentersHeightFirst
  , pattern MPSGraphNonMaximumSuppressionCoordinateModeCentersWidthFirst
  , MPSGraphOptions(MPSGraphOptions)
  , pattern MPSGraphOptionsNone
  , pattern MPSGraphOptionsSynchronizeResults
  , pattern MPSGraphOptionsVerbose
  , pattern MPSGraphOptionsDefault
  , MPSGraphPaddingMode(MPSGraphPaddingMode)
  , pattern MPSGraphPaddingModeConstant
  , pattern MPSGraphPaddingModeReflect
  , pattern MPSGraphPaddingModeSymmetric
  , pattern MPSGraphPaddingModeClampToEdge
  , pattern MPSGraphPaddingModeZero
  , pattern MPSGraphPaddingModePeriodic
  , pattern MPSGraphPaddingModeAntiPeriodic
  , MPSGraphResizeMode(MPSGraphResizeMode)
  , pattern MPSGraphResizeNearest
  , pattern MPSGraphResizeBilinear
  , MPSGraphResizeNearestRoundingMode(MPSGraphResizeNearestRoundingMode)
  , pattern MPSGraphResizeNearestRoundingModeRoundPreferCeil
  , pattern MPSGraphResizeNearestRoundingModeRoundPreferFloor
  , pattern MPSGraphResizeNearestRoundingModeCeil
  , pattern MPSGraphResizeNearestRoundingModeFloor
  , pattern MPSGraphResizeNearestRoundingModeRoundToEven
  , pattern MPSGraphResizeNearestRoundingModeRoundToOdd
  , MPSGraphScatterMode(MPSGraphScatterMode)
  , pattern MPSGraphScatterModeAdd
  , pattern MPSGraphScatterModeSub
  , pattern MPSGraphScatterModeMul
  , pattern MPSGraphScatterModeDiv
  , pattern MPSGraphScatterModeMin
  , pattern MPSGraphScatterModeMax
  , pattern MPSGraphScatterModeSet
  , MPSGraphSparseStorageType(MPSGraphSparseStorageType)
  , pattern MPSGraphSparseStorageCOO
  , pattern MPSGraphSparseStorageCSC
  , pattern MPSGraphSparseStorageCSR
  , MPSGraphTensorNamedDataLayout(MPSGraphTensorNamedDataLayout)
  , pattern MPSGraphTensorNamedDataLayoutNCHW
  , pattern MPSGraphTensorNamedDataLayoutNHWC
  , pattern MPSGraphTensorNamedDataLayoutOIHW
  , pattern MPSGraphTensorNamedDataLayoutHWIO
  , pattern MPSGraphTensorNamedDataLayoutCHW
  , pattern MPSGraphTensorNamedDataLayoutHWC
  , pattern MPSGraphTensorNamedDataLayoutHW
  , pattern MPSGraphTensorNamedDataLayoutNCDHW
  , pattern MPSGraphTensorNamedDataLayoutNDHWC
  , pattern MPSGraphTensorNamedDataLayoutOIDHW
  , pattern MPSGraphTensorNamedDataLayoutDHWIO

  ) where

import Foreign.Ptr (Ptr, nullPtr, castPtr)
import Foreign.LibFFI
import Foreign.C.Types
import Data.Int (Int8, Int16)
import Data.Word (Word16)
import Data.Coerce (coerce)

import ObjC.Runtime.Types
import ObjC.Runtime.MsgSend (sendMsg, sendClassMsg)
import ObjC.Runtime.Selector (mkSelector)
import ObjC.Runtime.Class (getRequiredClass)

import ObjC.MetalPerformanceShadersGraph.Internal.Classes
import ObjC.MetalPerformanceShadersGraph.Internal.Enums
import ObjC.MetalPerformanceShaders.Internal.Enums
import ObjC.Foundation.Internal.Classes
import ObjC.MetalPerformanceShaders.Internal.Classes

-- | Creates a new graph to insert nodes in.
--
-- ObjC selector: @+ new@
new :: IO (Id MPSGraph)
new  =
  do
    cls' <- getRequiredClass "MPSGraph"
    sendClassMsg cls' (mkSelector "new") (retPtr retVoid) [] >>= ownedObject . castPtr

-- | Initialize an MPSGraph to insert nodes in.
--
-- ObjC selector: @- init@
init_ :: IsMPSGraph mpsGraph => mpsGraph -> IO (Id MPSGraph)
init_ mpsGraph  =
    sendMsg mpsGraph (mkSelector "init") (retPtr retVoid) [] >>= ownedObject . castPtr

-- | Compiles the graph for the given feeds to returns the target tensor values, ensuring all target operations would be executed.
--
-- This call blocks until execution has completed. The compilation descriptor helps specialize the executable returned.
--
-- - Parameters:   - device: MPSGraph device to optimize for.   - feeds: Feeds dictionary for the placeholder tensors.   - targetTensors: Tensors for which the caller wishes MPSGraphTensorData to be returned.   - targetOperations: Operations to be completed at the end of the run.   - compilationDescriptor: compilation descriptor to set different compilation parameters. - Returns: A valid MPSGraphExecutable object
--
-- ObjC selector: @- compileWithDevice:feeds:targetTensors:targetOperations:compilationDescriptor:@
compileWithDevice_feeds_targetTensors_targetOperations_compilationDescriptor :: (IsMPSGraph mpsGraph, IsMPSGraphDevice device, IsNSArray targetTensors, IsNSArray targetOperations, IsMPSGraphCompilationDescriptor compilationDescriptor) => mpsGraph -> device -> RawId -> targetTensors -> targetOperations -> compilationDescriptor -> IO (Id MPSGraphExecutable)
compileWithDevice_feeds_targetTensors_targetOperations_compilationDescriptor mpsGraph  device feeds targetTensors targetOperations compilationDescriptor =
  withObjCPtr device $ \raw_device ->
    withObjCPtr targetTensors $ \raw_targetTensors ->
      withObjCPtr targetOperations $ \raw_targetOperations ->
        withObjCPtr compilationDescriptor $ \raw_compilationDescriptor ->
            sendMsg mpsGraph (mkSelector "compileWithDevice:feeds:targetTensors:targetOperations:compilationDescriptor:") (retPtr retVoid) [argPtr (castPtr raw_device :: Ptr ()), argPtr (castPtr (unRawId feeds) :: Ptr ()), argPtr (castPtr raw_targetTensors :: Ptr ()), argPtr (castPtr raw_targetOperations :: Ptr ()), argPtr (castPtr raw_compilationDescriptor :: Ptr ())] >>= retainedObject . castPtr

-- | Runs the graph for the given feeds and returns the target tensor values, ensuring all target operations also executed.
--
-- This call blocks until execution has completed.
--
-- - Parameters:   - feeds: Feeds dictionary for the placeholder tensors.   - targetTensors: Tensors for which the caller wishes MPSGraphTensorData to be returned.   - targetOperations: Operations to be completed at the end of the run. - Returns: A valid MPSGraphTensor : MPSGraphTensorData dictionary with results synchronized to the CPU memory.
--
-- ObjC selector: @- runWithFeeds:targetTensors:targetOperations:@
runWithFeeds_targetTensors_targetOperations :: (IsMPSGraph mpsGraph, IsNSArray targetTensors, IsNSArray targetOperations) => mpsGraph -> RawId -> targetTensors -> targetOperations -> IO RawId
runWithFeeds_targetTensors_targetOperations mpsGraph  feeds targetTensors targetOperations =
  withObjCPtr targetTensors $ \raw_targetTensors ->
    withObjCPtr targetOperations $ \raw_targetOperations ->
        fmap (RawId . castPtr) $ sendMsg mpsGraph (mkSelector "runWithFeeds:targetTensors:targetOperations:") (retPtr retVoid) [argPtr (castPtr (unRawId feeds) :: Ptr ()), argPtr (castPtr raw_targetTensors :: Ptr ()), argPtr (castPtr raw_targetOperations :: Ptr ())]

-- | Runs the graph for the given feeds and returns the target tensor values, ensuring all target operations also executed.
--
-- This call blocks until execution has completed.
--
-- - Parameters:   - commandQueue: CommandQueue passed to exectute the graph on.   - feeds: Feeds dictionary for the placeholder tensors.   - targetTensors: Tensors for which the caller wishes MPSGraphTensorData to be returned.   - targetOperations: Operations to be completed at the end of the run. - Returns: A valid MPSGraphTensor : MPSGraphTensorData dictionary with results synchronized to the CPU memory.
--
-- ObjC selector: @- runWithMTLCommandQueue:feeds:targetTensors:targetOperations:@
runWithMTLCommandQueue_feeds_targetTensors_targetOperations :: (IsMPSGraph mpsGraph, IsNSArray targetTensors, IsNSArray targetOperations) => mpsGraph -> RawId -> RawId -> targetTensors -> targetOperations -> IO RawId
runWithMTLCommandQueue_feeds_targetTensors_targetOperations mpsGraph  commandQueue feeds targetTensors targetOperations =
  withObjCPtr targetTensors $ \raw_targetTensors ->
    withObjCPtr targetOperations $ \raw_targetOperations ->
        fmap (RawId . castPtr) $ sendMsg mpsGraph (mkSelector "runWithMTLCommandQueue:feeds:targetTensors:targetOperations:") (retPtr retVoid) [argPtr (castPtr (unRawId commandQueue) :: Ptr ()), argPtr (castPtr (unRawId feeds) :: Ptr ()), argPtr (castPtr raw_targetTensors :: Ptr ()), argPtr (castPtr raw_targetOperations :: Ptr ())]

-- | Runs the graph for the given feeds and returns the target tensor values in the results dictionary provided by the user.
--
-- It also ensures all target operations also executed. This call blocks until execution has completed.
--
-- - Parameters:   - commandQueue: CommandQueue passed to exectute the graph on.   - feeds: Feeds dictionary for the placeholder tensors.   - targetOperations: Operations to be completed at the end of the run.   - resultsDictionary: MPSGraphTensors dictionary passed by user, these will be filled with graph output data.
--
-- ObjC selector: @- runWithMTLCommandQueue:feeds:targetOperations:resultsDictionary:@
runWithMTLCommandQueue_feeds_targetOperations_resultsDictionary :: (IsMPSGraph mpsGraph, IsNSArray targetOperations) => mpsGraph -> RawId -> RawId -> targetOperations -> RawId -> IO ()
runWithMTLCommandQueue_feeds_targetOperations_resultsDictionary mpsGraph  commandQueue feeds targetOperations resultsDictionary =
  withObjCPtr targetOperations $ \raw_targetOperations ->
      sendMsg mpsGraph (mkSelector "runWithMTLCommandQueue:feeds:targetOperations:resultsDictionary:") retVoid [argPtr (castPtr (unRawId commandQueue) :: Ptr ()), argPtr (castPtr (unRawId feeds) :: Ptr ()), argPtr (castPtr raw_targetOperations :: Ptr ()), argPtr (castPtr (unRawId resultsDictionary) :: Ptr ())]

-- | Runs the graph for the given feeds and returns the target tensor values, ensuring all target operations also executed.
--
-- This call is asynchronous and will return immediately if a completionHandler is set.
--
-- - Parameters:   - feeds: Feeds dictionary for the placeholder tensors.   - targetTensors: Tensors for which the caller wishes MPSGraphTensorData to be returned.   - targetOperations: Operations to be completed at the end of the run.   - executionDescriptor: ExecutionDescriptor to be passed in and used. - Returns: A valid MPSGraphTensor : MPSGraphTensorData dictionary with results synchronized to the CPU memory.
--
-- ObjC selector: @- runAsyncWithFeeds:targetTensors:targetOperations:executionDescriptor:@
runAsyncWithFeeds_targetTensors_targetOperations_executionDescriptor :: (IsMPSGraph mpsGraph, IsNSArray targetTensors, IsNSArray targetOperations, IsMPSGraphExecutionDescriptor executionDescriptor) => mpsGraph -> RawId -> targetTensors -> targetOperations -> executionDescriptor -> IO RawId
runAsyncWithFeeds_targetTensors_targetOperations_executionDescriptor mpsGraph  feeds targetTensors targetOperations executionDescriptor =
  withObjCPtr targetTensors $ \raw_targetTensors ->
    withObjCPtr targetOperations $ \raw_targetOperations ->
      withObjCPtr executionDescriptor $ \raw_executionDescriptor ->
          fmap (RawId . castPtr) $ sendMsg mpsGraph (mkSelector "runAsyncWithFeeds:targetTensors:targetOperations:executionDescriptor:") (retPtr retVoid) [argPtr (castPtr (unRawId feeds) :: Ptr ()), argPtr (castPtr raw_targetTensors :: Ptr ()), argPtr (castPtr raw_targetOperations :: Ptr ()), argPtr (castPtr raw_executionDescriptor :: Ptr ())]

-- | Runs the graph for the given feeds and returns the target tensor values, ensuring all target operations also executed.
--
-- This call is asynchronous and will return immediately if a completionHandler is set.
--
-- - Parameters:   - commandQueue: CommandQueue passed to exectute the graph on.   - feeds: Feeds dictionary for the placeholder tensors.   - targetTensors: Tensors for which the caller wishes MPSGraphTensorData to be returned.   - targetOperations: Operations to be completed at the end of the run.   - executionDescriptor: ExecutionDescriptor to be passed in and used. - Returns: A valid MPSGraphTensor : MPSGraphTensorData dictionary with results synchronized to the CPU memory if MPSGraphOptionsSynchronizeResults set.
--
-- ObjC selector: @- runAsyncWithMTLCommandQueue:feeds:targetTensors:targetOperations:executionDescriptor:@
runAsyncWithMTLCommandQueue_feeds_targetTensors_targetOperations_executionDescriptor :: (IsMPSGraph mpsGraph, IsNSArray targetTensors, IsNSArray targetOperations, IsMPSGraphExecutionDescriptor executionDescriptor) => mpsGraph -> RawId -> RawId -> targetTensors -> targetOperations -> executionDescriptor -> IO RawId
runAsyncWithMTLCommandQueue_feeds_targetTensors_targetOperations_executionDescriptor mpsGraph  commandQueue feeds targetTensors targetOperations executionDescriptor =
  withObjCPtr targetTensors $ \raw_targetTensors ->
    withObjCPtr targetOperations $ \raw_targetOperations ->
      withObjCPtr executionDescriptor $ \raw_executionDescriptor ->
          fmap (RawId . castPtr) $ sendMsg mpsGraph (mkSelector "runAsyncWithMTLCommandQueue:feeds:targetTensors:targetOperations:executionDescriptor:") (retPtr retVoid) [argPtr (castPtr (unRawId commandQueue) :: Ptr ()), argPtr (castPtr (unRawId feeds) :: Ptr ()), argPtr (castPtr raw_targetTensors :: Ptr ()), argPtr (castPtr raw_targetOperations :: Ptr ()), argPtr (castPtr raw_executionDescriptor :: Ptr ())]

-- | Encodes the graph for the given feeds to returns the target tensor values in the results dictionary provided by the user.
--
-- It ensures all target operations also executed. This call is asynchronous and will return immediately if a completionHandler is set.
--
-- - Parameters:   - commandQueue: CommandQueue passed to exectute the graph on.   - feeds: Feeds dictionary for the placeholder tensors.   - targetOperations: Operations to be completed at the end of the run.   - resultsDictionary: MPSGraphTensors dictionary passed by user, these will be filled with graph output data.   - executionDescriptor: ExecutionDescriptor to be passed in and used.
--
-- ObjC selector: @- runAsyncWithMTLCommandQueue:feeds:targetOperations:resultsDictionary:executionDescriptor:@
runAsyncWithMTLCommandQueue_feeds_targetOperations_resultsDictionary_executionDescriptor :: (IsMPSGraph mpsGraph, IsNSArray targetOperations, IsMPSGraphExecutionDescriptor executionDescriptor) => mpsGraph -> RawId -> RawId -> targetOperations -> RawId -> executionDescriptor -> IO ()
runAsyncWithMTLCommandQueue_feeds_targetOperations_resultsDictionary_executionDescriptor mpsGraph  commandQueue feeds targetOperations resultsDictionary executionDescriptor =
  withObjCPtr targetOperations $ \raw_targetOperations ->
    withObjCPtr executionDescriptor $ \raw_executionDescriptor ->
        sendMsg mpsGraph (mkSelector "runAsyncWithMTLCommandQueue:feeds:targetOperations:resultsDictionary:executionDescriptor:") retVoid [argPtr (castPtr (unRawId commandQueue) :: Ptr ()), argPtr (castPtr (unRawId feeds) :: Ptr ()), argPtr (castPtr raw_targetOperations :: Ptr ()), argPtr (castPtr (unRawId resultsDictionary) :: Ptr ()), argPtr (castPtr raw_executionDescriptor :: Ptr ())]

-- | Encodes the graph for the given feeds to returns the target tensor values, ensuring all target operations also executed.
--
-- This call is asynchronous and will return immediately if a completionHandler is set.
--
-- - Parameters:   - commandBuffer: commandBuffer passed to exectute the graph on, it is an MPSCommandBuffer, commitAndContinue might be called, please don't rely on underlying MTLCommandBuffer to remain uncommitted.   - feeds: Feeds dictionary for the placeholder tensors.   - targetTensors: Tensors for which the caller wishes MPSGraphTensorData to be returned.   - targetOperations: Operations to be completed at the end of the run.   - executionDescriptor: ExecutionDescriptor to be passed in and used. - Returns: A valid MPSGraphTensor : MPSGraphTensorData dictionary with results synchronized to the CPU memory if MPSGraphOptionsSynchronizeResults set.
--
-- ObjC selector: @- encodeToCommandBuffer:feeds:targetTensors:targetOperations:executionDescriptor:@
encodeToCommandBuffer_feeds_targetTensors_targetOperations_executionDescriptor :: (IsMPSGraph mpsGraph, IsMPSCommandBuffer commandBuffer, IsNSArray targetTensors, IsNSArray targetOperations, IsMPSGraphExecutionDescriptor executionDescriptor) => mpsGraph -> commandBuffer -> RawId -> targetTensors -> targetOperations -> executionDescriptor -> IO RawId
encodeToCommandBuffer_feeds_targetTensors_targetOperations_executionDescriptor mpsGraph  commandBuffer feeds targetTensors targetOperations executionDescriptor =
  withObjCPtr commandBuffer $ \raw_commandBuffer ->
    withObjCPtr targetTensors $ \raw_targetTensors ->
      withObjCPtr targetOperations $ \raw_targetOperations ->
        withObjCPtr executionDescriptor $ \raw_executionDescriptor ->
            fmap (RawId . castPtr) $ sendMsg mpsGraph (mkSelector "encodeToCommandBuffer:feeds:targetTensors:targetOperations:executionDescriptor:") (retPtr retVoid) [argPtr (castPtr raw_commandBuffer :: Ptr ()), argPtr (castPtr (unRawId feeds) :: Ptr ()), argPtr (castPtr raw_targetTensors :: Ptr ()), argPtr (castPtr raw_targetOperations :: Ptr ()), argPtr (castPtr raw_executionDescriptor :: Ptr ())]

-- | Encodes the graph for the given feeds to returns the target tensor values in the results dictionary provided by the user.
--
-- It ensures all target operations also executed. This call is asynchronous and will return immediately if a completionHandler is set.
--
-- - Parameters:   - commandBuffer: commandBuffer passed to execute the graph on, commitAndContinue might be called, please don't rely on underlying MTLCommandBuffer to remain uncommitted.   - feeds: Feeds dictionary for the placeholder tensors.   - targetOperations: Operations to be completed at the end of the run.   - resultsDictionary: MPSGraphTensors dictionary passed by user, these will be filled with graph output data.   - executionDescriptor: ExecutionDescriptor to be passed in and used.
--
-- ObjC selector: @- encodeToCommandBuffer:feeds:targetOperations:resultsDictionary:executionDescriptor:@
encodeToCommandBuffer_feeds_targetOperations_resultsDictionary_executionDescriptor :: (IsMPSGraph mpsGraph, IsMPSCommandBuffer commandBuffer, IsNSArray targetOperations, IsMPSGraphExecutionDescriptor executionDescriptor) => mpsGraph -> commandBuffer -> RawId -> targetOperations -> RawId -> executionDescriptor -> IO ()
encodeToCommandBuffer_feeds_targetOperations_resultsDictionary_executionDescriptor mpsGraph  commandBuffer feeds targetOperations resultsDictionary executionDescriptor =
  withObjCPtr commandBuffer $ \raw_commandBuffer ->
    withObjCPtr targetOperations $ \raw_targetOperations ->
      withObjCPtr executionDescriptor $ \raw_executionDescriptor ->
          sendMsg mpsGraph (mkSelector "encodeToCommandBuffer:feeds:targetOperations:resultsDictionary:executionDescriptor:") retVoid [argPtr (castPtr raw_commandBuffer :: Ptr ()), argPtr (castPtr (unRawId feeds) :: Ptr ()), argPtr (castPtr raw_targetOperations :: Ptr ()), argPtr (castPtr (unRawId resultsDictionary) :: Ptr ()), argPtr (castPtr raw_executionDescriptor :: Ptr ())]

-- | Creates a TopKGradient operation and returns the result tensor.
--
-- Finds the K largest values along the minor dimension of the input. The input must have at least K elements along its minor dimension.
--
-- - Parameters:   - gradient: Tensor containing the incoming gradient.   - source: Tensor containing source data.   - k: The number of largest values to return.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- topKWithGradientTensor:source:k:name:@
topKWithGradientTensor_source_k_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor gradient, IsMPSGraphTensor source, IsNSString name) => mpsGraph -> gradient -> source -> CULong -> name -> IO (Id MPSGraphTensor)
topKWithGradientTensor_source_k_name mpsGraph  gradient source k name =
  withObjCPtr gradient $ \raw_gradient ->
    withObjCPtr source $ \raw_source ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "topKWithGradientTensor:source:k:name:") (retPtr retVoid) [argPtr (castPtr raw_gradient :: Ptr ()), argPtr (castPtr raw_source :: Ptr ()), argCULong k, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a TopKGradient operation and returns the result tensor.
--
-- Finds the K largest values along the minor dimension of the input. The input must have at least K elements along its minor dimension.
--
-- - Parameters:   - gradient: Tensor containing the incoming gradient.   - source: Tensor containing source data.   - axis: The dimension along which to compute the TopK values..   - k: The number of largest values to return.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- topKWithGradientTensor:source:axis:k:name:@
topKWithGradientTensor_source_axis_k_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor gradient, IsMPSGraphTensor source, IsNSString name) => mpsGraph -> gradient -> source -> CLong -> CULong -> name -> IO (Id MPSGraphTensor)
topKWithGradientTensor_source_axis_k_name mpsGraph  gradient source axis k name =
  withObjCPtr gradient $ \raw_gradient ->
    withObjCPtr source $ \raw_source ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "topKWithGradientTensor:source:axis:k:name:") (retPtr retVoid) [argPtr (castPtr raw_gradient :: Ptr ()), argPtr (castPtr raw_source :: Ptr ()), argCLong axis, argCULong k, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a BottomKGradient operation and returns the result tensor.
--
-- Finds the K smallest values along the minor dimension of the input. The input must have at least K elements along its minor dimension.
--
-- - Parameters:   - gradient: Tensor containing the incoming gradient.   - source: Tensor containing source data.   - axis: The dimension along which to compute the BottomK values.   - k: The number of largest values to return.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- bottomKWithGradientTensor:source:axis:k:name:@
bottomKWithGradientTensor_source_axis_k_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor gradient, IsMPSGraphTensor source, IsNSString name) => mpsGraph -> gradient -> source -> CLong -> CULong -> name -> IO (Id MPSGraphTensor)
bottomKWithGradientTensor_source_axis_k_name mpsGraph  gradient source axis k name =
  withObjCPtr gradient $ \raw_gradient ->
    withObjCPtr source $ \raw_source ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "bottomKWithGradientTensor:source:axis:k:name:") (retPtr retVoid) [argPtr (castPtr raw_gradient :: Ptr ()), argPtr (castPtr raw_source :: Ptr ()), argCLong axis, argCULong k, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a TopKGradient operation and returns the result tensor.
--
-- Finds the K largest values along the minor dimension of the input. The input must have at least K elements along its minor dimension.
--
-- - Parameters:   - gradient: Tensor containing the incoming gradient.   - source: Tensor containing source data.   - kTensor: Tensor of the number of largest values to return.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- topKWithGradientTensor:source:kTensor:name:@
topKWithGradientTensor_source_kTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor gradient, IsMPSGraphTensor source, IsMPSGraphTensor kTensor, IsNSString name) => mpsGraph -> gradient -> source -> kTensor -> name -> IO (Id MPSGraphTensor)
topKWithGradientTensor_source_kTensor_name mpsGraph  gradient source kTensor name =
  withObjCPtr gradient $ \raw_gradient ->
    withObjCPtr source $ \raw_source ->
      withObjCPtr kTensor $ \raw_kTensor ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "topKWithGradientTensor:source:kTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_gradient :: Ptr ()), argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_kTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a TopKGradient operation and returns the result tensor.
--
-- Finds the K largest values along the minor dimension of the input. The input must have at least K elements along its minor dimension.
--
-- - Parameters:   - gradient: Tensor containing the incoming gradient.   - source: Tensor containing source data.   - axisTensor: Tensor containing the dimension along which to compute the TopK values.   - kTensor: Tensor of the number of largest values to return.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- topKWithGradientTensor:source:axisTensor:kTensor:name:@
topKWithGradientTensor_source_axisTensor_kTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor gradient, IsMPSGraphTensor source, IsMPSGraphTensor axisTensor, IsMPSGraphTensor kTensor, IsNSString name) => mpsGraph -> gradient -> source -> axisTensor -> kTensor -> name -> IO (Id MPSGraphTensor)
topKWithGradientTensor_source_axisTensor_kTensor_name mpsGraph  gradient source axisTensor kTensor name =
  withObjCPtr gradient $ \raw_gradient ->
    withObjCPtr source $ \raw_source ->
      withObjCPtr axisTensor $ \raw_axisTensor ->
        withObjCPtr kTensor $ \raw_kTensor ->
          withObjCPtr name $ \raw_name ->
              sendMsg mpsGraph (mkSelector "topKWithGradientTensor:source:axisTensor:kTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_gradient :: Ptr ()), argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_axisTensor :: Ptr ()), argPtr (castPtr raw_kTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a BottomKGradient operation and returns the result tensor.
--
-- Finds the K smallest values along the minor dimension of the input. The input must have at least K elements along its minor dimension.
--
-- - Parameters:   - gradient: Tensor containing the incoming gradient.   - source: Tensor containing source data.   - axisTensor: Tensor containing the dimension along which to compute the BottomK values.   - kTensor: Tensor of the number of largest values to return.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- bottomKWithGradientTensor:source:axisTensor:kTensor:name:@
bottomKWithGradientTensor_source_axisTensor_kTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor gradient, IsMPSGraphTensor source, IsMPSGraphTensor axisTensor, IsMPSGraphTensor kTensor, IsNSString name) => mpsGraph -> gradient -> source -> axisTensor -> kTensor -> name -> IO (Id MPSGraphTensor)
bottomKWithGradientTensor_source_axisTensor_kTensor_name mpsGraph  gradient source axisTensor kTensor name =
  withObjCPtr gradient $ \raw_gradient ->
    withObjCPtr source $ \raw_source ->
      withObjCPtr axisTensor $ \raw_axisTensor ->
        withObjCPtr kTensor $ \raw_kTensor ->
          withObjCPtr name $ \raw_name ->
              sendMsg mpsGraph (mkSelector "bottomKWithGradientTensor:source:axisTensor:kTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_gradient :: Ptr ()), argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_axisTensor :: Ptr ()), argPtr (castPtr raw_kTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a TopK operation and returns the value and indices tensors
--
-- Finds the k largest values along the minor dimension of the input. The source must have  at least k elements along its minor dimension.  The first element of the result array corresponds to the top values, and the second element of the result array corresponds to the indices of the top values.
--
-- - Parameters:   - source: Tensor containing source data   - k: The number of largest values to return   - name: The name for the operation. - Returns: A valid MPSGraphTensor array of size 2
--
-- ObjC selector: @- topKWithSourceTensor:k:name:@
topKWithSourceTensor_k_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor source, IsNSString name) => mpsGraph -> source -> CULong -> name -> IO (Id NSArray)
topKWithSourceTensor_k_name mpsGraph  source k name =
  withObjCPtr source $ \raw_source ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "topKWithSourceTensor:k:name:") (retPtr retVoid) [argPtr (castPtr raw_source :: Ptr ()), argCULong k, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a TopK operation and returns the result tensor.
--
-- Finds the k largest values along the minor dimension of the input. The source must have  at least k elements along its minor dimension.  The first element of the result array corresponds to the top values, and the second element of the result array corresponds to the indices of the top values.
--
-- - Parameters:   - source: Tensor containing source data.   - kTensor: Tensor of the number of largest values to return.   - name: The name for the operation. - Returns: A valid MPSGraphTensor array of size 2.
--
-- ObjC selector: @- topKWithSourceTensor:kTensor:name:@
topKWithSourceTensor_kTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor source, IsMPSGraphTensor kTensor, IsNSString name) => mpsGraph -> source -> kTensor -> name -> IO (Id NSArray)
topKWithSourceTensor_kTensor_name mpsGraph  source kTensor name =
  withObjCPtr source $ \raw_source ->
    withObjCPtr kTensor $ \raw_kTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "topKWithSourceTensor:kTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_kTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a TopK operation and returns the value and indices tensors.
--
-- Finds the k largest values along the minor dimension of the input. The source must have at least k elements along its minor dimension. The first element of the result array corresponds to the top values, and the second array corresponds to the indices of the top values.
--
-- - Parameters:   - source: Tensor containing source data.   - axis: The dimension along which to compute the TopK values.   - k: The number of largest values to return.   - name: The name for the operation. - Returns: A valid MPSGraphTensor array of size 2.
--
-- ObjC selector: @- topKWithSourceTensor:axis:k:name:@
topKWithSourceTensor_axis_k_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor source, IsNSString name) => mpsGraph -> source -> CLong -> CULong -> name -> IO (Id NSArray)
topKWithSourceTensor_axis_k_name mpsGraph  source axis k name =
  withObjCPtr source $ \raw_source ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "topKWithSourceTensor:axis:k:name:") (retPtr retVoid) [argPtr (castPtr raw_source :: Ptr ()), argCLong axis, argCULong k, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a BottomK operation and returns the value and indices tensors.
--
-- Finds the k smallest values along the minor dimension of the input. The source must have at least k elements along its minor dimension. The first element of the result array corresponds to the bottom values, and the second array corresponds to the indices of the bottom values.
--
-- - Parameters:   - source: Tensor containing source data.   - axis: The dimension along which to compute the BottomK values.   - k: The number of largest values to return.   - name: The name for the operation. - Returns: A valid MPSGraphTensor array of size 2.
--
-- ObjC selector: @- bottomKWithSourceTensor:axis:k:name:@
bottomKWithSourceTensor_axis_k_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor source, IsNSString name) => mpsGraph -> source -> CLong -> CULong -> name -> IO (Id NSArray)
bottomKWithSourceTensor_axis_k_name mpsGraph  source axis k name =
  withObjCPtr source $ \raw_source ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "bottomKWithSourceTensor:axis:k:name:") (retPtr retVoid) [argPtr (castPtr raw_source :: Ptr ()), argCLong axis, argCULong k, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a TopK operation and returns the result tensor.
--
-- Finds the k largest values along the minor dimension of the input. The source must have at least k elements along its minor dimension. The first element of the result array corresponds to the top values, and the second array corresponds to the indices of the top values.
--
-- - Parameters:   - source: Tensor containing source data.   - axisTensor: Tensor containing the dimension along which to compute the TopK values.   - kTensor: Tensor of the number of largest values to return.   - name: The name for the operation. - Returns: A valid MPSGraphTensor array of size 2.
--
-- ObjC selector: @- topKWithSourceTensor:axisTensor:kTensor:name:@
topKWithSourceTensor_axisTensor_kTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor source, IsMPSGraphTensor axisTensor, IsMPSGraphTensor kTensor, IsNSString name) => mpsGraph -> source -> axisTensor -> kTensor -> name -> IO (Id NSArray)
topKWithSourceTensor_axisTensor_kTensor_name mpsGraph  source axisTensor kTensor name =
  withObjCPtr source $ \raw_source ->
    withObjCPtr axisTensor $ \raw_axisTensor ->
      withObjCPtr kTensor $ \raw_kTensor ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "topKWithSourceTensor:axisTensor:kTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_axisTensor :: Ptr ()), argPtr (castPtr raw_kTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a BottomK operation and returns the result tensor.
--
-- Finds the k smallest values along the minor dimension of the input. The source must have at least k elements along its minor dimension. The first element of the result array corresponds to the bottom values, and the second array corresponds to the indices of the bottom values.
--
-- - Parameters:   - source: Tensor containing source data.   - axisTensor: Tensor containing the dimension along which to compute the BottomK values.   - kTensor: Tensor of the number of largest values to return.   - name: The name for the operation. - Returns: A valid MPSGraphTensor array of size 2.
--
-- ObjC selector: @- bottomKWithSourceTensor:axisTensor:kTensor:name:@
bottomKWithSourceTensor_axisTensor_kTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor source, IsMPSGraphTensor axisTensor, IsMPSGraphTensor kTensor, IsNSString name) => mpsGraph -> source -> axisTensor -> kTensor -> name -> IO (Id NSArray)
bottomKWithSourceTensor_axisTensor_kTensor_name mpsGraph  source axisTensor kTensor name =
  withObjCPtr source $ \raw_source ->
    withObjCPtr axisTensor $ \raw_axisTensor ->
      withObjCPtr kTensor $ \raw_kTensor ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "bottomKWithSourceTensor:axisTensor:kTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_axisTensor :: Ptr ()), argPtr (castPtr raw_kTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a reshape operation and returns the result tensor.
--
-- This operation reshapes the input tensor to the target shape. The shape must be compatible with the input tensor shape, specifically the volume of the input tensor has to match the volume defined by the shape. The shape is allowed to contain dynamic dimensions (-1) when the result type can be inferred unambiguously.
--
-- - Parameters:   - tensor: The tensor to be reshaped.   - shape: The result tensor shape.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- reshapeTensor:withShape:name:@
reshapeTensor_withShape_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> RawId -> name -> IO (Id MPSGraphTensor)
reshapeTensor_withShape_name mpsGraph  tensor shape name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "reshapeTensor:withShape:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr (unRawId shape) :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a reshape operation and returns the result tensor.
--
-- This operation reshapes the input tensor to the target shape. The shape tensor must be compatible with the input tensor shape, specifically the volume of the input tensor has to match the volume defined by the shape tensor. The shape tensor is allowed to contain dynamic dimensions (-1) when the result type can be inferred unambiguously.
--
-- - Parameters:   - tensor: The tensor to be reshaped.   - shapeTensor: A 1D tensor of type @MPSDataTypeInt32@ or @MPSDataTypeInt64@, that contains the target shape values.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- reshapeTensor:withShapeTensor:name:@
reshapeTensor_withShapeTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsMPSGraphTensor shapeTensor, IsNSString name) => mpsGraph -> tensor -> shapeTensor -> name -> IO (Id MPSGraphTensor)
reshapeTensor_withShapeTensor_name mpsGraph  tensor shapeTensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr shapeTensor $ \raw_shapeTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "reshapeTensor:withShapeTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_shapeTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a transpose operation and returns the result tensor.
--
-- Transposes the dimensions @dimensionIndex@ and @dimensionIndex2@ of the input tensor.
--
-- - Parameters:   - tensor: The tensor to be transposed.   - dimensionIndex: The first dimension index to be transposed.   - dimensionIndex2: The second dimension index to be transposed.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- transposeTensor:dimension:withDimension:name:@
transposeTensor_dimension_withDimension_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> CULong -> CULong -> name -> IO (Id MPSGraphTensor)
transposeTensor_dimension_withDimension_name mpsGraph  tensor dimensionIndex dimensionIndex2 name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "transposeTensor:dimension:withDimension:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argCULong dimensionIndex, argCULong dimensionIndex2, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a permutation operation and returns the result tensor.
--
-- Permutes the dimensions of the input tensor according to values in @permutation@.
--
-- - Parameters:   - tensor: The tensor to be permuted.   - permutation: An array of numbers defining the permutation, must be of length @rank(tensor)@ and define a valid permutation.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- transposeTensor:permutation:name:@
transposeTensor_permutation_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSArray permutation, IsNSString name) => mpsGraph -> tensor -> permutation -> name -> IO (Id MPSGraphTensor)
transposeTensor_permutation_name mpsGraph  tensor permutation name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr permutation $ \raw_permutation ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "transposeTensor:permutation:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_permutation :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a slice operation and returns the result tensor.
--
-- - Parameters:   - tensor: The tensor to be sliced.   - dimensionIndex: The dimension to slice.   - start: The starting index of the slice, can be negative to count from the end of the tensor dimension.   - length: The length of the slice.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- sliceTensor:dimension:start:length:name:@
sliceTensor_dimension_start_length_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> CULong -> CLong -> CLong -> name -> IO (Id MPSGraphTensor)
sliceTensor_dimension_start_length_name mpsGraph  tensor dimensionIndex start length_ name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "sliceTensor:dimension:start:length:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argCULong dimensionIndex, argCLong start, argCLong length_, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a strided-slice operation and returns the result tensor.
--
-- Slices a tensor starting from @starts@, stopping short before @ends@ stepping @strides@ paces between each value. Semantics based on [TensorFlow Strided Slice Op](https://www.tensorflow.org/api_docs/python/tf/strided_slice).
--
-- - Parameters:   - tensor: The tensor to be sliced.   - starts: An array of numbers that specify the starting points for each dimension.   - ends: An array of numbers that specify the ending points for each dimension.   - strides: An array of numbers that specify the strides for each dimension.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- sliceTensor:starts:ends:strides:name:@
sliceTensor_starts_ends_strides_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSArray starts, IsNSArray ends, IsNSArray strides, IsNSString name) => mpsGraph -> tensor -> starts -> ends -> strides -> name -> IO (Id MPSGraphTensor)
sliceTensor_starts_ends_strides_name mpsGraph  tensor starts ends strides name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr starts $ \raw_starts ->
      withObjCPtr ends $ \raw_ends ->
        withObjCPtr strides $ \raw_strides ->
          withObjCPtr name $ \raw_name ->
              sendMsg mpsGraph (mkSelector "sliceTensor:starts:ends:strides:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_starts :: Ptr ()), argPtr (castPtr raw_ends :: Ptr ()), argPtr (castPtr raw_strides :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a strided-slice operation and returns the result tensor.
--
-- Slices a tensor starting from @starts@, stopping short before @ends@ stepping @strides@ paces between each value. Semantics based on [TensorFlow Strided Slice Op](https://www.tensorflow.org/api_docs/python/tf/strided_slice).
--
-- - Parameters:   - tensor: The Tensor to be sliced.   - starts: An array of numbers that specify the starting points for each dimension.   - ends: An array of numbers that specify the ending points for each dimension.   - strides: An array of numbers that specify the strides for each dimension.   - startMask: A bitmask that indicates dimensions whose @starts@ values the operation should ignore.   - endMask: A bitmask that indicates dimensions whose @ends@ values the operation should ignore.   - squeezeMask: A bitmask that indicates dimensions the operation will squeeze out from the result.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- sliceTensor:starts:ends:strides:startMask:endMask:squeezeMask:name:@
sliceTensor_starts_ends_strides_startMask_endMask_squeezeMask_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSArray starts, IsNSArray ends, IsNSArray strides, IsNSString name) => mpsGraph -> tensor -> starts -> ends -> strides -> CUInt -> CUInt -> CUInt -> name -> IO (Id MPSGraphTensor)
sliceTensor_starts_ends_strides_startMask_endMask_squeezeMask_name mpsGraph  tensor starts ends strides startMask endMask squeezeMask name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr starts $ \raw_starts ->
      withObjCPtr ends $ \raw_ends ->
        withObjCPtr strides $ \raw_strides ->
          withObjCPtr name $ \raw_name ->
              sendMsg mpsGraph (mkSelector "sliceTensor:starts:ends:strides:startMask:endMask:squeezeMask:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_starts :: Ptr ()), argPtr (castPtr raw_ends :: Ptr ()), argPtr (castPtr raw_strides :: Ptr ()), argCUInt startMask, argCUInt endMask, argCUInt squeezeMask, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a strided-slice operation and returns the result tensor.
--
-- Slices a tensor starting from @startTensor@, stopping short before @endTensor@ stepping @strideTensor@ paces between each value. Semantics based on [TensorFlow Strided Slice Op](https://www.tensorflow.org/api_docs/python/tf/strided_slice).
--
-- - Parameters:   - tensor: The Tensor to be sliced.   - startTensor: The tensor that specifies the starting points for each dimension.   - endTensor: The tensor that specifies the ending points for each dimension.   - strideTensor: The tensor that specifies the strides for each dimension.   - startMask: A bitmask that indicates dimensions whose @starts@ values the operation should ignore.   - endMask: A bitmask that indicates dimensions whose @ends@ values the operation should ignore.   - squeezeMask: A bitmask that indicates dimensions the operation will squeeze out from the result.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- sliceTensor:startTensor:endTensor:strideTensor:startMask:endMask:squeezeMask:name:@
sliceTensor_startTensor_endTensor_strideTensor_startMask_endMask_squeezeMask_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsMPSGraphTensor startTensor, IsMPSGraphTensor endTensor, IsMPSGraphTensor strideTensor, IsNSString name) => mpsGraph -> tensor -> startTensor -> endTensor -> strideTensor -> CUInt -> CUInt -> CUInt -> name -> IO (Id MPSGraphTensor)
sliceTensor_startTensor_endTensor_strideTensor_startMask_endMask_squeezeMask_name mpsGraph  tensor startTensor endTensor strideTensor startMask endMask squeezeMask name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr startTensor $ \raw_startTensor ->
      withObjCPtr endTensor $ \raw_endTensor ->
        withObjCPtr strideTensor $ \raw_strideTensor ->
          withObjCPtr name $ \raw_name ->
              sendMsg mpsGraph (mkSelector "sliceTensor:startTensor:endTensor:strideTensor:startMask:endMask:squeezeMask:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_startTensor :: Ptr ()), argPtr (castPtr raw_endTensor :: Ptr ()), argPtr (castPtr raw_strideTensor :: Ptr ()), argCUInt startMask, argCUInt endMask, argCUInt squeezeMask, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a slice operation and returns the result tensor.
--
-- Slices a tensor starting from @startTensor@, stopping short before @startTensor + endTensor@ stepping a single pace between each value. Semantics based on [TensorFlow Strided Slice Op](https://www.tensorflow.org/api_docs/python/tf/strided_slice).
--
-- - Parameters:   - tensor: The Tensor to be sliced.   - startTensor: The tensor that specifies the starting points for each dimension.   - sizeTensor: The tensor that specifies the size of the result for each dimension.   - squeezeMask: A bitmask that indicates dimensions the operation will squeeze out from the result.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- sliceTensor:startTensor:sizeTensor:squeezeMask:name:@
sliceTensor_startTensor_sizeTensor_squeezeMask_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsMPSGraphTensor startTensor, IsMPSGraphTensor sizeTensor, IsNSString name) => mpsGraph -> tensor -> startTensor -> sizeTensor -> CUInt -> name -> IO (Id MPSGraphTensor)
sliceTensor_startTensor_sizeTensor_squeezeMask_name mpsGraph  tensor startTensor sizeTensor squeezeMask name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr startTensor $ \raw_startTensor ->
      withObjCPtr sizeTensor $ \raw_sizeTensor ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "sliceTensor:startTensor:sizeTensor:squeezeMask:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_startTensor :: Ptr ()), argPtr (castPtr raw_sizeTensor :: Ptr ()), argCUInt squeezeMask, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a strided-slice gradient operation and returns the result tensor.
--
-- - Parameters:   - inputGradientTensor: The input gradient.   - fwdInShapeTensor: The shape of the forward pass input, that is the shape of the gradient output.   - starts: An array of numbers that specify the starting points for each dimension.   - ends: An array of numbers that specify the ending points for each dimension.   - strides: An array of numbers that specify the strides for each dimension.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- sliceGradientTensor:fwdInShapeTensor:starts:ends:strides:name:@
sliceGradientTensor_fwdInShapeTensor_starts_ends_strides_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor inputGradientTensor, IsMPSGraphTensor fwdInShapeTensor, IsNSArray starts, IsNSArray ends, IsNSArray strides, IsNSString name) => mpsGraph -> inputGradientTensor -> fwdInShapeTensor -> starts -> ends -> strides -> name -> IO (Id MPSGraphTensor)
sliceGradientTensor_fwdInShapeTensor_starts_ends_strides_name mpsGraph  inputGradientTensor fwdInShapeTensor starts ends strides name =
  withObjCPtr inputGradientTensor $ \raw_inputGradientTensor ->
    withObjCPtr fwdInShapeTensor $ \raw_fwdInShapeTensor ->
      withObjCPtr starts $ \raw_starts ->
        withObjCPtr ends $ \raw_ends ->
          withObjCPtr strides $ \raw_strides ->
            withObjCPtr name $ \raw_name ->
                sendMsg mpsGraph (mkSelector "sliceGradientTensor:fwdInShapeTensor:starts:ends:strides:name:") (retPtr retVoid) [argPtr (castPtr raw_inputGradientTensor :: Ptr ()), argPtr (castPtr raw_fwdInShapeTensor :: Ptr ()), argPtr (castPtr raw_starts :: Ptr ()), argPtr (castPtr raw_ends :: Ptr ()), argPtr (castPtr raw_strides :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a strided-slice gradient operation and returns the result tensor.
--
-- - Parameters:   - inputGradientTensor: The input gradient.   - fwdInShapeTensor: The shape of the forward pass input, that is the shape of the gradient output.   - startTensor: The tensor that specifies the starting points for each dimension.   - endTensor: The tensor that specifies the ending points for each dimension.   - strideTensor: The tensor that specifies the strides for each dimension.   - startMask: A bitmask that indicates dimensions whose @starts@ values the operation should ignore.   - endMask: A bitmask that indicates dimensions whose @ends@ values the operation should ignore.   - squeezeMask: A bitmask that indicates dimensions the operation will squeeze out from the result.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- sliceGradientTensor:fwdInShapeTensor:startTensor:endTensor:strideTensor:startMask:endMask:squeezeMask:name:@
sliceGradientTensor_fwdInShapeTensor_startTensor_endTensor_strideTensor_startMask_endMask_squeezeMask_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor inputGradientTensor, IsMPSGraphTensor fwdInShapeTensor, IsMPSGraphTensor startTensor, IsMPSGraphTensor endTensor, IsMPSGraphTensor strideTensor, IsNSString name) => mpsGraph -> inputGradientTensor -> fwdInShapeTensor -> startTensor -> endTensor -> strideTensor -> CUInt -> CUInt -> CUInt -> name -> IO (Id MPSGraphTensor)
sliceGradientTensor_fwdInShapeTensor_startTensor_endTensor_strideTensor_startMask_endMask_squeezeMask_name mpsGraph  inputGradientTensor fwdInShapeTensor startTensor endTensor strideTensor startMask endMask squeezeMask name =
  withObjCPtr inputGradientTensor $ \raw_inputGradientTensor ->
    withObjCPtr fwdInShapeTensor $ \raw_fwdInShapeTensor ->
      withObjCPtr startTensor $ \raw_startTensor ->
        withObjCPtr endTensor $ \raw_endTensor ->
          withObjCPtr strideTensor $ \raw_strideTensor ->
            withObjCPtr name $ \raw_name ->
                sendMsg mpsGraph (mkSelector "sliceGradientTensor:fwdInShapeTensor:startTensor:endTensor:strideTensor:startMask:endMask:squeezeMask:name:") (retPtr retVoid) [argPtr (castPtr raw_inputGradientTensor :: Ptr ()), argPtr (castPtr raw_fwdInShapeTensor :: Ptr ()), argPtr (castPtr raw_startTensor :: Ptr ()), argPtr (castPtr raw_endTensor :: Ptr ()), argPtr (castPtr raw_strideTensor :: Ptr ()), argCUInt startMask, argCUInt endMask, argCUInt squeezeMask, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a slice gradient operation and returns the result tensor.
--
-- - Parameters:   - inputGradientTensor: The input gradient.   - fwdInShapeTensor: The shape of the forward pass input, that is the shape of the gradient output.   - startTensor: The tensor that specifies the starting points for each dimension.   - sizeTensor: The tensor that specifies the size of the forward result for each dimension.   - squeezeMask: A bitmask that indicates dimensions the operation will squeeze out from the result.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- sliceGradientTensor:fwdInShapeTensor:startTensor:sizeTensor:squeezeMask:name:@
sliceGradientTensor_fwdInShapeTensor_startTensor_sizeTensor_squeezeMask_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor inputGradientTensor, IsMPSGraphTensor fwdInShapeTensor, IsMPSGraphTensor startTensor, IsMPSGraphTensor sizeTensor, IsNSString name) => mpsGraph -> inputGradientTensor -> fwdInShapeTensor -> startTensor -> sizeTensor -> CUInt -> name -> IO (Id MPSGraphTensor)
sliceGradientTensor_fwdInShapeTensor_startTensor_sizeTensor_squeezeMask_name mpsGraph  inputGradientTensor fwdInShapeTensor startTensor sizeTensor squeezeMask name =
  withObjCPtr inputGradientTensor $ \raw_inputGradientTensor ->
    withObjCPtr fwdInShapeTensor $ \raw_fwdInShapeTensor ->
      withObjCPtr startTensor $ \raw_startTensor ->
        withObjCPtr sizeTensor $ \raw_sizeTensor ->
          withObjCPtr name $ \raw_name ->
              sendMsg mpsGraph (mkSelector "sliceGradientTensor:fwdInShapeTensor:startTensor:sizeTensor:squeezeMask:name:") (retPtr retVoid) [argPtr (castPtr raw_inputGradientTensor :: Ptr ()), argPtr (castPtr raw_fwdInShapeTensor :: Ptr ()), argPtr (castPtr raw_startTensor :: Ptr ()), argPtr (castPtr raw_sizeTensor :: Ptr ()), argCUInt squeezeMask, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a strided-slice gradient operation and returns the result tensor.
--
-- - Parameters:   - inputGradientTensor: The input gradient.   - fwdInShapeTensor: The shape of the forward pass input, that is the shape of the gradient output.   - starts: An array of numbers that specify the starting points for each dimension.   - ends: An array of numbers that specify the ending points for each dimension.   - strides: An array of numbers that specify the strides for each dimension.   - startMask: A bitmask that indicates dimensions whose @starts@ values the operation should ignore.   - endMask: A bitmask that indicates dimensions whose @ends@ values the operation should ignore.   - squeezeMask: A bitmask that indicates dimensions the operation will squeeze out from the result.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- sliceGradientTensor:fwdInShapeTensor:starts:ends:strides:startMask:endMask:squeezeMask:name:@
sliceGradientTensor_fwdInShapeTensor_starts_ends_strides_startMask_endMask_squeezeMask_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor inputGradientTensor, IsMPSGraphTensor fwdInShapeTensor, IsNSArray starts, IsNSArray ends, IsNSArray strides, IsNSString name) => mpsGraph -> inputGradientTensor -> fwdInShapeTensor -> starts -> ends -> strides -> CUInt -> CUInt -> CUInt -> name -> IO (Id MPSGraphTensor)
sliceGradientTensor_fwdInShapeTensor_starts_ends_strides_startMask_endMask_squeezeMask_name mpsGraph  inputGradientTensor fwdInShapeTensor starts ends strides startMask endMask squeezeMask name =
  withObjCPtr inputGradientTensor $ \raw_inputGradientTensor ->
    withObjCPtr fwdInShapeTensor $ \raw_fwdInShapeTensor ->
      withObjCPtr starts $ \raw_starts ->
        withObjCPtr ends $ \raw_ends ->
          withObjCPtr strides $ \raw_strides ->
            withObjCPtr name $ \raw_name ->
                sendMsg mpsGraph (mkSelector "sliceGradientTensor:fwdInShapeTensor:starts:ends:strides:startMask:endMask:squeezeMask:name:") (retPtr retVoid) [argPtr (castPtr raw_inputGradientTensor :: Ptr ()), argPtr (castPtr raw_fwdInShapeTensor :: Ptr ()), argPtr (castPtr raw_starts :: Ptr ()), argPtr (castPtr raw_ends :: Ptr ()), argPtr (castPtr raw_strides :: Ptr ()), argCUInt startMask, argCUInt endMask, argCUInt squeezeMask, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a strided-slice update operation and returns the result tensor.
--
-- - Parameters:   - dataTensor: The large tensor that will receive the update.   - updateTensor: The tensor with the new values that will replace values in the dataTensor.   - startsTensor: A Tensor that contains an array of numbers that specify the starting points for each dimension.   - endsTensor: A Tensor that contains an array of numbers that specify the ending points for each dimension.   - stridesTensor: A Tensor that contains an array of numbers that specify the strides for each dimension.   - startMask: A bitmask that indicates dimensions whose @starts@ values the operation should ignore.   - endMask: A bitmask that indicates dimensions whose @ends@ values the operation should ignore.   - squeezeMask: A bitmask that indicates dimensions the operation will squeeze out from the result.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- sliceUpdateDataTensor:updateTensor:startsTensor:endsTensor:stridesTensor:startMask:endMask:squeezeMask:name:@
sliceUpdateDataTensor_updateTensor_startsTensor_endsTensor_stridesTensor_startMask_endMask_squeezeMask_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor dataTensor, IsMPSGraphTensor updateTensor, IsMPSGraphTensor startsTensor, IsMPSGraphTensor endsTensor, IsMPSGraphTensor stridesTensor, IsNSString name) => mpsGraph -> dataTensor -> updateTensor -> startsTensor -> endsTensor -> stridesTensor -> CUInt -> CUInt -> CUInt -> name -> IO (Id MPSGraphTensor)
sliceUpdateDataTensor_updateTensor_startsTensor_endsTensor_stridesTensor_startMask_endMask_squeezeMask_name mpsGraph  dataTensor updateTensor startsTensor endsTensor stridesTensor startMask endMask squeezeMask name =
  withObjCPtr dataTensor $ \raw_dataTensor ->
    withObjCPtr updateTensor $ \raw_updateTensor ->
      withObjCPtr startsTensor $ \raw_startsTensor ->
        withObjCPtr endsTensor $ \raw_endsTensor ->
          withObjCPtr stridesTensor $ \raw_stridesTensor ->
            withObjCPtr name $ \raw_name ->
                sendMsg mpsGraph (mkSelector "sliceUpdateDataTensor:updateTensor:startsTensor:endsTensor:stridesTensor:startMask:endMask:squeezeMask:name:") (retPtr retVoid) [argPtr (castPtr raw_dataTensor :: Ptr ()), argPtr (castPtr raw_updateTensor :: Ptr ()), argPtr (castPtr raw_startsTensor :: Ptr ()), argPtr (castPtr raw_endsTensor :: Ptr ()), argPtr (castPtr raw_stridesTensor :: Ptr ()), argCUInt startMask, argCUInt endMask, argCUInt squeezeMask, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a strided-slice update operation and returns the result tensor.
--
-- - Parameters:   - dataTensor: The large tensor that will receive the update.   - updateTensor: The tensor with the new values that will replace values in the dataTensor.   - starts: An array of numbers that specify the starting points for each dimension.   - ends: An array of numbers that specify the ending points for each dimension.   - strides: An array of numbers that specify the strides for each dimension.   - startMask: A bitmask that indicates dimensions whose @starts@ values the operation should ignore.   - endMask: A bitmask that indicates dimensions whose @ends@ values the operation should ignore.   - squeezeMask: A bitmask that indicates dimensions the operation will squeeze out from the result.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- sliceUpdateDataTensor:updateTensor:starts:ends:strides:startMask:endMask:squeezeMask:name:@
sliceUpdateDataTensor_updateTensor_starts_ends_strides_startMask_endMask_squeezeMask_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor dataTensor, IsMPSGraphTensor updateTensor, IsNSArray starts, IsNSArray ends, IsNSArray strides, IsNSString name) => mpsGraph -> dataTensor -> updateTensor -> starts -> ends -> strides -> CUInt -> CUInt -> CUInt -> name -> IO (Id MPSGraphTensor)
sliceUpdateDataTensor_updateTensor_starts_ends_strides_startMask_endMask_squeezeMask_name mpsGraph  dataTensor updateTensor starts ends strides startMask endMask squeezeMask name =
  withObjCPtr dataTensor $ \raw_dataTensor ->
    withObjCPtr updateTensor $ \raw_updateTensor ->
      withObjCPtr starts $ \raw_starts ->
        withObjCPtr ends $ \raw_ends ->
          withObjCPtr strides $ \raw_strides ->
            withObjCPtr name $ \raw_name ->
                sendMsg mpsGraph (mkSelector "sliceUpdateDataTensor:updateTensor:starts:ends:strides:startMask:endMask:squeezeMask:name:") (retPtr retVoid) [argPtr (castPtr raw_dataTensor :: Ptr ()), argPtr (castPtr raw_updateTensor :: Ptr ()), argPtr (castPtr raw_starts :: Ptr ()), argPtr (castPtr raw_ends :: Ptr ()), argPtr (castPtr raw_strides :: Ptr ()), argCUInt startMask, argCUInt endMask, argCUInt squeezeMask, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a strided-slice update operation with zero masks and returns the result tensor.
--
-- - Parameters:   - dataTensor: The large tensor that will receive the update.   - updateTensor: The tensor with the new values that will replace values in the dataTensor.   - startsTensor: A Tensor that contains an array of numbers that specify the starting points for each dimension.   - endsTensor: A Tensor that contains an array of numbers that specify the ending points for each dimension.   - stridesTensor: A Tensor that contains an array of numbers that specify the strides for each dimension.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- sliceUpdateDataTensor:updateTensor:startsTensor:endsTensor:stridesTensor:name:@
sliceUpdateDataTensor_updateTensor_startsTensor_endsTensor_stridesTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor dataTensor, IsMPSGraphTensor updateTensor, IsMPSGraphTensor startsTensor, IsMPSGraphTensor endsTensor, IsMPSGraphTensor stridesTensor, IsNSString name) => mpsGraph -> dataTensor -> updateTensor -> startsTensor -> endsTensor -> stridesTensor -> name -> IO (Id MPSGraphTensor)
sliceUpdateDataTensor_updateTensor_startsTensor_endsTensor_stridesTensor_name mpsGraph  dataTensor updateTensor startsTensor endsTensor stridesTensor name =
  withObjCPtr dataTensor $ \raw_dataTensor ->
    withObjCPtr updateTensor $ \raw_updateTensor ->
      withObjCPtr startsTensor $ \raw_startsTensor ->
        withObjCPtr endsTensor $ \raw_endsTensor ->
          withObjCPtr stridesTensor $ \raw_stridesTensor ->
            withObjCPtr name $ \raw_name ->
                sendMsg mpsGraph (mkSelector "sliceUpdateDataTensor:updateTensor:startsTensor:endsTensor:stridesTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_dataTensor :: Ptr ()), argPtr (castPtr raw_updateTensor :: Ptr ()), argPtr (castPtr raw_startsTensor :: Ptr ()), argPtr (castPtr raw_endsTensor :: Ptr ()), argPtr (castPtr raw_stridesTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a strided-slice update operation with zero masks and returns the result tensor.
--
-- - Parameters:   - dataTensor: The large tensor that will receive the update.   - updateTensor: The tensor with the new values that will replace values in the dataTensor.   - starts: An array of numbers that specify the starting points for each dimension.   - ends: An array of numbers that specify the ending points for each dimension.   - strides: An array of numbers that specify the strides for each dimension.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- sliceUpdateDataTensor:updateTensor:starts:ends:strides:name:@
sliceUpdateDataTensor_updateTensor_starts_ends_strides_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor dataTensor, IsMPSGraphTensor updateTensor, IsNSArray starts, IsNSArray ends, IsNSArray strides, IsNSString name) => mpsGraph -> dataTensor -> updateTensor -> starts -> ends -> strides -> name -> IO (Id MPSGraphTensor)
sliceUpdateDataTensor_updateTensor_starts_ends_strides_name mpsGraph  dataTensor updateTensor starts ends strides name =
  withObjCPtr dataTensor $ \raw_dataTensor ->
    withObjCPtr updateTensor $ \raw_updateTensor ->
      withObjCPtr starts $ \raw_starts ->
        withObjCPtr ends $ \raw_ends ->
          withObjCPtr strides $ \raw_strides ->
            withObjCPtr name $ \raw_name ->
                sendMsg mpsGraph (mkSelector "sliceUpdateDataTensor:updateTensor:starts:ends:strides:name:") (retPtr retVoid) [argPtr (castPtr raw_dataTensor :: Ptr ()), argPtr (castPtr raw_updateTensor :: Ptr ()), argPtr (castPtr raw_starts :: Ptr ()), argPtr (castPtr raw_ends :: Ptr ()), argPtr (castPtr raw_strides :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a concatenation operation and returns the result tensor.
--
-- Concatenates two input tensors along the specified dimension. Tensors must be broadcast compatible along all other dimensions, and have the same datatype.
--
-- - Parameters:   - tensor: The first tensor to concatenate.   - tensor2: The second tensor to concatenate.   - dimensionIndex: The dimension to concatenate across, must be in range: `-rank <= dimension < rank`.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- concatTensor:withTensor:dimension:name:@
concatTensor_withTensor_dimension_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsMPSGraphTensor tensor2, IsNSString name) => mpsGraph -> tensor -> tensor2 -> CLong -> name -> IO (Id MPSGraphTensor)
concatTensor_withTensor_dimension_name mpsGraph  tensor tensor2 dimensionIndex name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr tensor2 $ \raw_tensor2 ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "concatTensor:withTensor:dimension:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_tensor2 :: Ptr ()), argCLong dimensionIndex, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a concatenation operation and returns the result tensor.
--
-- Concatenates all input tensors along the specified dimension. All inputs must be broadcast compatible along all other dimensions, and have the same datatype.
--
-- - Parameters:   - tensors: The tensors to concatenate.   - dimensionIndex: The dimension to concatenate across, must be in range: `-rank <= dimension < rank`.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- concatTensors:dimension:name:@
concatTensors_dimension_name :: (IsMPSGraph mpsGraph, IsNSArray tensors, IsNSString name) => mpsGraph -> tensors -> CLong -> name -> IO (Id MPSGraphTensor)
concatTensors_dimension_name mpsGraph  tensors dimensionIndex name =
  withObjCPtr tensors $ \raw_tensors ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "concatTensors:dimension:name:") (retPtr retVoid) [argPtr (castPtr raw_tensors :: Ptr ()), argCLong dimensionIndex, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a concatenation operation and returns the result tensor.
--
-- Concatenates all input tensors along specified dimension. All inputs must be broadcast compatible along all other dimensions, and have the same type.  When interleave is specified, all tensors will be interleaved. To interleave, make sure to provide broadcast compatible inputs along the specified dimension as well. For example: ```md    operand0 = [1, 2, 3]   operand1 = [4, 5, 6]   concat([operand0, operand1], axis = 0, interleave = YES) = [1, 4, 2, 5, 3, 6] ```
--
-- - Parameters:   - tensors: The tensors to concatenate.   - dimensionIndex: The dimension to concatenate across, must be in range: `-rank <= dimension < rank`.   - interleave: A boolean value that specifies whether the operation interleaves input tensors.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- concatTensors:dimension:interleave:name:@
concatTensors_dimension_interleave_name :: (IsMPSGraph mpsGraph, IsNSArray tensors, IsNSString name) => mpsGraph -> tensors -> CLong -> Bool -> name -> IO (Id MPSGraphTensor)
concatTensors_dimension_interleave_name mpsGraph  tensors dimensionIndex interleave name =
  withObjCPtr tensors $ \raw_tensors ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "concatTensors:dimension:interleave:name:") (retPtr retVoid) [argPtr (castPtr raw_tensors :: Ptr ()), argCLong dimensionIndex, argCULong (if interleave then 1 else 0), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a tile operation and returns the result tensor.
--
-- Creates a tensor which contains multiple copies of the input tensor along each dimension of the tensor.
--
-- - Parameters:   - tensor: The input tensor   - multiplier: An array of numbers that specifies how many copies per dimension MPSGraph produces.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- tileTensor:withMultiplier:name:@
tileTensor_withMultiplier_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> RawId -> name -> IO (Id MPSGraphTensor)
tileTensor_withMultiplier_name mpsGraph  tensor multiplier name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "tileTensor:withMultiplier:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr (unRawId multiplier) :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a tile gradient operation and returns the result tensor.
--
-- - Parameters:   - incomingGradientTensor: The input gradient tensor.   - sourceTensor: The input tensor of the forward pass.   - multiplier: An array of numbers that specifies how many copies per dimension MPSGraph produced in the forward pass.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- tileGradientWithIncomingGradientTensor:sourceTensor:withMultiplier:name:@
tileGradientWithIncomingGradientTensor_sourceTensor_withMultiplier_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor incomingGradientTensor, IsMPSGraphTensor sourceTensor, IsNSString name) => mpsGraph -> incomingGradientTensor -> sourceTensor -> RawId -> name -> IO (Id MPSGraphTensor)
tileGradientWithIncomingGradientTensor_sourceTensor_withMultiplier_name mpsGraph  incomingGradientTensor sourceTensor multiplier name =
  withObjCPtr incomingGradientTensor $ \raw_incomingGradientTensor ->
    withObjCPtr sourceTensor $ \raw_sourceTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "tileGradientWithIncomingGradientTensor:sourceTensor:withMultiplier:name:") (retPtr retVoid) [argPtr (castPtr raw_incomingGradientTensor :: Ptr ()), argPtr (castPtr raw_sourceTensor :: Ptr ()), argPtr (castPtr (unRawId multiplier) :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a padding operation and returns the result tensor.
--
-- - Parameters:   - tensor: The input tensor.   - paddingMode: The parameter that defines the padding mode.   - leftPadding: The parameter that defines how much padding the operation applies to the input tensor before each dimension - must be of size @rank(tensor)@.   - rightPadding: The parameter that defines how much padding the operation applies to the input tensor after each dimension - must be of size @rank(tensor)@.   - constantValue: The constant value the operation uses when @paddingMode = MPSGraphPaddingModeConstant@.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- padTensor:withPaddingMode:leftPadding:rightPadding:constantValue:name:@
padTensor_withPaddingMode_leftPadding_rightPadding_constantValue_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> MPSGraphPaddingMode -> RawId -> RawId -> CDouble -> name -> IO (Id MPSGraphTensor)
padTensor_withPaddingMode_leftPadding_rightPadding_constantValue_name mpsGraph  tensor paddingMode leftPadding rightPadding constantValue name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "padTensor:withPaddingMode:leftPadding:rightPadding:constantValue:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argCLong (coerce paddingMode), argPtr (castPtr (unRawId leftPadding) :: Ptr ()), argPtr (castPtr (unRawId rightPadding) :: Ptr ()), argCDouble constantValue, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a padding gradient operation and returns the result tensor.
--
-- - Parameters:   - incomingGradientTensor: The input gradient tensor.   - sourceTensor: The input tensor of the forward pass.   - paddingMode: The parameter that defines the padding mode.   - leftPadding: The parameter that defines how much padding the operation applies to the input tensor before each dimension - must be of size @rank(tensor)@.   - rightPadding: The parameter that defines how much padding the operation applies to the input tensor after each dimension - must be of size @rank(tensor)@.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- padGradientWithIncomingGradientTensor:sourceTensor:paddingMode:leftPadding:rightPadding:name:@
padGradientWithIncomingGradientTensor_sourceTensor_paddingMode_leftPadding_rightPadding_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor incomingGradientTensor, IsMPSGraphTensor sourceTensor, IsNSString name) => mpsGraph -> incomingGradientTensor -> sourceTensor -> MPSGraphPaddingMode -> RawId -> RawId -> name -> IO (Id MPSGraphTensor)
padGradientWithIncomingGradientTensor_sourceTensor_paddingMode_leftPadding_rightPadding_name mpsGraph  incomingGradientTensor sourceTensor paddingMode leftPadding rightPadding name =
  withObjCPtr incomingGradientTensor $ \raw_incomingGradientTensor ->
    withObjCPtr sourceTensor $ \raw_sourceTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "padGradientWithIncomingGradientTensor:sourceTensor:paddingMode:leftPadding:rightPadding:name:") (retPtr retVoid) [argPtr (castPtr raw_incomingGradientTensor :: Ptr ()), argPtr (castPtr raw_sourceTensor :: Ptr ()), argCLong (coerce paddingMode), argPtr (castPtr (unRawId leftPadding) :: Ptr ()), argPtr (castPtr (unRawId rightPadding) :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a space-to-depth2D operation and returns the result tensor.
--
-- This operation outputs a copy of the @input@ tensor, where values from the @widthAxis@ and @heightAxis@ dimensions are moved in spatial blocks of size @blockSize@ to the @depthAxis@ dimension. Use the @usePixelShuffleOrder@ parameter to control how the data within spatial blocks is ordered in the @depthAxis@ dimension: with @usePixelShuffleOrder=YES@ MPSGraph stores the values of the spatial blocks  contiguosly within the @depthAxis@ dimension, whereas otherwise they are stored interleaved with existing values in the @depthAxis@ dimension. This operation is the inverse of @MPSGraph/depthToSpace2DTensor:widthAxis:heightAxis:depthAxis:blockSize:usePixelShuffleOrder:name:@. - Parameters:   - tensor: The input tensor.   - widthAxis: The axis that defines the fastest running dimension within the block.   - heightAxis: The axis that defines the 2nd fastest running dimension within the block.   - depthAxis: The axis that defines the destination dimension, where to copy the blocks.   - blockSize: The size of the square spatial sub-block.   - usePixelShuffleOrder: A parameter that controls the layout of the sub-blocks within the depth dimension.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- spaceToDepth2DTensor:widthAxis:heightAxis:depthAxis:blockSize:usePixelShuffleOrder:name:@
spaceToDepth2DTensor_widthAxis_heightAxis_depthAxis_blockSize_usePixelShuffleOrder_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> CULong -> CULong -> CULong -> CULong -> Bool -> name -> IO (Id MPSGraphTensor)
spaceToDepth2DTensor_widthAxis_heightAxis_depthAxis_blockSize_usePixelShuffleOrder_name mpsGraph  tensor widthAxis heightAxis depthAxis blockSize usePixelShuffleOrder name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "spaceToDepth2DTensor:widthAxis:heightAxis:depthAxis:blockSize:usePixelShuffleOrder:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argCULong widthAxis, argCULong heightAxis, argCULong depthAxis, argCULong blockSize, argCULong (if usePixelShuffleOrder then 1 else 0), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a space-to-depth2D operation and returns the result tensor.
--
-- This operation outputs a copy of the @input@ tensor, where values from the @widthAxisTensor@ and @heightAxisTensor@ dimensions are moved in spatial blocks of size @blockSize@ to the @depthAxisTensor@ dimension. Use the @usePixelShuffleOrder@ parameter to control how the data within spatial blocks is ordered in the @depthAxisTensor@ dimension: with @usePixelShuffleOrder=YES@ MPSGraph stores the values of the spatial blocks  contiguosly within the @depthAxisTensor@ dimension, whereas otherwise they are stored interleaved with existing values in the @depthAxisTensor@ dimension. This operation is the inverse of ``MPSGraph/depthToSpace2DTensor:widthAxisTensor:heightAxisTensor:depthAxisTensor:blockSize:usePixelShuffleOrder:name:``.
--
-- - Parameters:   - tensor: The input tensor.   - widthAxisTensor: A scalar tensor that contains the axis that defines the fastest running dimension within the block.   - heightAxisTensor: A scalar tensor that contains the axis that defines the 2nd fastest running dimension within the block.   - depthAxisTensor: A scalar tensor that contains the axis that defines the destination dimension, where to copy the blocks.   - blockSize: The size of the square spatial sub-block.   - usePixelShuffleOrder: A parameter that controls the layout of the sub-blocks within the depth dimension.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- spaceToDepth2DTensor:widthAxisTensor:heightAxisTensor:depthAxisTensor:blockSize:usePixelShuffleOrder:name:@
spaceToDepth2DTensor_widthAxisTensor_heightAxisTensor_depthAxisTensor_blockSize_usePixelShuffleOrder_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsMPSGraphTensor widthAxisTensor, IsMPSGraphTensor heightAxisTensor, IsMPSGraphTensor depthAxisTensor, IsNSString name) => mpsGraph -> tensor -> widthAxisTensor -> heightAxisTensor -> depthAxisTensor -> CULong -> Bool -> name -> IO (Id MPSGraphTensor)
spaceToDepth2DTensor_widthAxisTensor_heightAxisTensor_depthAxisTensor_blockSize_usePixelShuffleOrder_name mpsGraph  tensor widthAxisTensor heightAxisTensor depthAxisTensor blockSize usePixelShuffleOrder name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr widthAxisTensor $ \raw_widthAxisTensor ->
      withObjCPtr heightAxisTensor $ \raw_heightAxisTensor ->
        withObjCPtr depthAxisTensor $ \raw_depthAxisTensor ->
          withObjCPtr name $ \raw_name ->
              sendMsg mpsGraph (mkSelector "spaceToDepth2DTensor:widthAxisTensor:heightAxisTensor:depthAxisTensor:blockSize:usePixelShuffleOrder:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_widthAxisTensor :: Ptr ()), argPtr (castPtr raw_heightAxisTensor :: Ptr ()), argPtr (castPtr raw_depthAxisTensor :: Ptr ()), argCULong blockSize, argCULong (if usePixelShuffleOrder then 1 else 0), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a depth-to-space2D operation and returns the result tensor.
--
-- This operation outputs a copy of the input tensor, where values from the  @depthAxis@ dimension are moved in spatial blocks of size @blockSize@ to the @heightAxis@ and @widthAxis@ dimensions.  Use the @usePixelShuffleOrder@ parameter to control how the data within spatial blocks is ordered in the @depthAxis@ dimension: with @usePixelShuffleOrder = YES@ MPSGraph stores the values of the spatial block contiguosly within the @depthAxis@ dimension, whereas without it they are stored interleaved with existing values in the @depthAxisTensor@ dimension. This operation is the inverse of ``MPSGraph/spaceToDepth2DTensor:widthAxis:heightAxis:depthAxis:blockSize:usePixelShuffleOrder:name:``.
--
-- - Parameters:   - tensor: The input tensor.   - widthAxis: The axis that defines the fastest running dimension within the block.   - heightAxis: The axis that defines the 2nd fastest running dimension within the block.   - depthAxis: The axis that defines the destination dimension, where to copy the blocks.   - blockSize: The size of the square spatial sub-block.   - usePixelShuffleOrder: A parameter that controls the layout of the sub-blocks within the depth dimension.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- depthToSpace2DTensor:widthAxis:heightAxis:depthAxis:blockSize:usePixelShuffleOrder:name:@
depthToSpace2DTensor_widthAxis_heightAxis_depthAxis_blockSize_usePixelShuffleOrder_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> CULong -> CULong -> CULong -> CULong -> Bool -> name -> IO (Id MPSGraphTensor)
depthToSpace2DTensor_widthAxis_heightAxis_depthAxis_blockSize_usePixelShuffleOrder_name mpsGraph  tensor widthAxis heightAxis depthAxis blockSize usePixelShuffleOrder name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "depthToSpace2DTensor:widthAxis:heightAxis:depthAxis:blockSize:usePixelShuffleOrder:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argCULong widthAxis, argCULong heightAxis, argCULong depthAxis, argCULong blockSize, argCULong (if usePixelShuffleOrder then 1 else 0), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a depth-to-space2D operation and returns the result tensor.
--
-- This operation outputs a copy of the input tensor, where values from the @depthAxisTensor@ dimension are moved in spatial blocks of size @blockSize@ to the @heightAxisTensor@ and @widthAxisTensor@ dimensions.  Use the @usePixelShuffleOrder@ parameter to control how the data within spatial blocks is ordered in the @depthAxisTensor@ dimension: with @usePixelShuffleOrder = YES@ MPSGraph stores the values of the spatial block contiguosly within the @depthAxisTensor@ dimension, whereas without it they are stored interleaved with existing values in the @depthAxisTensor@ dimension. This operation is the inverse of ``MPSGraph/spaceToDepth2DTensor:widthAxisTensor:heightAxisTensor:depthAxisTensor:blockSize:usePixelShuffleOrder:name:``.
--
-- - Parameters:   - tensor: The input tensor.   - widthAxisTensor: A scalar tensor that contains the axis that defines the fastest running dimension within the block.   - heightAxisTensor: A scalar tensor that contains the axis that defines the 2nd fastest running dimension within the block.   - depthAxisTensor: A scalar tensor that contains the axis that defines the destination dimension, where to copy the blocks.   - blockSize: The size of the square spatial sub-block.   - usePixelShuffleOrder: A parameter that controls the layout of the sub-blocks within the depth dimension.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- depthToSpace2DTensor:widthAxisTensor:heightAxisTensor:depthAxisTensor:blockSize:usePixelShuffleOrder:name:@
depthToSpace2DTensor_widthAxisTensor_heightAxisTensor_depthAxisTensor_blockSize_usePixelShuffleOrder_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsMPSGraphTensor widthAxisTensor, IsMPSGraphTensor heightAxisTensor, IsMPSGraphTensor depthAxisTensor, IsNSString name) => mpsGraph -> tensor -> widthAxisTensor -> heightAxisTensor -> depthAxisTensor -> CULong -> Bool -> name -> IO (Id MPSGraphTensor)
depthToSpace2DTensor_widthAxisTensor_heightAxisTensor_depthAxisTensor_blockSize_usePixelShuffleOrder_name mpsGraph  tensor widthAxisTensor heightAxisTensor depthAxisTensor blockSize usePixelShuffleOrder name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr widthAxisTensor $ \raw_widthAxisTensor ->
      withObjCPtr heightAxisTensor $ \raw_heightAxisTensor ->
        withObjCPtr depthAxisTensor $ \raw_depthAxisTensor ->
          withObjCPtr name $ \raw_name ->
              sendMsg mpsGraph (mkSelector "depthToSpace2DTensor:widthAxisTensor:heightAxisTensor:depthAxisTensor:blockSize:usePixelShuffleOrder:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_widthAxisTensor :: Ptr ()), argPtr (castPtr raw_heightAxisTensor :: Ptr ()), argPtr (castPtr raw_depthAxisTensor :: Ptr ()), argCULong blockSize, argCULong (if usePixelShuffleOrder then 1 else 0), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a space-to-batch operation and returns the result tensor.
--
-- This operation outputs a copy of the @input@ tensor, where values from the @spatialAxes@ (for @usePixelShuffleOrder=YES@ 1,2 or 3 axes supported, otherwise limited only by @MPSNDArray@ rank limitations) dimensions are moved in spatial blocks with rectangular size defined by @blockDimensions@ to the @batchAxis@ dimension. Use the @usePixelShuffleOrder@ parameter  to control how the data within spatial blocks is ordered in the @batchAxis@ dimension: with @usePixelShuffleOrder=YES@ MPSGraph stores the values of the spatial blocks contiguosly within the @batchAxis@ dimension, whereas otherwise they are stored interleaved with existing values in the @batchAxis@ dimension. Note: This operation is the inverse of     ``MPSGraph/batchToSpaceTensor:spatialAxes:batchAxis:blockDimensions:usePixelShuffleOrder:name:``. Note: This operation is a generalization of     ``MPSGraph/spaceToDepth2DTensor:widthAxis:heightAxis:depthAxis:blockSize:usePixelShuffleOrder:name:``.
--
-- - Parameters:   - tensor: The input tensor.   - spatialAxes: The axes that define the dimensions containing the spatial blocks.   - batchAxis: The axis that defines the destination dimension, where to copy the blocks.   - blockDimensions: An array of numbers that defines the size of the rectangular spatial sub-block.   - usePixelShuffleOrder: A parameter that controls layout of the sub-blocks within the batch dimension.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- spaceToBatchTensor:spatialAxes:batchAxis:blockDimensions:usePixelShuffleOrder:name:@
spaceToBatchTensor_spatialAxes_batchAxis_blockDimensions_usePixelShuffleOrder_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSArray spatialAxes, IsNSArray blockDimensions, IsNSString name) => mpsGraph -> tensor -> spatialAxes -> CLong -> blockDimensions -> Bool -> name -> IO (Id MPSGraphTensor)
spaceToBatchTensor_spatialAxes_batchAxis_blockDimensions_usePixelShuffleOrder_name mpsGraph  tensor spatialAxes batchAxis blockDimensions usePixelShuffleOrder name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr spatialAxes $ \raw_spatialAxes ->
      withObjCPtr blockDimensions $ \raw_blockDimensions ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "spaceToBatchTensor:spatialAxes:batchAxis:blockDimensions:usePixelShuffleOrder:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_spatialAxes :: Ptr ()), argCLong batchAxis, argPtr (castPtr raw_blockDimensions :: Ptr ()), argCULong (if usePixelShuffleOrder then 1 else 0), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a space-to-batch operation and returns the result tensor.
--
-- This operation outputs a copy of the @input@ tensor, where values from the @spatialAxesTensor@ (for @usePixelShuffleOrder=YES@ 1,2 or 3 axes supported, otherwise limited only by @MPSNDArray@ rank limitations) dimensions are moved in spatial blocks with rectangular size defined by @blockDimensionsTensor@ to the @batchAxisTensor@ dimension. Use the @usePixelShuffleOrder@ parameter  to control how the data within spatial blocks is ordered in the @batchAxisTensor@ dimension: with @usePixelShuffleOrder=YES@ MPSGraph stores the values of the spatial blocks contiguosly within the @batchAxisTensor@ dimension, whereas otherwise they are stored interleaved with existing values in the @batchAxisTensor@ dimension. Note: This operation is the inverse of     ``MPSGraph/batchToSpaceTensor:spatialAxesTensor:batchAxisTensor:blockDimensionsTensor:usePixelShuffleOrder:name:``. Note: This operation is a generalization of     ``MPSGraph/spaceToDepth2DTensor:widthAxisTensor:heightAxisTensor:depthAxisTensor:blockSize:usePixelShuffleOrder:name:``.
--
-- - Parameters:   - tensor: The input tensor.   - spatialAxesTensor: A tensor that contains the axes that define the dimensions containing the spatial blocks.   - batchAxisTensor: A tensor that contains the axis that defines the destination dimension, where to copy the blocks.   - blockDimensionsTensor: A tensor that defines the size of the rectangular spatial sub-block.   - usePixelShuffleOrder: A parameter that controls layout of the sub-blocks within the batch dimension.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- spaceToBatchTensor:spatialAxesTensor:batchAxisTensor:blockDimensionsTensor:usePixelShuffleOrder:name:@
spaceToBatchTensor_spatialAxesTensor_batchAxisTensor_blockDimensionsTensor_usePixelShuffleOrder_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsMPSGraphTensor spatialAxesTensor, IsMPSGraphTensor batchAxisTensor, IsMPSGraphTensor blockDimensionsTensor, IsNSString name) => mpsGraph -> tensor -> spatialAxesTensor -> batchAxisTensor -> blockDimensionsTensor -> Bool -> name -> IO (Id MPSGraphTensor)
spaceToBatchTensor_spatialAxesTensor_batchAxisTensor_blockDimensionsTensor_usePixelShuffleOrder_name mpsGraph  tensor spatialAxesTensor batchAxisTensor blockDimensionsTensor usePixelShuffleOrder name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr spatialAxesTensor $ \raw_spatialAxesTensor ->
      withObjCPtr batchAxisTensor $ \raw_batchAxisTensor ->
        withObjCPtr blockDimensionsTensor $ \raw_blockDimensionsTensor ->
          withObjCPtr name $ \raw_name ->
              sendMsg mpsGraph (mkSelector "spaceToBatchTensor:spatialAxesTensor:batchAxisTensor:blockDimensionsTensor:usePixelShuffleOrder:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_spatialAxesTensor :: Ptr ()), argPtr (castPtr raw_batchAxisTensor :: Ptr ()), argPtr (castPtr raw_blockDimensionsTensor :: Ptr ()), argCULong (if usePixelShuffleOrder then 1 else 0), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a batch-to-space operation and returns the result tensor.
--
-- This operation outputs a copy of the input tensor, where values from the  @batchAxis@ dimension are moved in spatial blocks of size @blockDimensions@ to the @spatialAxes@ dimensions (for @usePixelShuffleOrder=YES@ 1,2 or 3 axes supported, otherwise limited only by @MPSNDArray@ rank limitations).  Use the @usePixelShuffleOrder@ parameter to control how the data within spatial blocks is ordered in the @batchAxis@ dimension: with @usePixelShuffleOrder = YES@ MPSGraph stores the values of the spatial block contiguosly within the @batchAxis@ dimension whereas without it they are stored interleaved with existing values in the @batchAxis@ dimension. Note: This operation is the inverse of     ``MPSGraph/spaceToBatchTensor:spatialAxes:batchAxis:blockDimensions:usePixelShuffleOrder:name:``. Note: This operation is a generalization of     ``MPSGraph/depthToSpace2DTensor:widthAxis:heightAxis:depthAxis:blockSize:usePixelShuffleOrder:name:``.
--
-- - Parameters:   - tensor: The input tensor.   - spatialAxes: The axes that define the dimensions containing the spatial blocks.   - batchAxis: The axis that defines the destination dimension, where to copy the blocks.   - blockDimensions: An array of numbers that defines the size of the rectangular spatial sub-block.   - usePixelShuffleOrder: A parameter that controls layout of the sub-blocks within the batch dimension.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- batchToSpaceTensor:spatialAxes:batchAxis:blockDimensions:usePixelShuffleOrder:name:@
batchToSpaceTensor_spatialAxes_batchAxis_blockDimensions_usePixelShuffleOrder_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSArray spatialAxes, IsNSArray blockDimensions, IsNSString name) => mpsGraph -> tensor -> spatialAxes -> CLong -> blockDimensions -> Bool -> name -> IO (Id MPSGraphTensor)
batchToSpaceTensor_spatialAxes_batchAxis_blockDimensions_usePixelShuffleOrder_name mpsGraph  tensor spatialAxes batchAxis blockDimensions usePixelShuffleOrder name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr spatialAxes $ \raw_spatialAxes ->
      withObjCPtr blockDimensions $ \raw_blockDimensions ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "batchToSpaceTensor:spatialAxes:batchAxis:blockDimensions:usePixelShuffleOrder:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_spatialAxes :: Ptr ()), argCLong batchAxis, argPtr (castPtr raw_blockDimensions :: Ptr ()), argCULong (if usePixelShuffleOrder then 1 else 0), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a batch-to-space operation and returns the result tensor.
--
-- This operation outputs a copy of the input tensor, where values from the @batchAxisTensor@ dimension are moved in spatial blocks of size @blockDimensionsTensor@ to the @spatialAxesTensor@ dimensions (for @usePixelShuffleOrder=YES@ 1,2 or 3 axes supported, otherwise limited only by @MPSNDArray@ rank limitations).  Use the @usePixelShuffleOrder@ parameter to control how the data within spatial blocks is ordered in the @batchAxisTensor@ dimension: with @usePixelShuffleOrder = YES@ MPSGraph stores the values of the spatial block contiguosly within the @batchAxisTensor@ dimension whereas without it they are stored interleaved with existing values in the @batchAxisTensor@ dimension. Note: This operation is the inverse of ``MPSGraph/spaceToBatchTensor:spatialAxesTensor:batchAxisTensor:blockDimensionsTensor:usePixelShuffleOrder:name:``. Note: This operation is a generalization of ``MPSGraph/depthToSpace2DTensor:widthAxisTensor:heightAxisTensor:depthAxisTensor:blockSize:usePixelShuffleOrder:name:``.
--
-- - Parameters:   - tensor: The input tensor.   - spatialAxesTensor: A tensor that contains the axes that define the dimensions containing the spatial blocks.   - batchAxisTensor: A tensor that contains the axis that defines the destination dimension, where to copy the blocks.   - blockDimensionsTensor: A tensor that defines the size of the rectangular spatial sub-block.   - usePixelShuffleOrder: A parameter that controls layout of the sub-blocks within the batch dimension.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- batchToSpaceTensor:spatialAxesTensor:batchAxisTensor:blockDimensionsTensor:usePixelShuffleOrder:name:@
batchToSpaceTensor_spatialAxesTensor_batchAxisTensor_blockDimensionsTensor_usePixelShuffleOrder_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsMPSGraphTensor spatialAxesTensor, IsMPSGraphTensor batchAxisTensor, IsMPSGraphTensor blockDimensionsTensor, IsNSString name) => mpsGraph -> tensor -> spatialAxesTensor -> batchAxisTensor -> blockDimensionsTensor -> Bool -> name -> IO (Id MPSGraphTensor)
batchToSpaceTensor_spatialAxesTensor_batchAxisTensor_blockDimensionsTensor_usePixelShuffleOrder_name mpsGraph  tensor spatialAxesTensor batchAxisTensor blockDimensionsTensor usePixelShuffleOrder name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr spatialAxesTensor $ \raw_spatialAxesTensor ->
      withObjCPtr batchAxisTensor $ \raw_batchAxisTensor ->
        withObjCPtr blockDimensionsTensor $ \raw_blockDimensionsTensor ->
          withObjCPtr name $ \raw_name ->
              sendMsg mpsGraph (mkSelector "batchToSpaceTensor:spatialAxesTensor:batchAxisTensor:blockDimensionsTensor:usePixelShuffleOrder:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_spatialAxesTensor :: Ptr ()), argPtr (castPtr raw_batchAxisTensor :: Ptr ()), argPtr (castPtr raw_blockDimensionsTensor :: Ptr ()), argCULong (if usePixelShuffleOrder then 1 else 0), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a reverse operation and returns the result tensor.
--
-- Reverses a tensor on given axes. Semantics based on [TensorFlow reverse op](https://www.tensorflow.org/api_docs/python/tf/reverse).
--
-- - Parameters:   - tensor: The tensor to be reversed.   - axesTensor: A tensor that specifies axes to be reversed (Axes must be unique and within normal axis range).   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- reverseTensor:axesTensor:name:@
reverseTensor_axesTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsMPSGraphTensor axesTensor, IsNSString name) => mpsGraph -> tensor -> axesTensor -> name -> IO (Id MPSGraphTensor)
reverseTensor_axesTensor_name mpsGraph  tensor axesTensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr axesTensor $ \raw_axesTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "reverseTensor:axesTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_axesTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a reverse operation and returns the result tensor.
--
-- Reverses a tensor on given axes. Semantics based on [TensorFlow reverse op](https://www.tensorflow.org/api_docs/python/tf/reverse).
--
-- - Parameters:   - tensor: The tensor to be reversed.   - axes: A tensor that specifies axes to be reversed (Axes must be unique and within normal axis range).   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- reverseTensor:axes:name:@
reverseTensor_axes_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSArray axes, IsNSString name) => mpsGraph -> tensor -> axes -> name -> IO (Id MPSGraphTensor)
reverseTensor_axes_name mpsGraph  tensor axes name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr axes $ \raw_axes ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "reverseTensor:axes:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_axes :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a reverse operation and returns the result tensor.
--
-- Reverses a tensor on all axes. Semantics based on [TensorFlow reverse op](https://www.tensorflow.org/api_docs/python/tf/reverse).
--
-- - Parameters:   - tensor: The tensor to be reversed.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- reverseTensor:name:@
reverseTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> name -> IO (Id MPSGraphTensor)
reverseTensor_name mpsGraph  tensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "reverseTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a flatten2D operation and returns the result tensor.
--
-- Flattens dimensions before @axis@ to @result[0]@ and dimensions starting from @axis@ to @result[1]@ and returns a rank-2 tensor as result.
--
-- - Parameters:   - tensor: The tensor to be flattened.   - axis: The axis around which to flatten.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- flatten2DTensor:axis:name:@
flatten2DTensor_axis_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> CLong -> name -> IO (Id MPSGraphTensor)
flatten2DTensor_axis_name mpsGraph  tensor axis name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "flatten2DTensor:axis:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argCLong axis, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a flatten2D operation and returns the result tensor.
--
-- Flattens dimensions before @axis@ to @result[0]@ and dimensions starting from @axis@ to @result[1]@ and returns a rank-2 tensor as result.
--
-- - Parameters:   - tensor: The tensor to be flattened.   - axisTensor: A scalar tensor that contains the axis around which to flatten.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- flatten2DTensor:axisTensor:name:@
flatten2DTensor_axisTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsMPSGraphTensor axisTensor, IsNSString name) => mpsGraph -> tensor -> axisTensor -> name -> IO (Id MPSGraphTensor)
flatten2DTensor_axisTensor_name mpsGraph  tensor axisTensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr axisTensor $ \raw_axisTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "flatten2DTensor:axisTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_axisTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a broadcast operation and returns the result tensor.
--
-- Broadcasts values inside the tensor, starting from the trailing dimensions, to give it the correct shape. This is equivalent to the broadcasting for arithmetic operations when operands have different shapes.
--
-- - Parameters:   - tensor: The tensor to be broadcasted   - shape: The shape of the result tensor.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- broadcastTensor:toShape:name:@
broadcastTensor_toShape_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> RawId -> name -> IO (Id MPSGraphTensor)
broadcastTensor_toShape_name mpsGraph  tensor shape name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "broadcastTensor:toShape:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr (unRawId shape) :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a broadcast operation and returns the result tensor.
--
-- Broadcasts values inside the tensor, starting from the trailing dimensions, to give it the correct shape. This is equivalent to the broadcasting for arithmetic operations when operands have different shapes.
--
-- - Parameters:   - tensor: The Tensor to be broadcasted.   - shapeTensor: A rank-1 tensor of type @MPSDataTypeInt32@ or @MPSDataTypeInt64@ that defines the shape of the result tensor.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- broadcastTensor:toShapeTensor:name:@
broadcastTensor_toShapeTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsMPSGraphTensor shapeTensor, IsNSString name) => mpsGraph -> tensor -> shapeTensor -> name -> IO (Id MPSGraphTensor)
broadcastTensor_toShapeTensor_name mpsGraph  tensor shapeTensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr shapeTensor $ \raw_shapeTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "broadcastTensor:toShapeTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_shapeTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a shape-of operation and returns the result tensor.
--
-- Returns a rank-1 tensor of type @MPSDataTypeInt32@ with the values of the static shape of the input tensor.
--
-- - Parameters:   - tensor: The input tensor.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- shapeOfTensor:name:@
shapeOfTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> name -> IO (Id MPSGraphTensor)
shapeOfTensor_name mpsGraph  tensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "shapeOfTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a cast operation and returns the result tensor.
--
-- Returns the input tensor casted to the specied data type.
--
-- - Parameters:   - tensor: The input tensor.   - type: The datatype to which MPSGraph casts the input.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- castTensor:toType:name:@
castTensor_toType_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> MPSDataType -> name -> IO (Id MPSGraphTensor)
castTensor_toType_name mpsGraph  tensor type_ name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "castTensor:toType:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argCUInt (coerce type_), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a reinterpret cast operation and returns the result tensor.
--
-- Returns input tensor (with element type @tensor_type@) reinterpreted to element type passed in with the last dimension scaled by @sizeof(tensor_type) / sizeof(type)@.  This operation is endianness agnostic and MPSGraph reinterprets the data with the endianness of the system.
--
-- - Parameters:   - tensor: The input tensor.   - type: The element type of the returned tensor.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- reinterpretCastTensor:toType:name:@
reinterpretCastTensor_toType_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> MPSDataType -> name -> IO (Id MPSGraphTensor)
reinterpretCastTensor_toType_name mpsGraph  tensor type_ name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "reinterpretCastTensor:toType:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argCUInt (coerce type_), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a stack operation and returns the result tensor.
--
-- Stacks all input tensors along @axis@ into a result tensor of @rank + 1@. Tensors must be broadcast compatible along all dimensions except @axis@, and have the same type.
--
-- - Parameters:   - inputTensors: The input tensors.   - axis: The dimension to stack tensors into result. Must be in range: `-rank + 1 <= dimension < rank + 1`.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- stackTensors:axis:name:@
stackTensors_axis_name :: (IsMPSGraph mpsGraph, IsNSArray inputTensors, IsNSString name) => mpsGraph -> inputTensors -> CLong -> name -> IO (Id MPSGraphTensor)
stackTensors_axis_name mpsGraph  inputTensors axis name =
  withObjCPtr inputTensors $ \raw_inputTensors ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "stackTensors:axis:name:") (retPtr retVoid) [argPtr (castPtr raw_inputTensors :: Ptr ()), argCLong axis, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a split operation and returns the result tensor.
--
-- Splits the input tensor along @axis@ into multiple result tensors of size determined by @splitSizes@. Requires that the sum of @splitSizes@ is equal to the lenth of the input along @axis@.
--
-- - Parameters:   - tensor: The input tensor.   - splitSizes: The lengths of the result tensors along the split axis.   - axis: The dimension along which MPSGraph splits the input tensor.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- splitTensor:splitSizes:axis:name:@
splitTensor_splitSizes_axis_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSArray splitSizes, IsNSString name) => mpsGraph -> tensor -> splitSizes -> CLong -> name -> IO (Id NSArray)
splitTensor_splitSizes_axis_name mpsGraph  tensor splitSizes axis name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr splitSizes $ \raw_splitSizes ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "splitTensor:splitSizes:axis:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_splitSizes :: Ptr ()), argCLong axis, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a split operation and returns the result tensor.
--
-- Splits the input tensor along @axis@ into multiple result tensors of size determined by @splitSizesTensor@. Requires that the sum of the elements of @splitSizesTensor@ is equal to the lenth of the input along @axis@.
--
-- - Parameters:   - tensor: The input tensor   - splitSizesTensor: The lengths of the result tensors along the split axis.   - axis: The dimension along which MPSGraph splits the input tensor.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- splitTensor:splitSizesTensor:axis:name:@
splitTensor_splitSizesTensor_axis_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsMPSGraphTensor splitSizesTensor, IsNSString name) => mpsGraph -> tensor -> splitSizesTensor -> CLong -> name -> IO (Id NSArray)
splitTensor_splitSizesTensor_axis_name mpsGraph  tensor splitSizesTensor axis name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr splitSizesTensor $ \raw_splitSizesTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "splitTensor:splitSizesTensor:axis:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_splitSizesTensor :: Ptr ()), argCLong axis, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a split operation and returns the result tensor.
--
-- Splits the input tensor along @axis@ into @numsplits@ result tensors of equal size. Requires that the lenth of the input along @axis@ is divisible by @numSplits@.
--
-- - Parameters:   - tensor: The input tensor.   - numSplits: The number of result tensors to split to.   - axis: The dimension along which MPSGraph splits the input tensor.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- splitTensor:numSplits:axis:name:@
splitTensor_numSplits_axis_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> CULong -> CLong -> name -> IO (Id NSArray)
splitTensor_numSplits_axis_name mpsGraph  tensor numSplits axis name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "splitTensor:numSplits:axis:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argCULong numSplits, argCLong axis, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a squeeze operation and returns the result tensor.
--
-- Squeezes the tensor, removing all dimensions with size 1.
--
-- - Parameters:   - tensor: The input tensor.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- squeezeTensor:name:@
squeezeTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> name -> IO (Id MPSGraphTensor)
squeezeTensor_name mpsGraph  tensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "squeezeTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a squeeze operation and returns the result tensor.
--
-- Squeezes the tensor, removing a dimension with size 1 at the specified axis. The size of the input tensor must be 1 at the specified axis.
--
-- - Parameters:   - tensor: The input tensor.   - axis: The axis to squeeze.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- squeezeTensor:axis:name:@
squeezeTensor_axis_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> CLong -> name -> IO (Id MPSGraphTensor)
squeezeTensor_axis_name mpsGraph  tensor axis name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "squeezeTensor:axis:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argCLong axis, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a squeeze operation and returns the result tensor.
--
-- Squeezes the tensor, removing dimensions with size 1 at specified axes.  The size of the input tensor must be 1 at all specified axes.
--
-- - Parameters:   - tensor: The input tensor.   - axes: The axes to squeeze.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- squeezeTensor:axes:name:@
squeezeTensor_axes_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSArray axes, IsNSString name) => mpsGraph -> tensor -> axes -> name -> IO (Id MPSGraphTensor)
squeezeTensor_axes_name mpsGraph  tensor axes name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr axes $ \raw_axes ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "squeezeTensor:axes:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_axes :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a squeeze operation and returns the result tensor.
--
-- Squeezes the tensor, removing dimensions with size 1 at specified axes. The size of the input tensor must be 1 at all specified axes.
--
-- - Parameters:   - tensor: The input tensor.   - axesTensor: The tensor containing the axes to squeeze.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- squeezeTensor:axesTensor:name:@
squeezeTensor_axesTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsMPSGraphTensor axesTensor, IsNSString name) => mpsGraph -> tensor -> axesTensor -> name -> IO (Id MPSGraphTensor)
squeezeTensor_axesTensor_name mpsGraph  tensor axesTensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr axesTensor $ \raw_axesTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "squeezeTensor:axesTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_axesTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates an expand-dimensions operation and returns the result tensor.
--
-- Expands the tensor, inserting a dimension with size 1 at the specified axis.
--
-- - Parameters:   - tensor: The input tensor.   - axis: The axis to expand.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- expandDimsOfTensor:axis:name:@
expandDimsOfTensor_axis_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> CLong -> name -> IO (Id MPSGraphTensor)
expandDimsOfTensor_axis_name mpsGraph  tensor axis name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "expandDimsOfTensor:axis:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argCLong axis, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates an expand-dimensions operation and returns the result tensor.
--
-- Expands the tensor, inserting dimensions with size 1 at specified axes.
--
-- - Parameters:   - tensor: The input tensor.   - axes: The axes to expand.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- expandDimsOfTensor:axes:name:@
expandDimsOfTensor_axes_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSArray axes, IsNSString name) => mpsGraph -> tensor -> axes -> name -> IO (Id MPSGraphTensor)
expandDimsOfTensor_axes_name mpsGraph  tensor axes name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr axes $ \raw_axes ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "expandDimsOfTensor:axes:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_axes :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates an expand-dimensions operation and returns the result tensor.
--
-- Expands the tensor, inserting dimensions with size 1 at specified axes.
--
-- - Parameters:   - tensor: The input tensor.   - axesTensor: The tensor containing the axes to expand.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- expandDimsOfTensor:axesTensor:name:@
expandDimsOfTensor_axesTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsMPSGraphTensor axesTensor, IsNSString name) => mpsGraph -> tensor -> axesTensor -> name -> IO (Id MPSGraphTensor)
expandDimsOfTensor_axesTensor_name mpsGraph  tensor axesTensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr axesTensor $ \raw_axesTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "expandDimsOfTensor:axesTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_axesTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a get-coordindate operation and returns the result tensor.
--
-- Creates a tensor of specified shape with value at index @[i_0, i_1, ... , i_N] = i_axis@ For example,  ```md  coordinateAlongAxis(0, withShape=[5]) = [0, 1, 2, 3, 4]  coordinateAlongAxis(0, withShape=[3,2]) = [[0, 0],                                            [1, 1],                                            [2, 2]] ```
--
-- - Parameters:   - axis: The coordinate axis an element's value is set to. Negative values wrap around.   - shape: The shape of the result tensor.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- coordinateAlongAxis:withShape:name:@
coordinateAlongAxis_withShape_name :: (IsMPSGraph mpsGraph, IsNSString name) => mpsGraph -> CLong -> RawId -> name -> IO (Id MPSGraphTensor)
coordinateAlongAxis_withShape_name mpsGraph  axis shape name =
  withObjCPtr name $ \raw_name ->
      sendMsg mpsGraph (mkSelector "coordinateAlongAxis:withShape:name:") (retPtr retVoid) [argCLong axis, argPtr (castPtr (unRawId shape) :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a get-coordindate operation and returns the result tensor.
--
-- See ``MPSGraph/coordinateAlongAxis:withShape:name:``.
--
-- - Parameters:   - axisTensor: A Scalar tensor of type @MPSDataTypeInt32@, that specifies the coordinate axis an element's value is set to. Negative values wrap around.   - shape: The shape of the result tensor.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- coordinateAlongAxisTensor:withShape:name:@
coordinateAlongAxisTensor_withShape_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor axisTensor, IsNSString name) => mpsGraph -> axisTensor -> RawId -> name -> IO (Id MPSGraphTensor)
coordinateAlongAxisTensor_withShape_name mpsGraph  axisTensor shape name =
  withObjCPtr axisTensor $ \raw_axisTensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "coordinateAlongAxisTensor:withShape:name:") (retPtr retVoid) [argPtr (castPtr raw_axisTensor :: Ptr ()), argPtr (castPtr (unRawId shape) :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a get-coordindate operation and returns the result tensor.
--
-- See ``coordinateAlongAxis:withShape:name:``.
--
-- - Parameters:   - axis: The coordinate axis an element's value is set to. Negative values wrap around.   - shapeTensor: A rank-1 tensor of type @MPSDataTypeInt32@ or @MPSDataTypeInt64@ that defines the shape of the result tensor.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- coordinateAlongAxis:withShapeTensor:name:@
coordinateAlongAxis_withShapeTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor shapeTensor, IsNSString name) => mpsGraph -> CLong -> shapeTensor -> name -> IO (Id MPSGraphTensor)
coordinateAlongAxis_withShapeTensor_name mpsGraph  axis shapeTensor name =
  withObjCPtr shapeTensor $ \raw_shapeTensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "coordinateAlongAxis:withShapeTensor:name:") (retPtr retVoid) [argCLong axis, argPtr (castPtr raw_shapeTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a get-coordindate operation and returns the result tensor.
--
-- See ``coordinateAlongAxis:withShape:name:``.
--
-- - Parameters:   - axisTensor: A Scalar tensor of type @MPSDataTypeInt32@, that specifies the coordinate axis an element's value is set to. Negative values wrap around.   - shapeTensor: A rank-1 tensor of type @MPSDataTypeInt32@ or @MPSDataTypeInt64@ that defines the shape of the result tensor.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- coordinateAlongAxisTensor:withShapeTensor:name:@
coordinateAlongAxisTensor_withShapeTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor axisTensor, IsMPSGraphTensor shapeTensor, IsNSString name) => mpsGraph -> axisTensor -> shapeTensor -> name -> IO (Id MPSGraphTensor)
coordinateAlongAxisTensor_withShapeTensor_name mpsGraph  axisTensor shapeTensor name =
  withObjCPtr axisTensor $ \raw_axisTensor ->
    withObjCPtr shapeTensor $ \raw_shapeTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "coordinateAlongAxisTensor:withShapeTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_axisTensor :: Ptr ()), argPtr (castPtr raw_shapeTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a stencil operation and returns the result tensor.
--
-- Performs a weighted reduction operation (See ``MPSGraphStencilOpDescriptor/reductionMode``) on the last 4 dimensions of the @source@ over the window determined by @weights@, according to the value defined in @descriptor@.  ```md     y[i] = reduction{j  w} ( x[ i + j ]w[j] ) ```
--
-- - Parameters:   - source: The tensor containing the source data. Must be of rank 4 or greater.   - weights: A 4-D tensor containing the weights data.   - descriptor: The descriptor object that specifies the parameters for the stencil operation.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- stencilWithSourceTensor:weightsTensor:descriptor:name:@
stencilWithSourceTensor_weightsTensor_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor source, IsMPSGraphTensor weights, IsMPSGraphStencilOpDescriptor descriptor, IsNSString name) => mpsGraph -> source -> weights -> descriptor -> name -> IO (Id MPSGraphTensor)
stencilWithSourceTensor_weightsTensor_descriptor_name mpsGraph  source weights descriptor name =
  withObjCPtr source $ \raw_source ->
    withObjCPtr weights $ \raw_weights ->
      withObjCPtr descriptor $ \raw_descriptor ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "stencilWithSourceTensor:weightsTensor:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_weights :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a sparse tensor representation.
--
-- sparseVals corresponds to non zero values in matrix.  indexTensor0 and indexTensor1 are indices used for indexing into sparse data structure.  For COO, indexTensor0 is x index and indexTensor1 is y index.  For CSC, indexTensor0 and indexTensor1 correspond to rowIndex and colStarts respectively.  For CSR, indexTensor0 and indexTensor1 correspond to colIndex and rowStarts respectively. You must set input tensors appropriately for each sparse storage type.
--
-- - Parameters:   - sparseStorageType: A sparseStorageType.   - inputTensorArray: An array of input tensors as [sparseVals, indexTensor0, indexTensor1].   - shape: The shape of the sparse tensor.   - dataType: The dataType of the sparse tensor.   - name: A name for the operation. - Returns: A valid ``MPSGraphTensor`` object.
--
-- ObjC selector: @- sparseTensorWithType:tensors:shape:dataType:name:@
sparseTensorWithType_tensors_shape_dataType_name :: (IsMPSGraph mpsGraph, IsNSArray inputTensorArray, IsNSString name) => mpsGraph -> MPSGraphSparseStorageType -> inputTensorArray -> RawId -> MPSDataType -> name -> IO (Id MPSGraphTensor)
sparseTensorWithType_tensors_shape_dataType_name mpsGraph  sparseStorageType inputTensorArray shape dataType name =
  withObjCPtr inputTensorArray $ \raw_inputTensorArray ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "sparseTensorWithType:tensors:shape:dataType:name:") (retPtr retVoid) [argCULong (coerce sparseStorageType), argPtr (castPtr raw_inputTensorArray :: Ptr ()), argPtr (castPtr (unRawId shape) :: Ptr ()), argCUInt (coerce dataType), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a sparse tensor representation.
--
-- sparseVals corresponds to non zero values in matrix.  indexTensor0 and indexTensor1 are indices used for indexing into sparse data structure.  For COO, indexTensor0 is x index and indexTensor1 is y index . For CSC, indexTensor0 and indexTensor1 correspond to rowIndex and colStarts respectively.  For CSR, indexTensor0 and indexTensor1 correspond to colIndex and rowStarts respectively. You must set input tensors appropriately for each sparse storage type.
--
-- - Parameters:   - sparseDescriptor: A sparseDescriptor.   - inputTensorArray: An array of input tensors as [sparseVals, indexTensor0, indexTensor1].   - shape: The shape of the sparse tensor.   - name: A name for the operation. - Returns: A valid ``MPSGraphTensor`` object
--
-- ObjC selector: @- sparseTensorWithDescriptor:tensors:shape:name:@
sparseTensorWithDescriptor_tensors_shape_name :: (IsMPSGraph mpsGraph, IsMPSGraphCreateSparseOpDescriptor sparseDescriptor, IsNSArray inputTensorArray, IsNSString name) => mpsGraph -> sparseDescriptor -> inputTensorArray -> RawId -> name -> IO (Id MPSGraphTensor)
sparseTensorWithDescriptor_tensors_shape_name mpsGraph  sparseDescriptor inputTensorArray shape name =
  withObjCPtr sparseDescriptor $ \raw_sparseDescriptor ->
    withObjCPtr inputTensorArray $ \raw_inputTensorArray ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "sparseTensorWithDescriptor:tensors:shape:name:") (retPtr retVoid) [argPtr (castPtr raw_sparseDescriptor :: Ptr ()), argPtr (castPtr raw_inputTensorArray :: Ptr ()), argPtr (castPtr (unRawId shape) :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Sorts the elements of the input tensor along the specified axis.
--
-- - Parameters:   - tensor: The input tensor   - axis: The tensor dimension over which you sort the tensor   - descending: If true, reverse the sort direction   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- sortWithTensor:axis:descending:name:@
sortWithTensor_axis_descending_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> CLong -> Bool -> name -> IO (Id MPSGraphTensor)
sortWithTensor_axis_descending_name mpsGraph  tensor axis descending name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "sortWithTensor:axis:descending:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argCLong axis, argCULong (if descending then 1 else 0), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Sorts the elements of the input tensor along the specified axis.
--
-- - Parameters:   - tensor: The input tensor   - axisTensor: The tensor dimension over which you sort the tensor   - descending: If true, reverse the sort direction   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- sortWithTensor:axisTensor:descending:name:@
sortWithTensor_axisTensor_descending_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsMPSGraphTensor axisTensor, IsNSString name) => mpsGraph -> tensor -> axisTensor -> Bool -> name -> IO (Id MPSGraphTensor)
sortWithTensor_axisTensor_descending_name mpsGraph  tensor axisTensor descending name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr axisTensor $ \raw_axisTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "sortWithTensor:axisTensor:descending:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_axisTensor :: Ptr ()), argCULong (if descending then 1 else 0), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Sorts the elements of the input tensor along the specified axis.
--
-- - Parameters:   - tensor: The input tensor   - axis: The tensor dimension over which you sort the tensor   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- sortWithTensor:axis:name:@
sortWithTensor_axis_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> CLong -> name -> IO (Id MPSGraphTensor)
sortWithTensor_axis_name mpsGraph  tensor axis name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "sortWithTensor:axis:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argCLong axis, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Sorts the elements of the input tensor along the specified axis.
--
-- - Parameters:   - tensor: The input tensor   - axisTensor: The tensor dimension over which you sort the tensor   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- sortWithTensor:axisTensor:name:@
sortWithTensor_axisTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsMPSGraphTensor axisTensor, IsNSString name) => mpsGraph -> tensor -> axisTensor -> name -> IO (Id MPSGraphTensor)
sortWithTensor_axisTensor_name mpsGraph  tensor axisTensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr axisTensor $ \raw_axisTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "sortWithTensor:axisTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_axisTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Computes the indices that sort the elements of the input tensor along the specified axis.
--
-- - Parameters:   - tensor: The input tensor   - axis: The tensor dimension over which you sort the tensor   - descending: If true, reverse the sort direction   - name: The name for the operation. - Returns: A valid MPSGraphTensor object with 32-bit integer data type
--
-- ObjC selector: @- argSortWithTensor:axis:descending:name:@
argSortWithTensor_axis_descending_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> CLong -> Bool -> name -> IO (Id MPSGraphTensor)
argSortWithTensor_axis_descending_name mpsGraph  tensor axis descending name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "argSortWithTensor:axis:descending:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argCLong axis, argCULong (if descending then 1 else 0), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Computes the indices that sort the elements of the input tensor along the specified axis.
--
-- - Parameters:   - tensor: The input tensor   - axisTensor: The tensor dimension over which you sort the tensor   - descending: If true, reverse the sort direction   - name: The name for the operation. - Returns: A valid MPSGraphTensor object with 32-bit integer data type
--
-- ObjC selector: @- argSortWithTensor:axisTensor:descending:name:@
argSortWithTensor_axisTensor_descending_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsMPSGraphTensor axisTensor, IsNSString name) => mpsGraph -> tensor -> axisTensor -> Bool -> name -> IO (Id MPSGraphTensor)
argSortWithTensor_axisTensor_descending_name mpsGraph  tensor axisTensor descending name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr axisTensor $ \raw_axisTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "argSortWithTensor:axisTensor:descending:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_axisTensor :: Ptr ()), argCULong (if descending then 1 else 0), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Computes the indices that sort the elements of the input tensor along the specified axis.
--
-- - Parameters:   - tensor: The input tensor   - axis: The tensor dimension over which you sort the tensor   - name: The name for the operation. - Returns: A valid MPSGraphTensor object with 32-bit integer data type
--
-- ObjC selector: @- argSortWithTensor:axis:name:@
argSortWithTensor_axis_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> CLong -> name -> IO (Id MPSGraphTensor)
argSortWithTensor_axis_name mpsGraph  tensor axis name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "argSortWithTensor:axis:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argCLong axis, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Computes the indices that sort the elements of the input tensor along the specified axis.
--
-- - Parameters:   - tensor: The input tensor   - axisTensor: The tensor dimension over which you sort the tensor   - name: The name for the operation. - Returns: A valid MPSGraphTensor object with 32-bit integer data type
--
-- ObjC selector: @- argSortWithTensor:axisTensor:name:@
argSortWithTensor_axisTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsMPSGraphTensor axisTensor, IsNSString name) => mpsGraph -> tensor -> axisTensor -> name -> IO (Id MPSGraphTensor)
argSortWithTensor_axisTensor_name mpsGraph  tensor axisTensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr axisTensor $ \raw_axisTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "argSortWithTensor:axisTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_axisTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a ScatterAlongAxis operation and returns the result tensor.
--
-- Scatter values from @updatesTensor@ along the specified @axis@ at indices in @indicesTensor@ into a result tensor.  Values are updated following @mode@. See MPSGraphScatterMode.  The shape of @updatesTensor@ and @indicesTensor@ must match. @shape@ must match except at @axis@.  The shape of the result tensor is equal to @shape@ and initialized with an initial value corresponding to @mode@.  If an index is out of bounds of @shape@ along @axis@ the update value is skipped.
--
-- - Parameters:   - axis: The axis to scatter to. Negative values wrap around   - updatesTensor: The input tensor to scatter values from   - indicesTensor: Int32 or Int64 tensor used to index the result tensor.   - mode: The type of update to use   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- scatterAlongAxis:withUpdatesTensor:indicesTensor:shape:mode:name:@
scatterAlongAxis_withUpdatesTensor_indicesTensor_shape_mode_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor updatesTensor, IsMPSGraphTensor indicesTensor, IsNSString name) => mpsGraph -> CLong -> updatesTensor -> indicesTensor -> RawId -> MPSGraphScatterMode -> name -> IO (Id MPSGraphTensor)
scatterAlongAxis_withUpdatesTensor_indicesTensor_shape_mode_name mpsGraph  axis updatesTensor indicesTensor shape mode name =
  withObjCPtr updatesTensor $ \raw_updatesTensor ->
    withObjCPtr indicesTensor $ \raw_indicesTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "scatterAlongAxis:withUpdatesTensor:indicesTensor:shape:mode:name:") (retPtr retVoid) [argCLong axis, argPtr (castPtr raw_updatesTensor :: Ptr ()), argPtr (castPtr raw_indicesTensor :: Ptr ()), argPtr (castPtr (unRawId shape) :: Ptr ()), argCLong (coerce mode), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a ScatterAlongAxis operation and returns the result tensor.
--
-- Scatter values from @updatesTensor@ along the specified @axis@ at indices in @indicesTensor@ into a result tensor. Values are updated following @mode@. See MPSGraphScatterMode. The shape of @updatesTensor@ and @indicesTensor@ must match. @shape@ must match except at @axis@. The shape of the result tensor is equal to @shape@ and initialized with an initial value corresponding to @mode@. If an index is out of bounds of @shape@ along @axis@ the update value is skipped.
--
-- - Parameters:   - axisTensor: Scalar Int32 tensor. The axis to scatter to. Negative values wrap around   - updatesTensor: The input tensor to scatter values from   - indicesTensor: Int32 or Int64 tensor used to index the result tensor.   - mode: The type of update to use   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- scatterAlongAxisTensor:withUpdatesTensor:indicesTensor:shape:mode:name:@
scatterAlongAxisTensor_withUpdatesTensor_indicesTensor_shape_mode_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor axisTensor, IsMPSGraphTensor updatesTensor, IsMPSGraphTensor indicesTensor, IsNSString name) => mpsGraph -> axisTensor -> updatesTensor -> indicesTensor -> RawId -> MPSGraphScatterMode -> name -> IO (Id MPSGraphTensor)
scatterAlongAxisTensor_withUpdatesTensor_indicesTensor_shape_mode_name mpsGraph  axisTensor updatesTensor indicesTensor shape mode name =
  withObjCPtr axisTensor $ \raw_axisTensor ->
    withObjCPtr updatesTensor $ \raw_updatesTensor ->
      withObjCPtr indicesTensor $ \raw_indicesTensor ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "scatterAlongAxisTensor:withUpdatesTensor:indicesTensor:shape:mode:name:") (retPtr retVoid) [argPtr (castPtr raw_axisTensor :: Ptr ()), argPtr (castPtr raw_updatesTensor :: Ptr ()), argPtr (castPtr raw_indicesTensor :: Ptr ()), argPtr (castPtr (unRawId shape) :: Ptr ()), argCLong (coerce mode), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a ScatterAlongAxis operation and returns the result tensor.
--
-- Scatter values from @updatesTensor@ along the specified @axis@ at indices in @indicesTensor@ onto @dataTensor@.  Values in @dataTensor@ are updated following @mode@. See MPSGraphScatterMode.  The shape of @updatesTensor@ and @indicesTensor@ must match. The shape of @dataTensor@ must match except at @axis@.  If an index is out of bounds of @shape@ along @axis@ the update value is skipped.  For example,  ```md data = [ [0, 0, 0],          [1, 1, 1],          [2, 2, 2],          [3, 3, 3] ] updates = [ [1, 2, 3],             [4, 5, 6] ] indices = [ [2, 1, 0],             [1, 3, 2] ] axis = 0 result = scatterAlongAxis(axis, data, updates, indices, MPSGraphScatterModeAdd, "scatter") result = [ [0, 0, 3],            [5, 3, 1],            [3, 2, 8],            [3, 8, 3] ] ```
--
-- - Parameters:   - axis: The axis to scatter to. Negative values wrap around   - dataTensor: The input tensor to scatter values onto   - updatesTensor: The input tensor to scatter values from   - indicesTensor: Int32 or Int64 tensor used to index the result tensor.   - mode: The type of update to use   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- scatterAlongAxis:withDataTensor:updatesTensor:indicesTensor:mode:name:@
scatterAlongAxis_withDataTensor_updatesTensor_indicesTensor_mode_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor dataTensor, IsMPSGraphTensor updatesTensor, IsMPSGraphTensor indicesTensor, IsNSString name) => mpsGraph -> CLong -> dataTensor -> updatesTensor -> indicesTensor -> MPSGraphScatterMode -> name -> IO (Id MPSGraphTensor)
scatterAlongAxis_withDataTensor_updatesTensor_indicesTensor_mode_name mpsGraph  axis dataTensor updatesTensor indicesTensor mode name =
  withObjCPtr dataTensor $ \raw_dataTensor ->
    withObjCPtr updatesTensor $ \raw_updatesTensor ->
      withObjCPtr indicesTensor $ \raw_indicesTensor ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "scatterAlongAxis:withDataTensor:updatesTensor:indicesTensor:mode:name:") (retPtr retVoid) [argCLong axis, argPtr (castPtr raw_dataTensor :: Ptr ()), argPtr (castPtr raw_updatesTensor :: Ptr ()), argPtr (castPtr raw_indicesTensor :: Ptr ()), argCLong (coerce mode), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a ScatterAlongAxis operation and returns the result tensor.
--
-- Scatter values from @updatesTensor@ along the specified @axis@ at indices in @indicesTensor@ onto @dataTensor@. Values in @dataTensor@ are updated following @mode@. See MPSGraphScatterMode. The shape of @updatesTensor@ and @indicesTensor@ must match. The shape of @dataTensor@ must match except at @axis@. If an index is out of bounds of @shape@ along @axis@ the update value is skipped. For example, ```md data = [ [0, 0, 0],          [1, 1, 1],          [2, 2, 2],          [3, 3, 3] ] updates = [ [1, 2, 3],             [4, 5, 6] ] indices = [ [2, 1, 0],             [1, 3, 2] ] axis = 0 result = scatterAlongAxis(axis, data, updates, indices, MPSGraphScatterModeAdd, "scatter") result = [ [0, 0, 3],            [5, 3, 1],            [3, 2, 8],            [3, 8, 3] ] ```
--
-- - Parameters:   - axisTensor: Scalar Int32 tensor. The axis to scatter to. Negative values wrap around   - dataTensor: The input tensor to scatter values onto   - updatesTensor: The input tensor to scatter values from   - indicesTensor: Int32 or Int64 tensor used to index the result tensor.   - mode: The type of update to use   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- scatterAlongAxisTensor:withDataTensor:updatesTensor:indicesTensor:mode:name:@
scatterAlongAxisTensor_withDataTensor_updatesTensor_indicesTensor_mode_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor axisTensor, IsMPSGraphTensor dataTensor, IsMPSGraphTensor updatesTensor, IsMPSGraphTensor indicesTensor, IsNSString name) => mpsGraph -> axisTensor -> dataTensor -> updatesTensor -> indicesTensor -> MPSGraphScatterMode -> name -> IO (Id MPSGraphTensor)
scatterAlongAxisTensor_withDataTensor_updatesTensor_indicesTensor_mode_name mpsGraph  axisTensor dataTensor updatesTensor indicesTensor mode name =
  withObjCPtr axisTensor $ \raw_axisTensor ->
    withObjCPtr dataTensor $ \raw_dataTensor ->
      withObjCPtr updatesTensor $ \raw_updatesTensor ->
        withObjCPtr indicesTensor $ \raw_indicesTensor ->
          withObjCPtr name $ \raw_name ->
              sendMsg mpsGraph (mkSelector "scatterAlongAxisTensor:withDataTensor:updatesTensor:indicesTensor:mode:name:") (retPtr retVoid) [argPtr (castPtr raw_axisTensor :: Ptr ()), argPtr (castPtr raw_dataTensor :: Ptr ()), argPtr (castPtr raw_updatesTensor :: Ptr ()), argPtr (castPtr raw_indicesTensor :: Ptr ()), argCLong (coerce mode), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a Scatter operation and returns the result tensor.
--
-- Scatters the slices in updatesTensor to the result tensor along the indices in indicesTensor.  The scatter is defined as  ```md  U = updates.rank  P = res.rank  res[i_{0},...,i_{axis-1},indices[i_{axis}],i_{axis+1},...,i_{U-1}] = updates[i_{0},...,i_{axis-1},i_{axis},i_{axis+1},...,i_{U-1}]  ```  Collisions will be updated according to mode. The tensors have the following shape requirements ```md  U = P  indices.rank = 1  updates.shape[0:axis-1] = res.shape[0:axis-1]  updates.shape[axis] = indices.shape[0]  updates.shape[axis+1:U] = res.shape[0:P]  ```
--
-- - Parameters:   - updatesTensor: Tensor containing values to be inserted into the result tensor.   - indicesTensor: Tensor containg the result indices to insert values at.   - shape: The shape of the result tensor.   - axis: The axis of the result tensor to scatter values along.   - mode: The type of update to use on the destination.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- scatterWithUpdatesTensor:indicesTensor:shape:axis:mode:name:@
scatterWithUpdatesTensor_indicesTensor_shape_axis_mode_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor updatesTensor, IsMPSGraphTensor indicesTensor, IsNSString name) => mpsGraph -> updatesTensor -> indicesTensor -> RawId -> CLong -> MPSGraphScatterMode -> name -> IO (Id MPSGraphTensor)
scatterWithUpdatesTensor_indicesTensor_shape_axis_mode_name mpsGraph  updatesTensor indicesTensor shape axis mode name =
  withObjCPtr updatesTensor $ \raw_updatesTensor ->
    withObjCPtr indicesTensor $ \raw_indicesTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "scatterWithUpdatesTensor:indicesTensor:shape:axis:mode:name:") (retPtr retVoid) [argPtr (castPtr raw_updatesTensor :: Ptr ()), argPtr (castPtr raw_indicesTensor :: Ptr ()), argPtr (castPtr (unRawId shape) :: Ptr ()), argCLong axis, argCLong (coerce mode), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a Scatter operation and returns the result tensor.
--
-- Scatters the slices in updatesTensor to the result tensor along the indices in indicesTensor, on top of dataTensor.  The scatter is defined as  ```md  U = updates.rank  P = res.rank  res[...] = data[...]  res[i_{0},...,i_{axis-1},indices[i_{axis}],i_{axis+1},...,i_{U-1}] += updates[i_{0},...,i_{axis-1},i_{axis},i_{axis+1},...,i_{U-1}] // Note += is used but this depends on mode  ```  Collisions will be updated according to mode. The tensors have the following shape requirements ```md  U = P  indices.rank = 1  data.shape = res.shape  updates.shape[0:axis-1] = res.shape[0:axis-1]  updates.shape[axis] = indices.shape[0]  updates.shape[axis+1:U] = res.shape[0:P]  ```
--
-- - Parameters:   - dataTensor: Tensor containing inital values of same shape as result tensor   - updatesTensor: Tensor containing values to be inserted into the result tensor.   - indicesTensor: Tensor containg the result indices to insert values at   - axis: The axis of the result tensor to scatter values along   - mode: The type of update to use on the destination   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- scatterWithDataTensor:updatesTensor:indicesTensor:axis:mode:name:@
scatterWithDataTensor_updatesTensor_indicesTensor_axis_mode_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor dataTensor, IsMPSGraphTensor updatesTensor, IsMPSGraphTensor indicesTensor, IsNSString name) => mpsGraph -> dataTensor -> updatesTensor -> indicesTensor -> CLong -> MPSGraphScatterMode -> name -> IO (Id MPSGraphTensor)
scatterWithDataTensor_updatesTensor_indicesTensor_axis_mode_name mpsGraph  dataTensor updatesTensor indicesTensor axis mode name =
  withObjCPtr dataTensor $ \raw_dataTensor ->
    withObjCPtr updatesTensor $ \raw_updatesTensor ->
      withObjCPtr indicesTensor $ \raw_indicesTensor ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "scatterWithDataTensor:updatesTensor:indicesTensor:axis:mode:name:") (retPtr retVoid) [argPtr (castPtr raw_dataTensor :: Ptr ()), argPtr (castPtr raw_updatesTensor :: Ptr ()), argPtr (castPtr raw_indicesTensor :: Ptr ()), argCLong axis, argCLong (coerce mode), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a ScatterND operation and returns the result tensor.
--
-- Scatters the slices in updatesTensor to the result tensor along the indices in indicesTensor.  The scatter is defined as  ```md  B = batchDims  U = updates.rank - B  P = res.rank - B  Q = inds.rank - B  K = inds.shape[-1]  index_slice = indices[i_{b0},...,i_{bB},i_{0},..,i_{Q-1}]  res[i_{b0},...,i_{bB},index_slice[0],...,index_slice[K-1]] = updates[i_{b0},...,i_{bB},i_{0},...,i_{Q-1}]  ```  Collisions will be summed, and slices not set by indices are set to 0. The tensors have the following shape requirements ```md  K <= P  U = (P-K) + Q-1  indices.shape[0:Q-1] = updates.shape[0:Q-1]  updates.shape[Q:U] = res.shape[K:P]  ```
--
-- - Parameters:   - updatesTensor: Tensor containing slices to be inserted into the result tensor.   - indicesTensor: Tensor containg the result indices to insert slices at   - shape: The shape of the result tensor.   - batchDimensions: The number of batch dimensions   - mode: The type of update to use on the destination   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- scatterNDWithUpdatesTensor:indicesTensor:shape:batchDimensions:mode:name:@
scatterNDWithUpdatesTensor_indicesTensor_shape_batchDimensions_mode_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor updatesTensor, IsMPSGraphTensor indicesTensor, IsNSString name) => mpsGraph -> updatesTensor -> indicesTensor -> RawId -> CULong -> MPSGraphScatterMode -> name -> IO (Id MPSGraphTensor)
scatterNDWithUpdatesTensor_indicesTensor_shape_batchDimensions_mode_name mpsGraph  updatesTensor indicesTensor shape batchDimensions mode name =
  withObjCPtr updatesTensor $ \raw_updatesTensor ->
    withObjCPtr indicesTensor $ \raw_indicesTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "scatterNDWithUpdatesTensor:indicesTensor:shape:batchDimensions:mode:name:") (retPtr retVoid) [argPtr (castPtr raw_updatesTensor :: Ptr ()), argPtr (castPtr raw_indicesTensor :: Ptr ()), argPtr (castPtr (unRawId shape) :: Ptr ()), argCULong batchDimensions, argCLong (coerce mode), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a ScatterND operation and returns the result tensor.
--
-- Scatters the slices in updatesTensor to the result tensor along the indices in indicesTensor.  The scatter is defined as  ```md  B = batchDims  U = updates.rank - B  P = res.rank - B  Q = inds.rank - B  K = inds.shape[-1]  index_slice = indices[i_{b0},...,i_{bB},i_{0},..,i_{Q-1}]  res[i_{b0},...,i_{bB},index_slice[0],...,index_slice[K-1]] = updates[i_{b0},...,i_{bB},i_{0},...,i_{Q-1}]  ```  Collisions will be summed, and slices not set by indices are set to 0. The tensors have the following shape requirements ```md  K <= P  U = (P-K) + Q-1  indices.shape[0:Q-1] = updates.shape[0:Q-1]  updates.shape[Q:U] = res.shape[K:P]  ```
--
-- - Parameters:   - updatesTensor: Tensor containing slices to be inserted into the result tensor.   - indicesTensor: Tensor containg the result indices to insert slices at   - shape: The shape of the result tensor.   - batchDimensions: The number of batch dimensions   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- scatterNDWithUpdatesTensor:indicesTensor:shape:batchDimensions:name:@
scatterNDWithUpdatesTensor_indicesTensor_shape_batchDimensions_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor updatesTensor, IsMPSGraphTensor indicesTensor, IsNSString name) => mpsGraph -> updatesTensor -> indicesTensor -> RawId -> CULong -> name -> IO (Id MPSGraphTensor)
scatterNDWithUpdatesTensor_indicesTensor_shape_batchDimensions_name mpsGraph  updatesTensor indicesTensor shape batchDimensions name =
  withObjCPtr updatesTensor $ \raw_updatesTensor ->
    withObjCPtr indicesTensor $ \raw_indicesTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "scatterNDWithUpdatesTensor:indicesTensor:shape:batchDimensions:name:") (retPtr retVoid) [argPtr (castPtr raw_updatesTensor :: Ptr ()), argPtr (castPtr raw_indicesTensor :: Ptr ()), argPtr (castPtr (unRawId shape) :: Ptr ()), argCULong batchDimensions, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a ScatterND operation and returns the result tensor.
--
-- Scatters the slices in updatesTensor to the result tensor along the indices in indicesTensor, on top of dataTensor.  The scatter is defined as  ```md  B = batchDims  U = updates.rank - B  P = res.rank - B  Q = inds.rank - B  K = inds.shape[-1]  index_slice = indices[i_{b0},...,i_{bB},i_{0},..,i_{Q-1}]  res[...] = data[...]  res[i_{b0},...,i_{bB},index_slice[0],...,index_slice[K-1]] += updates[i_{b0},...,i_{bB},i_{0},...,i_{Q-1}] // Note += is used but this depends on mode  ```  Collisions will be updated according to mode, and slices not set by indices are set to 0. The tensors have the following shape requirements ```md  K <= P  U = (P-K) + Q-1  data.shape = res.shape  indices.shape[0:Q-1] = updates.shape[0:Q-1]  updates.shape[Q:U] = res.shape[K:P]  ```
--
-- - Parameters:   - dataTensor: Tensor containing inital values of same shape as result tensor   - updatesTensor: Tensor containing slices to be inserted into the result tensor.   - indicesTensor: Tensor containg the result indices to insert slices at   - batchDimensions: The number of batch dimensions   - mode: The type of update to use on the destination   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- scatterNDWithDataTensor:updatesTensor:indicesTensor:batchDimensions:mode:name:@
scatterNDWithDataTensor_updatesTensor_indicesTensor_batchDimensions_mode_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor dataTensor, IsMPSGraphTensor updatesTensor, IsMPSGraphTensor indicesTensor, IsNSString name) => mpsGraph -> dataTensor -> updatesTensor -> indicesTensor -> CULong -> MPSGraphScatterMode -> name -> IO (Id MPSGraphTensor)
scatterNDWithDataTensor_updatesTensor_indicesTensor_batchDimensions_mode_name mpsGraph  dataTensor updatesTensor indicesTensor batchDimensions mode name =
  withObjCPtr dataTensor $ \raw_dataTensor ->
    withObjCPtr updatesTensor $ \raw_updatesTensor ->
      withObjCPtr indicesTensor $ \raw_indicesTensor ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "scatterNDWithDataTensor:updatesTensor:indicesTensor:batchDimensions:mode:name:") (retPtr retVoid) [argPtr (castPtr raw_dataTensor :: Ptr ()), argPtr (castPtr raw_updatesTensor :: Ptr ()), argPtr (castPtr raw_indicesTensor :: Ptr ()), argCULong batchDimensions, argCLong (coerce mode), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Samples a tensor using the coordinates provided.
--
-- Given an input tensor (N, H1, W1, C) or (N, C, H1, W1) and coordinates tensor (N, H2, W2, 2) this operation outputs a tensor of  size (N, H2, W2, C) or (N, C, H2, W2) by sampling the input tensor at the coordinates provided by the coordinates tensor.
--
-- - Parameters:   - source: Tensor containing source data   - coordinates: a tensor (N, Hout, Wout, 2) that contains the coordinates of the samples in the source tensor that constitute the output tensor.   - layout: Specifies what layout the provided tensor is in. The returned tensor will follow the same layout. Valid layouts are NHWC and NCHW.   - normalizeCoordinates: If true, coordinates are within [-1, 1] x [-1, 1] otherwise they are in pixels in the input tensor.   - relativeCoordinates: If true, coordinates are relative to the postion of the pixel in the output tensor and scaled back to the input tensor size   - alignCorners: If true, coordinate extrema are equal to the center of edge pixels, otherwise extrema are equal to outer edge of edge pixels   - paddingMode: determines how samples outside the inputTensor are evaluated (only constant, reflect, symmetric and clampToEdge are supported)   - samplingMode: Can be either MPSGraphResizeNearest or MPSGraphResizeBilinear. Nearest sampling will use roundPreferCeil.   - constantValue: If paddingMode is MPSGraphPaddingModeConstant, then this constant is used for samples outside the input tensor.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- sampleGridWithSourceTensor:coordinateTensor:layout:normalizeCoordinates:relativeCoordinates:alignCorners:paddingMode:samplingMode:constantValue:name:@
sampleGridWithSourceTensor_coordinateTensor_layout_normalizeCoordinates_relativeCoordinates_alignCorners_paddingMode_samplingMode_constantValue_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor source, IsMPSGraphTensor coordinates, IsNSString name) => mpsGraph -> source -> coordinates -> MPSGraphTensorNamedDataLayout -> Bool -> Bool -> Bool -> MPSGraphPaddingMode -> MPSGraphResizeMode -> CDouble -> name -> IO (Id MPSGraphTensor)
sampleGridWithSourceTensor_coordinateTensor_layout_normalizeCoordinates_relativeCoordinates_alignCorners_paddingMode_samplingMode_constantValue_name mpsGraph  source coordinates layout normalizeCoordinates relativeCoordinates alignCorners paddingMode samplingMode constantValue name =
  withObjCPtr source $ \raw_source ->
    withObjCPtr coordinates $ \raw_coordinates ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "sampleGridWithSourceTensor:coordinateTensor:layout:normalizeCoordinates:relativeCoordinates:alignCorners:paddingMode:samplingMode:constantValue:name:") (retPtr retVoid) [argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_coordinates :: Ptr ()), argCULong (coerce layout), argCULong (if normalizeCoordinates then 1 else 0), argCULong (if relativeCoordinates then 1 else 0), argCULong (if alignCorners then 1 else 0), argCLong (coerce paddingMode), argCULong (coerce samplingMode), argCDouble constantValue, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Samples a tensor using the coordinates provided, using nearest neighbor sampling with specified rounding mode.
--
-- Given an input tensor (N, H1, W1, C) or (N, C, H1, W1) and coordinates tensor (N, H2, W2, 2) this operation outputs a tensor of  size (N, H2, W2, C) or (N, C, H2, W2) by sampling the input tensor at the coordinates provided by the coordinates tensor.
--
-- - Parameters:   - source: Tensor containing source data   - coordinates: a tensor (N, Hout, Wout, 2) that contains the coordinates of the samples in the source tensor that constitute the output tensor.   - layout: Specifies what layout the provided tensor is in. The returned tensor will follow the same layout. Valid layouts are NHWC and NCHW.   - normalizeCoordinates: If true, coordinates are within [-1, 1] x [-1, 1] otherwise they are in pixels in the input tensor.   - relativeCoordinates: If true, coordinates are relative to the postion of the pixel in the output tensor and scaled back to the input tensor size   - alignCorners: If true, coordinate extrema are equal to the center of edge pixels, otherwise extrema are equal to outer edge of edge pixels   - paddingMode: determines how samples outside the inputTensor are evaluated (only constant, reflect, symmetric and clampToEdge are supported)   - nearestRoundingMode: The rounding mode to use for determining the nearest neighbor. Valid modes are roundPreferCeil, roundPreferFloor, ceil, and floor.   - constantValue: If paddingMode is MPSGraphPaddingModeConstant, then this constant is used for samples outside the input tensor.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- sampleGridWithSourceTensor:coordinateTensor:layout:normalizeCoordinates:relativeCoordinates:alignCorners:paddingMode:nearestRoundingMode:constantValue:name:@
sampleGridWithSourceTensor_coordinateTensor_layout_normalizeCoordinates_relativeCoordinates_alignCorners_paddingMode_nearestRoundingMode_constantValue_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor source, IsMPSGraphTensor coordinates, IsNSString name) => mpsGraph -> source -> coordinates -> MPSGraphTensorNamedDataLayout -> Bool -> Bool -> Bool -> MPSGraphPaddingMode -> MPSGraphResizeNearestRoundingMode -> CDouble -> name -> IO (Id MPSGraphTensor)
sampleGridWithSourceTensor_coordinateTensor_layout_normalizeCoordinates_relativeCoordinates_alignCorners_paddingMode_nearestRoundingMode_constantValue_name mpsGraph  source coordinates layout normalizeCoordinates relativeCoordinates alignCorners paddingMode nearestRoundingMode constantValue name =
  withObjCPtr source $ \raw_source ->
    withObjCPtr coordinates $ \raw_coordinates ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "sampleGridWithSourceTensor:coordinateTensor:layout:normalizeCoordinates:relativeCoordinates:alignCorners:paddingMode:nearestRoundingMode:constantValue:name:") (retPtr retVoid) [argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_coordinates :: Ptr ()), argCULong (coerce layout), argCULong (if normalizeCoordinates then 1 else 0), argCULong (if relativeCoordinates then 1 else 0), argCULong (if alignCorners then 1 else 0), argCLong (coerce paddingMode), argCULong (coerce nearestRoundingMode), argCDouble constantValue, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a single-gate RNN operation and returns the value and optionally the training state tensor.
--
-- This operation returns tensors @h@ and optionally @z@ that are defined recursively as follows:  ```md  for t = 0 to T-1    z[t] = x[t] W^T + (h[t-1]m) R^T + b   h[t] = activation( z[t] ), where ```  @W@ is optional @inputWeight@, @R@ is @recurrentWeight@, @b@ is @bias@, @m@ is optional @mask@, @x[t]@ is @source@ @h[t]@ is the first output, @z[t]@ is the second output (optional) and @h[-1]@ is @initState@.  See ``MPSGraphSingleGateRNNDescriptor`` for different @activation@ options.
--
-- - Parameters:   - source: A tensor that contains the source data @x[t]@ with the data layout [T,N,I].             In case @inputWeight = nil@ and @bidirectional = NO@ then the layout is [T,N,H] and             for @inputWeight = nil@ and @bidirectional = YES@ the layout is [T,N,2H].   - recurrentWeight: A tensor containing the recurrent weights @R@. For @bidirectional@ the layout is [2,H,H] and otherwise it is [H,H].   - inputWeight: A tensor containing the input weights matrix @W@ - optional, if missing the operation assumes a diagonal unit-matrix.                  For @bidirectional@ the layout is [2H,I] and otherwise it is [H,I].   - bias: A tensor containing the bias @b@ - optional, if missing the operation assumes zeroes. For @bidirectional@ the layout is [2H] and otherwise it is [H].   - initState: The initial internal state of the RNN @h[-1]@ - optional, if missing the operation assumes zeroes. For @bidirectional@ the layout is [N,2H] and otherwise it is [N,H].   - mask: A tensor containing the mask @m@ - optional, if missing the operation assumes ones. This is useful for dropout support.   - descriptor: A descriptor that defines the parameters for the RNN operation.   - name: The name for the operation. - Returns: A valid MPSGraphTensor array of size 1 or 2, depending on value of @descriptor.training@. The layout of the both outputs is [T,N,H] or [T,N,2H] for bidirectional.
--
-- ObjC selector: @- singleGateRNNWithSourceTensor:recurrentWeight:inputWeight:bias:initState:mask:descriptor:name:@
singleGateRNNWithSourceTensor_recurrentWeight_inputWeight_bias_initState_mask_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor source, IsMPSGraphTensor recurrentWeight, IsMPSGraphTensor inputWeight, IsMPSGraphTensor bias, IsMPSGraphTensor initState, IsMPSGraphTensor mask, IsMPSGraphSingleGateRNNDescriptor descriptor, IsNSString name) => mpsGraph -> source -> recurrentWeight -> inputWeight -> bias -> initState -> mask -> descriptor -> name -> IO (Id NSArray)
singleGateRNNWithSourceTensor_recurrentWeight_inputWeight_bias_initState_mask_descriptor_name mpsGraph  source recurrentWeight inputWeight bias initState mask descriptor name =
  withObjCPtr source $ \raw_source ->
    withObjCPtr recurrentWeight $ \raw_recurrentWeight ->
      withObjCPtr inputWeight $ \raw_inputWeight ->
        withObjCPtr bias $ \raw_bias ->
          withObjCPtr initState $ \raw_initState ->
            withObjCPtr mask $ \raw_mask ->
              withObjCPtr descriptor $ \raw_descriptor ->
                withObjCPtr name $ \raw_name ->
                    sendMsg mpsGraph (mkSelector "singleGateRNNWithSourceTensor:recurrentWeight:inputWeight:bias:initState:mask:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_recurrentWeight :: Ptr ()), argPtr (castPtr raw_inputWeight :: Ptr ()), argPtr (castPtr raw_bias :: Ptr ()), argPtr (castPtr raw_initState :: Ptr ()), argPtr (castPtr raw_mask :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a single-gate RNN operation and returns the value and optionally the training state tensor.
--
-- This operation returns tensors @h@ and optionally @z@ that are defined recursively as follows: ```md for t = 0 to T-1   z[t] = x[t] W^T + (h[t-1]m) R^T + b   h[t] = activation( z[t] ), where ``` @W@ is optional @inputWeight@, @R@ is @recurrentWeight@, @b@ is @bias@, @m@ is optional @mask@, @x[t]@ is @source@ @h[t]@ is the first output, @z[t]@ is the second output (optional) and @h[-1]@ is @initState@.  See ``MPSGraphSingleGateRNNDescriptor`` for different @activation@ options.
--
-- - Parameters:   - source: A tensor that contains the source data @x[t]@ with the data layout [T,N,I].             In case @inputWeight = nil@ and @bidirectional = NO@ then the layout is [T,N,H] and             for @inputWeight = nil@ and @bidirectional = YES@ the layout is [T,N,2H].   - recurrentWeight: A tensor containing the recurrent weights @R@. For @bidirectional@ the layout is [2,H,H] and otherwise it is [H,H].   - inputWeight: A tensor containing the input weights matrix @W@ - optional, if missing the operation assumes a diagonal unit-matrix.                  For @bidirectional@ the layout is [2H,I] and otherwise it is [H,I].   - bias: A tensor containing the bias @b@ - optional, if missing the operation assumes zeroes. For @bidirectional@ the layout is [2H] and otherwise it is [H].   - initState: The initial internal state of the RNN @h[-1]@ - optional, if missing the operation assumes zeroes. For @bidirectional@ the layout is [N,2H] and otherwise it is [N,H].   - descriptor: A descriptor that defines the parameters for the RNN operation.   - name: The name for the operation. - Returns: A valid MPSGraphTensor array of size 1 or 2, depending on value of @descriptor.training@. The layout of the both outputs is [T,N,H] or [T,N,2H] for bidirectional.
--
-- ObjC selector: @- singleGateRNNWithSourceTensor:recurrentWeight:inputWeight:bias:initState:descriptor:name:@
singleGateRNNWithSourceTensor_recurrentWeight_inputWeight_bias_initState_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor source, IsMPSGraphTensor recurrentWeight, IsMPSGraphTensor inputWeight, IsMPSGraphTensor bias, IsMPSGraphTensor initState, IsMPSGraphSingleGateRNNDescriptor descriptor, IsNSString name) => mpsGraph -> source -> recurrentWeight -> inputWeight -> bias -> initState -> descriptor -> name -> IO (Id NSArray)
singleGateRNNWithSourceTensor_recurrentWeight_inputWeight_bias_initState_descriptor_name mpsGraph  source recurrentWeight inputWeight bias initState descriptor name =
  withObjCPtr source $ \raw_source ->
    withObjCPtr recurrentWeight $ \raw_recurrentWeight ->
      withObjCPtr inputWeight $ \raw_inputWeight ->
        withObjCPtr bias $ \raw_bias ->
          withObjCPtr initState $ \raw_initState ->
            withObjCPtr descriptor $ \raw_descriptor ->
              withObjCPtr name $ \raw_name ->
                  sendMsg mpsGraph (mkSelector "singleGateRNNWithSourceTensor:recurrentWeight:inputWeight:bias:initState:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_recurrentWeight :: Ptr ()), argPtr (castPtr raw_inputWeight :: Ptr ()), argPtr (castPtr raw_bias :: Ptr ()), argPtr (castPtr raw_initState :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a single-gate RNN operation and returns the value and optionally the training state tensor.
--
-- This operation returns tensors @h@ and optionally @z@ that are defined recursively as follows: ```md for t = 0 to T-1   z[t] = x[t] W^T + (h[t-1]m) R^T + b   h[t] = activation( z[t] ), where ``` @W@ is optional @inputWeight@, @R@ is @recurrentWeight@, @b@ is @bias@, @m@ is optional @mask@, @x[t]@ is @source@ @h[t]@ is the first output, @z[t]@ is the second output (optional) and @h[-1]@ is @initState@.  See ``MPSGraphSingleGateRNNDescriptor`` for different @activation@ options.
--
-- - Parameters:   - source: A tensor that contains the source data @x[t]@ with the data layout [T,N,I].             In case @inputWeight = nil@ and @bidirectional = NO@ then the layout is [T,N,H] and             for @inputWeight = nil@ and @bidirectional = YES@ the layout is [T,N,2H].   - recurrentWeight: A tensor containing the recurrent weights @R@. For @bidirectional@ the layout is [2,H,H] and otherwise it is [H,H].   - initState: The initial internal state of the RNN @h[-1]@ - optional, if missing the operation assumes zeroes. For @bidirectional@ the layout is [N,2H] and otherwise it is [N,H].   - descriptor: A descriptor that defines the parameters for the RNN operation.   - name: The name for the operation. - Returns: A valid MPSGraphTensor array of size 1 or 2, depending on value of @descriptor.training@. The layout of the both outputs is [T,N,H] or [T,N,2H] for bidirectional.
--
-- ObjC selector: @- singleGateRNNWithSourceTensor:recurrentWeight:initState:descriptor:name:@
singleGateRNNWithSourceTensor_recurrentWeight_initState_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor source, IsMPSGraphTensor recurrentWeight, IsMPSGraphTensor initState, IsMPSGraphSingleGateRNNDescriptor descriptor, IsNSString name) => mpsGraph -> source -> recurrentWeight -> initState -> descriptor -> name -> IO (Id NSArray)
singleGateRNNWithSourceTensor_recurrentWeight_initState_descriptor_name mpsGraph  source recurrentWeight initState descriptor name =
  withObjCPtr source $ \raw_source ->
    withObjCPtr recurrentWeight $ \raw_recurrentWeight ->
      withObjCPtr initState $ \raw_initState ->
        withObjCPtr descriptor $ \raw_descriptor ->
          withObjCPtr name $ \raw_name ->
              sendMsg mpsGraph (mkSelector "singleGateRNNWithSourceTensor:recurrentWeight:initState:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_recurrentWeight :: Ptr ()), argPtr (castPtr raw_initState :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a single-gate RNN gradient operation and returns the gradient tensor values.
--
-- For details of this operation and parameters, refer to documentation of ``MPSGraph/singleGateRNNWithSourceTensor:recurrentWeight:inputWeight:bias:initState:mask:descriptor:name:``.
--
-- - Parameters:   - source: A tensor that contains the source data @x[t]@ with the data layout [T,N,I].             In case @inputWeight = nil@ and @bidirectional = NO@ then the layout is [T,N,H] and             for @inputWeight = nil@ and @bidirectional = YES@ the layout is [T,N,2H].   - recurrentWeight: A tensor containing the recurrent weights @R@. For @bidirectional@ the layout is [2,H,H] and otherwise it is [H,H].                 Note: For @bidirectional@ this tensor must have a static shape.   - sourceGradient: The input gradient, that is the gradient of a tensor with respect to the first output of the forward pass.   - zState: The second output of             ``MPSGraph/singleGateRNNWithSourceTensor:recurrentWeight:inputWeight:bias:initState:mask:descriptor:name:``             with @descriptor.training = YES@.   - stateGradient: The input gradient coming from the future timestep - optional, if missing the operation assumes zeroes.   - inputWeight: A tensor containing the input weights matrix @W@ - optional, if missing the operation assumes a diagonal unit-matrix.                  For @bidirectional@ the layout is [2H,I] and otherwise it is [H,I].   - bias: A tensor containing the bias @b@ - optional, if missing the operation assumes zeroes. For @bidirectional@ the layout is [2H] and otherwise it is [H].   - initState: The initial internal state of the RNN @h[-1]@ - optional, if missing the operation assumes zeroes. For @bidirectional@ the layout is [N,2H] and otherwise it is [N,H].   - mask: A tensor containing the mask @m@ - optional, if missing the operation assumes ones. This is useful for dropout support.   - descriptor: A descriptor that defines the parameters for the RNN operation.   - name: The name for the operation. - Returns: A valid @MPSGraphTensor@ array containing gradients for each input tensor, except for @sourceGradient@ and @mask@. In case an input is @nil@, no gradient will be returned for it. The order of the gradients will be: for @source@, for @recurrentWeight@, for @inputWeight@, for @bias@ and finally for @initState@.
--
-- ObjC selector: @- singleGateRNNGradientsWithSourceTensor:recurrentWeight:sourceGradient:zState:stateGradient:inputWeight:bias:initState:mask:descriptor:name:@
singleGateRNNGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_stateGradient_inputWeight_bias_initState_mask_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor source, IsMPSGraphTensor recurrentWeight, IsMPSGraphTensor sourceGradient, IsMPSGraphTensor zState, IsMPSGraphTensor stateGradient, IsMPSGraphTensor inputWeight, IsMPSGraphTensor bias, IsMPSGraphTensor initState, IsMPSGraphTensor mask, IsMPSGraphSingleGateRNNDescriptor descriptor, IsNSString name) => mpsGraph -> source -> recurrentWeight -> sourceGradient -> zState -> stateGradient -> inputWeight -> bias -> initState -> mask -> descriptor -> name -> IO (Id NSArray)
singleGateRNNGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_stateGradient_inputWeight_bias_initState_mask_descriptor_name mpsGraph  source recurrentWeight sourceGradient zState stateGradient inputWeight bias initState mask descriptor name =
  withObjCPtr source $ \raw_source ->
    withObjCPtr recurrentWeight $ \raw_recurrentWeight ->
      withObjCPtr sourceGradient $ \raw_sourceGradient ->
        withObjCPtr zState $ \raw_zState ->
          withObjCPtr stateGradient $ \raw_stateGradient ->
            withObjCPtr inputWeight $ \raw_inputWeight ->
              withObjCPtr bias $ \raw_bias ->
                withObjCPtr initState $ \raw_initState ->
                  withObjCPtr mask $ \raw_mask ->
                    withObjCPtr descriptor $ \raw_descriptor ->
                      withObjCPtr name $ \raw_name ->
                          sendMsg mpsGraph (mkSelector "singleGateRNNGradientsWithSourceTensor:recurrentWeight:sourceGradient:zState:stateGradient:inputWeight:bias:initState:mask:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_recurrentWeight :: Ptr ()), argPtr (castPtr raw_sourceGradient :: Ptr ()), argPtr (castPtr raw_zState :: Ptr ()), argPtr (castPtr raw_stateGradient :: Ptr ()), argPtr (castPtr raw_inputWeight :: Ptr ()), argPtr (castPtr raw_bias :: Ptr ()), argPtr (castPtr raw_initState :: Ptr ()), argPtr (castPtr raw_mask :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a single-gate RNN gradient operation and returns the gradient tensor values.
--
-- For details of this operation and parameters, refer to documentation of ``MPSGraph/singleGateRNNWithSourceTensor:recurrentWeight:inputWeight:bias:initState:mask:descriptor:name:``.
--
-- - Parameters:   - source: A tensor that contains the source data @x[t]@ with the data layout [T,N,I].             In case @inputWeight = nil@ and @bidirectional = NO@ then the layout is [T,N,H] and             for @inputWeight = nil@ and @bidirectional = YES@ the layout is [T,N,2H].   - recurrentWeight: A tensor containing the recurrent weights @R@. For @bidirectional@ the layout is [2,H,H] and otherwise it is [H,H].                 Note: For @bidirectional@ this tensor must have a static shape.   - sourceGradient: The input gradient, that is the gradient of a tensor with respect to the first output of the forward pass.   - zState: The second output of             ``MPSGraph/singleGateRNNWithSourceTensor:recurrentWeight:inputWeight:bias:initState:mask:descriptor:name:``             with @descriptor.training = YES@.   - inputWeight: A tensor containing the input weights matrix @W@ - optional, if missing the operation assumes a diagonal unit-matrix.                  For @bidirectional@ the layout is [2H,I] and otherwise it is [H,I].   - bias: A tensor containing the bias @b@ - optional, if missing the operation assumes zeroes. For @bidirectional@ the layout is [2H] and otherwise it is [H].   - initState: The initial internal state of the RNN @h[-1]@ - optional, if missing the operation assumes zeroes. For @bidirectional@ the layout is [N,2H] and otherwise it is [N,H].   - mask: A tensor containing the mask @m@ - optional, if missing the operation assumes ones. This is useful for dropout support.   - descriptor: A descriptor that defines the parameters for the RNN operation.   - name: The name for the operation. - Returns: A valid @MPSGraphTensor@ array containing gradients for each input tensor, except for @sourceGradient@ and @mask@. In case an input is @nil@, no gradient will be returned for it. The order of the gradients will be: for @source@, for @recurrentWeight@, for @inputWeight@, for @bias@ and finally for @initState@.
--
-- ObjC selector: @- singleGateRNNGradientsWithSourceTensor:recurrentWeight:sourceGradient:zState:inputWeight:bias:initState:mask:descriptor:name:@
singleGateRNNGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_inputWeight_bias_initState_mask_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor source, IsMPSGraphTensor recurrentWeight, IsMPSGraphTensor sourceGradient, IsMPSGraphTensor zState, IsMPSGraphTensor inputWeight, IsMPSGraphTensor bias, IsMPSGraphTensor initState, IsMPSGraphTensor mask, IsMPSGraphSingleGateRNNDescriptor descriptor, IsNSString name) => mpsGraph -> source -> recurrentWeight -> sourceGradient -> zState -> inputWeight -> bias -> initState -> mask -> descriptor -> name -> IO (Id NSArray)
singleGateRNNGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_inputWeight_bias_initState_mask_descriptor_name mpsGraph  source recurrentWeight sourceGradient zState inputWeight bias initState mask descriptor name =
  withObjCPtr source $ \raw_source ->
    withObjCPtr recurrentWeight $ \raw_recurrentWeight ->
      withObjCPtr sourceGradient $ \raw_sourceGradient ->
        withObjCPtr zState $ \raw_zState ->
          withObjCPtr inputWeight $ \raw_inputWeight ->
            withObjCPtr bias $ \raw_bias ->
              withObjCPtr initState $ \raw_initState ->
                withObjCPtr mask $ \raw_mask ->
                  withObjCPtr descriptor $ \raw_descriptor ->
                    withObjCPtr name $ \raw_name ->
                        sendMsg mpsGraph (mkSelector "singleGateRNNGradientsWithSourceTensor:recurrentWeight:sourceGradient:zState:inputWeight:bias:initState:mask:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_recurrentWeight :: Ptr ()), argPtr (castPtr raw_sourceGradient :: Ptr ()), argPtr (castPtr raw_zState :: Ptr ()), argPtr (castPtr raw_inputWeight :: Ptr ()), argPtr (castPtr raw_bias :: Ptr ()), argPtr (castPtr raw_initState :: Ptr ()), argPtr (castPtr raw_mask :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a single-gate RNN gradient operation and returns the gradient tensor values.
--
-- For details of this operation and parameters, refer to documentation of ``MPSGraph/singleGateRNNWithSourceTensor:recurrentWeight:inputWeight:bias:initState:mask:descriptor:name:``.
--
-- - Parameters:   - source: A tensor that contains the source data @x[t]@ with the data layout [T,N,I].             In case @inputWeight = nil@ and @bidirectional = NO@ then the layout is [T,N,H] and             for @inputWeight = nil@ and @bidirectional = YES@ the layout is [T,N,2H].   - recurrentWeight: A tensor containing the recurrent weights @R@. For @bidirectional@ the layout is [2,H,H] and otherwise it is [H,H].                 Note: For @bidirectional@ this tensor must have a static shape.   - sourceGradient: The input gradient, that is the gradient of a tensor with respect to the first output of the forward pass.   - zState: The second output of             ``MPSGraph/singleGateRNNWithSourceTensor:recurrentWeight:inputWeight:bias:initState:mask:descriptor:name:``             with @descriptor.training = YES@.   - inputWeight: A tensor containing the input weights matrix @W@ - optional, if missing the operation assumes a diagonal unit-matrix.                  For @bidirectional@ the layout is [2H,I] and otherwise it is [H,I].   - bias: A tensor containing the bias @b@ - optional, if missing the operation assumes zeroes. For @bidirectional@ the layout is [2H] and otherwise it is [H].   - initState: The initial internal state of the RNN @h[-1]@ - optional, if missing the operation assumes zeroes. For @bidirectional@ the layout is [N,2H] and otherwise it is [N,H].   - descriptor: A descriptor that defines the parameters for the RNN operation.   - name: The name for the operation. - Returns: A valid @MPSGraphTensor@ array containing gradients for each input tensor, except for @sourceGradient@ and @mask@. In case an input is @nil@, no gradient will be returned for it. The order of the gradients will be: for @source@, for @recurrentWeight@, for @inputWeight@, for @bias@ and finally for @initState@.
--
-- ObjC selector: @- singleGateRNNGradientsWithSourceTensor:recurrentWeight:sourceGradient:zState:inputWeight:bias:initState:descriptor:name:@
singleGateRNNGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_inputWeight_bias_initState_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor source, IsMPSGraphTensor recurrentWeight, IsMPSGraphTensor sourceGradient, IsMPSGraphTensor zState, IsMPSGraphTensor inputWeight, IsMPSGraphTensor bias, IsMPSGraphTensor initState, IsMPSGraphSingleGateRNNDescriptor descriptor, IsNSString name) => mpsGraph -> source -> recurrentWeight -> sourceGradient -> zState -> inputWeight -> bias -> initState -> descriptor -> name -> IO (Id NSArray)
singleGateRNNGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_inputWeight_bias_initState_descriptor_name mpsGraph  source recurrentWeight sourceGradient zState inputWeight bias initState descriptor name =
  withObjCPtr source $ \raw_source ->
    withObjCPtr recurrentWeight $ \raw_recurrentWeight ->
      withObjCPtr sourceGradient $ \raw_sourceGradient ->
        withObjCPtr zState $ \raw_zState ->
          withObjCPtr inputWeight $ \raw_inputWeight ->
            withObjCPtr bias $ \raw_bias ->
              withObjCPtr initState $ \raw_initState ->
                withObjCPtr descriptor $ \raw_descriptor ->
                  withObjCPtr name $ \raw_name ->
                      sendMsg mpsGraph (mkSelector "singleGateRNNGradientsWithSourceTensor:recurrentWeight:sourceGradient:zState:inputWeight:bias:initState:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_recurrentWeight :: Ptr ()), argPtr (castPtr raw_sourceGradient :: Ptr ()), argPtr (castPtr raw_zState :: Ptr ()), argPtr (castPtr raw_inputWeight :: Ptr ()), argPtr (castPtr raw_bias :: Ptr ()), argPtr (castPtr raw_initState :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a single-gate RNN gradient operation and returns the gradient tensor values.
--
-- For details of this operation and parameters, refer to documentation of ``MPSGraph/singleGateRNNWithSourceTensor:recurrentWeight:inputWeight:bias:initState:mask:descriptor:name:``.
--
-- - Parameters:   - source: A tensor that contains the source data @x[t]@ with the data layout [T,N,I].             In case @inputWeight = nil@ and @bidirectional = NO@ then the layout is [T,N,H] and             for @inputWeight = nil@ and @bidirectional = YES@ the layout is [T,N,2H].   - recurrentWeight: A tensor containing the recurrent weights @R@. For @bidirectional@ the layout is [2,H,H] and otherwise it is [H,H].                 Note: For @bidirectional@ this tensor must have a static shape.   - sourceGradient: The input gradient, that is the gradient of a tensor with respect to the first output of the forward pass.   - zState: The second output of             ``MPSGraph/singleGateRNNWithSourceTensor:recurrentWeight:inputWeight:bias:initState:mask:descriptor:name:``             with @descriptor.training = YES@.   - initState: The initial internal state of the RNN @h[-1]@ - optional, if missing the operation assumes zeroes. For @bidirectional@ the layout is [N,2H] and otherwise it is [N,H].   - descriptor: A descriptor that defines the parameters for the RNN operation.   - name: The name for the operation. - Returns: A valid @MPSGraphTensor@ array containing gradients for each input tensor, except for @sourceGradient@ and @mask@. In case an input is @nil@, no gradient will be returned for it. The order of the gradients will be: for @source@, for @recurrentWeight@, for @inputWeight@, for @bias@ and finally for @initState@.
--
-- ObjC selector: @- singleGateRNNGradientsWithSourceTensor:recurrentWeight:sourceGradient:zState:initState:descriptor:name:@
singleGateRNNGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_initState_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor source, IsMPSGraphTensor recurrentWeight, IsMPSGraphTensor sourceGradient, IsMPSGraphTensor zState, IsMPSGraphTensor initState, IsMPSGraphSingleGateRNNDescriptor descriptor, IsNSString name) => mpsGraph -> source -> recurrentWeight -> sourceGradient -> zState -> initState -> descriptor -> name -> IO (Id NSArray)
singleGateRNNGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_initState_descriptor_name mpsGraph  source recurrentWeight sourceGradient zState initState descriptor name =
  withObjCPtr source $ \raw_source ->
    withObjCPtr recurrentWeight $ \raw_recurrentWeight ->
      withObjCPtr sourceGradient $ \raw_sourceGradient ->
        withObjCPtr zState $ \raw_zState ->
          withObjCPtr initState $ \raw_initState ->
            withObjCPtr descriptor $ \raw_descriptor ->
              withObjCPtr name $ \raw_name ->
                  sendMsg mpsGraph (mkSelector "singleGateRNNGradientsWithSourceTensor:recurrentWeight:sourceGradient:zState:initState:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_recurrentWeight :: Ptr ()), argPtr (castPtr raw_sourceGradient :: Ptr ()), argPtr (castPtr raw_zState :: Ptr ()), argPtr (castPtr raw_initState :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates an LSTM operation and returns the value tensor and optionally the cell state tensor and  the training state tensor.
--
-- This operation returns tensors @h@ and optionally @c@ and optionally @z@ that are defined recursively as follows:  ```md for t = 0 to T-1   z[t] = [i, f, z, o][t] = f( (h[t-1] m) R^T + x'[t] + p c[t-1] )   x'[t] = x[t] W^T + b   c[t] = f[t]c[t-1] + i[t]z[t]   h[t] = o[t]g(c[t]), where ``` @W@ is optional @inputWeight@, @R@ is @recurrentWeight@, @b@ is optional @bias@, @m@ is optional @mask@, @x[t]@ is @source@ @h[t]@ is the first output, @c[t]@ is the second output (optional), @z[t]@ is either the second or third output (optional), @h[-1]@ is @initCell@.  and @h[-1]@ is @initState@. @p@ is an optional peephole vector. See ``MPSGraphLSTMDescriptor`` for different @activation@ options for @f()@ and @g()@.
--
-- - Parameters:   - source: A tensor containing the source data @x[t]@  with the data layout [T,N,I]. In case @inputWeight = nil@ and @bidirectional = NO@ then the layout is [T,N,4H] and for @inputWeight = nil@ and @bidirectional = YES@ the layout is [T,N,8H].   - recurrentWeight: A tensor containing the recurrent weights @R@. For @bidirectional@ the layout is [2,4H,H] and otherwise it is [4H,H].   - inputWeight: A tensor containing the input weights matrix @W@ - optional, if missing the operation assumes a diagonal unit-matrix. For @bidirectional@ the layout is [8H,I] and otherwise it is [4H,I].   - bias: A tensor containing the bias @b@ - optional, if missing the operation assumes zeroes. For @bidirectional@ the layout is [8H] and otherwise it is [4H].   - initState: The initial internal state of the LSTM @h[-1]@ - optional, if missing the operation assumes zeroes.                 For @bidirectional@ the layout is [N,2H] and otherwise it is [N,H].   - initCell: The initial internal cell of the LSTM @h[-1]@ - optional, if missing the operation assumes zeroes.                 For @bidirectional@ the layout is [N,2H] and otherwise it is [N,H].   - mask: A tensor containing the mask @m@ - optional, if missing the operation assumes ones. Useful for dropout.   - peephole: A tensor containing the peephole vector @v@ - optional, if missing the operation assumes zeroes. Shape is [4H], ie. a vector for each gate, or [2,4H] for bidirectional.   - descriptor: A descriptor that defines the parameters for the LSTM operation.   - name: The name for the operation. - Returns: A valid @MPSGraphTensor@ array of size 1 or 2 or 3, depending on values of @descriptor.produceCell@ and @descriptor.training@.     The layout of the both state and cell outputs are [T,N,H] or [T,N,2H] for bidirectional, and the layout of the trainingState output is [T,N,4H] or [T,N,8H] for bidirectional.
--
-- ObjC selector: @- LSTMWithSourceTensor:recurrentWeight:inputWeight:bias:initState:initCell:mask:peephole:descriptor:name:@
lstmWithSourceTensor_recurrentWeight_inputWeight_bias_initState_initCell_mask_peephole_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor source, IsMPSGraphTensor recurrentWeight, IsMPSGraphTensor inputWeight, IsMPSGraphTensor bias, IsMPSGraphTensor initState, IsMPSGraphTensor initCell, IsMPSGraphTensor mask, IsMPSGraphTensor peephole, IsMPSGraphLSTMDescriptor descriptor, IsNSString name) => mpsGraph -> source -> recurrentWeight -> inputWeight -> bias -> initState -> initCell -> mask -> peephole -> descriptor -> name -> IO (Id NSArray)
lstmWithSourceTensor_recurrentWeight_inputWeight_bias_initState_initCell_mask_peephole_descriptor_name mpsGraph  source recurrentWeight inputWeight bias initState initCell mask peephole descriptor name =
  withObjCPtr source $ \raw_source ->
    withObjCPtr recurrentWeight $ \raw_recurrentWeight ->
      withObjCPtr inputWeight $ \raw_inputWeight ->
        withObjCPtr bias $ \raw_bias ->
          withObjCPtr initState $ \raw_initState ->
            withObjCPtr initCell $ \raw_initCell ->
              withObjCPtr mask $ \raw_mask ->
                withObjCPtr peephole $ \raw_peephole ->
                  withObjCPtr descriptor $ \raw_descriptor ->
                    withObjCPtr name $ \raw_name ->
                        sendMsg mpsGraph (mkSelector "LSTMWithSourceTensor:recurrentWeight:inputWeight:bias:initState:initCell:mask:peephole:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_recurrentWeight :: Ptr ()), argPtr (castPtr raw_inputWeight :: Ptr ()), argPtr (castPtr raw_bias :: Ptr ()), argPtr (castPtr raw_initState :: Ptr ()), argPtr (castPtr raw_initCell :: Ptr ()), argPtr (castPtr raw_mask :: Ptr ()), argPtr (castPtr raw_peephole :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates an LSTM operation and returns the value tensor and optionally the cell state tensor and  the training state tensor.
--
-- This operation returns tensors @h@ and optionally @c@ and optionally @z@ that are defined recursively as follows: ```md for t = 0 to T-1   z[t] = [i, f, z, o][t] = f( (h[t-1] m) R^T + x'[t] + p c[t-1] )   x'[t] = x[t] W^T + b   c[t] = f[t]c[t-1] + i[t]z[t]   h[t] = o[t]g(c[t]), where ``` @W@ is optional @inputWeight@, @R@ is @recurrentWeight@, @b@ is optional @bias@, @m@ is optional @mask@, @x[t]@ is @source@ @h[t]@ is the first output, @c[t]@ is the second output (optional), @z[t]@ is either the second or third output (optional), @h[-1]@ is @initCell@.  and @h[-1]@ is @initState@. @p@ is an optional peephole vector. See ``MPSGraphLSTMDescriptor`` for different @activation@ options for @f()@ and @g()@.
--
-- - Parameters:   - source: A tensor containing the source data @x[t]@  with the data layout [T,N,I]. In case @inputWeight = nil@ and @bidirectional = NO@ then the layout is [T,N,4H] and for @inputWeight = nil@ and @bidirectional = YES@ the layout is [T,N,8H].   - recurrentWeight: A tensor containing the recurrent weights @R@. For @bidirectional@ the layout is [2,4H,H] and otherwise it is [4H,H].   - inputWeight: A tensor containing the input weights matrix @W@ - optional, if missing the operation assumes a diagonal unit-matrix. For @bidirectional@ the layout is [8H,I] and otherwise it is [4H,I].   - bias: A tensor containing the bias @b@ - optional, if missing the operation assumes zeroes. For @bidirectional@ the layout is [8H] and otherwise it is [4H].   - initState: The initial internal state of the LSTM @h[-1]@ - optional, if missing the operation assumes zeroes.                 For @bidirectional@ the layout is [N,2H] and otherwise it is [N,H].   - initCell: The initial internal cell of the LSTM @h[-1]@ - optional, if missing the operation assumes zeroes.                 For @bidirectional@ the layout is [N,2H] and otherwise it is [N,H].   - descriptor: A descriptor that defines the parameters for the LSTM operation.   - name: The name for the operation. - Returns: A valid @MPSGraphTensor@ array of size 1 or 2 or 3, depending on values of @descriptor.produceCell@ and @descriptor.training@.     The layout of the both state and cell outputs are [T,N,H] or [T,N,2H] for bidirectional, and the layout of the trainingState output is [T,N,4H] or [T,N,8H] for bidirectional.
--
-- ObjC selector: @- LSTMWithSourceTensor:recurrentWeight:inputWeight:bias:initState:initCell:descriptor:name:@
lstmWithSourceTensor_recurrentWeight_inputWeight_bias_initState_initCell_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor source, IsMPSGraphTensor recurrentWeight, IsMPSGraphTensor inputWeight, IsMPSGraphTensor bias, IsMPSGraphTensor initState, IsMPSGraphTensor initCell, IsMPSGraphLSTMDescriptor descriptor, IsNSString name) => mpsGraph -> source -> recurrentWeight -> inputWeight -> bias -> initState -> initCell -> descriptor -> name -> IO (Id NSArray)
lstmWithSourceTensor_recurrentWeight_inputWeight_bias_initState_initCell_descriptor_name mpsGraph  source recurrentWeight inputWeight bias initState initCell descriptor name =
  withObjCPtr source $ \raw_source ->
    withObjCPtr recurrentWeight $ \raw_recurrentWeight ->
      withObjCPtr inputWeight $ \raw_inputWeight ->
        withObjCPtr bias $ \raw_bias ->
          withObjCPtr initState $ \raw_initState ->
            withObjCPtr initCell $ \raw_initCell ->
              withObjCPtr descriptor $ \raw_descriptor ->
                withObjCPtr name $ \raw_name ->
                    sendMsg mpsGraph (mkSelector "LSTMWithSourceTensor:recurrentWeight:inputWeight:bias:initState:initCell:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_recurrentWeight :: Ptr ()), argPtr (castPtr raw_inputWeight :: Ptr ()), argPtr (castPtr raw_bias :: Ptr ()), argPtr (castPtr raw_initState :: Ptr ()), argPtr (castPtr raw_initCell :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates an LSTM operation and returns the value tensor and optionally the cell state tensor and  the training state tensor.
--
-- This operation returns tensors @h@ and optionally @c@ and optionally @z@ that are defined recursively as follows: ```md for t = 0 to T-1   z[t] = [i, f, z, o][t] = f( (h[t-1] m) R^T + x'[t] + p c[t-1] )   x'[t] = x[t] W^T + b   c[t] = f[t]c[t-1] + i[t]z[t]   h[t] = o[t]g(c[t]), where ``` @W@ is optional @inputWeight@, @R@ is @recurrentWeight@, @b@ is optional @bias@, @m@ is optional @mask@, @x[t]@ is @source@ @h[t]@ is the first output, @c[t]@ is the second output (optional), @z[t]@ is either the second or third output (optional), @h[-1]@ is @initCell@.  and @h[-1]@ is @initState@. @p@ is an optional peephole vector. See ``MPSGraphLSTMDescriptor`` for different @activation@ options for @f()@ and @g()@.
--
-- - Parameters:   - source: A tensor containing the source data @x[t]@  with the data layout [T,N,I]. In case @inputWeight = nil@ and @bidirectional = NO@ then the layout is [T,N,4H] and for @inputWeight = nil@ and @bidirectional = YES@ the layout is [T,N,8H].   - recurrentWeight: A tensor containing the recurrent weights @R@. For @bidirectional@ the layout is [2,4H,H] and otherwise it is [4H,H].   - initState: The initial internal state of the LSTM @h[-1]@ - optional, if missing the operation assumes zeroes.                 For @bidirectional@ the layout is [N,2H] and otherwise it is [N,H].   - initCell: The initial internal cell of the LSTM @h[-1]@ - optional, if missing the operation assumes zeroes.                 For @bidirectional@ the layout is [N,2H] and otherwise it is [N,H].   - descriptor: A descriptor that defines the parameters for the LSTM operation.   - name: The name for the operation. - Returns: A valid @MPSGraphTensor@ array of size 1 or 2 or 3, depending on values of @descriptor.produceCell@ and @descriptor.training@.     The layout of the both state and cell outputs are [T,N,H] or [T,N,2H] for bidirectional, and the layout of the trainingState output is [T,N,4H] or [T,N,8H] for bidirectional.
--
-- ObjC selector: @- LSTMWithSourceTensor:recurrentWeight:initState:initCell:descriptor:name:@
lstmWithSourceTensor_recurrentWeight_initState_initCell_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor source, IsMPSGraphTensor recurrentWeight, IsMPSGraphTensor initState, IsMPSGraphTensor initCell, IsMPSGraphLSTMDescriptor descriptor, IsNSString name) => mpsGraph -> source -> recurrentWeight -> initState -> initCell -> descriptor -> name -> IO (Id NSArray)
lstmWithSourceTensor_recurrentWeight_initState_initCell_descriptor_name mpsGraph  source recurrentWeight initState initCell descriptor name =
  withObjCPtr source $ \raw_source ->
    withObjCPtr recurrentWeight $ \raw_recurrentWeight ->
      withObjCPtr initState $ \raw_initState ->
        withObjCPtr initCell $ \raw_initCell ->
          withObjCPtr descriptor $ \raw_descriptor ->
            withObjCPtr name $ \raw_name ->
                sendMsg mpsGraph (mkSelector "LSTMWithSourceTensor:recurrentWeight:initState:initCell:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_recurrentWeight :: Ptr ()), argPtr (castPtr raw_initState :: Ptr ()), argPtr (castPtr raw_initCell :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates an LSTM gradient operation and returns the gradient tensor values.
--
-- For details of this operation and parameters, refer to documentation of ``MPSGraph/LSTMWithSourceTensor:recurrentWeight:inputWeight:bias:initState:initCell:mask:peephole:descriptor:name:``.
--
-- - Parameters:   - source: A tensor containing the source data @x[t]@  with the data layout [T,N,I]. In case @inputWeight = nil@ and @bidirectional = NO@ then the layout is [T,N,4H] and for @inputWeight = nil@ and @bidirectional = YES@ the layout is [T,N,8H].   - recurrentWeight: A tensor containing the recurrent weights @R@. For @bidirectional@ the layout is [2,4H,H] and otherwise it is [4H,H].   - sourceGradient: The input gradient, that is the gradient of a tensor with respect to the first output of the forward pass.   - zState: The third output of         ``MPSGraph/LSTMWithSourceTensor:recurrentWeight:inputWeight:bias:initState:initCell:descriptor:name:``         with @descriptor.training = YES@.   - cellOutputFwd: The second output of         ``MPSGraph/LSTMWithSourceTensor:recurrentWeight:inputWeight:bias:initState:initCell:descriptor:name:``         with @descriptor.training = YES@ or @descriptor.produceCell = YES@.   - stateGradient: The input gradient for state coming from the future timestep - optional, if missing the operation assumes zeroes.   - cellGradient: Input gradient for cell coming from the future timestep - optional, if missing the operation assumes zeroes.   - inputWeight: A tensor containing the input weights matrix @W@ - optional, if missing the operation assumes a diagonal unit-matrix. For @bidirectional@ the layout is [8H,I] and otherwise it is [4H,I].   - bias: A tensor containing the bias @b@ - optional, if missing the operation assumes zeroes. For @bidirectional@ the layout is [8H] and otherwise it is [4H].   - initState: The initial internal state of the LSTM @h[-1]@ - optional, if missing the operation assumes zeroes.                 For @bidirectional@ the layout is [N,2H] and otherwise it is [N,H].   - initCell: The initial internal cell of the LSTM @h[-1]@ - optional, if missing the operation assumes zeroes.                 For @bidirectional@ the layout is [N,2H] and otherwise it is [N,H].   - mask: A tensor containing the mask @m@ - optional, if missing the operation assumes ones. Useful for dropout.   - peephole: A tensor containing the peephole vector @v@ - optional, if missing the operation assumes zeroes. Shape is [4H], ie. a vector for each gate, or [2,4H] for bidirectional.   - descriptor: A descriptor that defines the parameters for the LSTM operation.   - name: The name for the operation. - Returns: A valid @MPSGraphTensor@ array containing gradients for each input tensor, except for @sourceGradient@ and @mask@. In case an input is nil, no gradient will be returned for it. The order of the gradients will be: for @source@, for @recurrentWeight@, for @inputWeight@, for @bias@, for @peephole@, for @initState@ and for @initCell@.
--
-- ObjC selector: @- LSTMGradientsWithSourceTensor:recurrentWeight:sourceGradient:zState:cellOutputFwd:stateGradient:cellGradient:inputWeight:bias:initState:initCell:mask:peephole:descriptor:name:@
lstmGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_cellOutputFwd_stateGradient_cellGradient_inputWeight_bias_initState_initCell_mask_peephole_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor source, IsMPSGraphTensor recurrentWeight, IsMPSGraphTensor sourceGradient, IsMPSGraphTensor zState, IsMPSGraphTensor cellOutputFwd, IsMPSGraphTensor stateGradient, IsMPSGraphTensor cellGradient, IsMPSGraphTensor inputWeight, IsMPSGraphTensor bias, IsMPSGraphTensor initState, IsMPSGraphTensor initCell, IsMPSGraphTensor mask, IsMPSGraphTensor peephole, IsMPSGraphLSTMDescriptor descriptor, IsNSString name) => mpsGraph -> source -> recurrentWeight -> sourceGradient -> zState -> cellOutputFwd -> stateGradient -> cellGradient -> inputWeight -> bias -> initState -> initCell -> mask -> peephole -> descriptor -> name -> IO (Id NSArray)
lstmGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_cellOutputFwd_stateGradient_cellGradient_inputWeight_bias_initState_initCell_mask_peephole_descriptor_name mpsGraph  source recurrentWeight sourceGradient zState cellOutputFwd stateGradient cellGradient inputWeight bias initState initCell mask peephole descriptor name =
  withObjCPtr source $ \raw_source ->
    withObjCPtr recurrentWeight $ \raw_recurrentWeight ->
      withObjCPtr sourceGradient $ \raw_sourceGradient ->
        withObjCPtr zState $ \raw_zState ->
          withObjCPtr cellOutputFwd $ \raw_cellOutputFwd ->
            withObjCPtr stateGradient $ \raw_stateGradient ->
              withObjCPtr cellGradient $ \raw_cellGradient ->
                withObjCPtr inputWeight $ \raw_inputWeight ->
                  withObjCPtr bias $ \raw_bias ->
                    withObjCPtr initState $ \raw_initState ->
                      withObjCPtr initCell $ \raw_initCell ->
                        withObjCPtr mask $ \raw_mask ->
                          withObjCPtr peephole $ \raw_peephole ->
                            withObjCPtr descriptor $ \raw_descriptor ->
                              withObjCPtr name $ \raw_name ->
                                  sendMsg mpsGraph (mkSelector "LSTMGradientsWithSourceTensor:recurrentWeight:sourceGradient:zState:cellOutputFwd:stateGradient:cellGradient:inputWeight:bias:initState:initCell:mask:peephole:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_recurrentWeight :: Ptr ()), argPtr (castPtr raw_sourceGradient :: Ptr ()), argPtr (castPtr raw_zState :: Ptr ()), argPtr (castPtr raw_cellOutputFwd :: Ptr ()), argPtr (castPtr raw_stateGradient :: Ptr ()), argPtr (castPtr raw_cellGradient :: Ptr ()), argPtr (castPtr raw_inputWeight :: Ptr ()), argPtr (castPtr raw_bias :: Ptr ()), argPtr (castPtr raw_initState :: Ptr ()), argPtr (castPtr raw_initCell :: Ptr ()), argPtr (castPtr raw_mask :: Ptr ()), argPtr (castPtr raw_peephole :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates an LSTM gradient operation and returns the gradient tensor values.
--
-- For details of this operation and parameters, refer to documentation of ``MPSGraph/LSTMWithSourceTensor:recurrentWeight:inputWeight:bias:initState:initCell:mask:peephole:descriptor:name:``.
--
-- - Parameters:   - source: A tensor containing the source data @x[t]@  with the data layout [T,N,I]. In case @inputWeight = nil@ and @bidirectional = NO@ then the layout is [T,N,4H] and for @inputWeight = nil@ and @bidirectional = YES@ the layout is [T,N,8H].   - recurrentWeight: A tensor containing the recurrent weights @R@. For @bidirectional@ the layout is [2,4H,H] and otherwise it is [4H,H].   - sourceGradient: The input gradient, that is the gradient of a tensor with respect to the first output of the forward pass.   - zState: The third output of         ``MPSGraph/LSTMWithSourceTensor:recurrentWeight:inputWeight:bias:initState:initCell:descriptor:name:``         with @descriptor.training = YES@.   - cellOutputFwd: The second output of         ``MPSGraph/LSTMWithSourceTensor:recurrentWeight:inputWeight:bias:initState:initCell:descriptor:name:``         with @descriptor.training = YES@ or @descriptor.produceCell = YES@.   - inputWeight: A tensor containing the input weights matrix @W@ - optional, if missing the operation assumes a diagonal unit-matrix. For @bidirectional@ the layout is [8H,I] and otherwise it is [4H,I].   - bias: A tensor containing the bias @b@ - optional, if missing the operation assumes zeroes. For @bidirectional@ the layout is [8H] and otherwise it is [4H].   - initState: The initial internal state of the LSTM @h[-1]@ - optional, if missing the operation assumes zeroes.                 For @bidirectional@ the layout is [N,2H] and otherwise it is [N,H].   - initCell: The initial internal cell of the LSTM @h[-1]@ - optional, if missing the operation assumes zeroes.                 For @bidirectional@ the layout is [N,2H] and otherwise it is [N,H].   - mask: A tensor containing the mask @m@ - optional, if missing the operation assumes ones. Useful for dropout.   - descriptor: A descriptor that defines the parameters for the LSTM operation.   - name: The name for the operation. - Returns: A valid @MPSGraphTensor@ array containing gradients for each input tensor, except for @sourceGradient@ and @mask@. In case an input is nil, no gradient will be returned for it. The order of the gradients will be: for @source@, for @recurrentWeight@, for @inputWeight@, for @bias@, for @peephole@, for @initState@ and for @initCell@.
--
-- ObjC selector: @- LSTMGradientsWithSourceTensor:recurrentWeight:sourceGradient:zState:cellOutputFwd:inputWeight:bias:initState:initCell:mask:descriptor:name:@
lstmGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_cellOutputFwd_inputWeight_bias_initState_initCell_mask_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor source, IsMPSGraphTensor recurrentWeight, IsMPSGraphTensor sourceGradient, IsMPSGraphTensor zState, IsMPSGraphTensor cellOutputFwd, IsMPSGraphTensor inputWeight, IsMPSGraphTensor bias, IsMPSGraphTensor initState, IsMPSGraphTensor initCell, IsMPSGraphTensor mask, IsMPSGraphLSTMDescriptor descriptor, IsNSString name) => mpsGraph -> source -> recurrentWeight -> sourceGradient -> zState -> cellOutputFwd -> inputWeight -> bias -> initState -> initCell -> mask -> descriptor -> name -> IO (Id NSArray)
lstmGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_cellOutputFwd_inputWeight_bias_initState_initCell_mask_descriptor_name mpsGraph  source recurrentWeight sourceGradient zState cellOutputFwd inputWeight bias initState initCell mask descriptor name =
  withObjCPtr source $ \raw_source ->
    withObjCPtr recurrentWeight $ \raw_recurrentWeight ->
      withObjCPtr sourceGradient $ \raw_sourceGradient ->
        withObjCPtr zState $ \raw_zState ->
          withObjCPtr cellOutputFwd $ \raw_cellOutputFwd ->
            withObjCPtr inputWeight $ \raw_inputWeight ->
              withObjCPtr bias $ \raw_bias ->
                withObjCPtr initState $ \raw_initState ->
                  withObjCPtr initCell $ \raw_initCell ->
                    withObjCPtr mask $ \raw_mask ->
                      withObjCPtr descriptor $ \raw_descriptor ->
                        withObjCPtr name $ \raw_name ->
                            sendMsg mpsGraph (mkSelector "LSTMGradientsWithSourceTensor:recurrentWeight:sourceGradient:zState:cellOutputFwd:inputWeight:bias:initState:initCell:mask:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_recurrentWeight :: Ptr ()), argPtr (castPtr raw_sourceGradient :: Ptr ()), argPtr (castPtr raw_zState :: Ptr ()), argPtr (castPtr raw_cellOutputFwd :: Ptr ()), argPtr (castPtr raw_inputWeight :: Ptr ()), argPtr (castPtr raw_bias :: Ptr ()), argPtr (castPtr raw_initState :: Ptr ()), argPtr (castPtr raw_initCell :: Ptr ()), argPtr (castPtr raw_mask :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates an LSTM gradient operation and returns the gradient tensor values.
--
-- For details of this operation and parameters, refer to documentation of ``MPSGraph/LSTMWithSourceTensor:recurrentWeight:inputWeight:bias:initState:initCell:mask:peephole:descriptor:name:``.
--
-- - Parameters:   - source: A tensor containing the source data @x[t]@  with the data layout [T,N,I]. In case @inputWeight = nil@ and @bidirectional = NO@ then the layout is [T,N,4H] and for @inputWeight = nil@ and @bidirectional = YES@ the layout is [T,N,8H].   - recurrentWeight: A tensor containing the recurrent weights @R@. For @bidirectional@ the layout is [2,4H,H] and otherwise it is [4H,H].   - sourceGradient: The input gradient, that is the gradient of a tensor with respect to the first output of the forward pass.   - zState: The third output of         ``MPSGraph/LSTMWithSourceTensor:recurrentWeight:inputWeight:bias:initState:initCell:descriptor:name:``         with @descriptor.training = YES@.   - cellOutputFwd: The second output of         ``MPSGraph/LSTMWithSourceTensor:recurrentWeight:inputWeight:bias:initState:initCell:descriptor:name:``         with @descriptor.training = YES@ or @descriptor.produceCell = YES@.   - inputWeight: A tensor containing the input weights matrix @W@ - optional, if missing the operation assumes a diagonal unit-matrix. For @bidirectional@ the layout is [8H,I] and otherwise it is [4H,I].   - bias: A tensor containing the bias @b@ - optional, if missing the operation assumes zeroes. For @bidirectional@ the layout is [8H] and otherwise it is [4H].   - initState: The initial internal state of the LSTM @h[-1]@ - optional, if missing the operation assumes zeroes.                 For @bidirectional@ the layout is [N,2H] and otherwise it is [N,H].   - initCell: The initial internal cell of the LSTM @h[-1]@ - optional, if missing the operation assumes zeroes.                 For @bidirectional@ the layout is [N,2H] and otherwise it is [N,H].   - descriptor: A descriptor that defines the parameters for the LSTM operation.   - name: The name for the operation. - Returns: A valid @MPSGraphTensor@ array containing gradients for each input tensor, except for @sourceGradient@ and @mask@. In case an input is nil, no gradient will be returned for it. The order of the gradients will be: for @source@, for @recurrentWeight@, for @inputWeight@, for @bias@, for @initState@ and for @initCell@.
--
-- ObjC selector: @- LSTMGradientsWithSourceTensor:recurrentWeight:sourceGradient:zState:cellOutputFwd:inputWeight:bias:initState:initCell:descriptor:name:@
lstmGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_cellOutputFwd_inputWeight_bias_initState_initCell_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor source, IsMPSGraphTensor recurrentWeight, IsMPSGraphTensor sourceGradient, IsMPSGraphTensor zState, IsMPSGraphTensor cellOutputFwd, IsMPSGraphTensor inputWeight, IsMPSGraphTensor bias, IsMPSGraphTensor initState, IsMPSGraphTensor initCell, IsMPSGraphLSTMDescriptor descriptor, IsNSString name) => mpsGraph -> source -> recurrentWeight -> sourceGradient -> zState -> cellOutputFwd -> inputWeight -> bias -> initState -> initCell -> descriptor -> name -> IO (Id NSArray)
lstmGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_cellOutputFwd_inputWeight_bias_initState_initCell_descriptor_name mpsGraph  source recurrentWeight sourceGradient zState cellOutputFwd inputWeight bias initState initCell descriptor name =
  withObjCPtr source $ \raw_source ->
    withObjCPtr recurrentWeight $ \raw_recurrentWeight ->
      withObjCPtr sourceGradient $ \raw_sourceGradient ->
        withObjCPtr zState $ \raw_zState ->
          withObjCPtr cellOutputFwd $ \raw_cellOutputFwd ->
            withObjCPtr inputWeight $ \raw_inputWeight ->
              withObjCPtr bias $ \raw_bias ->
                withObjCPtr initState $ \raw_initState ->
                  withObjCPtr initCell $ \raw_initCell ->
                    withObjCPtr descriptor $ \raw_descriptor ->
                      withObjCPtr name $ \raw_name ->
                          sendMsg mpsGraph (mkSelector "LSTMGradientsWithSourceTensor:recurrentWeight:sourceGradient:zState:cellOutputFwd:inputWeight:bias:initState:initCell:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_recurrentWeight :: Ptr ()), argPtr (castPtr raw_sourceGradient :: Ptr ()), argPtr (castPtr raw_zState :: Ptr ()), argPtr (castPtr raw_cellOutputFwd :: Ptr ()), argPtr (castPtr raw_inputWeight :: Ptr ()), argPtr (castPtr raw_bias :: Ptr ()), argPtr (castPtr raw_initState :: Ptr ()), argPtr (castPtr raw_initCell :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates an LSTM gradient operation and returns the gradient tensor values.
--
-- For details of this operation and parameters, refer to documentation of ``MPSGraph/LSTMWithSourceTensor:recurrentWeight:inputWeight:bias:initState:initCell:mask:peephole:descriptor:name:``.
--
-- - Parameters:   - source: A tensor containing the source data @x[t]@  with the data layout [T,N,I]. In case @inputWeight = nil@ and @bidirectional = NO@ then the layout is [T,N,4H] and for @inputWeight = nil@ and @bidirectional = YES@ the layout is [T,N,8H].   - recurrentWeight: A tensor containing the recurrent weights @R@. For @bidirectional@ the layout is [2,4H,H] and otherwise it is [4H,H].   - sourceGradient: The input gradient, that is the gradient of a tensor with respect to the first output of the forward pass.   - zState: The third output of         ``MPSGraph/LSTMWithSourceTensor:recurrentWeight:inputWeight:bias:initState:initCell:descriptor:name:``         with @descriptor.training = YES@.   - cellOutputFwd: The second output of         ``MPSGraph/LSTMWithSourceTensor:recurrentWeight:inputWeight:bias:initState:initCell:descriptor:name:``         with @descriptor.training = YES@ or @descriptor.produceCell = YES@.   - descriptor: A descriptor that defines the parameters for the LSTM operation.   - name: The name for the operation. - Returns: A valid @MPSGraphTensor@ array containing gradients for each input tensor, except for @sourceGradient@ and @mask@. In case an input is nil, no gradient will be returned for it. The order of the gradients will be: for @source@, for @recurrentWeight@, for @inputWeight@, for @bias@, for @initState@ and for @initCell@.
--
-- ObjC selector: @- LSTMGradientsWithSourceTensor:recurrentWeight:sourceGradient:zState:cellOutputFwd:descriptor:name:@
lstmGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_cellOutputFwd_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor source, IsMPSGraphTensor recurrentWeight, IsMPSGraphTensor sourceGradient, IsMPSGraphTensor zState, IsMPSGraphTensor cellOutputFwd, IsMPSGraphLSTMDescriptor descriptor, IsNSString name) => mpsGraph -> source -> recurrentWeight -> sourceGradient -> zState -> cellOutputFwd -> descriptor -> name -> IO (Id NSArray)
lstmGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_cellOutputFwd_descriptor_name mpsGraph  source recurrentWeight sourceGradient zState cellOutputFwd descriptor name =
  withObjCPtr source $ \raw_source ->
    withObjCPtr recurrentWeight $ \raw_recurrentWeight ->
      withObjCPtr sourceGradient $ \raw_sourceGradient ->
        withObjCPtr zState $ \raw_zState ->
          withObjCPtr cellOutputFwd $ \raw_cellOutputFwd ->
            withObjCPtr descriptor $ \raw_descriptor ->
              withObjCPtr name $ \raw_name ->
                  sendMsg mpsGraph (mkSelector "LSTMGradientsWithSourceTensor:recurrentWeight:sourceGradient:zState:cellOutputFwd:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_recurrentWeight :: Ptr ()), argPtr (castPtr raw_sourceGradient :: Ptr ()), argPtr (castPtr raw_zState :: Ptr ()), argPtr (castPtr raw_cellOutputFwd :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a GRU operation and returns the value and optionally the training state tensor.
--
-- This operation returns tensors @h@ and optionally @z@ that are defined recursively as follows:  ```md  for t = 0 to T-1    z[t] = fz( (h[t-1] m) R^T + x[t] W^T + b ),   r[t] = fr( (h[t-1] m) R^T + x[t] W^T + b ),   c[t] = (h[t-1] r[t] m) R^T   o[t] = fo( c[t] + x[t] W^T + b )   h[t] = z[t]h[t-1] + (1-z[t])o[t] ```  If @resetAfter = YES@ then @c[t]@ is replaced by ```md    c[t] = ( (h[t-1] m) R^T + b2 ) r[t] ```  If @flipZ = YES@ then @h[t]@ is replaced by ```md    h[t] = (1-z[t])h[t-1] + z[t]o[t]. ```  @W@ is optional @inputWeight@, @R@ is @recurrentWeight@, @b@ is optional  @bias@, @m@ is optional @mask@, @x[t]@ is @source@ @h[t]@ is the first output, @z[t]@ is the second output (optional) and @h[-1]@ is @initState@. @b2@ is an optional @resetBias@ vector, only used when @resetAfter = YES@. See ``MPSGraphGRUDescriptor`` for different @activation@ options for @f()@.
--
-- - Parameters:   - source: A tensor containing the source data @x[t]@ with the data layout [T,N,I]. In case @inputWeight = nil@ and @bidirectional = NO@ then the layout is [T,N,3H] and for @inputWeight = nil@ and @bidirectional = YES@ the layout is [T,N,6H].   - recurrentWeight: A tensor containing the recurrent weights @R@. For @bidirectional@ the layout is [2,3H,H] and otherwise it is [3H,H].   - inputWeight: A tensor containing the input weights matrix @W@ - optional, if missing the operation assumes a diagonal unit-matrix.                     For @bidirectional@ the layout is [6H,I] and otherwise it is [3H,I].   - bias: A tensor containing the bias @b@ - optional, if missing the operation assumes zeroes. For @bidirectional@ the layout is [6H] and otherwise it is [3H].   - initState: The initial internal state of the LSTM @h[-1]@ - optional, if missing the operation assumes zeroes. For @bidirectional@ the layout is [N,2H] and otherwise it is [N,H].   - mask: A tensor containing the mask @m@ - optional, if missing the operation assumes ones. Useful for dropout.   - secondaryBias: A tensor containing the secondary bias vector @b2@ - optional, if missing the operation assumes zeroes. Only used with @reset_after = YES@. Shape is [H], ie. a vector for each gate, or [2H] for bidirectional.   - descriptor: A descriptor that defines the parameters for the GRU operation.   - name: The name for the operation. - Returns: A valid @MPSGraphTensor@ array of size 1 or 2 depending on value of  @descriptor.training@.            The layout of the state output is [T,N,H] or [T,N,2H] for bidirectional,            and the layout of the @trainingState@ output is [T,N,3H] or [T,N,6H] for bidirectional.
--
-- ObjC selector: @- GRUWithSourceTensor:recurrentWeight:inputWeight:bias:initState:mask:secondaryBias:descriptor:name:@
gruWithSourceTensor_recurrentWeight_inputWeight_bias_initState_mask_secondaryBias_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor source, IsMPSGraphTensor recurrentWeight, IsMPSGraphTensor inputWeight, IsMPSGraphTensor bias, IsMPSGraphTensor initState, IsMPSGraphTensor mask, IsMPSGraphTensor secondaryBias, IsMPSGraphGRUDescriptor descriptor, IsNSString name) => mpsGraph -> source -> recurrentWeight -> inputWeight -> bias -> initState -> mask -> secondaryBias -> descriptor -> name -> IO (Id NSArray)
gruWithSourceTensor_recurrentWeight_inputWeight_bias_initState_mask_secondaryBias_descriptor_name mpsGraph  source recurrentWeight inputWeight bias initState mask secondaryBias descriptor name =
  withObjCPtr source $ \raw_source ->
    withObjCPtr recurrentWeight $ \raw_recurrentWeight ->
      withObjCPtr inputWeight $ \raw_inputWeight ->
        withObjCPtr bias $ \raw_bias ->
          withObjCPtr initState $ \raw_initState ->
            withObjCPtr mask $ \raw_mask ->
              withObjCPtr secondaryBias $ \raw_secondaryBias ->
                withObjCPtr descriptor $ \raw_descriptor ->
                  withObjCPtr name $ \raw_name ->
                      sendMsg mpsGraph (mkSelector "GRUWithSourceTensor:recurrentWeight:inputWeight:bias:initState:mask:secondaryBias:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_recurrentWeight :: Ptr ()), argPtr (castPtr raw_inputWeight :: Ptr ()), argPtr (castPtr raw_bias :: Ptr ()), argPtr (castPtr raw_initState :: Ptr ()), argPtr (castPtr raw_mask :: Ptr ()), argPtr (castPtr raw_secondaryBias :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a GRU operation and returns the value and optionally the training state tensor.
--
-- This operation returns tensors @h@ and optionally @z@ that are defined recursively as follows: ```md for t = 0 to T-1   z[t] = fz( (h[t-1] m) R^T + x[t] W^T + b ),   r[t] = fr( (h[t-1] m) R^T + x[t] W^T + b ),   c[t] = (h[t-1] r[t] m) R^T   o[t] = fo( c[t] + x[t] W^T + b )   h[t] = z[t]h[t-1] + (1-z[t])o[t] ``` If @resetAfter = YES@ then @c[t]@ is replaced by ```md   c[t] = ( (h[t-1] m) R^T + b2 ) r[t] ``` If @flipZ = YES@ then @h[t]@ is replaced by ```md   h[t] = (1-z[t])h[t-1] + z[t]o[t]. ``` @W@ is optional @inputWeight@, @R@ is @recurrentWeight@, @b@ is optional  @bias@, @m@ is optional @mask@, @x[t]@ is @source@ @h[t]@ is the first output, @z[t]@ is the second output (optional) and @h[-1]@ is @initState@. @b2@ is an optional @resetBias@ vector, only used when @resetAfter = YES@. See ``MPSGraphGRUDescriptor`` for different @activation@ options for @f()@.
--
-- - Parameters:   - source: A tensor containing the source data @x[t]@ with the data layout [T,N,I]. In case @inputWeight = nil@ and @bidirectional = NO@ then the layout is [T,N,3H] and for @inputWeight = nil@ and @bidirectional = YES@ the layout is [T,N,6H].   - recurrentWeight: A tensor containing the recurrent weights @R@. For @bidirectional@ the layout is [2,3H,H] and otherwise it is [3H,H].   - inputWeight: A tensor containing the input weights matrix @W@ - optional, if missing the operation assumes a diagonal unit-matrix.                     For @bidirectional@ the layout is [6H,I] and otherwise it is [3H,I].   - bias: A tensor containing the bias @b@ - optional, if missing the operation assumes zeroes. For @bidirectional@ the layout is [6H] and otherwise it is [3H].   - initState: The initial internal state of the LSTM @h[-1]@ - optional, if missing the operation assumes zeroes. For @bidirectional@ the layout is [N,2H] and otherwise it is [N,H].   - descriptor: A descriptor that defines the parameters for the GRU operation.   - name: The name for the operation. - Returns: A valid @MPSGraphTensor@ array of size 1 or 2 depending on value of  @descriptor.training@.            The layout of the state output is [T,N,H] or [T,N,2H] for bidirectional,            and the layout of the @trainingState@ output is [T,N,3H] or [T,N,6H] for bidirectional.
--
-- ObjC selector: @- GRUWithSourceTensor:recurrentWeight:inputWeight:bias:initState:descriptor:name:@
gruWithSourceTensor_recurrentWeight_inputWeight_bias_initState_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor source, IsMPSGraphTensor recurrentWeight, IsMPSGraphTensor inputWeight, IsMPSGraphTensor bias, IsMPSGraphTensor initState, IsMPSGraphGRUDescriptor descriptor, IsNSString name) => mpsGraph -> source -> recurrentWeight -> inputWeight -> bias -> initState -> descriptor -> name -> IO (Id NSArray)
gruWithSourceTensor_recurrentWeight_inputWeight_bias_initState_descriptor_name mpsGraph  source recurrentWeight inputWeight bias initState descriptor name =
  withObjCPtr source $ \raw_source ->
    withObjCPtr recurrentWeight $ \raw_recurrentWeight ->
      withObjCPtr inputWeight $ \raw_inputWeight ->
        withObjCPtr bias $ \raw_bias ->
          withObjCPtr initState $ \raw_initState ->
            withObjCPtr descriptor $ \raw_descriptor ->
              withObjCPtr name $ \raw_name ->
                  sendMsg mpsGraph (mkSelector "GRUWithSourceTensor:recurrentWeight:inputWeight:bias:initState:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_recurrentWeight :: Ptr ()), argPtr (castPtr raw_inputWeight :: Ptr ()), argPtr (castPtr raw_bias :: Ptr ()), argPtr (castPtr raw_initState :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a GRU operation and returns the value and optionally the training state tensor.
--
-- This operation returns tensors @h@ and optionally @z@ that are defined recursively as follows: ```md for t = 0 to T-1   z[t] = fz( (h[t-1] m) R^T + x[t] W^T + b ),   r[t] = fr( (h[t-1] m) R^T + x[t] W^T + b ),   c[t] = (h[t-1] r[t] m) R^T   o[t] = fo( c[t] + x[t] W^T + b )   h[t] = z[t]h[t-1] + (1-z[t])o[t] ``` If @resetAfter = YES@ then @c[t]@ is replaced by ```md   c[t] = ( (h[t-1] m) R^T + b2 ) r[t] ``` If @flipZ = YES@ then @h[t]@ is replaced by ```md   h[t] = (1-z[t])h[t-1] + z[t]o[t]. ``` @W@ is optional @inputWeight@, @R@ is @recurrentWeight@, @b@ is optional  @bias@, @m@ is optional @mask@, @x[t]@ is @source@ @h[t]@ is the first output, @z[t]@ is the second output (optional) and @h[-1]@ is @initState@. @b2@ is an optional @resetBias@ vector, only used when @resetAfter = YES@. See ``MPSGraphGRUDescriptor`` for different @activation@ options for @f()@.
--
-- - Parameters:   - source: A tensor containing the source data @x[t]@ with the data layout [T,N,I]. In case @inputWeight = nil@ and @bidirectional = NO@ then the layout is [T,N,3H] and for @inputWeight = nil@ and @bidirectional = YES@ the layout is [T,N,6H].   - recurrentWeight: A tensor containing the recurrent weights @R@. For @bidirectional@ the layout is [2,3H,H] and otherwise it is [3H,H].   - inputWeight: A tensor containing the input weights matrix @W@ - optional, if missing the operation assumes a diagonal unit-matrix.                     For @bidirectional@ the layout is [6H,I] and otherwise it is [3H,I].   - bias: A tensor containing the bias @b@ - optional, if missing the operation assumes zeroes. For @bidirectional@ the layout is [6H] and otherwise it is [3H].   - descriptor: A descriptor that defines the parameters for the GRU operation.   - name: The name for the operation. - Returns: A valid @MPSGraphTensor@ array of size 1 or 2 depending on value of  @descriptor.training@.            The layout of the state output is [T,N,H] or [T,N,2H] for bidirectional,            and the layout of the @trainingState@ output is [T,N,3H] or [T,N,6H] for bidirectional.
--
-- ObjC selector: @- GRUWithSourceTensor:recurrentWeight:inputWeight:bias:descriptor:name:@
gruWithSourceTensor_recurrentWeight_inputWeight_bias_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor source, IsMPSGraphTensor recurrentWeight, IsMPSGraphTensor inputWeight, IsMPSGraphTensor bias, IsMPSGraphGRUDescriptor descriptor, IsNSString name) => mpsGraph -> source -> recurrentWeight -> inputWeight -> bias -> descriptor -> name -> IO (Id NSArray)
gruWithSourceTensor_recurrentWeight_inputWeight_bias_descriptor_name mpsGraph  source recurrentWeight inputWeight bias descriptor name =
  withObjCPtr source $ \raw_source ->
    withObjCPtr recurrentWeight $ \raw_recurrentWeight ->
      withObjCPtr inputWeight $ \raw_inputWeight ->
        withObjCPtr bias $ \raw_bias ->
          withObjCPtr descriptor $ \raw_descriptor ->
            withObjCPtr name $ \raw_name ->
                sendMsg mpsGraph (mkSelector "GRUWithSourceTensor:recurrentWeight:inputWeight:bias:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_recurrentWeight :: Ptr ()), argPtr (castPtr raw_inputWeight :: Ptr ()), argPtr (castPtr raw_bias :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a GRU gradient operation and returns the gradient tensor values.
--
-- For details of this operation and parameters, refer to documentation of ``MPSGraph/GRUWithSourceTensor:recurrentWeight:inputWeight:bias:initState:mask:secondaryBias:descriptor:name:``.
--
-- - Parameters:   - source: A tensor containing the source data @x[t]@ with the data layout [T,N,I]. In case @inputWeight = nil@ and @bidirectional = NO@ then the layout is [T,N,3H] and for @inputWeight = nil@ and @bidirectional = YES@ the layout is [T,N,6H].   - recurrentWeight: A tensor containing the recurrent weights @R@. For @bidirectional@ the layout is [2,3H,H] and otherwise it is [3H,H].   - sourceGradient: The input gradient, that is the gradient of a tensor with respect to the first output of the forward pass.   - zState: The second output of         ``MPSGraph/GRUWithSourceTensor:recurrentWeight:inputWeight:bias:initState:descriptor:name:``         with  @descriptor.training = YES@.   - outputFwd: The first output of         ``MPSGraph/GRUWithSourceTensor:recurrentWeight:inputWeight:bias:initState:descriptor:name:``         with @descriptor.training = YES@.   - stateGradient: The input gradient for state coming from the future timestep - optional, if missing the operation assumes zeroes.   - inputWeight: A tensor containing the input weights matrix @W@ - optional, if missing the operation assumes a diagonal unit-matrix.                     For @bidirectional@ the layout is [6H,I] and otherwise it is [3H,I].   - bias: A tensor containing the bias @b@ - optional, if missing the operation assumes zeroes. For @bidirectional@ the layout is [6H] and otherwise it is [3H].   - initState: The initial internal state of the LSTM @h[-1]@ - optional, if missing the operation assumes zeroes. For @bidirectional@ the layout is [N,2H] and otherwise it is [N,H].   - mask: A tensor containing the mask @m@ - optional, if missing the operation assumes ones. Useful for dropout.   - secondaryBias: A tensor containing the secondary bias vector @b2@ - optional, if missing the operation assumes zeroes. Only used with @reset_after = YES@. Shape is [H], ie. a vector for each gate, or [2H] for bidirectional.   - descriptor: A descriptor that defines the parameters for the GRU operation.   - name: The name for the operation. - Returns: A valid @MPSGraphTensor@ array containing gradients for each input tensor, except for @sourceGradient@ and @mask@. In case an input is nil, no gradient will be returned for it. The order of the gradients will be: for @source@, for @recurrentWeight@, for @inputWeight@, for @bias@, for @initState@ and for @secondaryBias@.
--
-- ObjC selector: @- GRUGradientsWithSourceTensor:recurrentWeight:sourceGradient:zState:outputFwd:stateGradient:inputWeight:bias:initState:mask:secondaryBias:descriptor:name:@
gruGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_outputFwd_stateGradient_inputWeight_bias_initState_mask_secondaryBias_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor source, IsMPSGraphTensor recurrentWeight, IsMPSGraphTensor sourceGradient, IsMPSGraphTensor zState, IsMPSGraphTensor outputFwd, IsMPSGraphTensor stateGradient, IsMPSGraphTensor inputWeight, IsMPSGraphTensor bias, IsMPSGraphTensor initState, IsMPSGraphTensor mask, IsMPSGraphTensor secondaryBias, IsMPSGraphGRUDescriptor descriptor, IsNSString name) => mpsGraph -> source -> recurrentWeight -> sourceGradient -> zState -> outputFwd -> stateGradient -> inputWeight -> bias -> initState -> mask -> secondaryBias -> descriptor -> name -> IO (Id NSArray)
gruGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_outputFwd_stateGradient_inputWeight_bias_initState_mask_secondaryBias_descriptor_name mpsGraph  source recurrentWeight sourceGradient zState outputFwd stateGradient inputWeight bias initState mask secondaryBias descriptor name =
  withObjCPtr source $ \raw_source ->
    withObjCPtr recurrentWeight $ \raw_recurrentWeight ->
      withObjCPtr sourceGradient $ \raw_sourceGradient ->
        withObjCPtr zState $ \raw_zState ->
          withObjCPtr outputFwd $ \raw_outputFwd ->
            withObjCPtr stateGradient $ \raw_stateGradient ->
              withObjCPtr inputWeight $ \raw_inputWeight ->
                withObjCPtr bias $ \raw_bias ->
                  withObjCPtr initState $ \raw_initState ->
                    withObjCPtr mask $ \raw_mask ->
                      withObjCPtr secondaryBias $ \raw_secondaryBias ->
                        withObjCPtr descriptor $ \raw_descriptor ->
                          withObjCPtr name $ \raw_name ->
                              sendMsg mpsGraph (mkSelector "GRUGradientsWithSourceTensor:recurrentWeight:sourceGradient:zState:outputFwd:stateGradient:inputWeight:bias:initState:mask:secondaryBias:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_recurrentWeight :: Ptr ()), argPtr (castPtr raw_sourceGradient :: Ptr ()), argPtr (castPtr raw_zState :: Ptr ()), argPtr (castPtr raw_outputFwd :: Ptr ()), argPtr (castPtr raw_stateGradient :: Ptr ()), argPtr (castPtr raw_inputWeight :: Ptr ()), argPtr (castPtr raw_bias :: Ptr ()), argPtr (castPtr raw_initState :: Ptr ()), argPtr (castPtr raw_mask :: Ptr ()), argPtr (castPtr raw_secondaryBias :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a GRU gradient operation and returns the gradient tensor values.
--
-- For details of this operation and parameters, refer to documentation of ``MPSGraph/GRUWithSourceTensor:recurrentWeight:inputWeight:bias:initState:mask:secondaryBias:descriptor:name:``.
--
-- - Parameters:   - source: A tensor containing the source data @x[t]@ with the data layout [T,N,I]. In case @inputWeight = nil@ and @bidirectional = NO@ then the layout is [T,N,3H] and for @inputWeight = nil@ and @bidirectional = YES@ the layout is [T,N,6H].   - recurrentWeight: A tensor containing the recurrent weights @R@. For @bidirectional@ the layout is [2,3H,H] and otherwise it is [3H,H].   - sourceGradient: The input gradient, that is the gradient of a tensor with respect to the first output of the forward pass.   - zState: The second output of         ``MPSGraph/GRUWithSourceTensor:recurrentWeight:inputWeight:bias:initState:descriptor:name:``         with  @descriptor.training = YES@.   - outputFwd: The first output of         ``MPSGraph/GRUWithSourceTensor:recurrentWeight:inputWeight:bias:initState:descriptor:name:``         with @descriptor.training = YES@.   - inputWeight: A tensor containing the input weights matrix @W@ - optional, if missing the operation assumes a diagonal unit-matrix.                     For @bidirectional@ the layout is [6H,I] and otherwise it is [3H,I].   - bias: A tensor containing the bias @b@ - optional, if missing the operation assumes zeroes. For @bidirectional@ the layout is [6H] and otherwise it is [3H].   - initState: The initial internal state of the LSTM @h[-1]@ - optional, if missing the operation assumes zeroes. For @bidirectional@ the layout is [N,2H] and otherwise it is [N,H].   - descriptor: A descriptor that defines the parameters for the GRU operation.   - name: The name for the operation. - Returns: A valid @MPSGraphTensor@ array containing gradients for each input tensor, except for @sourceGradient@ and @mask@. In case an input is nil, no gradient will be returned for it. The order of the gradients will be: for @source@, for @recurrentWeight@, for @inputWeight@, for @bias@ and for @initState@.
--
-- ObjC selector: @- GRUGradientsWithSourceTensor:recurrentWeight:sourceGradient:zState:outputFwd:inputWeight:bias:initState:descriptor:name:@
gruGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_outputFwd_inputWeight_bias_initState_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor source, IsMPSGraphTensor recurrentWeight, IsMPSGraphTensor sourceGradient, IsMPSGraphTensor zState, IsMPSGraphTensor outputFwd, IsMPSGraphTensor inputWeight, IsMPSGraphTensor bias, IsMPSGraphTensor initState, IsMPSGraphGRUDescriptor descriptor, IsNSString name) => mpsGraph -> source -> recurrentWeight -> sourceGradient -> zState -> outputFwd -> inputWeight -> bias -> initState -> descriptor -> name -> IO (Id NSArray)
gruGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_outputFwd_inputWeight_bias_initState_descriptor_name mpsGraph  source recurrentWeight sourceGradient zState outputFwd inputWeight bias initState descriptor name =
  withObjCPtr source $ \raw_source ->
    withObjCPtr recurrentWeight $ \raw_recurrentWeight ->
      withObjCPtr sourceGradient $ \raw_sourceGradient ->
        withObjCPtr zState $ \raw_zState ->
          withObjCPtr outputFwd $ \raw_outputFwd ->
            withObjCPtr inputWeight $ \raw_inputWeight ->
              withObjCPtr bias $ \raw_bias ->
                withObjCPtr initState $ \raw_initState ->
                  withObjCPtr descriptor $ \raw_descriptor ->
                    withObjCPtr name $ \raw_name ->
                        sendMsg mpsGraph (mkSelector "GRUGradientsWithSourceTensor:recurrentWeight:sourceGradient:zState:outputFwd:inputWeight:bias:initState:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_recurrentWeight :: Ptr ()), argPtr (castPtr raw_sourceGradient :: Ptr ()), argPtr (castPtr raw_zState :: Ptr ()), argPtr (castPtr raw_outputFwd :: Ptr ()), argPtr (castPtr raw_inputWeight :: Ptr ()), argPtr (castPtr raw_bias :: Ptr ()), argPtr (castPtr raw_initState :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a GRU gradient operation and returns the gradient tensor values.
--
-- For details of this operation and parameters, refer to documentation of ``MPSGraph/GRUWithSourceTensor:recurrentWeight:inputWeight:bias:initState:mask:secondaryBias:descriptor:name:``.
--
-- - Parameters:   - source: A tensor containing the source data @x[t]@ with the data layout [T,N,I]. In case @inputWeight = nil@ and @bidirectional = NO@ then the layout is [T,N,3H] and for @inputWeight = nil@ and @bidirectional = YES@ the layout is [T,N,6H].   - recurrentWeight: A tensor containing the recurrent weights @R@. For @bidirectional@ the layout is [2,3H,H] and otherwise it is [3H,H].   - sourceGradient: The input gradient, that is the gradient of a tensor with respect to the first output of the forward pass.   - zState: The second output of         ``MPSGraph/GRUWithSourceTensor:recurrentWeight:inputWeight:bias:initState:descriptor:name:``         with  @descriptor.training = YES@.   - outputFwd: The first output of         ``MPSGraph/GRUWithSourceTensor:recurrentWeight:inputWeight:bias:initState:descriptor:name:``         with @descriptor.training = YES@.   - inputWeight: A tensor containing the input weights matrix @W@ - optional, if missing the operation assumes a diagonal unit-matrix.                     For @bidirectional@ the layout is [6H,I] and otherwise it is [3H,I].   - bias: A tensor containing the bias @b@ - optional, if missing the operation assumes zeroes. For @bidirectional@ the layout is [6H] and otherwise it is [3H].   - descriptor: A descriptor that defines the parameters for the GRU operation.   - name: The name for the operation. - Returns: A valid @MPSGraphTensor@ array containing gradients for each input tensor, except for @sourceGradient@ and @mask@. In case an input is nil, no gradient will be returned for it. The order of the gradients will be: for @source@, for @recurrentWeight@, for @inputWeight@ and for @bias@.
--
-- ObjC selector: @- GRUGradientsWithSourceTensor:recurrentWeight:sourceGradient:zState:outputFwd:inputWeight:bias:descriptor:name:@
gruGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_outputFwd_inputWeight_bias_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor source, IsMPSGraphTensor recurrentWeight, IsMPSGraphTensor sourceGradient, IsMPSGraphTensor zState, IsMPSGraphTensor outputFwd, IsMPSGraphTensor inputWeight, IsMPSGraphTensor bias, IsMPSGraphGRUDescriptor descriptor, IsNSString name) => mpsGraph -> source -> recurrentWeight -> sourceGradient -> zState -> outputFwd -> inputWeight -> bias -> descriptor -> name -> IO (Id NSArray)
gruGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_outputFwd_inputWeight_bias_descriptor_name mpsGraph  source recurrentWeight sourceGradient zState outputFwd inputWeight bias descriptor name =
  withObjCPtr source $ \raw_source ->
    withObjCPtr recurrentWeight $ \raw_recurrentWeight ->
      withObjCPtr sourceGradient $ \raw_sourceGradient ->
        withObjCPtr zState $ \raw_zState ->
          withObjCPtr outputFwd $ \raw_outputFwd ->
            withObjCPtr inputWeight $ \raw_inputWeight ->
              withObjCPtr bias $ \raw_bias ->
                withObjCPtr descriptor $ \raw_descriptor ->
                  withObjCPtr name $ \raw_name ->
                      sendMsg mpsGraph (mkSelector "GRUGradientsWithSourceTensor:recurrentWeight:sourceGradient:zState:outputFwd:inputWeight:bias:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_recurrentWeight :: Ptr ()), argPtr (castPtr raw_sourceGradient :: Ptr ()), argPtr (castPtr raw_zState :: Ptr ()), argPtr (castPtr raw_outputFwd :: Ptr ()), argPtr (castPtr raw_inputWeight :: Ptr ()), argPtr (castPtr raw_bias :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a Resize operation and returns the result tensor.
--
-- Resamples input images to given size. Result images will be distorted if size is of different aspect ratio.  Resize supports the following modes:  Nearest Neighbor - values are interpolated using the closest neighbor pixel  Bilinear - values are computed using bilinear interpolation of 4 neighboring pixels  Destination indices are computed using direct index scaling by default, with no offset added.  If the centerResult parameter is true, the destination indices will be scaled and shifted to be centered  on the input image.  If the alignCorners parameter is true, the corners of the result images will match the input images.  Scaling will be modified to a factor of (size - 1) / (inputSize - 1). When alignCorners is true, the  centerResult parameter does nothing.  In order to achieve the same behavior as OpenCV's resize and TensorFlowV2's resize,  ```md  centerResult = YES;  alginCorners = NO;  ```  To achieve the same behavior as TensorFlowV1 resize  ```md  centerResult = NO;  ```
--
-- - Parameters:   - imagesTensor: Tensor containing input images.   - size: A 2-element shape as [newHeight, newWidth]   - mode: The resampling mode to use. If nearest sampling is specifed, RoundPreferCeil mode will be used.   - centerResult: Controls if the result image is centered on the input image. When NO, the result will have the top left corner aligned   - alignCorners: When YES, the result image will have the same value as the input image in the corners   - layout: Specifies what layout the provided tensor is in. The returned tensor will follow the same layout. Valid layouts are NHWC, NCHW, HWC, CHW, and HW.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- resizeTensor:size:mode:centerResult:alignCorners:layout:name:@
resizeTensor_size_mode_centerResult_alignCorners_layout_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor imagesTensor, IsNSString name) => mpsGraph -> imagesTensor -> RawId -> MPSGraphResizeMode -> Bool -> Bool -> MPSGraphTensorNamedDataLayout -> name -> IO (Id MPSGraphTensor)
resizeTensor_size_mode_centerResult_alignCorners_layout_name mpsGraph  imagesTensor size mode centerResult alignCorners layout name =
  withObjCPtr imagesTensor $ \raw_imagesTensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "resizeTensor:size:mode:centerResult:alignCorners:layout:name:") (retPtr retVoid) [argPtr (castPtr raw_imagesTensor :: Ptr ()), argPtr (castPtr (unRawId size) :: Ptr ()), argCULong (coerce mode), argCULong (if centerResult then 1 else 0), argCULong (if alignCorners then 1 else 0), argCULong (coerce layout), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a Resize operation and returns the result tensor.
--
-- Resamples input images to given size. Result images will be distorted if size is of different aspect ratio.  Resize supports the following modes:  Nearest Neighbor - values are interpolated using the closest neighbor pixel  Bilinear - values are computed using bilinear interpolation of 4 neighboring pixels  Destination indices are computed using direct index scaling by default, with no offset added.  If the centerResult parameter is true, the destination indices will be scaled and shifted to be centered  on the input image.  If the alignCorners parameter is true, the corners of the result images will match the input images.  Scaling will be modified to a factor of (size - 1) / (inputSize - 1). When alignCorners is true, the  centerResult parameter does nothing.  In order to achieve the same behavior as OpenCV's resize and TensorFlowV2's resize,  ```md  centerResult = YES;  alginCorners = NO;  ```  To achieve the same behavior as TensorFlowV1 resize  ```md  centerResult = NO;  ```
--
-- - Parameters:   - imagesTensor: Tensor containing input images.   - size: 1D Int32 or Int64 tensor. A 2-element shape as [newHeight, newWidth]   - mode: The resampling mode to use. If nearest sampling is specifed, RoundPreferCeil mode will be used.   - centerResult: Controls if the result image is centered on the input image. When NO, the result will have the top left corner aligned   - alignCorners: When YES, the result image will have the same value as the input image in the corners   - layout: Specifies what layout the provided tensor is in. The returned tensor will follow the same layout. Valid layouts are NHWC, NCHW, HWC, CHW, and HW.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- resizeTensor:sizeTensor:mode:centerResult:alignCorners:layout:name:@
resizeTensor_sizeTensor_mode_centerResult_alignCorners_layout_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor imagesTensor, IsMPSGraphTensor size, IsNSString name) => mpsGraph -> imagesTensor -> size -> MPSGraphResizeMode -> Bool -> Bool -> MPSGraphTensorNamedDataLayout -> name -> IO (Id MPSGraphTensor)
resizeTensor_sizeTensor_mode_centerResult_alignCorners_layout_name mpsGraph  imagesTensor size mode centerResult alignCorners layout name =
  withObjCPtr imagesTensor $ \raw_imagesTensor ->
    withObjCPtr size $ \raw_size ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "resizeTensor:sizeTensor:mode:centerResult:alignCorners:layout:name:") (retPtr retVoid) [argPtr (castPtr raw_imagesTensor :: Ptr ()), argPtr (castPtr raw_size :: Ptr ()), argCULong (coerce mode), argCULong (if centerResult then 1 else 0), argCULong (if alignCorners then 1 else 0), argCULong (coerce layout), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a Resize operation and returns the result tensor.
--
-- Resamples input images to given size. Result images will be distorted if size is of different aspect ratio. Resize supports the following modes: Nearest Neighbor - values are interpolated using the closest neighbor pixel Bilinear - values are computed using bilinear interpolation of 4 neighboring pixels Destination indices are computed using direct index scaling by default, with no offset added. If the centerResult parameter is true, the destination indices will be scaled and shifted to be centered on the input image. If the alignCorners parameter is true, the corners of the result images will match the input images. Scaling will be modified to a factor of (size - 1) / (inputSize - 1). When alignCorners is true, the centerResult parameter does nothing. In order to achieve the same behavior as OpenCV's resize and TensorFlowV2's resize, ```md centerResult = YES; alginCorners = NO; ``` To achieve the same behavior as TensorFlowV1 resize ```md centerResult = NO; ```
--
-- - Parameters:   - imagesTensor: Tensor containing input images.   - size: The target size of the result tensor. 1D Int32 or Int64 tensor of size equal to rank of input.   - mode: The resampling mode to use. If nearest sampling is specifed, RoundPreferCeil mode will be used.   - centerResult: Controls if the result image is centered on the input image. When NO, the result will have the top left corner aligned   - alignCorners: When YES, the result image will have the same value as the input image in the corners   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- resizeTensor:sizeTensor:mode:centerResult:alignCorners:name:@
resizeTensor_sizeTensor_mode_centerResult_alignCorners_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor imagesTensor, IsMPSGraphTensor size, IsNSString name) => mpsGraph -> imagesTensor -> size -> MPSGraphResizeMode -> Bool -> Bool -> name -> IO (Id MPSGraphTensor)
resizeTensor_sizeTensor_mode_centerResult_alignCorners_name mpsGraph  imagesTensor size mode centerResult alignCorners name =
  withObjCPtr imagesTensor $ \raw_imagesTensor ->
    withObjCPtr size $ \raw_size ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "resizeTensor:sizeTensor:mode:centerResult:alignCorners:name:") (retPtr retVoid) [argPtr (castPtr raw_imagesTensor :: Ptr ()), argPtr (castPtr raw_size :: Ptr ()), argCULong (coerce mode), argCULong (if centerResult then 1 else 0), argCULong (if alignCorners then 1 else 0), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Resamples input images to given size using nearest neighbor sampling.
--
-- This API allows for the rounding mode to be specified. Resamples input images to given size. Result images will be distorted if size is of different aspect ratio. Resize supports the following modes: Nearest Neighbor - values are interpolated using the closest neighbor pixel Bilinear - values are computed using bilinear interpolation of 4 neighboring pixels Destination indices are computed using direct index scaling by default, with no offset added. If the centerResult parameter is true, the destination indices will be scaled and shifted to be centered on the input image. If the alignCorners parameter is true, the corners of the result images will match the input images. Scaling will be modified to a factor of (size - 1) / (inputSize - 1). When alignCorners is true, the centerResult parameter does nothing. In order to achieve the same behavior as OpenCV's resize and TensorFlowV2's resize, ```md centerResult = YES; alginCorners = NO; ``` To achieve the same behavior as TensorFlowV1 resize ```md centerResult = NO; ```
--
-- - Parameters:   - imagesTensor: Tensor containing input images.   - size: 1D Int32 or Int64 tensor. A 2-element shape as [newHeight, newWidth]   - nearestRoundingMode: The rounding mode to use when using nearest resampling. Default is roundPreferCeil.   - centerResult: Controls if the result image is centered on the input image. When NO, the result will have the top left corner aligned   - alignCorners: When YES, the result image will have the same value as the input image in the corners   - layout: Specifies what layout the provided tensor is in. The returned tensor will follow the same layout. Valid layouts are NHWC, NCHW, HWC, CHW, and HW.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- resizeNearestWithTensor:sizeTensor:nearestRoundingMode:centerResult:alignCorners:layout:name:@
resizeNearestWithTensor_sizeTensor_nearestRoundingMode_centerResult_alignCorners_layout_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor imagesTensor, IsMPSGraphTensor size, IsNSString name) => mpsGraph -> imagesTensor -> size -> MPSGraphResizeNearestRoundingMode -> Bool -> Bool -> MPSGraphTensorNamedDataLayout -> name -> IO (Id MPSGraphTensor)
resizeNearestWithTensor_sizeTensor_nearestRoundingMode_centerResult_alignCorners_layout_name mpsGraph  imagesTensor size nearestRoundingMode centerResult alignCorners layout name =
  withObjCPtr imagesTensor $ \raw_imagesTensor ->
    withObjCPtr size $ \raw_size ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "resizeNearestWithTensor:sizeTensor:nearestRoundingMode:centerResult:alignCorners:layout:name:") (retPtr retVoid) [argPtr (castPtr raw_imagesTensor :: Ptr ()), argPtr (castPtr raw_size :: Ptr ()), argCULong (coerce nearestRoundingMode), argCULong (if centerResult then 1 else 0), argCULong (if alignCorners then 1 else 0), argCULong (coerce layout), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a Resize operation and returns the result tensor.
--
-- Resamples input images to given size using nearest neighbor sampling. Result images will be distorted if size is of different aspect ratio. Destination indices are computed using direct index scaling by default, with no offset added. If the centerResult parameter is true, the destination indices will be scaled and shifted to be centered on the input image. If the alignCorners parameter is true, the corners of the result images will match the input images. Scaling will be modified to a factor of (size - 1) / (inputSize - 1). When alignCorners is true, the centerResult parameter does nothing. In order to achieve the same behavior as OpenCV's resize and TensorFlowV2's resize, ```md centerResult = YES; alginCorners = NO; ``` To achieve the same behavior as TensorFlowV1 resize ```md centerResult = NO; ```
--
-- - Parameters:   - imagesTensor: Tensor containing input images.   - size: The target size of the result tensor. 1D Int32 or Int64 tensor of size equal to rank of input.   - nearestRoundingMode: The rounding mode to use when using nearest resampling. Default is roundPreferCeil.   - centerResult: Controls if the result image is centered on the input image. When NO, the result will have the top left corner aligned   - alignCorners: When YES, the result image will have the same value as the input image in the corners   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- resizeNearestWithTensor:sizeTensor:nearestRoundingMode:centerResult:alignCorners:name:@
resizeNearestWithTensor_sizeTensor_nearestRoundingMode_centerResult_alignCorners_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor imagesTensor, IsMPSGraphTensor size, IsNSString name) => mpsGraph -> imagesTensor -> size -> MPSGraphResizeNearestRoundingMode -> Bool -> Bool -> name -> IO (Id MPSGraphTensor)
resizeNearestWithTensor_sizeTensor_nearestRoundingMode_centerResult_alignCorners_name mpsGraph  imagesTensor size nearestRoundingMode centerResult alignCorners name =
  withObjCPtr imagesTensor $ \raw_imagesTensor ->
    withObjCPtr size $ \raw_size ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "resizeNearestWithTensor:sizeTensor:nearestRoundingMode:centerResult:alignCorners:name:") (retPtr retVoid) [argPtr (castPtr raw_imagesTensor :: Ptr ()), argPtr (castPtr raw_size :: Ptr ()), argCULong (coerce nearestRoundingMode), argCULong (if centerResult then 1 else 0), argCULong (if alignCorners then 1 else 0), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Resamples input images to given size using bilinear sampling.
--
-- Resamples input images to given size using nearest neighbor sampling. Result images will be distorted if size is of different aspect ratio. Destination indices are computed using direct index scaling by default, with no offset added. If the centerResult parameter is true, the destination indices will be scaled and shifted to be centered on the input image. If the alignCorners parameter is true, the corners of the result images will match the input images. Scaling will be modified to a factor of (size - 1) / (inputSize - 1). When alignCorners is true, the centerResult parameter does nothing. In order to achieve the same behavior as OpenCV's resize and TensorFlowV2's resize, ```md centerResult = YES; alginCorners = NO; ``` To achieve the same behavior as TensorFlowV1 resize ```md centerResult = NO; ```
--
-- - Parameters:   - imagesTensor: Tensor containing input images.   - size: 1D Int32 or Int64 tensor. A 2-element shape as [newHeight, newWidth]   - centerResult: Controls if the result image is centered on the input image. When NO, the result will have the top left corner aligned   - alignCorners: When YES, the result image will have the same value as the input image in the corners   - layout: Specifies what layout the provided tensor is in. The returned tensor will follow the same layout. Valid layouts are NHWC, NCHW, HWC, CHW, and HW.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- resizeBilinearWithTensor:sizeTensor:centerResult:alignCorners:layout:name:@
resizeBilinearWithTensor_sizeTensor_centerResult_alignCorners_layout_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor imagesTensor, IsMPSGraphTensor size, IsNSString name) => mpsGraph -> imagesTensor -> size -> Bool -> Bool -> MPSGraphTensorNamedDataLayout -> name -> IO (Id MPSGraphTensor)
resizeBilinearWithTensor_sizeTensor_centerResult_alignCorners_layout_name mpsGraph  imagesTensor size centerResult alignCorners layout name =
  withObjCPtr imagesTensor $ \raw_imagesTensor ->
    withObjCPtr size $ \raw_size ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "resizeBilinearWithTensor:sizeTensor:centerResult:alignCorners:layout:name:") (retPtr retVoid) [argPtr (castPtr raw_imagesTensor :: Ptr ()), argPtr (castPtr raw_size :: Ptr ()), argCULong (if centerResult then 1 else 0), argCULong (if alignCorners then 1 else 0), argCULong (coerce layout), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a Resize operation and returns the result tensor.
--
-- Resamples input images to given size using bilinear sampling. Result images will be distorted if size is of different aspect ratio. Destination indices are computed using direct index scaling by default, with no offset added. If the centerResult parameter is true, the destination indices will be scaled and shifted to be centered on the input image. If the alignCorners parameter is true, the corners of the result images will match the input images. Scaling will be modified to a factor of (size - 1) / (inputSize - 1). When alignCorners is true, the centerResult parameter does nothing. In order to achieve the same behavior as OpenCV's resize and TensorFlowV2's resize, ```md centerResult = YES; alginCorners = NO; ``` To achieve the same behavior as TensorFlowV1 resize ```md centerResult = NO; ```
--
-- - Parameters:   - imagesTensor: Tensor containing input images.   - size: The target size of the result tensor. 1D Int32 or Int64 tensor of size equal to rank of input.   - centerResult: Controls if the result image is centered on the input image. When NO, the result will have the top left corner aligned   - alignCorners: When YES, the result image will have the same value as the input image in the corners   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- resizeBilinearWithTensor:sizeTensor:centerResult:alignCorners:name:@
resizeBilinearWithTensor_sizeTensor_centerResult_alignCorners_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor imagesTensor, IsMPSGraphTensor size, IsNSString name) => mpsGraph -> imagesTensor -> size -> Bool -> Bool -> name -> IO (Id MPSGraphTensor)
resizeBilinearWithTensor_sizeTensor_centerResult_alignCorners_name mpsGraph  imagesTensor size centerResult alignCorners name =
  withObjCPtr imagesTensor $ \raw_imagesTensor ->
    withObjCPtr size $ \raw_size ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "resizeBilinearWithTensor:sizeTensor:centerResult:alignCorners:name:") (retPtr retVoid) [argPtr (castPtr raw_imagesTensor :: Ptr ()), argPtr (castPtr raw_size :: Ptr ()), argCULong (if centerResult then 1 else 0), argCULong (if alignCorners then 1 else 0), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Resamples input images to given size using the provided scale and offset.  Destination indices are computed using  ```md  dst_indices = (src_indicesscale) + offset  ```  For most use cases passing the scale and offset directly is unnecessary, and it is  preferable to use the API specifying centerResult and alignCorners.
--
-- - Parameters:   - imagesTensor: Tensor containing input images.   - size: 1D Int32 or Int64 tensor. A 2-element shape as [newHeight, newWidth]   - scaleOffset: 1D float tensor. A 4-element shape as [scaleY, scaleX, offsetY, offsetX]   - mode: The resampling mode to use. If nearest sampling is specifed, RoundPreferCeil mode will be used.   - layout: Specifies what layout the provided tensor is in. The returned tensor will follow the same layout. Valid layouts are NHWC, NCHW, HWC, CHW, and HW.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- resizeTensor:sizeTensor:scaleOffsetTensor:mode:layout:name:@
resizeTensor_sizeTensor_scaleOffsetTensor_mode_layout_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor imagesTensor, IsMPSGraphTensor size, IsMPSGraphTensor scaleOffset, IsNSString name) => mpsGraph -> imagesTensor -> size -> scaleOffset -> MPSGraphResizeMode -> MPSGraphTensorNamedDataLayout -> name -> IO (Id MPSGraphTensor)
resizeTensor_sizeTensor_scaleOffsetTensor_mode_layout_name mpsGraph  imagesTensor size scaleOffset mode layout name =
  withObjCPtr imagesTensor $ \raw_imagesTensor ->
    withObjCPtr size $ \raw_size ->
      withObjCPtr scaleOffset $ \raw_scaleOffset ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "resizeTensor:sizeTensor:scaleOffsetTensor:mode:layout:name:") (retPtr retVoid) [argPtr (castPtr raw_imagesTensor :: Ptr ()), argPtr (castPtr raw_size :: Ptr ()), argPtr (castPtr raw_scaleOffset :: Ptr ()), argCULong (coerce mode), argCULong (coerce layout), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a Resize operation and returns the result tensor.
--
-- Resamples input images to given size using the provided scale and offset. Destination indices are computed using ```md dst_indices = (src_indices * scale) + offset ``` For most use cases passing the scale and offset directly is unnecessary, and it is preferable to use the API specifying centerResult and alignCorners.
--
-- - Parameters:   - imagesTensor: Tensor containing input images.   - size: The target size of the result tensor.  1D Int32 or Int64 tensor of size equal to rank of input.   - scale: 1D float tensor of size equal to rank of input.   - offset: 1D float tensor of size equal to rank of input.   - mode: The resampling mode to use. If nearest sampling is specifed, RoundPreferCeil mode will be used.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- resizeTensor:sizeTensor:scaleTensor:offsetTensor:mode:name:@
resizeTensor_sizeTensor_scaleTensor_offsetTensor_mode_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor imagesTensor, IsMPSGraphTensor size, IsMPSGraphTensor scale, IsMPSGraphTensor offset, IsNSString name) => mpsGraph -> imagesTensor -> size -> scale -> offset -> MPSGraphResizeMode -> name -> IO (Id MPSGraphTensor)
resizeTensor_sizeTensor_scaleTensor_offsetTensor_mode_name mpsGraph  imagesTensor size scale offset mode name =
  withObjCPtr imagesTensor $ \raw_imagesTensor ->
    withObjCPtr size $ \raw_size ->
      withObjCPtr scale $ \raw_scale ->
        withObjCPtr offset $ \raw_offset ->
          withObjCPtr name $ \raw_name ->
              sendMsg mpsGraph (mkSelector "resizeTensor:sizeTensor:scaleTensor:offsetTensor:mode:name:") (retPtr retVoid) [argPtr (castPtr raw_imagesTensor :: Ptr ()), argPtr (castPtr raw_size :: Ptr ()), argPtr (castPtr raw_scale :: Ptr ()), argPtr (castPtr raw_offset :: Ptr ()), argCULong (coerce mode), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Resamples input images to given size using the provided scale and offset and nearest neighbor sampling  See above discussion for more details.
--
-- - Parameters:   - imagesTensor: Tensor containing input images.   - size: 1D Int32 or Int64 tensor. A 2-element shape as [newHeight, newWidth]   - scaleOffset: 1D float tensor. A 4-element shape as [scaleY, scaleX, offsetY, offsetX]   - nearestRoundingMode: The rounding mode to use when using nearest resampling.   - layout: Specifies what layout the provided tensor is in. The returned tensor will follow the same layout. Valid layouts are NHWC, NCHW, HWC, CHW, and HW.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- resizeNearestWithTensor:sizeTensor:scaleOffsetTensor:nearestRoundingMode:layout:name:@
resizeNearestWithTensor_sizeTensor_scaleOffsetTensor_nearestRoundingMode_layout_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor imagesTensor, IsMPSGraphTensor size, IsMPSGraphTensor scaleOffset, IsNSString name) => mpsGraph -> imagesTensor -> size -> scaleOffset -> MPSGraphResizeNearestRoundingMode -> MPSGraphTensorNamedDataLayout -> name -> IO (Id MPSGraphTensor)
resizeNearestWithTensor_sizeTensor_scaleOffsetTensor_nearestRoundingMode_layout_name mpsGraph  imagesTensor size scaleOffset nearestRoundingMode layout name =
  withObjCPtr imagesTensor $ \raw_imagesTensor ->
    withObjCPtr size $ \raw_size ->
      withObjCPtr scaleOffset $ \raw_scaleOffset ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "resizeNearestWithTensor:sizeTensor:scaleOffsetTensor:nearestRoundingMode:layout:name:") (retPtr retVoid) [argPtr (castPtr raw_imagesTensor :: Ptr ()), argPtr (castPtr raw_size :: Ptr ()), argPtr (castPtr raw_scaleOffset :: Ptr ()), argCULong (coerce nearestRoundingMode), argCULong (coerce layout), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a Resize operation and returns the result tensor.
--
-- Resamples input images to given size using the provided scale and offset and nearest neighbor sampling. Destination indices are computed using ```md dst_indices = (src_indices * scale) + offset ``` For most use cases passing the scale and offset directly is unnecessary, and it is preferable to use the API specifying centerResult and alignCorners.
--
-- - Parameters:   - imagesTensor: Tensor containing input images.   - size: The target size of the result tensor.  1D Int32 or Int64 tensor of size equal to rank of input.   - scale: 1D float tensor of size equal to rank of input.   - offset: 1D float tensor of size equal to rank of input.   - nearestRoundingMode: The rounding mode to use when using nearest resampling. Default is roundPreferCeil.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- resizeNearestWithTensor:sizeTensor:scaleTensor:offsetTensor:nearestRoundingMode:name:@
resizeNearestWithTensor_sizeTensor_scaleTensor_offsetTensor_nearestRoundingMode_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor imagesTensor, IsMPSGraphTensor size, IsMPSGraphTensor scale, IsMPSGraphTensor offset, IsNSString name) => mpsGraph -> imagesTensor -> size -> scale -> offset -> MPSGraphResizeNearestRoundingMode -> name -> IO (Id MPSGraphTensor)
resizeNearestWithTensor_sizeTensor_scaleTensor_offsetTensor_nearestRoundingMode_name mpsGraph  imagesTensor size scale offset nearestRoundingMode name =
  withObjCPtr imagesTensor $ \raw_imagesTensor ->
    withObjCPtr size $ \raw_size ->
      withObjCPtr scale $ \raw_scale ->
        withObjCPtr offset $ \raw_offset ->
          withObjCPtr name $ \raw_name ->
              sendMsg mpsGraph (mkSelector "resizeNearestWithTensor:sizeTensor:scaleTensor:offsetTensor:nearestRoundingMode:name:") (retPtr retVoid) [argPtr (castPtr raw_imagesTensor :: Ptr ()), argPtr (castPtr raw_size :: Ptr ()), argPtr (castPtr raw_scale :: Ptr ()), argPtr (castPtr raw_offset :: Ptr ()), argCULong (coerce nearestRoundingMode), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Resamples input images to given size using the provided scale and offset and bilinear sampling  See above discussion for more details.
--
-- - Parameters:   - imagesTensor: Tensor containing input images.   - size: 1D Int32 or Int64 tensor. A 2-element shape as [newHeight, newWidth]   - scaleOffset: 1D float tensor. A 4-element shape as [scaleY, scaleX, offsetY, offsetX]   - nearestRoundingMode: The rounding mode to use when using nearest resampling.   - layout: Specifies what layout the provided tensor is in. The returned tensor will follow the same layout. Valid layouts are NHWC, NCHW, HWC, CHW, and HW.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- resizeBilinearWithTensor:sizeTensor:scaleOffsetTensor:layout:name:@
resizeBilinearWithTensor_sizeTensor_scaleOffsetTensor_layout_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor imagesTensor, IsMPSGraphTensor size, IsMPSGraphTensor scaleOffset, IsNSString name) => mpsGraph -> imagesTensor -> size -> scaleOffset -> MPSGraphTensorNamedDataLayout -> name -> IO (Id MPSGraphTensor)
resizeBilinearWithTensor_sizeTensor_scaleOffsetTensor_layout_name mpsGraph  imagesTensor size scaleOffset layout name =
  withObjCPtr imagesTensor $ \raw_imagesTensor ->
    withObjCPtr size $ \raw_size ->
      withObjCPtr scaleOffset $ \raw_scaleOffset ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "resizeBilinearWithTensor:sizeTensor:scaleOffsetTensor:layout:name:") (retPtr retVoid) [argPtr (castPtr raw_imagesTensor :: Ptr ()), argPtr (castPtr raw_size :: Ptr ()), argPtr (castPtr raw_scaleOffset :: Ptr ()), argCULong (coerce layout), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a Resize operation and returns the result tensor.
--
-- Resamples input images to given size using the provided scale and offset and bilinear sampling. Destination indices are computed using ```md dst_indices = (src_indices * scale) + offset ``` For most use cases passing the scale and offset directly is unnecessary, and it is preferable to use the API specifying centerResult and alignCorners.
--
-- - Parameters:   - imagesTensor: Tensor containing input images.   - size: The target size of the result tensor.  1D Int32 or Int64 tensor of size equal to rank of input.   - scale: 1D float tensor of size equal to rank of input.   - offset: 1D float tensor of size equal to rank of input.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- resizeBilinearWithTensor:sizeTensor:scaleTensor:offsetTensor:name:@
resizeBilinearWithTensor_sizeTensor_scaleTensor_offsetTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor imagesTensor, IsMPSGraphTensor size, IsMPSGraphTensor scale, IsMPSGraphTensor offset, IsNSString name) => mpsGraph -> imagesTensor -> size -> scale -> offset -> name -> IO (Id MPSGraphTensor)
resizeBilinearWithTensor_sizeTensor_scaleTensor_offsetTensor_name mpsGraph  imagesTensor size scale offset name =
  withObjCPtr imagesTensor $ \raw_imagesTensor ->
    withObjCPtr size $ \raw_size ->
      withObjCPtr scale $ \raw_scale ->
        withObjCPtr offset $ \raw_offset ->
          withObjCPtr name $ \raw_name ->
              sendMsg mpsGraph (mkSelector "resizeBilinearWithTensor:sizeTensor:scaleTensor:offsetTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_imagesTensor :: Ptr ()), argPtr (castPtr raw_size :: Ptr ()), argPtr (castPtr raw_scale :: Ptr ()), argPtr (castPtr raw_offset :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a Resize gradient operation and returns the result tensor.
--
-- Computes the gradient for the forward pass Resize op with identical parameters.  See discussion of resizeTensor for more in depth description of resize paramters.
--
-- - Parameters:   - gradient: Incoming gradient tensor   - input: Forward pass input tensor   - mode: The resampling mode to use. If nearest sampling is specifed, RoundPreferCeil mode will be used.   - centerResult: Controls if the result image is centered on the input image. When NO, the result will have the top left corner aligned   - alignCorners: When YES, the result image will have the same value as the input image in the corners   - layout: Specifies what layout the provided tensor is in. The returned tensor will follow the same layout. Valid layouts are NHWC, NCHW, HWC, CHW, and HW.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- resizeWithGradientTensor:input:mode:centerResult:alignCorners:layout:name:@
resizeWithGradientTensor_input_mode_centerResult_alignCorners_layout_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor gradient, IsMPSGraphTensor input, IsNSString name) => mpsGraph -> gradient -> input -> MPSGraphResizeMode -> Bool -> Bool -> MPSGraphTensorNamedDataLayout -> name -> IO (Id MPSGraphTensor)
resizeWithGradientTensor_input_mode_centerResult_alignCorners_layout_name mpsGraph  gradient input mode centerResult alignCorners layout name =
  withObjCPtr gradient $ \raw_gradient ->
    withObjCPtr input $ \raw_input ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "resizeWithGradientTensor:input:mode:centerResult:alignCorners:layout:name:") (retPtr retVoid) [argPtr (castPtr raw_gradient :: Ptr ()), argPtr (castPtr raw_input :: Ptr ()), argCULong (coerce mode), argCULong (if centerResult then 1 else 0), argCULong (if alignCorners then 1 else 0), argCULong (coerce layout), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a Resize gradient operation and returns the result tensor.
--
-- Computes the gradient for the forward pass Resize op with identical parameters.  See discussion of resizeTensor for more in depth description of resize paramters.
--
-- - Parameters:   - gradient: Incoming gradient tensor   - input: Forward pass input tensor   - nearestRoundingMode: The rounding mode to use when using nearest resampling.   - centerResult: Controls if the result image is centered on the input image. When NO, the result will have the top left corner aligned   - alignCorners: When YES, the result image will have the same value as the input image in the corners   - layout: Specifies what layout the provided tensor is in. The returned tensor will follow the same layout. Valid layouts are NHWC, NCHW, HWC, CHW, and HW.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- resizeNearestWithGradientTensor:input:nearestRoundingMode:centerResult:alignCorners:layout:name:@
resizeNearestWithGradientTensor_input_nearestRoundingMode_centerResult_alignCorners_layout_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor gradient, IsMPSGraphTensor input, IsNSString name) => mpsGraph -> gradient -> input -> MPSGraphResizeNearestRoundingMode -> Bool -> Bool -> MPSGraphTensorNamedDataLayout -> name -> IO (Id MPSGraphTensor)
resizeNearestWithGradientTensor_input_nearestRoundingMode_centerResult_alignCorners_layout_name mpsGraph  gradient input nearestRoundingMode centerResult alignCorners layout name =
  withObjCPtr gradient $ \raw_gradient ->
    withObjCPtr input $ \raw_input ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "resizeNearestWithGradientTensor:input:nearestRoundingMode:centerResult:alignCorners:layout:name:") (retPtr retVoid) [argPtr (castPtr raw_gradient :: Ptr ()), argPtr (castPtr raw_input :: Ptr ()), argCULong (coerce nearestRoundingMode), argCULong (if centerResult then 1 else 0), argCULong (if alignCorners then 1 else 0), argCULong (coerce layout), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a Resize gradient operation and returns the result tensor.
--
-- Computes the gradient for the forward pass Resize op with identical parameters.  See discussion of resizeTensor for more in depth description of resize paramters.
--
-- - Parameters:   - gradient: Incoming gradient tensor   - input: Forward pass input tensor   - centerResult: Controls if the result image is centered on the input image. When NO, the result will have the top left corner aligned   - alignCorners: When YES, the result image will have the same value as the input image in the corners   - layout: Specifies what layout the provided tensor is in. The returned tensor will follow the same layout. Valid layouts are NHWC, NCHW, HWC, CHW, and HW.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- resizeBilinearWithGradientTensor:input:centerResult:alignCorners:layout:name:@
resizeBilinearWithGradientTensor_input_centerResult_alignCorners_layout_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor gradient, IsMPSGraphTensor input, IsNSString name) => mpsGraph -> gradient -> input -> Bool -> Bool -> MPSGraphTensorNamedDataLayout -> name -> IO (Id MPSGraphTensor)
resizeBilinearWithGradientTensor_input_centerResult_alignCorners_layout_name mpsGraph  gradient input centerResult alignCorners layout name =
  withObjCPtr gradient $ \raw_gradient ->
    withObjCPtr input $ \raw_input ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "resizeBilinearWithGradientTensor:input:centerResult:alignCorners:layout:name:") (retPtr retVoid) [argPtr (castPtr raw_gradient :: Ptr ()), argPtr (castPtr raw_input :: Ptr ()), argCULong (if centerResult then 1 else 0), argCULong (if alignCorners then 1 else 0), argCULong (coerce layout), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a Resize gradient operation and returns the result tensor.
--
-- Computes the gradient for the forward pass Resize op with identical parameters.  See discussion of resizeTensor for more in depth description of resize paramters.
--
-- - Parameters:   - gradient: Incoming gradient tensor   - input: Forward pass input tensor   - scaleOffset: 1D float tensor. A 4-element shape as [scaleY, scaleX, offsetY, offsetX]   - mode: The resampling mode to use. If nearest sampling is specifed, RoundPreferCeil mode will be used.   - layout: Specifies what layout the provided tensor is in. The returned tensor will follow the same layout. Valid layouts are NHWC, NCHW, HWC, CHW, and HW.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- resizeWithGradientTensor:input:scaleOffsetTensor:mode:layout:name:@
resizeWithGradientTensor_input_scaleOffsetTensor_mode_layout_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor gradient, IsMPSGraphTensor input, IsMPSGraphTensor scaleOffset, IsNSString name) => mpsGraph -> gradient -> input -> scaleOffset -> MPSGraphResizeMode -> MPSGraphTensorNamedDataLayout -> name -> IO (Id MPSGraphTensor)
resizeWithGradientTensor_input_scaleOffsetTensor_mode_layout_name mpsGraph  gradient input scaleOffset mode layout name =
  withObjCPtr gradient $ \raw_gradient ->
    withObjCPtr input $ \raw_input ->
      withObjCPtr scaleOffset $ \raw_scaleOffset ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "resizeWithGradientTensor:input:scaleOffsetTensor:mode:layout:name:") (retPtr retVoid) [argPtr (castPtr raw_gradient :: Ptr ()), argPtr (castPtr raw_input :: Ptr ()), argPtr (castPtr raw_scaleOffset :: Ptr ()), argCULong (coerce mode), argCULong (coerce layout), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a Resize gradient operation and returns the result tensor.
--
-- Computes the gradient for the forward pass Resize op with identical parameters.  See discussion of resizeTensor for more in depth description of resize paramters.
--
-- - Parameters:   - gradient: Incoming gradient tensor   - input: Forward pass input tensor   - scale: 1D float tensor of size equal to rank of input.   - offset: 1D float tensor of size equal to rank of input.   - mode: The resampling mode to use. If nearest sampling is specifed, RoundPreferCeil mode will be used.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- resizeWithGradientTensor:input:scaleTensor:offsetTensor:mode:name:@
resizeWithGradientTensor_input_scaleTensor_offsetTensor_mode_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor gradient, IsMPSGraphTensor input, IsMPSGraphTensor scale, IsMPSGraphTensor offset, IsNSString name) => mpsGraph -> gradient -> input -> scale -> offset -> MPSGraphResizeMode -> name -> IO (Id MPSGraphTensor)
resizeWithGradientTensor_input_scaleTensor_offsetTensor_mode_name mpsGraph  gradient input scale offset mode name =
  withObjCPtr gradient $ \raw_gradient ->
    withObjCPtr input $ \raw_input ->
      withObjCPtr scale $ \raw_scale ->
        withObjCPtr offset $ \raw_offset ->
          withObjCPtr name $ \raw_name ->
              sendMsg mpsGraph (mkSelector "resizeWithGradientTensor:input:scaleTensor:offsetTensor:mode:name:") (retPtr retVoid) [argPtr (castPtr raw_gradient :: Ptr ()), argPtr (castPtr raw_input :: Ptr ()), argPtr (castPtr raw_scale :: Ptr ()), argPtr (castPtr raw_offset :: Ptr ()), argCULong (coerce mode), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a Resize gradient operation and returns the result tensor.
--
-- Computes the gradient for the forward pass Resize op with identical parameters. See discussion of resizeTensor for more in depth description of resize paramters.
--
-- - Parameters:   - gradient: Incoming gradient tensor   - input: Forward pass input tensor   - scaleOffset: 1D float tensor. A 4-element shape as [scaleY, scaleX, offsetY, offsetX]   - nearestRoundingMode: The rounding mode to use when using nearest resampling.   - layout: Specifies what layout the provided tensor is in. The returned tensor will follow the same layout. Valid layouts are NHWC, NCHW, HWC, CHW, and HW.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- resizeNearestWithGradientTensor:input:scaleOffsetTensor:nearestRoundingMode:layout:name:@
resizeNearestWithGradientTensor_input_scaleOffsetTensor_nearestRoundingMode_layout_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor gradient, IsMPSGraphTensor input, IsMPSGraphTensor scaleOffset, IsNSString name) => mpsGraph -> gradient -> input -> scaleOffset -> MPSGraphResizeNearestRoundingMode -> MPSGraphTensorNamedDataLayout -> name -> IO (Id MPSGraphTensor)
resizeNearestWithGradientTensor_input_scaleOffsetTensor_nearestRoundingMode_layout_name mpsGraph  gradient input scaleOffset nearestRoundingMode layout name =
  withObjCPtr gradient $ \raw_gradient ->
    withObjCPtr input $ \raw_input ->
      withObjCPtr scaleOffset $ \raw_scaleOffset ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "resizeNearestWithGradientTensor:input:scaleOffsetTensor:nearestRoundingMode:layout:name:") (retPtr retVoid) [argPtr (castPtr raw_gradient :: Ptr ()), argPtr (castPtr raw_input :: Ptr ()), argPtr (castPtr raw_scaleOffset :: Ptr ()), argCULong (coerce nearestRoundingMode), argCULong (coerce layout), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a Resize gradient operation and returns the result tensor.
--
-- Computes the gradient for the forward pass Resize op with nearest neighbor sampling and identical parameters. See discussion of resizeTensor for more in depth description of resize paramters.
--
-- - Parameters:   - gradient: Incoming gradient tensor   - input: Forward pass input tensor   - scale: 1D float tensor of size equal to rank of input.   - offset: 1D float tensor of size equal to rank of input.   - nearestRoundingMode: The rounding mode to use when using nearest resampling. Default is roundPreferCeil.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- resizeNearestWithGradientTensor:input:scaleTensor:offsetTensor:nearestRoundingMode:name:@
resizeNearestWithGradientTensor_input_scaleTensor_offsetTensor_nearestRoundingMode_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor gradient, IsMPSGraphTensor input, IsMPSGraphTensor scale, IsMPSGraphTensor offset, IsNSString name) => mpsGraph -> gradient -> input -> scale -> offset -> MPSGraphResizeNearestRoundingMode -> name -> IO (Id MPSGraphTensor)
resizeNearestWithGradientTensor_input_scaleTensor_offsetTensor_nearestRoundingMode_name mpsGraph  gradient input scale offset nearestRoundingMode name =
  withObjCPtr gradient $ \raw_gradient ->
    withObjCPtr input $ \raw_input ->
      withObjCPtr scale $ \raw_scale ->
        withObjCPtr offset $ \raw_offset ->
          withObjCPtr name $ \raw_name ->
              sendMsg mpsGraph (mkSelector "resizeNearestWithGradientTensor:input:scaleTensor:offsetTensor:nearestRoundingMode:name:") (retPtr retVoid) [argPtr (castPtr raw_gradient :: Ptr ()), argPtr (castPtr raw_input :: Ptr ()), argPtr (castPtr raw_scale :: Ptr ()), argPtr (castPtr raw_offset :: Ptr ()), argCULong (coerce nearestRoundingMode), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a Resize gradient operation and returns the result tensor.
--
-- Computes the gradient for the forward pass Resize op with bilinear sampling and identical parameters. See discussion of resizeTensor for more in depth description of resize paramters.
--
-- - Parameters:   - gradient: Incoming gradient tensor   - input: Forward pass input tensor   - scaleOffset: 1D float tensor. A 4-element shape as [scaleY, scaleX, offsetY, offsetX]   - layout: Specifies what layout the provided tensor is in. The returned tensor will follow the same layout. Valid layouts are NHWC, NCHW, HWC, CHW, and HW.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- resizeBilinearWithGradientTensor:input:scaleOffsetTensor:layout:name:@
resizeBilinearWithGradientTensor_input_scaleOffsetTensor_layout_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor gradient, IsMPSGraphTensor input, IsMPSGraphTensor scaleOffset, IsNSString name) => mpsGraph -> gradient -> input -> scaleOffset -> MPSGraphTensorNamedDataLayout -> name -> IO (Id MPSGraphTensor)
resizeBilinearWithGradientTensor_input_scaleOffsetTensor_layout_name mpsGraph  gradient input scaleOffset layout name =
  withObjCPtr gradient $ \raw_gradient ->
    withObjCPtr input $ \raw_input ->
      withObjCPtr scaleOffset $ \raw_scaleOffset ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "resizeBilinearWithGradientTensor:input:scaleOffsetTensor:layout:name:") (retPtr retVoid) [argPtr (castPtr raw_gradient :: Ptr ()), argPtr (castPtr raw_input :: Ptr ()), argPtr (castPtr raw_scaleOffset :: Ptr ()), argCULong (coerce layout), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a Resize gradient operation and returns the result tensor.
--
-- Computes the gradient for the forward pass Resize op with bilinear sampling and identical parameters.
--
-- - Parameters:   - gradient: Incoming gradient tensor   - input: Forward pass input tensor   - scale: 1D float tensor of size equal to rank of input.   - offset: 1D float tensor of size equal to rank of input.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- resizeBilinearWithGradientTensor:input:scaleTensor:offsetTensor:name:@
resizeBilinearWithGradientTensor_input_scaleTensor_offsetTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor gradient, IsMPSGraphTensor input, IsMPSGraphTensor scale, IsMPSGraphTensor offset, IsNSString name) => mpsGraph -> gradient -> input -> scale -> offset -> name -> IO (Id MPSGraphTensor)
resizeBilinearWithGradientTensor_input_scaleTensor_offsetTensor_name mpsGraph  gradient input scale offset name =
  withObjCPtr gradient $ \raw_gradient ->
    withObjCPtr input $ \raw_input ->
      withObjCPtr scale $ \raw_scale ->
        withObjCPtr offset $ \raw_offset ->
          withObjCPtr name $ \raw_name ->
              sendMsg mpsGraph (mkSelector "resizeBilinearWithGradientTensor:input:scaleTensor:offsetTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_gradient :: Ptr ()), argPtr (castPtr raw_input :: Ptr ()), argPtr (castPtr raw_scale :: Ptr ()), argPtr (castPtr raw_offset :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a reduction sum operation and returns the result tensor.
--
-- - Parameters:   - tensor: input tensor   - axis: axis of reduction   - name: name for the operation - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- reductionSumWithTensor:axis:name:@
reductionSumWithTensor_axis_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> CLong -> name -> IO (Id MPSGraphTensor)
reductionSumWithTensor_axis_name mpsGraph  tensor axis name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "reductionSumWithTensor:axis:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argCLong axis, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a reduction sum operation and returns the result tensor.
--
-- - Parameters:   - tensor: input tensor   - axes: axes of reduction   - name: name for the operation - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- reductionSumWithTensor:axes:name:@
reductionSumWithTensor_axes_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSArray axes, IsNSString name) => mpsGraph -> tensor -> axes -> name -> IO (Id MPSGraphTensor)
reductionSumWithTensor_axes_name mpsGraph  tensor axes name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr axes $ \raw_axes ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "reductionSumWithTensor:axes:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_axes :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a reduction max operation and returns the result tensor.
--
-- - Parameters:   - tensor: input tensor   - axis: axis of reduction   - name: name for the operation - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- reductionMaximumWithTensor:axis:name:@
reductionMaximumWithTensor_axis_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> CLong -> name -> IO (Id MPSGraphTensor)
reductionMaximumWithTensor_axis_name mpsGraph  tensor axis name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "reductionMaximumWithTensor:axis:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argCLong axis, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a reduction max operation and returns the result tensor.
--
-- - Parameters:   - tensor: input tensor   - axes: axes of reduction   - name: name for the operation - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- reductionMaximumWithTensor:axes:name:@
reductionMaximumWithTensor_axes_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSArray axes, IsNSString name) => mpsGraph -> tensor -> axes -> name -> IO (Id MPSGraphTensor)
reductionMaximumWithTensor_axes_name mpsGraph  tensor axes name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr axes $ \raw_axes ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "reductionMaximumWithTensor:axes:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_axes :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a reduction minimum operation and returns the result tensor.
--
-- - Parameters:   - tensor: input tensor   - axis: axis of reduction   - name: name for the operation - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- reductionMinimumWithTensor:axis:name:@
reductionMinimumWithTensor_axis_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> CLong -> name -> IO (Id MPSGraphTensor)
reductionMinimumWithTensor_axis_name mpsGraph  tensor axis name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "reductionMinimumWithTensor:axis:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argCLong axis, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a reduction min operation and returns the result tensor.
--
-- - Parameters:   - tensor: input tensor   - axes: axes of reduction   - name: name for the operation - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- reductionMinimumWithTensor:axes:name:@
reductionMinimumWithTensor_axes_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSArray axes, IsNSString name) => mpsGraph -> tensor -> axes -> name -> IO (Id MPSGraphTensor)
reductionMinimumWithTensor_axes_name mpsGraph  tensor axes name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr axes $ \raw_axes ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "reductionMinimumWithTensor:axes:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_axes :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a reduction max propagate NaN operation and returns the result tensor.
--
-- - Parameters:   - tensor: input tensor   - axis: axis of reduction   - name: name for the operation - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- reductionMaximumPropagateNaNWithTensor:axis:name:@
reductionMaximumPropagateNaNWithTensor_axis_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> CLong -> name -> IO (Id MPSGraphTensor)
reductionMaximumPropagateNaNWithTensor_axis_name mpsGraph  tensor axis name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "reductionMaximumPropagateNaNWithTensor:axis:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argCLong axis, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a reduction max propagate NaN operation and returns the result tensor.
--
-- - Parameters:   - tensor: input tensor   - axes: axes of reduction   - name: name for the operation - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- reductionMaximumPropagateNaNWithTensor:axes:name:@
reductionMaximumPropagateNaNWithTensor_axes_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSArray axes, IsNSString name) => mpsGraph -> tensor -> axes -> name -> IO (Id MPSGraphTensor)
reductionMaximumPropagateNaNWithTensor_axes_name mpsGraph  tensor axes name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr axes $ \raw_axes ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "reductionMaximumPropagateNaNWithTensor:axes:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_axes :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a reduction min propagate NaN operation and returns the result tensor.
--
-- - Parameters:   - tensor: input tensor   - axis: axis of reduction   - name: name for the operation - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- reductionMinimumPropagateNaNWithTensor:axis:name:@
reductionMinimumPropagateNaNWithTensor_axis_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> CLong -> name -> IO (Id MPSGraphTensor)
reductionMinimumPropagateNaNWithTensor_axis_name mpsGraph  tensor axis name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "reductionMinimumPropagateNaNWithTensor:axis:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argCLong axis, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a reduction min propagate NaN operation and returns the result tensor.
--
-- - Parameters:   - tensor: input tensor   - axes: axes of reduction   - name: name for the operation - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- reductionMinimumPropagateNaNWithTensor:axes:name:@
reductionMinimumPropagateNaNWithTensor_axes_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSArray axes, IsNSString name) => mpsGraph -> tensor -> axes -> name -> IO (Id MPSGraphTensor)
reductionMinimumPropagateNaNWithTensor_axes_name mpsGraph  tensor axes name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr axes $ \raw_axes ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "reductionMinimumPropagateNaNWithTensor:axes:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_axes :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a reduction product operation and returns the result tensor.
--
-- - Parameters:   - tensor: input tensor   - axis: axis of reduction   - name: name for the operation - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- reductionProductWithTensor:axis:name:@
reductionProductWithTensor_axis_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> CLong -> name -> IO (Id MPSGraphTensor)
reductionProductWithTensor_axis_name mpsGraph  tensor axis name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "reductionProductWithTensor:axis:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argCLong axis, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a reduction product operation and returns the result tensor.
--
-- - Parameters:   - tensor: input tensor   - axes: axes of reduction   - name: name for the operation - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- reductionProductWithTensor:axes:name:@
reductionProductWithTensor_axes_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSArray axes, IsNSString name) => mpsGraph -> tensor -> axes -> name -> IO (Id MPSGraphTensor)
reductionProductWithTensor_axes_name mpsGraph  tensor axes name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr axes $ \raw_axes ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "reductionProductWithTensor:axes:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_axes :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a reduction argMax operation and returns the result tensor.
--
-- - Parameters:   - tensor: input tensor   - axis: axis of reduction   - name: name for the operation - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- reductionArgMaximumWithTensor:axis:name:@
reductionArgMaximumWithTensor_axis_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> CLong -> name -> IO (Id MPSGraphTensor)
reductionArgMaximumWithTensor_axis_name mpsGraph  tensor axis name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "reductionArgMaximumWithTensor:axis:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argCLong axis, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a reduction argMin operation and returns the result tensor.
--
-- - Parameters:   - tensor: input tensor   - axis: axis of reduction   - name: name for the operation - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- reductionArgMinimumWithTensor:axis:name:@
reductionArgMinimumWithTensor_axis_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> CLong -> name -> IO (Id MPSGraphTensor)
reductionArgMinimumWithTensor_axis_name mpsGraph  tensor axis name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "reductionArgMinimumWithTensor:axis:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argCLong axis, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a reduction and operation and returns the result tensor.
--
-- - Parameters:   - tensor: input tensor   - axis: axis of reduction   - name: name for the operation - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- reductionAndWithTensor:axis:name:@
reductionAndWithTensor_axis_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> CLong -> name -> IO (Id MPSGraphTensor)
reductionAndWithTensor_axis_name mpsGraph  tensor axis name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "reductionAndWithTensor:axis:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argCLong axis, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a reduction and operation and returns the result tensor.
--
-- - Parameters:   - tensor: input tensor   - axes: axes of reduction   - name: name for the operation - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- reductionAndWithTensor:axes:name:@
reductionAndWithTensor_axes_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSArray axes, IsNSString name) => mpsGraph -> tensor -> axes -> name -> IO (Id MPSGraphTensor)
reductionAndWithTensor_axes_name mpsGraph  tensor axes name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr axes $ \raw_axes ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "reductionAndWithTensor:axes:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_axes :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a reduction or operation and returns the result tensor.
--
-- - Parameters:   - tensor: input tensor   - axis: axis of reduction   - name: name for the operation - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- reductionOrWithTensor:axis:name:@
reductionOrWithTensor_axis_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> CLong -> name -> IO (Id MPSGraphTensor)
reductionOrWithTensor_axis_name mpsGraph  tensor axis name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "reductionOrWithTensor:axis:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argCLong axis, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a reduction or operation and returns the result tensor.
--
-- - Parameters:   - tensor: input tensor   - axes: axes of reduction   - name: name for the operation - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- reductionOrWithTensor:axes:name:@
reductionOrWithTensor_axes_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSArray axes, IsNSString name) => mpsGraph -> tensor -> axes -> name -> IO (Id MPSGraphTensor)
reductionOrWithTensor_axes_name mpsGraph  tensor axes name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr axes $ \raw_axes ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "reductionOrWithTensor:axes:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_axes :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a tensor representing state using the Philox algorithm with given counter and key values.
--
-- Generates random numbers using the Philox counter-based algorithm, for further details see:  John K. Salmon, Mark A. Moraes, Ron O. Dror, and David E. Shaw. Parallel Random Numbers: As Easy as 1, 2, 3.  A stateTensor generated with this API can be used in MPSGraph Random APIs which accept a stateTensor. The  updated stateTensor is returned alongside the random values, and can be fed to the following random layer. In  most use cases, a stateTensor should only need to be initialized once at the start of the graph. A stateTensor can  be set as a target tensor of an MPSGraph execution to obtain a stateTensor serialized as an NDArray. This can be  used as input to a placeholder in the graph to avoid ever needing to have a state intilization layer in an MPSGraph.  This can allow for a continued stream through multiple executions of a single MPSGraph by having the final  stateTensor as a target tensor passed into the following MPSGraph execution as a placeholder input. This may be  helpful for training graphs in particular.  ```md  MPSGraph *graph = [MPSGraph new];  MPSGraphTensor *stateTensor = [graph randomPhiloxStateTensorWithSeed: seed name: nil];  NSArray<MPSGraphTensor*> *resultTensors0 = [graph randomUniformTensorWithShape:
--
-- - Parameters:   - seed: Initial counter and key values will be generated using seed.   - name: Name for the operation - Returns: An MPSGraphTensor representing a random state, to be passed as an input to a random op.
--
-- ObjC selector: @- randomPhiloxStateTensorWithSeed:name:@
randomPhiloxStateTensorWithSeed_name :: (IsMPSGraph mpsGraph, IsNSString name) => mpsGraph -> CULong -> name -> IO (Id MPSGraphTensor)
randomPhiloxStateTensorWithSeed_name mpsGraph  seed name =
  withObjCPtr name $ \raw_name ->
      sendMsg mpsGraph (mkSelector "randomPhiloxStateTensorWithSeed:name:") (retPtr retVoid) [argCULong seed, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a tensor representing state using the Philox algorithm with given counter and key values.
--
-- See randomPhiloxStateTensorWithSeed.
--
-- - Parameters:   - counterLow: The value to initilaize lower 64 bits of counter to. Philox utilizes a 128 bit counter   - counterHigh: The value to initilaize upper 64 bits of counter to. Philox utilizes a 128 bit counter   - key: The value to initialize the key to in Philox algorithm.   - name: Name for the operation - Returns: An MPSGraphTensor representing a random state, to be passed as an input to a random op.
--
-- ObjC selector: @- randomPhiloxStateTensorWithCounterLow:counterHigh:key:name:@
randomPhiloxStateTensorWithCounterLow_counterHigh_key_name :: (IsMPSGraph mpsGraph, IsNSString name) => mpsGraph -> CULong -> CULong -> CULong -> name -> IO (Id MPSGraphTensor)
randomPhiloxStateTensorWithCounterLow_counterHigh_key_name mpsGraph  counterLow counterHigh key name =
  withObjCPtr name $ \raw_name ->
      sendMsg mpsGraph (mkSelector "randomPhiloxStateTensorWithCounterLow:counterHigh:key:name:") (retPtr retVoid) [argCULong counterLow, argCULong counterHigh, argCULong key, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a Random op of type matching distribution in descriptor and returns random values.
--
-- Returns a tensor of provided shape of random values in the distribution specified. Uses a random seed value to initalize state. No state is preserved, and subsequent calls are not guaranteed to result in a unique stream of  random values.
--
-- - Parameters:   - shape: The shape of the tensor generated   - descriptor: The descriptor of the distribution. See MPSGraphRandomOpDescriptor.   - name: The name for the operation. - Returns: An MPSGraphTensor of shape containing random values in the defined range.
--
-- ObjC selector: @- randomTensorWithShape:descriptor:name:@
randomTensorWithShape_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphRandomOpDescriptor descriptor, IsNSString name) => mpsGraph -> RawId -> descriptor -> name -> IO (Id MPSGraphTensor)
randomTensorWithShape_descriptor_name mpsGraph  shape descriptor name =
  withObjCPtr descriptor $ \raw_descriptor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "randomTensorWithShape:descriptor:name:") (retPtr retVoid) [argPtr (castPtr (unRawId shape) :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a Random op of type matching distribution in descriptor and returns random values.
--
-- Returns a tensor of provided shape of random values in the distribution specified. Uses a random seed value to initalize state. No state is preserved, and subsequent calls are not guaranteed to result in a unique stream of random values.
--
-- - Parameters:   - shapeTensor: 1D Int32 or Int64 tensor. The shape of the tensor generated   - descriptor: The descriptor of the distribution. See MPSGraphRandomOpDescriptor.   - name: The name for the operation. - Returns: An MPSGraphTensor of shape containing random values in the defined range.
--
-- ObjC selector: @- randomTensorWithShapeTensor:descriptor:name:@
randomTensorWithShapeTensor_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor shapeTensor, IsMPSGraphRandomOpDescriptor descriptor, IsNSString name) => mpsGraph -> shapeTensor -> descriptor -> name -> IO (Id MPSGraphTensor)
randomTensorWithShapeTensor_descriptor_name mpsGraph  shapeTensor descriptor name =
  withObjCPtr shapeTensor $ \raw_shapeTensor ->
    withObjCPtr descriptor $ \raw_descriptor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "randomTensorWithShapeTensor:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_shapeTensor :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a Random op of type matching distribution in descriptor and returns random values.
--
-- Returns a tensor of provided shape of random values in the distribution specified. Uses the provided seed value to initalize state. No state is preserved, and all calls with equal seed yield an identical stream of random values.
--
-- - Parameters:   - shape: The shape of the tensor generated   - descriptor: The descriptor of the distribution. See MPSGraphRandomOpDescriptor.   - seed: The seed to use to initialize state. All calls with equal seed yield an identical stream of random values.   - name: The name for the operation. - Returns: An MPSGraphTensor of shape containing random values in the defined range.
--
-- ObjC selector: @- randomTensorWithShape:descriptor:seed:name:@
randomTensorWithShape_descriptor_seed_name :: (IsMPSGraph mpsGraph, IsMPSGraphRandomOpDescriptor descriptor, IsNSString name) => mpsGraph -> RawId -> descriptor -> CULong -> name -> IO (Id MPSGraphTensor)
randomTensorWithShape_descriptor_seed_name mpsGraph  shape descriptor seed name =
  withObjCPtr descriptor $ \raw_descriptor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "randomTensorWithShape:descriptor:seed:name:") (retPtr retVoid) [argPtr (castPtr (unRawId shape) :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argCULong seed, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a Random op of type matching distribution in descriptor and returns random values.
--
-- Returns a tensor of provided shape of random values in the distribution specified. Uses the provided seed value to initalize state. No state is preserved, and all calls with equal seed yield an identical stream of random values.
--
-- - Parameters:   - shapeTensor: 1D Int32 or Int64 tensor. The shape of the tensor generated   - descriptor: The descriptor of the distribution. See MPSGraphRandomOpDescriptor.   - seed: The seed to use to initialize state. All calls with equal seed yield an identical stream of random values.   - name: The name for the operation. - Returns: An MPSGraphTensor of shape containing random values in the defined range.
--
-- ObjC selector: @- randomTensorWithShapeTensor:descriptor:seed:name:@
randomTensorWithShapeTensor_descriptor_seed_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor shapeTensor, IsMPSGraphRandomOpDescriptor descriptor, IsNSString name) => mpsGraph -> shapeTensor -> descriptor -> CULong -> name -> IO (Id MPSGraphTensor)
randomTensorWithShapeTensor_descriptor_seed_name mpsGraph  shapeTensor descriptor seed name =
  withObjCPtr shapeTensor $ \raw_shapeTensor ->
    withObjCPtr descriptor $ \raw_descriptor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "randomTensorWithShapeTensor:descriptor:seed:name:") (retPtr retVoid) [argPtr (castPtr raw_shapeTensor :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argCULong seed, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a Random op of type matching distribution in descriptor, and returns random values and updated state.
--
-- Returns an array of 2 tensors, where the first is of provided shape of random values in the distribution specified, and the second is the updated state tensor. Uses the provided state to define a stream of random values. No state is preserved, and all calls with equal state yield an identical stream of random values. The initial stateTensor provided should be created using the MPSGraph  randomPhiloxStateTensor APIs. The resulting stateTensor from this op can be passed as an argument to the following  random calls to continue sampling from the stream.
--
-- - Parameters:   - shape: The shape of the tensor generated   - descriptor: The descriptor of the distribution. See MPSGraphRandomOpDescriptor.   - state: The state to define a stream of random values. All calls with equal state yield an identical stream of random values.   - name: The name for the operation. - Returns: An array of MPSGraphTensor of size 2. The first MPSGraphTensor is of shape containing random values in the defined range.  The second MPSGraphTensor is the updated state tensor.
--
-- ObjC selector: @- randomTensorWithShape:descriptor:stateTensor:name:@
randomTensorWithShape_descriptor_stateTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphRandomOpDescriptor descriptor, IsMPSGraphTensor state, IsNSString name) => mpsGraph -> RawId -> descriptor -> state -> name -> IO (Id NSArray)
randomTensorWithShape_descriptor_stateTensor_name mpsGraph  shape descriptor state name =
  withObjCPtr descriptor $ \raw_descriptor ->
    withObjCPtr state $ \raw_state ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "randomTensorWithShape:descriptor:stateTensor:name:") (retPtr retVoid) [argPtr (castPtr (unRawId shape) :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_state :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a Random op of type matching distribution in descriptor, and returns random values and updated state.
--
-- Returns an array of 2 tensors, where the first is of provided shape of random values in the distribution specified, and the second is the updated state tensor. Uses the provided state to define a stream of random values. No state is preserved, and all calls with equal state yield an identical stream of random values. The initial stateTensor provided should be created using the MPSGraph randomPhiloxStateTensor APIs. The resulting stateTensor from this op can be passed as an argument to the following random calls to continue sampling from the stream.
--
-- - Parameters:   - shapeTensor: 1D Int32 or Int64 tensor. The shape of the tensor generated.   - descriptor: The descriptor of the distribution. See MPSGraphRandomOpDescriptor.   - state: The state to define a stream of random values. All calls with equal state yield an identical stream of random values.   - name: The name for the operation. - Returns: An array of MPSGraphTensor of size 2. The first MPSGraphTensor is of shape containing random values in the defined range. The second MPSGraphTensor is the updated state tensor.
--
-- ObjC selector: @- randomTensorWithShapeTensor:descriptor:stateTensor:name:@
randomTensorWithShapeTensor_descriptor_stateTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor shapeTensor, IsMPSGraphRandomOpDescriptor descriptor, IsMPSGraphTensor state, IsNSString name) => mpsGraph -> shapeTensor -> descriptor -> state -> name -> IO (Id NSArray)
randomTensorWithShapeTensor_descriptor_stateTensor_name mpsGraph  shapeTensor descriptor state name =
  withObjCPtr shapeTensor $ \raw_shapeTensor ->
    withObjCPtr descriptor $ \raw_descriptor ->
      withObjCPtr state $ \raw_state ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "randomTensorWithShapeTensor:descriptor:stateTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_shapeTensor :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_state :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a RandomUniform operation and returns random uniform values
--
-- Returns a tensor of provided shape of random uniform values in the range [0.0, 1.0). Uses a random seed value to initalize state. No state is preserved, and subsequent calls are not guaranteed to result in a unique stream of  random values.
--
-- - Parameters:   - shape: The shape of the tensor generated   - name: The name for the operation. - Returns: An MPSGraphTensor of shape containing random values in the defined range.
--
-- ObjC selector: @- randomUniformTensorWithShape:name:@
randomUniformTensorWithShape_name :: (IsMPSGraph mpsGraph, IsNSString name) => mpsGraph -> RawId -> name -> IO (Id MPSGraphTensor)
randomUniformTensorWithShape_name mpsGraph  shape name =
  withObjCPtr name $ \raw_name ->
      sendMsg mpsGraph (mkSelector "randomUniformTensorWithShape:name:") (retPtr retVoid) [argPtr (castPtr (unRawId shape) :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a RandomUniform operation and returns random uniform values
--
-- Returns a tensor of provided shape of random uniform values in the range [0.0, 1.0). Uses a random seed value to initalize state. No state is preserved, and subsequent calls are not guaranteed to result in a unique stream of random values.
--
-- - Parameters:   - shapeTensor: 1D Int32 or Int64 tensor. The shape of the tensor generated   - name: The name for the operation. - Returns: An MPSGraphTensor of shape containing random values in the defined range.
--
-- ObjC selector: @- randomUniformTensorWithShapeTensor:name:@
randomUniformTensorWithShapeTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor shapeTensor, IsNSString name) => mpsGraph -> shapeTensor -> name -> IO (Id MPSGraphTensor)
randomUniformTensorWithShapeTensor_name mpsGraph  shapeTensor name =
  withObjCPtr shapeTensor $ \raw_shapeTensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "randomUniformTensorWithShapeTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_shapeTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a RandomUniform operation and returns random uniform values
--
-- Returns a tensor of provided shape of random uniform values in the range [0.0, 1.0). Uses the provided seed value to initalize state. No state is preserved, and all calls with equal seed yield an identical stream of random values.
--
-- - Parameters:   - shape: The shape of the tensor generated   - seed: The seed to use to initialize state. All calls with equal seed yield an identical stream of random values.   - name: The name for the operation. - Returns: An MPSGraphTensor of shape containing random values in the defined range.
--
-- ObjC selector: @- randomUniformTensorWithShape:seed:name:@
randomUniformTensorWithShape_seed_name :: (IsMPSGraph mpsGraph, IsNSString name) => mpsGraph -> RawId -> CULong -> name -> IO (Id MPSGraphTensor)
randomUniformTensorWithShape_seed_name mpsGraph  shape seed name =
  withObjCPtr name $ \raw_name ->
      sendMsg mpsGraph (mkSelector "randomUniformTensorWithShape:seed:name:") (retPtr retVoid) [argPtr (castPtr (unRawId shape) :: Ptr ()), argCULong seed, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a RandomUniform operation and returns random uniform values
--
-- Returns a tensor of provided shape of random uniform values in the range [0.0, 1.0). Uses the provided seed value to initalize state. No state is preserved, and all calls with equal seed yield an identical stream of random values.
--
-- - Parameters:   - shapeTensor: 1D Int32 or Int64 tensor. The shape of the tensor generated   - seed: The seed to use to initialize state. All calls with equal seed yield an identical stream of random values.   - name: The name for the operation. - Returns: An MPSGraphTensor of shape containing random values in the defined range.
--
-- ObjC selector: @- randomUniformTensorWithShapeTensor:seed:name:@
randomUniformTensorWithShapeTensor_seed_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor shapeTensor, IsNSString name) => mpsGraph -> shapeTensor -> CULong -> name -> IO (Id MPSGraphTensor)
randomUniformTensorWithShapeTensor_seed_name mpsGraph  shapeTensor seed name =
  withObjCPtr shapeTensor $ \raw_shapeTensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "randomUniformTensorWithShapeTensor:seed:name:") (retPtr retVoid) [argPtr (castPtr raw_shapeTensor :: Ptr ()), argCULong seed, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a RandomUniform operation and returns random uniform values and updated state
--
-- Returns an array of 2 tensors, where the first is a tensor of provided shape of random uniform values in the range  [0.0, 1.0), and the second is the updated state tensor. The provided state is used to define a stream of random values. No state is preserved, and all calls with equal state  yield an identical stream of random values. The initial stateTensor provided should be created using the MPSGraph  randomPhiloxStateTensor APIs. The resulting stateTensor from this op can be passed as an argument to the following  random calls to continue sampling from the stream.
--
-- - Parameters:   - shape: The shape of the tensor generated   - state: The state to define a stream of random values. All calls with equal state yield an identical stream of random values.   - name: The name for the operation. - Returns: An array of MPSGraphTensor of size 2. The first MPSGraphTensor is of shape containing random values in the defined range.  The second MPSGraphTensor is the updated state tensor.
--
-- ObjC selector: @- randomUniformTensorWithShape:stateTensor:name:@
randomUniformTensorWithShape_stateTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor state, IsNSString name) => mpsGraph -> RawId -> state -> name -> IO (Id NSArray)
randomUniformTensorWithShape_stateTensor_name mpsGraph  shape state name =
  withObjCPtr state $ \raw_state ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "randomUniformTensorWithShape:stateTensor:name:") (retPtr retVoid) [argPtr (castPtr (unRawId shape) :: Ptr ()), argPtr (castPtr raw_state :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a RandomUniform operation and returns random uniform values and updated state
--
-- Returns an array of 2 tensors, where the first is a tensor of provided shape of random uniform values in the range [0.0, 1.0), and the second is the updated state tensor. The provided state is used to define a stream of random values. No state is preserved, and all calls with equal state yield an identical stream of random values. The initial stateTensor provided should be created using the MPSGraph randomPhiloxStateTensor APIs. The resulting stateTensor from this op can be passed as an argument to the following random calls to continue sampling from the stream.
--
-- - Parameters:   - shapeTensor: 1D Int32 or Int64 tensor. The shape of the tensor generated   - state: The state to define a stream of random values. All calls with equal state yield an identical stream of random values.   - name: The name for the operation. - Returns: An array of MPSGraphTensor of size 2. The first MPSGraphTensor is of shape containing random values in the defined range. The second MPSGraphTensor is the updated state tensor.
--
-- ObjC selector: @- randomUniformTensorWithShapeTensor:stateTensor:name:@
randomUniformTensorWithShapeTensor_stateTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor shapeTensor, IsMPSGraphTensor state, IsNSString name) => mpsGraph -> shapeTensor -> state -> name -> IO (Id NSArray)
randomUniformTensorWithShapeTensor_stateTensor_name mpsGraph  shapeTensor state name =
  withObjCPtr shapeTensor $ \raw_shapeTensor ->
    withObjCPtr state $ \raw_state ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "randomUniformTensorWithShapeTensor:stateTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_shapeTensor :: Ptr ()), argPtr (castPtr raw_state :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a dropout operation and returns the result
--
-- Removes values in the @tensor@ with a percentage chance equal to @rate@. Removed values are set to 0
--
-- - Parameters:   - tensor: Input tensor   - rate: The rate of values to be set to 0   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- dropoutTensor:rate:name:@
dropoutTensor_rate_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> CDouble -> name -> IO (Id MPSGraphTensor)
dropoutTensor_rate_name mpsGraph  tensor rate name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "dropoutTensor:rate:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argCDouble rate, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a dropout operation and returns the result
--
-- Removes values in the @tensor@ with a percentage chance equal to @rate@. Removed values are set to 0
--
-- - Parameters:   - tensor: Input tensor   - rate: The rate of values to be set to 0   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- dropoutTensor:rateTensor:name:@
dropoutTensor_rateTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsMPSGraphTensor rate, IsNSString name) => mpsGraph -> tensor -> rate -> name -> IO (Id MPSGraphTensor)
dropoutTensor_rateTensor_name mpsGraph  tensor rate name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr rate $ \raw_rate ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "dropoutTensor:rateTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_rate :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a Quantize operation and returns the result tensor.
--
-- Convert the float @tensor@ to an i8 or u8 tensor by applying a scale + bias transform:  result = (tensor / scale) + zeroPoint
--
-- - Parameters:   - tensor: Input tensor to be quantized   - scale: Scale scalar parameter   - zeroPoint: Bias scalar parameter (converted to dataType of resultTensor)   - dataType: Integer data type of the result tensor.   - name: The name for the operation. - Returns: A valid MPSGraphTensor array of datatype dataType
--
-- ObjC selector: @- quantizeTensor:scale:zeroPoint:dataType:name:@
quantizeTensor_scale_zeroPoint_dataType_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> CDouble -> CDouble -> MPSDataType -> name -> IO (Id MPSGraphTensor)
quantizeTensor_scale_zeroPoint_dataType_name mpsGraph  tensor scale zeroPoint dataType name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "quantizeTensor:scale:zeroPoint:dataType:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argCDouble scale, argCDouble zeroPoint, argCUInt (coerce dataType), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates Dequantize operation and returns the result tensor.
--
-- Convert the i8 or u8 @tensor@ to a float tensor by applying a scale + bias transform:  result = scale(tensor - zeroPoint)
--
-- - Parameters:   - tensor: Input tensor to be dequantized   - scale: Scale scalar parameter   - zeroPoint: Bias scalar parameter (converted to dataType of tensor)   - dataType: Float data type of the result tensor.   - name: The name for the operation. - Returns: A valid MPSGraphTensor array of datatype dataType
--
-- ObjC selector: @- dequantizeTensor:scale:zeroPoint:dataType:name:@
dequantizeTensor_scale_zeroPoint_dataType_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> CDouble -> CDouble -> MPSDataType -> name -> IO (Id MPSGraphTensor)
dequantizeTensor_scale_zeroPoint_dataType_name mpsGraph  tensor scale zeroPoint dataType name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "dequantizeTensor:scale:zeroPoint:dataType:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argCDouble scale, argCDouble zeroPoint, argCUInt (coerce dataType), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a Quantize operation and returns the result tensor.
--
-- Convert the float @tensor@ to an i8 or u8 tensor by applying a scale + bias transform:  result = (tensor / scaleTensor) + zeroPoint
--
-- - Parameters:   - tensor: Input tensor to be quantized   - scaleTensor: Scale 1D Tensor parameter with size == tensor.shape[axis]   - zeroPoint: Bias scalar parameter (converted to dataType of resultTensor)   - dataType: Integer data type of the result tensor.   - axis: Axis on which the scale 1D value is being broadcasted   - name: The name for the operation. - Returns: A valid MPSGraphTensor array of datatype dataType
--
-- ObjC selector: @- quantizeTensor:scaleTensor:zeroPoint:dataType:axis:name:@
quantizeTensor_scaleTensor_zeroPoint_dataType_axis_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsMPSGraphTensor scaleTensor, IsNSString name) => mpsGraph -> tensor -> scaleTensor -> CDouble -> MPSDataType -> CLong -> name -> IO (Id MPSGraphTensor)
quantizeTensor_scaleTensor_zeroPoint_dataType_axis_name mpsGraph  tensor scaleTensor zeroPoint dataType axis name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr scaleTensor $ \raw_scaleTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "quantizeTensor:scaleTensor:zeroPoint:dataType:axis:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_scaleTensor :: Ptr ()), argCDouble zeroPoint, argCUInt (coerce dataType), argCLong axis, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates Dequantize operation and returns the result tensor.
--
-- Convert the i8 or u8 @tensor@ to a float tensor by applying a scale + bias transform:  result = scaleTensor(tensor - zeroPoint)
--
-- - Parameters:   - tensor: Input tensor to be dequantized   - scaleTensor: Scale scalar or 1D Tensor parameter with size == tensor.shape[axis]   - zeroPoint: Bias scalar parameter (converted to dataType of tensor)   - dataType: Float data type of the result tensor.   - axis: Axis on which the scale 1D value is being broadcasted   - name: The name for the operation. - Returns: A valid MPSGraphTensor array of datatype dataType
--
-- ObjC selector: @- dequantizeTensor:scaleTensor:zeroPoint:dataType:axis:name:@
dequantizeTensor_scaleTensor_zeroPoint_dataType_axis_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsMPSGraphTensor scaleTensor, IsNSString name) => mpsGraph -> tensor -> scaleTensor -> CDouble -> MPSDataType -> CLong -> name -> IO (Id MPSGraphTensor)
dequantizeTensor_scaleTensor_zeroPoint_dataType_axis_name mpsGraph  tensor scaleTensor zeroPoint dataType axis name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr scaleTensor $ \raw_scaleTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "dequantizeTensor:scaleTensor:zeroPoint:dataType:axis:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_scaleTensor :: Ptr ()), argCDouble zeroPoint, argCUInt (coerce dataType), argCLong axis, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a Quantize operation and returns the result tensor.
--
-- Convert the float @tensor@ to an i8 or u8 tensor by applying a scale + bias transform:  result = (tensor / scaleTensor) + zeroPointTensor
--
-- - Parameters:   - tensor: Input tensor to be quantized   - scaleTensor: Scale scalar or 1D Tensor parameter with size == tensor.shape[axis]   - zeroPointTensor: Bias scalar or 1D Tensor parameter with size == tensor.shape[axis]   - dataType: Integer data type of the result tensor.   - axis: Axis on which the scale 1D value is being broadcasted   - name: The name for the operation. - Returns: A valid MPSGraphTensor array of datatype dataType
--
-- ObjC selector: @- quantizeTensor:scaleTensor:zeroPointTensor:dataType:axis:name:@
quantizeTensor_scaleTensor_zeroPointTensor_dataType_axis_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsMPSGraphTensor scaleTensor, IsMPSGraphTensor zeroPointTensor, IsNSString name) => mpsGraph -> tensor -> scaleTensor -> zeroPointTensor -> MPSDataType -> CLong -> name -> IO (Id MPSGraphTensor)
quantizeTensor_scaleTensor_zeroPointTensor_dataType_axis_name mpsGraph  tensor scaleTensor zeroPointTensor dataType axis name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr scaleTensor $ \raw_scaleTensor ->
      withObjCPtr zeroPointTensor $ \raw_zeroPointTensor ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "quantizeTensor:scaleTensor:zeroPointTensor:dataType:axis:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_scaleTensor :: Ptr ()), argPtr (castPtr raw_zeroPointTensor :: Ptr ()), argCUInt (coerce dataType), argCLong axis, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a dequantize operation and returns the result tensor.
--
-- Convert the i8 or u8 @tensor@ to a float tensor by applying a scale + bias transform:  result = scaleTensor(tensor - zeroPointTensor)
--
-- - Parameters:   - tensor: Input tensor to be dequantized   - scaleTensor: Scale scalar or 1D Tensor parameter with size == tensor.shape[axis]   - zeroPointTensor: Bias scalar or 1D Tensor parameter with size == tensor.shape[axis]   - dataType: Float data type of the result tensor.   - axis: Axis on which the scale 1D value is being broadcasted   - name: The name for the operation. - Returns: A valid MPSGraphTensor array of datatype dataType
--
-- ObjC selector: @- dequantizeTensor:scaleTensor:zeroPointTensor:dataType:axis:name:@
dequantizeTensor_scaleTensor_zeroPointTensor_dataType_axis_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsMPSGraphTensor scaleTensor, IsMPSGraphTensor zeroPointTensor, IsNSString name) => mpsGraph -> tensor -> scaleTensor -> zeroPointTensor -> MPSDataType -> CLong -> name -> IO (Id MPSGraphTensor)
dequantizeTensor_scaleTensor_zeroPointTensor_dataType_axis_name mpsGraph  tensor scaleTensor zeroPointTensor dataType axis name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr scaleTensor $ \raw_scaleTensor ->
      withObjCPtr zeroPointTensor $ \raw_zeroPointTensor ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "dequantizeTensor:scaleTensor:zeroPointTensor:dataType:axis:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_scaleTensor :: Ptr ()), argPtr (castPtr raw_zeroPointTensor :: Ptr ()), argCUInt (coerce dataType), argCLong axis, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a dequantize operation and returns the result tensor.
--
-- Convert the i8, u8, i4 or u4 @tensor@ to a float tensor by applying a scale and bias transform: ```md result = scaleTensor(tensor - zeroPointTensor). ```
--
-- - Parameters:   - tensor: Input tensor to be dequantized.   - scaleTensor: The scale tensor with groups support.   - zeroPointTensor: The bias tensor with groups support.   - dataType: Float data type of the result tensor.   - name: The name for the operation. - Returns: A valid ``MPSGraphTensor`` array of datatype @dataType@.
--
-- ObjC selector: @- dequantizeTensor:scaleTensor:zeroPointTensor:dataType:name:@
dequantizeTensor_scaleTensor_zeroPointTensor_dataType_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsMPSGraphTensor scaleTensor, IsMPSGraphTensor zeroPointTensor, IsNSString name) => mpsGraph -> tensor -> scaleTensor -> zeroPointTensor -> MPSDataType -> name -> IO (Id MPSGraphTensor)
dequantizeTensor_scaleTensor_zeroPointTensor_dataType_name mpsGraph  tensor scaleTensor zeroPointTensor dataType name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr scaleTensor $ \raw_scaleTensor ->
      withObjCPtr zeroPointTensor $ \raw_zeroPointTensor ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "dequantizeTensor:scaleTensor:zeroPointTensor:dataType:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_scaleTensor :: Ptr ()), argPtr (castPtr raw_zeroPointTensor :: Ptr ()), argCUInt (coerce dataType), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a dequantize operation and returns the result tensor.
--
-- Converts the i8, u8, i4 or u4 @tensor@ to a float tensor by applying a scale and bias transform: ```md result = scaleTensor * tensor. ```
--
-- - Parameters:   - tensor: Input tensor to be dequantized.   - scaleTensor: Scale Tensor parameter with groups support.   - dataType: Float data type of the result tensor.   - name: The name for the operation. - Returns: A valid ``MPSGraphTensor`` array of datatype @dataType@.
--
-- ObjC selector: @- dequantizeTensor:scaleTensor:dataType:name:@
dequantizeTensor_scaleTensor_dataType_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsMPSGraphTensor scaleTensor, IsNSString name) => mpsGraph -> tensor -> scaleTensor -> MPSDataType -> name -> IO (Id MPSGraphTensor)
dequantizeTensor_scaleTensor_dataType_name mpsGraph  tensor scaleTensor dataType name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr scaleTensor $ \raw_scaleTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "dequantizeTensor:scaleTensor:dataType:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_scaleTensor :: Ptr ()), argCUInt (coerce dataType), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a lookup-table based quantization operation and returns the result tensor.
--
-- Converts a u8 or u4 @tensor@ to a float tensor by applying a lookup operation: ```md result[i1,...,in] = LUTTensor[i1',...,in',tensor[i1,...,in]]. ``` Note: The operation supports LUT groups up to the last 3 dimensions for @tensor@.
--
-- - Parameters:   - tensor: Input tensor to be dequantized.   - LUTTensor: The lookup table to use - for u4 the last dimension should have 16 elements, and for u8 256 elements.   - name: The name for the operation. - Returns: A valid ``MPSGraphTensor`` object.
--
-- ObjC selector: @- dequantizeTensor:LUTTensor:name:@
dequantizeTensor_LUTTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsMPSGraphTensor lutTensor, IsNSString name) => mpsGraph -> tensor -> lutTensor -> name -> IO (Id MPSGraphTensor)
dequantizeTensor_LUTTensor_name mpsGraph  tensor lutTensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr lutTensor $ \raw_lutTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "dequantizeTensor:LUTTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_lutTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a vector lookup-table based quantization operation and returns the result tensor.
--
-- Converts a u8 or u4 @tensor@ to a float tensor by applying a lookup operation, where each input index defines a vector of values. The operation reads the vector values from the last dimension of the lookup table tensor and stores them into the dimension defined by @axis@ on the result tensor. ```md result[i1, ... , i_axis, ..., in] = LUTTensor[i1', ..., in', tensor[i1, ..., in], i_axis] ``` Note: The operation supports LUT groups up to the last 2 dimensions for @tensor@.
--
-- - Parameters:   - tensor: Input tensor to be dequantized.   - LUTTensor: The lookup table to use - for u4 the second to last dimension should have 16 elements, and for u8 256 elements.   - axis: Axis on which the scale 1D value is being broadcasted.   - name: The name for the operation. - Returns: A valid ``MPSGraphTensor`` object.
--
-- ObjC selector: @- dequantizeTensor:LUTTensor:axis:name:@
dequantizeTensor_LUTTensor_axis_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsMPSGraphTensor lutTensor, IsNSString name) => mpsGraph -> tensor -> lutTensor -> CLong -> name -> IO (Id MPSGraphTensor)
dequantizeTensor_LUTTensor_axis_name mpsGraph  tensor lutTensor axis name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr lutTensor $ \raw_lutTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "dequantizeTensor:LUTTensor:axis:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_lutTensor :: Ptr ()), argCLong axis, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a 2D max-pooling operation and returns the result tensor.
--
-- - Parameters:   - source: A 2D Image source as tensor - must be of rank=4. The layout is defined by @descriptor.dataLayout@.   - descriptor: A pooling operation descriptor that specifies pooling window sizes, strides, dilation rates, paddings and layouts.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- maxPooling2DWithSourceTensor:descriptor:name:@
maxPooling2DWithSourceTensor_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor source, IsMPSGraphPooling2DOpDescriptor descriptor, IsNSString name) => mpsGraph -> source -> descriptor -> name -> IO (Id MPSGraphTensor)
maxPooling2DWithSourceTensor_descriptor_name mpsGraph  source descriptor name =
  withObjCPtr source $ \raw_source ->
    withObjCPtr descriptor $ \raw_descriptor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "maxPooling2DWithSourceTensor:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a 2D max-pooling operation and returns the result tensor and the corresponding indices tensor.
--
-- In order to Computes the indices, @returnIndicesMode@ of the descriptor must be set. The datatype of indices tensor can be set using @returnIndicesDataType@. If @returnIndicesMode = MPSGraphPoolingReturnIndicesNone@ then only the first result MPSGraph returns will be valid and using the second result will assert.
--
-- - Parameters:   - source: A 2D Image source as tensor - must be of rank=4. The layout is defined by @descriptor.dataLayout@.   - descriptor: A pooling operation descriptor that specifies pooling window sizes, strides, dilation rates, paddings and layouts.   - name: The name for the operation. - Returns: An array of two MPSGraphTensors. The first tensor holds the result of max pool and the second tensor holds the corresponding indices
--
-- ObjC selector: @- maxPooling2DReturnIndicesWithSourceTensor:descriptor:name:@
maxPooling2DReturnIndicesWithSourceTensor_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor source, IsMPSGraphPooling2DOpDescriptor descriptor, IsNSString name) => mpsGraph -> source -> descriptor -> name -> IO (Id NSArray)
maxPooling2DReturnIndicesWithSourceTensor_descriptor_name mpsGraph  source descriptor name =
  withObjCPtr source $ \raw_source ->
    withObjCPtr descriptor $ \raw_descriptor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "maxPooling2DReturnIndicesWithSourceTensor:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a max-pooling gradient operation and returns the result tensor.
--
-- - Parameters:   - gradient: A 2D input gradient tensor - must be of rank=4. The layout is defined by @descriptor.dataLayout@.   - source: The input tensor for the forward pass.   - descriptor: A pooling operation descriptor that specifies pooling window sizes, strides, dilation rates, paddings and layouts.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- maxPooling2DGradientWithGradientTensor:sourceTensor:descriptor:name:@
maxPooling2DGradientWithGradientTensor_sourceTensor_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor gradient, IsMPSGraphTensor source, IsMPSGraphPooling2DOpDescriptor descriptor, IsNSString name) => mpsGraph -> gradient -> source -> descriptor -> name -> IO (Id MPSGraphTensor)
maxPooling2DGradientWithGradientTensor_sourceTensor_descriptor_name mpsGraph  gradient source descriptor name =
  withObjCPtr gradient $ \raw_gradient ->
    withObjCPtr source $ \raw_source ->
      withObjCPtr descriptor $ \raw_descriptor ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "maxPooling2DGradientWithGradientTensor:sourceTensor:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_gradient :: Ptr ()), argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a max-pooling gradient operation and returns the result tensor.
--
-- With this API MPSGraph computes the max-pooling gradient efficiently by reusing the indices from the forward API instead of recomputing them. The descriptor must set @returnIndicesMode@ and @returnIndicesDataType@ to the same value as that set by the forward pass.
--
-- - Parameters:   - gradient: A 2D input gradient tensor - must be of rank=4. The layout is defined by @descriptor.dataLayout@.   - indices: The indices tensor returned from ``MPSGraph/maxPooling2DReturnIndicesWithSourceTensor:descriptor:name:``.   - outputShape: The shape of the destination gradient.   - descriptor: A pooling operation descriptor that specifies pooling window sizes, strides, dilation rates, paddings and layouts.   - name: The name for the operation. - Returns: Destination gradient tensor.
--
-- ObjC selector: @- maxPooling2DGradientWithGradientTensor:indicesTensor:outputShape:descriptor:name:@
maxPooling2DGradientWithGradientTensor_indicesTensor_outputShape_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor gradient, IsMPSGraphTensor indices, IsMPSGraphPooling2DOpDescriptor descriptor, IsNSString name) => mpsGraph -> gradient -> indices -> RawId -> descriptor -> name -> IO (Id MPSGraphTensor)
maxPooling2DGradientWithGradientTensor_indicesTensor_outputShape_descriptor_name mpsGraph  gradient indices outputShape descriptor name =
  withObjCPtr gradient $ \raw_gradient ->
    withObjCPtr indices $ \raw_indices ->
      withObjCPtr descriptor $ \raw_descriptor ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "maxPooling2DGradientWithGradientTensor:indicesTensor:outputShape:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_gradient :: Ptr ()), argPtr (castPtr raw_indices :: Ptr ()), argPtr (castPtr (unRawId outputShape) :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a max-pooling gradient operation and returns the result tensor.
--
-- With this API MPSGraph computes the max-pooling gradient efficiently by reusing the indices from the forward API instead of recomputing them. The descriptor must set @returnIndicesMode@ and @returnIndicesDataType@ to the same value as that set by the forward pass.
--
-- - Parameters:   - gradient: A 2D input gradient tensor - must be of rank=4. The layout is defined by @descriptor.dataLayout@.   - indices: The indices tensor returned from ``MPSGraph/maxPooling2DReturnIndicesWithSourceTensor:descriptor:name:``.   - outputShape: A tensor containing the shape of the destination gradient.   - descriptor: A pooling operation descriptor that specifies pooling window sizes, strides, dilation rates, paddings and layouts.   - name: The name for the operation. - Returns: Destination gradient tensor.
--
-- ObjC selector: @- maxPooling2DGradientWithGradientTensor:indicesTensor:outputShapeTensor:descriptor:name:@
maxPooling2DGradientWithGradientTensor_indicesTensor_outputShapeTensor_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor gradient, IsMPSGraphTensor indices, IsMPSGraphTensor outputShape, IsMPSGraphPooling2DOpDescriptor descriptor, IsNSString name) => mpsGraph -> gradient -> indices -> outputShape -> descriptor -> name -> IO (Id MPSGraphTensor)
maxPooling2DGradientWithGradientTensor_indicesTensor_outputShapeTensor_descriptor_name mpsGraph  gradient indices outputShape descriptor name =
  withObjCPtr gradient $ \raw_gradient ->
    withObjCPtr indices $ \raw_indices ->
      withObjCPtr outputShape $ \raw_outputShape ->
        withObjCPtr descriptor $ \raw_descriptor ->
          withObjCPtr name $ \raw_name ->
              sendMsg mpsGraph (mkSelector "maxPooling2DGradientWithGradientTensor:indicesTensor:outputShapeTensor:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_gradient :: Ptr ()), argPtr (castPtr raw_indices :: Ptr ()), argPtr (castPtr raw_outputShape :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a 2D average-pooling operation and returns the result tensor.
--
-- - Parameters:   - source: A 2D Image source as tensor - must be of rank=4. The layout is defined by @descriptor.dataLayout@.   - descriptor: A pooling operation descriptor that specifies pooling window sizes, strides, dilation rates, paddings and layouts.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- avgPooling2DWithSourceTensor:descriptor:name:@
avgPooling2DWithSourceTensor_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor source, IsMPSGraphPooling2DOpDescriptor descriptor, IsNSString name) => mpsGraph -> source -> descriptor -> name -> IO (Id MPSGraphTensor)
avgPooling2DWithSourceTensor_descriptor_name mpsGraph  source descriptor name =
  withObjCPtr source $ \raw_source ->
    withObjCPtr descriptor $ \raw_descriptor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "avgPooling2DWithSourceTensor:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a 2D average pooling gradient operation and returns the result tensor.
--
-- - Parameters:   - gradient: A 2D input gradient tensor - must be of rank=4. The layout is defined by @descriptor.dataLayout@.   - source: The input tensor for the forward pass.   - descriptor: A pooling operation descriptor that specifies pooling window sizes, strides, dilation rates, paddings and layouts.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- avgPooling2DGradientWithGradientTensor:sourceTensor:descriptor:name:@
avgPooling2DGradientWithGradientTensor_sourceTensor_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor gradient, IsMPSGraphTensor source, IsMPSGraphPooling2DOpDescriptor descriptor, IsNSString name) => mpsGraph -> gradient -> source -> descriptor -> name -> IO (Id MPSGraphTensor)
avgPooling2DGradientWithGradientTensor_sourceTensor_descriptor_name mpsGraph  gradient source descriptor name =
  withObjCPtr gradient $ \raw_gradient ->
    withObjCPtr source $ \raw_source ->
      withObjCPtr descriptor $ \raw_descriptor ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "avgPooling2DGradientWithGradientTensor:sourceTensor:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_gradient :: Ptr ()), argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a 4D max-pooling operation and returns the result tensor.
--
-- - Parameters:   - source: A source tensor.   - descriptor: A pooling operation descriptor that specifies pooling window sizes, strides, dilation rates and paddings.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- maxPooling4DWithSourceTensor:descriptor:name:@
maxPooling4DWithSourceTensor_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor source, IsMPSGraphPooling4DOpDescriptor descriptor, IsNSString name) => mpsGraph -> source -> descriptor -> name -> IO (Id MPSGraphTensor)
maxPooling4DWithSourceTensor_descriptor_name mpsGraph  source descriptor name =
  withObjCPtr source $ \raw_source ->
    withObjCPtr descriptor $ \raw_descriptor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "maxPooling4DWithSourceTensor:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a 4D max-pooling operation and returns the result tensor and the corresponding indices tensor.
--
-- In order to Computes the indices, @returnIndicesMode@ of the descriptor must be set. The datatype of indices tensor can be set using @returnIndicesDataType@. If @returnIndicesMode = MPSGraphPoolingReturnIndicesNone@ then only the first result MPSGraph returns will be valid and using the second result will assert.
--
-- - Parameters:   - source: The source tensor on which pooling will be performed.   - descriptor: A pooling operation descriptor that specifies pooling window sizes, strides, dilation rates and paddings.   - name: The name for the operation. - Returns: An array of two MPSGraphTensors. The first tensor holds the result of max pool and the second tensor holds the corresponding indices.
--
-- ObjC selector: @- maxPooling4DReturnIndicesWithSourceTensor:descriptor:name:@
maxPooling4DReturnIndicesWithSourceTensor_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor source, IsMPSGraphPooling4DOpDescriptor descriptor, IsNSString name) => mpsGraph -> source -> descriptor -> name -> IO (Id NSArray)
maxPooling4DReturnIndicesWithSourceTensor_descriptor_name mpsGraph  source descriptor name =
  withObjCPtr source $ \raw_source ->
    withObjCPtr descriptor $ \raw_descriptor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "maxPooling4DReturnIndicesWithSourceTensor:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a max-pooling gradient operation and returns the result tensor.
--
-- - Parameters:   - gradient: An input gradient tensor.   - source: The input tensor for the forward pass.   - descriptor: A pooling operation descriptor that specifies pooling window sizes, strides, dilation rates and paddings.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- maxPooling4DGradientWithGradientTensor:sourceTensor:descriptor:name:@
maxPooling4DGradientWithGradientTensor_sourceTensor_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor gradient, IsMPSGraphTensor source, IsMPSGraphPooling4DOpDescriptor descriptor, IsNSString name) => mpsGraph -> gradient -> source -> descriptor -> name -> IO (Id MPSGraphTensor)
maxPooling4DGradientWithGradientTensor_sourceTensor_descriptor_name mpsGraph  gradient source descriptor name =
  withObjCPtr gradient $ \raw_gradient ->
    withObjCPtr source $ \raw_source ->
      withObjCPtr descriptor $ \raw_descriptor ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "maxPooling4DGradientWithGradientTensor:sourceTensor:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_gradient :: Ptr ()), argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a max-pooling gradient operation and returns the result tensor.
--
-- With this API MPSGraph computes the max-pooling gradient efficiently by reusing the indices from the forward API instead of recomputing them. The descriptor must set @returnIndicesMode@ and @returnIndicesDataType@ to the same value as that set by the forward pass.
--
-- - Parameters:   - gradient: An input gradient tensor.   - indices: Indices tensor returned from ``MPSGraph/maxPooling4DReturnIndicesWithSourceTensor:descriptor:name:``.   - outputShape: The shape of the destination gradient.   - descriptor: A pooling operation descriptor that specifies pooling window sizes, strides, dilation rates, paddings and layouts.   - name: The name for the operation. - Returns: Destination gradient tensor.
--
-- ObjC selector: @- maxPooling4DGradientWithGradientTensor:indicesTensor:outputShape:descriptor:name:@
maxPooling4DGradientWithGradientTensor_indicesTensor_outputShape_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor gradient, IsMPSGraphTensor indices, IsMPSGraphPooling4DOpDescriptor descriptor, IsNSString name) => mpsGraph -> gradient -> indices -> RawId -> descriptor -> name -> IO (Id MPSGraphTensor)
maxPooling4DGradientWithGradientTensor_indicesTensor_outputShape_descriptor_name mpsGraph  gradient indices outputShape descriptor name =
  withObjCPtr gradient $ \raw_gradient ->
    withObjCPtr indices $ \raw_indices ->
      withObjCPtr descriptor $ \raw_descriptor ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "maxPooling4DGradientWithGradientTensor:indicesTensor:outputShape:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_gradient :: Ptr ()), argPtr (castPtr raw_indices :: Ptr ()), argPtr (castPtr (unRawId outputShape) :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a max-pooling gradient operation and returns the result tensor.
--
-- With this API MPSGraph computes the max-pooling gradient efficiently by reusing the indices from the forward API instead of recomputing them. The descriptor must set @returnIndicesMode@ and @returnIndicesDataType@ to the same value as that set by the forward pass.
--
-- - Parameters:   - gradient: An input gradient tensor.   - indices: The indices tensor returned from ``MPSGraph/maxPooling4DReturnIndicesWithSourceTensor:descriptor:name:``.   - outputShape: A tensor containing the shape of the destination gradient.   - descriptor: A pooling operation descriptor that specifies pooling window sizes, strides, dilation rates, paddings and layouts.   - name: The name for the operation. - Returns: Destination gradient tensor.
--
-- ObjC selector: @- maxPooling4DGradientWithGradientTensor:indicesTensor:outputShapeTensor:descriptor:name:@
maxPooling4DGradientWithGradientTensor_indicesTensor_outputShapeTensor_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor gradient, IsMPSGraphTensor indices, IsMPSGraphTensor outputShape, IsMPSGraphPooling4DOpDescriptor descriptor, IsNSString name) => mpsGraph -> gradient -> indices -> outputShape -> descriptor -> name -> IO (Id MPSGraphTensor)
maxPooling4DGradientWithGradientTensor_indicesTensor_outputShapeTensor_descriptor_name mpsGraph  gradient indices outputShape descriptor name =
  withObjCPtr gradient $ \raw_gradient ->
    withObjCPtr indices $ \raw_indices ->
      withObjCPtr outputShape $ \raw_outputShape ->
        withObjCPtr descriptor $ \raw_descriptor ->
          withObjCPtr name $ \raw_name ->
              sendMsg mpsGraph (mkSelector "maxPooling4DGradientWithGradientTensor:indicesTensor:outputShapeTensor:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_gradient :: Ptr ()), argPtr (castPtr raw_indices :: Ptr ()), argPtr (castPtr raw_outputShape :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a 4D average pooling operation and returns the result tensor.
--
-- - Parameters:   - source: A source tensor.   - descriptor: A pooling operation descriptor that specifies pooling window sizes, strides, dilation rates and paddings.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- avgPooling4DWithSourceTensor:descriptor:name:@
avgPooling4DWithSourceTensor_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor source, IsMPSGraphPooling4DOpDescriptor descriptor, IsNSString name) => mpsGraph -> source -> descriptor -> name -> IO (Id MPSGraphTensor)
avgPooling4DWithSourceTensor_descriptor_name mpsGraph  source descriptor name =
  withObjCPtr source $ \raw_source ->
    withObjCPtr descriptor $ \raw_descriptor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "avgPooling4DWithSourceTensor:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates an average pooling gradient operation and returns the result tensor.
--
-- - Parameters:   - gradient: An input gradient tensor.   - source: The input tensor for the forward pass.   - descriptor: A pooling operation descriptor that specifies pooling window sizes, strides, dilation rates and paddings.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- avgPooling4DGradientWithGradientTensor:sourceTensor:descriptor:name:@
avgPooling4DGradientWithGradientTensor_sourceTensor_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor gradient, IsMPSGraphTensor source, IsMPSGraphPooling4DOpDescriptor descriptor, IsNSString name) => mpsGraph -> gradient -> source -> descriptor -> name -> IO (Id MPSGraphTensor)
avgPooling4DGradientWithGradientTensor_sourceTensor_descriptor_name mpsGraph  gradient source descriptor name =
  withObjCPtr gradient $ \raw_gradient ->
    withObjCPtr source $ \raw_source ->
      withObjCPtr descriptor $ \raw_descriptor ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "avgPooling4DGradientWithGradientTensor:sourceTensor:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_gradient :: Ptr ()), argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a 4D L2-norm pooling operation and returns the result tensor.
--
-- - Parameters:   - source: A source tensor.   - descriptor: A pooling operation descriptor that specifies pooling window sizes, strides, dilation rates and paddings.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- L2NormPooling4DWithSourceTensor:descriptor:name:@
l2NormPooling4DWithSourceTensor_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor source, IsMPSGraphPooling4DOpDescriptor descriptor, IsNSString name) => mpsGraph -> source -> descriptor -> name -> IO (Id MPSGraphTensor)
l2NormPooling4DWithSourceTensor_descriptor_name mpsGraph  source descriptor name =
  withObjCPtr source $ \raw_source ->
    withObjCPtr descriptor $ \raw_descriptor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "L2NormPooling4DWithSourceTensor:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a L2-Norm pooling gradient operation and returns the result tensor.
--
-- - Parameters:   - gradient: An input gradient tensor.   - source: The input tensor for the forward pass.   - descriptor: A pooling operation descriptor that specifies pooling window sizes, strides, dilation rates and paddings.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- L2NormPooling4DGradientWithGradientTensor:sourceTensor:descriptor:name:@
l2NormPooling4DGradientWithGradientTensor_sourceTensor_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor gradient, IsMPSGraphTensor source, IsMPSGraphPooling4DOpDescriptor descriptor, IsNSString name) => mpsGraph -> gradient -> source -> descriptor -> name -> IO (Id MPSGraphTensor)
l2NormPooling4DGradientWithGradientTensor_sourceTensor_descriptor_name mpsGraph  gradient source descriptor name =
  withObjCPtr gradient $ \raw_gradient ->
    withObjCPtr source $ \raw_source ->
      withObjCPtr descriptor $ \raw_descriptor ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "L2NormPooling4DGradientWithGradientTensor:sourceTensor:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_gradient :: Ptr ()), argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | The Stochastic gradient descent performs a gradient descent.
--
-- @variable = variable - (learningRate * g)@ where,  @g@ is gradient of error wrt variable
--
-- - Parameters:   - learningRateTensor: scalar tensor which indicates the learning rate to use with the optimizer   - valuesTensor: values tensor, usually representing the trainable parameters   - gradientTensor: partial gradient of the trainable parameters with respect to loss   - name: name for the operation - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- stochasticGradientDescentWithLearningRateTensor:valuesTensor:gradientTensor:name:@
stochasticGradientDescentWithLearningRateTensor_valuesTensor_gradientTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor learningRateTensor, IsMPSGraphTensor valuesTensor, IsMPSGraphTensor gradientTensor, IsNSString name) => mpsGraph -> learningRateTensor -> valuesTensor -> gradientTensor -> name -> IO (Id MPSGraphTensor)
stochasticGradientDescentWithLearningRateTensor_valuesTensor_gradientTensor_name mpsGraph  learningRateTensor valuesTensor gradientTensor name =
  withObjCPtr learningRateTensor $ \raw_learningRateTensor ->
    withObjCPtr valuesTensor $ \raw_valuesTensor ->
      withObjCPtr gradientTensor $ \raw_gradientTensor ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "stochasticGradientDescentWithLearningRateTensor:valuesTensor:gradientTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_learningRateTensor :: Ptr ()), argPtr (castPtr raw_valuesTensor :: Ptr ()), argPtr (castPtr raw_gradientTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | The Stochastic gradient descent performs a gradient descent @variable = variable - (learningRate * g)@ where, @g@ is gradient of error wrt variable this op directly writes to the variable
--
-- - Parameters:   - learningRateTensor: scalar tensor which indicates the learning rate to use with the optimizer   - variable: variable operation with trainable parameters   - gradientTensor: partial gradient of the trainable parameters with respect to loss   - name: name for the operation - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- applyStochasticGradientDescentWithLearningRateTensor:variable:gradientTensor:name:@
applyStochasticGradientDescentWithLearningRateTensor_variable_gradientTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor learningRateTensor, IsMPSGraphVariableOp variable, IsMPSGraphTensor gradientTensor, IsNSString name) => mpsGraph -> learningRateTensor -> variable -> gradientTensor -> name -> IO (Id MPSGraphOperation)
applyStochasticGradientDescentWithLearningRateTensor_variable_gradientTensor_name mpsGraph  learningRateTensor variable gradientTensor name =
  withObjCPtr learningRateTensor $ \raw_learningRateTensor ->
    withObjCPtr variable $ \raw_variable ->
      withObjCPtr gradientTensor $ \raw_gradientTensor ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "applyStochasticGradientDescentWithLearningRateTensor:variable:gradientTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_learningRateTensor :: Ptr ()), argPtr (castPtr raw_variable :: Ptr ()), argPtr (castPtr raw_gradientTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates operations to apply Adam optimization.
--
-- The adam update ops are added  current learning rate: ```md lr[t] = learningRate * sqrt(1 - beta2^t) / (1 - beta1^t) m[t] = beta1 * m[t-1] + (1 - beta1) * g v[t] = beta2 * v[t-1] + (1 - beta2) * (g ^ 2) maxVel[t] = max(maxVel[t-1], v[t]) variable = variable - lr[t] * m[t] / (sqrt(maxVel) + epsilon) ``` - Parameters:   - learningRateTensor: scalar tensor which indicates the learning rate to use with the optimizer   - beta1Tensor: beta1Tensor   - beta2Tensor: beta2Tensor   - beta1PowerTensor: @beta1^t@ beta1 power tensor   - beta2PowerTensor: @beta2^t@ beta2 power tensor   - valuesTensor: values to update with optimization   - momentumTensor: momentum tensor   - velocityTensor: velocity tensor   - maximumVelocityTensor: optional maximum velocity tensor   - gradientTensor: partial gradient of the trainable parameters with respect to loss   - name: name for the operation - Returns: if maximumVelocity is nil array of 3 tensors (update, newMomentum, newVelocity) else array of 4 tensors (update, newMomentum, newVelocity, newMaximumVelocity)
--
-- ObjC selector: @- adamWithLearningRateTensor:beta1Tensor:beta2Tensor:epsilonTensor:beta1PowerTensor:beta2PowerTensor:valuesTensor:momentumTensor:velocityTensor:maximumVelocityTensor:gradientTensor:name:@
adamWithLearningRateTensor_beta1Tensor_beta2Tensor_epsilonTensor_beta1PowerTensor_beta2PowerTensor_valuesTensor_momentumTensor_velocityTensor_maximumVelocityTensor_gradientTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor learningRateTensor, IsMPSGraphTensor beta1Tensor, IsMPSGraphTensor beta2Tensor, IsMPSGraphTensor epsilonTensor, IsMPSGraphTensor beta1PowerTensor, IsMPSGraphTensor beta2PowerTensor, IsMPSGraphTensor valuesTensor, IsMPSGraphTensor momentumTensor, IsMPSGraphTensor velocityTensor, IsMPSGraphTensor maximumVelocityTensor, IsMPSGraphTensor gradientTensor, IsNSString name) => mpsGraph -> learningRateTensor -> beta1Tensor -> beta2Tensor -> epsilonTensor -> beta1PowerTensor -> beta2PowerTensor -> valuesTensor -> momentumTensor -> velocityTensor -> maximumVelocityTensor -> gradientTensor -> name -> IO (Id NSArray)
adamWithLearningRateTensor_beta1Tensor_beta2Tensor_epsilonTensor_beta1PowerTensor_beta2PowerTensor_valuesTensor_momentumTensor_velocityTensor_maximumVelocityTensor_gradientTensor_name mpsGraph  learningRateTensor beta1Tensor beta2Tensor epsilonTensor beta1PowerTensor beta2PowerTensor valuesTensor momentumTensor velocityTensor maximumVelocityTensor gradientTensor name =
  withObjCPtr learningRateTensor $ \raw_learningRateTensor ->
    withObjCPtr beta1Tensor $ \raw_beta1Tensor ->
      withObjCPtr beta2Tensor $ \raw_beta2Tensor ->
        withObjCPtr epsilonTensor $ \raw_epsilonTensor ->
          withObjCPtr beta1PowerTensor $ \raw_beta1PowerTensor ->
            withObjCPtr beta2PowerTensor $ \raw_beta2PowerTensor ->
              withObjCPtr valuesTensor $ \raw_valuesTensor ->
                withObjCPtr momentumTensor $ \raw_momentumTensor ->
                  withObjCPtr velocityTensor $ \raw_velocityTensor ->
                    withObjCPtr maximumVelocityTensor $ \raw_maximumVelocityTensor ->
                      withObjCPtr gradientTensor $ \raw_gradientTensor ->
                        withObjCPtr name $ \raw_name ->
                            sendMsg mpsGraph (mkSelector "adamWithLearningRateTensor:beta1Tensor:beta2Tensor:epsilonTensor:beta1PowerTensor:beta2PowerTensor:valuesTensor:momentumTensor:velocityTensor:maximumVelocityTensor:gradientTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_learningRateTensor :: Ptr ()), argPtr (castPtr raw_beta1Tensor :: Ptr ()), argPtr (castPtr raw_beta2Tensor :: Ptr ()), argPtr (castPtr raw_epsilonTensor :: Ptr ()), argPtr (castPtr raw_beta1PowerTensor :: Ptr ()), argPtr (castPtr raw_beta2PowerTensor :: Ptr ()), argPtr (castPtr raw_valuesTensor :: Ptr ()), argPtr (castPtr raw_momentumTensor :: Ptr ()), argPtr (castPtr raw_velocityTensor :: Ptr ()), argPtr (castPtr raw_maximumVelocityTensor :: Ptr ()), argPtr (castPtr raw_gradientTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates operations to apply Adam optimization.
--
-- The adam update ops are added ```md m[t] = beta1m[t-1] + (1 - beta1) * g v[t] = beta2v[t-1] + (1 - beta2) * (g ^ 2) maxVel[t] = max(maxVel[t-1],v[t])  variable = variable - lr[t] * m[t] / (sqrt(maxVel) + epsilon) ``` - Parameters:   - learningRateTensor: scalar tensor which indicates the learning rate to use with the optimizer   - beta1Tensor: beta1Tensor   - beta2Tensor: beta2Tensor   - epsilonTensor: epsilon tensor   - valuesTensor: values to update with optimization   - momentumTensor: momentum tensor   - velocityTensor: velocity tensor   - maximumVelocityTensor: optional maximum velocity tensor   - gradientTensor: partial gradient of the trainable parameters with respect to loss   - name: name for the operation - Returns: if maximumVelocity is nil array of 3 tensors (update, newMomentum, newVelocity) else array of 4 tensors (update, newMomentum, newVelocity, newMaximumVelocity)
--
-- ObjC selector: @- adamWithCurrentLearningRateTensor:beta1Tensor:beta2Tensor:epsilonTensor:valuesTensor:momentumTensor:velocityTensor:maximumVelocityTensor:gradientTensor:name:@
adamWithCurrentLearningRateTensor_beta1Tensor_beta2Tensor_epsilonTensor_valuesTensor_momentumTensor_velocityTensor_maximumVelocityTensor_gradientTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor currentLearningRateTensor, IsMPSGraphTensor beta1Tensor, IsMPSGraphTensor beta2Tensor, IsMPSGraphTensor epsilonTensor, IsMPSGraphTensor valuesTensor, IsMPSGraphTensor momentumTensor, IsMPSGraphTensor velocityTensor, IsMPSGraphTensor maximumVelocityTensor, IsMPSGraphTensor gradientTensor, IsNSString name) => mpsGraph -> currentLearningRateTensor -> beta1Tensor -> beta2Tensor -> epsilonTensor -> valuesTensor -> momentumTensor -> velocityTensor -> maximumVelocityTensor -> gradientTensor -> name -> IO (Id NSArray)
adamWithCurrentLearningRateTensor_beta1Tensor_beta2Tensor_epsilonTensor_valuesTensor_momentumTensor_velocityTensor_maximumVelocityTensor_gradientTensor_name mpsGraph  currentLearningRateTensor beta1Tensor beta2Tensor epsilonTensor valuesTensor momentumTensor velocityTensor maximumVelocityTensor gradientTensor name =
  withObjCPtr currentLearningRateTensor $ \raw_currentLearningRateTensor ->
    withObjCPtr beta1Tensor $ \raw_beta1Tensor ->
      withObjCPtr beta2Tensor $ \raw_beta2Tensor ->
        withObjCPtr epsilonTensor $ \raw_epsilonTensor ->
          withObjCPtr valuesTensor $ \raw_valuesTensor ->
            withObjCPtr momentumTensor $ \raw_momentumTensor ->
              withObjCPtr velocityTensor $ \raw_velocityTensor ->
                withObjCPtr maximumVelocityTensor $ \raw_maximumVelocityTensor ->
                  withObjCPtr gradientTensor $ \raw_gradientTensor ->
                    withObjCPtr name $ \raw_name ->
                        sendMsg mpsGraph (mkSelector "adamWithCurrentLearningRateTensor:beta1Tensor:beta2Tensor:epsilonTensor:valuesTensor:momentumTensor:velocityTensor:maximumVelocityTensor:gradientTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_currentLearningRateTensor :: Ptr ()), argPtr (castPtr raw_beta1Tensor :: Ptr ()), argPtr (castPtr raw_beta2Tensor :: Ptr ()), argPtr (castPtr raw_epsilonTensor :: Ptr ()), argPtr (castPtr raw_valuesTensor :: Ptr ()), argPtr (castPtr raw_momentumTensor :: Ptr ()), argPtr (castPtr raw_velocityTensor :: Ptr ()), argPtr (castPtr raw_maximumVelocityTensor :: Ptr ()), argPtr (castPtr raw_gradientTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a oneHot operation and returns the result tensor.
--
-- Creates a tensor of rank equal to the indicesTensor rank + 1.  Inserts a new axis at the axis specified, or the minor axis if axis is -1. The values at the indices in the indicesTensor will have the onValue,  and all other values will be set to the offValue.
--
-- - Parameters:   - indicesTensor: Tensor of indices for on values   - depth: Depth of the oneHot vector along the axis   - axis: The axis to insert the new oneHot vector at. Defaults to -1, the minor axis   - dataType: MPSDataType of the result tensor Defaults to MPSDataTypeFloat   - onValue: The value for indices designated by the indicesTensor. This value must match the specified data type. Defaults to 1.0f   - offValue: The value for indices not designated by the indicesTensor. This value must match the specified data type. Defaults to 0.0f   - name: Name for the operation - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- oneHotWithIndicesTensor:depth:axis:dataType:onValue:offValue:name:@
oneHotWithIndicesTensor_depth_axis_dataType_onValue_offValue_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor indicesTensor, IsNSString name) => mpsGraph -> indicesTensor -> CULong -> CULong -> MPSDataType -> CDouble -> CDouble -> name -> IO (Id MPSGraphTensor)
oneHotWithIndicesTensor_depth_axis_dataType_onValue_offValue_name mpsGraph  indicesTensor depth axis dataType onValue offValue name =
  withObjCPtr indicesTensor $ \raw_indicesTensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "oneHotWithIndicesTensor:depth:axis:dataType:onValue:offValue:name:") (retPtr retVoid) [argPtr (castPtr raw_indicesTensor :: Ptr ()), argCULong depth, argCULong axis, argCUInt (coerce dataType), argCDouble onValue, argCDouble offValue, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a oneHot operation and returns the result tensor.
--
-- Creates a tensor of rank equal to the rank of @indicesTensor@ + 1. Inserts a new axis at the minor dimension. The values at the indices in the indicesTensor will have the onValue, and all other values will be set to the offValue.
--
-- - Parameters:   - indicesTensor: Tensor of indices for on values   - depth: Depth of the oneHot vector along the axis   - dataType: MPSDataType of the result tensor.   - onValue: The value for indices designated by the indicesTensor. This value must match the specified data type.   - offValue: The value for indices not designated by the indicesTensor. This value must match the specified data type.   - name: Name for the operation - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- oneHotWithIndicesTensor:depth:dataType:onValue:offValue:name:@
oneHotWithIndicesTensor_depth_dataType_onValue_offValue_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor indicesTensor, IsNSString name) => mpsGraph -> indicesTensor -> CULong -> MPSDataType -> CDouble -> CDouble -> name -> IO (Id MPSGraphTensor)
oneHotWithIndicesTensor_depth_dataType_onValue_offValue_name mpsGraph  indicesTensor depth dataType onValue offValue name =
  withObjCPtr indicesTensor $ \raw_indicesTensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "oneHotWithIndicesTensor:depth:dataType:onValue:offValue:name:") (retPtr retVoid) [argPtr (castPtr raw_indicesTensor :: Ptr ()), argCULong depth, argCUInt (coerce dataType), argCDouble onValue, argCDouble offValue, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a oneHot operation and returns the result tensor.
--
-- Creates a tensor of rank equal to the rank of @indicesTensor@ + 1. Inserts a new axis at the axis specified, or the minor axis if @axis@ is -1. The values at the indices in the indicesTensor will be set to 1, and all other values will be set to 0.
--
-- - Parameters:   - indicesTensor: Tensor of indices for on values   - depth: Depth of the oneHot vector along the axis   - axis: The axis to insert the new oneHot vector at   - dataType: MPSDataType of the result tensor.   - name: Name for the operation - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- oneHotWithIndicesTensor:depth:axis:dataType:name:@
oneHotWithIndicesTensor_depth_axis_dataType_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor indicesTensor, IsNSString name) => mpsGraph -> indicesTensor -> CULong -> CULong -> MPSDataType -> name -> IO (Id MPSGraphTensor)
oneHotWithIndicesTensor_depth_axis_dataType_name mpsGraph  indicesTensor depth axis dataType name =
  withObjCPtr indicesTensor $ \raw_indicesTensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "oneHotWithIndicesTensor:depth:axis:dataType:name:") (retPtr retVoid) [argPtr (castPtr raw_indicesTensor :: Ptr ()), argCULong depth, argCULong axis, argCUInt (coerce dataType), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a oneHot operation and returns the result tensor.
--
-- Creates a tensor of rank equal to the rank of @indicesTensor@ + 1, of type MPSDataTypeFloat32. Inserts a new axis at the axis specified, or the minor axis if @axis@ is -1. The values at the indices in the indicesTensor will be set to 1, and all other values will be set to 0.
--
-- - Parameters:   - indicesTensor: Tensor of indices for on values   - depth: Depth of the oneHot vector along the axis   - axis: The axis to insert the new oneHot vector at   - name: Name for the operation - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- oneHotWithIndicesTensor:depth:axis:name:@
oneHotWithIndicesTensor_depth_axis_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor indicesTensor, IsNSString name) => mpsGraph -> indicesTensor -> CULong -> CULong -> name -> IO (Id MPSGraphTensor)
oneHotWithIndicesTensor_depth_axis_name mpsGraph  indicesTensor depth axis name =
  withObjCPtr indicesTensor $ \raw_indicesTensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "oneHotWithIndicesTensor:depth:axis:name:") (retPtr retVoid) [argPtr (castPtr raw_indicesTensor :: Ptr ()), argCULong depth, argCULong axis, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a oneHot operation and returns the result tensor.
--
-- Creates a tensor of rank equal to the rank of @indicesTensor@ + 1. Inserts a new axis at the minor dimension. The values at the indices in the indicesTensor will be set to 1, and all other values will be set to 0.
--
-- - Parameters:   - indicesTensor: Tensor of indices for on values   - depth: Depth of the oneHot vector along the axis   - dataType: MPSDataType of the result tensor.   - name: Name for the operation - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- oneHotWithIndicesTensor:depth:dataType:name:@
oneHotWithIndicesTensor_depth_dataType_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor indicesTensor, IsNSString name) => mpsGraph -> indicesTensor -> CULong -> MPSDataType -> name -> IO (Id MPSGraphTensor)
oneHotWithIndicesTensor_depth_dataType_name mpsGraph  indicesTensor depth dataType name =
  withObjCPtr indicesTensor $ \raw_indicesTensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "oneHotWithIndicesTensor:depth:dataType:name:") (retPtr retVoid) [argPtr (castPtr raw_indicesTensor :: Ptr ()), argCULong depth, argCUInt (coerce dataType), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a oneHot operation and returns the result tensor.
--
-- Creates a tensor of rank equal to the rank of @indicesTensor@ + 1, of type MPSDataTypeFloat32. Inserts a new axis at the minor dimension. The values at the indices in the indicesTensor will be set to 1, and all other values will be set to 0.
--
-- - Parameters:   - indicesTensor: Tensor of indices for on values   - depth: Depth of the oneHot vector along the axis   - name: Name for the operation - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- oneHotWithIndicesTensor:depth:name:@
oneHotWithIndicesTensor_depth_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor indicesTensor, IsNSString name) => mpsGraph -> indicesTensor -> CULong -> name -> IO (Id MPSGraphTensor)
oneHotWithIndicesTensor_depth_name mpsGraph  indicesTensor depth name =
  withObjCPtr indicesTensor $ \raw_indicesTensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "oneHotWithIndicesTensor:depth:name:") (retPtr retVoid) [argPtr (castPtr raw_indicesTensor :: Ptr ()), argCULong depth, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Returns the mean of the first input along the specified axes.
--
-- - Parameters:   - axes: A list of axes over which to perform the reduction. The order of dimensions goes from the slowest moving at axis=0 to the fastest moving dimension.   - name: An optional name for the operation. - Returns: A valid @MPSGraphTensor@ object.
--
-- ObjC selector: @- meanOfTensor:axes:name:@
meanOfTensor_axes_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSArray axes, IsNSString name) => mpsGraph -> tensor -> axes -> name -> IO (Id MPSGraphTensor)
meanOfTensor_axes_name mpsGraph  tensor axes name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr axes $ \raw_axes ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "meanOfTensor:axes:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_axes :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Returns the variance of the first input along the specified axes when the mean has been precomputed.
--
-- - Parameters:   - axes: A list of axes over which to perform the reduction such that the order of dimensions goes from the slowest moving at axis=0 to the fastest moving dimension.   - name: An optional name for the operation. - Returns: A valid @MPSGraphTensor@ object.
--
-- ObjC selector: @- varianceOfTensor:meanTensor:axes:name:@
varianceOfTensor_meanTensor_axes_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsMPSGraphTensor meanTensor, IsNSArray axes, IsNSString name) => mpsGraph -> tensor -> meanTensor -> axes -> name -> IO (Id MPSGraphTensor)
varianceOfTensor_meanTensor_axes_name mpsGraph  tensor meanTensor axes name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr meanTensor $ \raw_meanTensor ->
      withObjCPtr axes $ \raw_axes ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "varianceOfTensor:meanTensor:axes:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_meanTensor :: Ptr ()), argPtr (castPtr raw_axes :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Returns the variance of the first input along the specified axes.
--
-- - Parameters:   - axes: A list of axes over which to perform the reduction. Tthe order of dimensions goes from the slowest moving at axis=0 to the fastest moving dimension.   - name: An optional name for the operation. - Returns: A valid @MPSGraphTensor@ object.
--
-- ObjC selector: @- varianceOfTensor:axes:name:@
varianceOfTensor_axes_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSArray axes, IsNSString name) => mpsGraph -> tensor -> axes -> name -> IO (Id MPSGraphTensor)
varianceOfTensor_axes_name mpsGraph  tensor axes name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr axes $ \raw_axes ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "varianceOfTensor:axes:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_axes :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a batch normalization operation and returns the result tensor.
--
-- The mean and variance tensors should be outputs of @meanWithTensor:axes:name@ and @varianceWithTensor:meanTensor:axes:name@.  Use the axes parameter to achieve different types of normalizations.  For example (assuming your data is in NxHxWxC format)  Batch normalization: axes = [0, 1, 2]  Instance normalization: axes = [1, 2]  Shapes for gamma and beta must match the input data along at least one dimension and will be broadcast along the rest.  For batch normalization, gamma and beta would typically be 1x1x1xC i.e. one value per channel.
--
-- - Parameters:   - tensor: The input tensor.   - mean: The mean tensor.   - variance: The variance tensor.   - gamma: The tensor used to scale the normalized result.   - beta: The tensor used to bias the normalized result.   - epsilon: A small value to add to the variance when normalizing the inputs.   - name: An optional name for the operation. - Returns: A valid @MPSGraphTensor@ object.
--
-- ObjC selector: @- normalizationWithTensor:meanTensor:varianceTensor:gammaTensor:betaTensor:epsilon:name:@
normalizationWithTensor_meanTensor_varianceTensor_gammaTensor_betaTensor_epsilon_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsMPSGraphTensor mean, IsMPSGraphTensor variance, IsMPSGraphTensor gamma, IsMPSGraphTensor beta, IsNSString name) => mpsGraph -> tensor -> mean -> variance -> gamma -> beta -> CFloat -> name -> IO (Id MPSGraphTensor)
normalizationWithTensor_meanTensor_varianceTensor_gammaTensor_betaTensor_epsilon_name mpsGraph  tensor mean variance gamma beta epsilon name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr mean $ \raw_mean ->
      withObjCPtr variance $ \raw_variance ->
        withObjCPtr gamma $ \raw_gamma ->
          withObjCPtr beta $ \raw_beta ->
            withObjCPtr name $ \raw_name ->
                sendMsg mpsGraph (mkSelector "normalizationWithTensor:meanTensor:varianceTensor:gammaTensor:betaTensor:epsilon:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_mean :: Ptr ()), argPtr (castPtr raw_variance :: Ptr ()), argPtr (castPtr raw_gamma :: Ptr ()), argPtr (castPtr raw_beta :: Ptr ()), argCFloat epsilon, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a normalization gamma-gradient operation and returns the result tensor.
--
-- The mean and variance tensors should be outputs of ``meanWithTensor:axes:name`` and ``varianceWithTensor:meanTensor:axes:name``. Use the axes parameter to achieve different types of normalizations. For example (assuming your data is in @NxHxWxC@ format) Batch normalization: axes = [0, 1, 2] Instance normalization: axes = [1, 2]
--
-- - Parameters:   - incomingGradientTensor: The incoming original @resultTensor@ gradient.   - sourceTensor: The original input source in forward direction.   - meanTensor: The mean tensor.   - varianceTensor: The variance tensor.   - axes: The axes of normalization.   - epsilon: A small value to add to the variance when normalizing the inputs.   - name: An optional name for the operation. - Returns: A valid @MPSGraphTensor@ object.
--
-- ObjC selector: @- normalizationGammaGradientWithIncomingGradientTensor:sourceTensor:meanTensor:varianceTensor:reductionAxes:epsilon:name:@
normalizationGammaGradientWithIncomingGradientTensor_sourceTensor_meanTensor_varianceTensor_reductionAxes_epsilon_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor incomingGradientTensor, IsMPSGraphTensor sourceTensor, IsMPSGraphTensor meanTensor, IsMPSGraphTensor varianceTensor, IsNSArray axes, IsNSString name) => mpsGraph -> incomingGradientTensor -> sourceTensor -> meanTensor -> varianceTensor -> axes -> CFloat -> name -> IO (Id MPSGraphTensor)
normalizationGammaGradientWithIncomingGradientTensor_sourceTensor_meanTensor_varianceTensor_reductionAxes_epsilon_name mpsGraph  incomingGradientTensor sourceTensor meanTensor varianceTensor axes epsilon name =
  withObjCPtr incomingGradientTensor $ \raw_incomingGradientTensor ->
    withObjCPtr sourceTensor $ \raw_sourceTensor ->
      withObjCPtr meanTensor $ \raw_meanTensor ->
        withObjCPtr varianceTensor $ \raw_varianceTensor ->
          withObjCPtr axes $ \raw_axes ->
            withObjCPtr name $ \raw_name ->
                sendMsg mpsGraph (mkSelector "normalizationGammaGradientWithIncomingGradientTensor:sourceTensor:meanTensor:varianceTensor:reductionAxes:epsilon:name:") (retPtr retVoid) [argPtr (castPtr raw_incomingGradientTensor :: Ptr ()), argPtr (castPtr raw_sourceTensor :: Ptr ()), argPtr (castPtr raw_meanTensor :: Ptr ()), argPtr (castPtr raw_varianceTensor :: Ptr ()), argPtr (castPtr raw_axes :: Ptr ()), argCFloat epsilon, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a normalization beta-gradient operation and returns the result tensor.
--
-- The mean and variance tensors should be outputs of ``meanWithTensor:axes:name`` and ``varianceWithTensor:meanTensor:axes:name``. Use the axes parameter to achieve different types of normalizations. For example (assuming your data is in @NxHxWxC@ format) Batch normalization: axes = [0, 1, 2] Instance normalization: axes = [1, 2]
--
-- - Parameters:   - incomingGradientTensor: The incoming original @resultTensor@ gradient.   - sourceTensor: The original input source in forward direction.   - axes: The axes of normalization.   - name: An optional name for the operation. - Returns: A valid @MPSGraphTensor@ object.
--
-- ObjC selector: @- normalizationBetaGradientWithIncomingGradientTensor:sourceTensor:reductionAxes:name:@
normalizationBetaGradientWithIncomingGradientTensor_sourceTensor_reductionAxes_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor incomingGradientTensor, IsMPSGraphTensor sourceTensor, IsNSArray axes, IsNSString name) => mpsGraph -> incomingGradientTensor -> sourceTensor -> axes -> name -> IO (Id MPSGraphTensor)
normalizationBetaGradientWithIncomingGradientTensor_sourceTensor_reductionAxes_name mpsGraph  incomingGradientTensor sourceTensor axes name =
  withObjCPtr incomingGradientTensor $ \raw_incomingGradientTensor ->
    withObjCPtr sourceTensor $ \raw_sourceTensor ->
      withObjCPtr axes $ \raw_axes ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "normalizationBetaGradientWithIncomingGradientTensor:sourceTensor:reductionAxes:name:") (retPtr retVoid) [argPtr (castPtr raw_incomingGradientTensor :: Ptr ()), argPtr (castPtr raw_sourceTensor :: Ptr ()), argPtr (castPtr raw_axes :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a normalization input gradient operation and returns the result tensor.
--
-- The mean and variance tensors should be outputs of ``meanWithTensor:axes:name`` and ``varianceWithTensor:meanTensor:axes:name``. Use the axes parameter to achieve different types of normalizations. For example (assuming your data is in @NxHxWxC@ format) Batch normalization: axes = [0, 1, 2] Instance normalization: axes = [1, 2]
--
-- - Parameters:   - incomingGradientTensor: The incoming original @resultTensor@ gradient.   - sourceTensor: The original input source in forward direction.   - meanTensor: The mean tensor.   - varianceTensor: The variance tensor.   - gamma: The gamma tensor.   - gammaGradient: The @gammaGradient@ tensor.   - betaGradient: The @betaGradient@ tensor   - axes: The axes of normalization.   - epsilon: A small value to add to the variance when normalizing the inputs.   - name: An optional name for the operation.
--
-- ObjC selector: @- normalizationGradientWithIncomingGradientTensor:sourceTensor:meanTensor:varianceTensor:gammaTensor:gammaGradientTensor:betaGradientTensor:reductionAxes:epsilon:name:@
normalizationGradientWithIncomingGradientTensor_sourceTensor_meanTensor_varianceTensor_gammaTensor_gammaGradientTensor_betaGradientTensor_reductionAxes_epsilon_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor incomingGradientTensor, IsMPSGraphTensor sourceTensor, IsMPSGraphTensor meanTensor, IsMPSGraphTensor varianceTensor, IsMPSGraphTensor gamma, IsMPSGraphTensor gammaGradient, IsMPSGraphTensor betaGradient, IsNSArray axes, IsNSString name) => mpsGraph -> incomingGradientTensor -> sourceTensor -> meanTensor -> varianceTensor -> gamma -> gammaGradient -> betaGradient -> axes -> CFloat -> name -> IO (Id MPSGraphTensor)
normalizationGradientWithIncomingGradientTensor_sourceTensor_meanTensor_varianceTensor_gammaTensor_gammaGradientTensor_betaGradientTensor_reductionAxes_epsilon_name mpsGraph  incomingGradientTensor sourceTensor meanTensor varianceTensor gamma gammaGradient betaGradient axes epsilon name =
  withObjCPtr incomingGradientTensor $ \raw_incomingGradientTensor ->
    withObjCPtr sourceTensor $ \raw_sourceTensor ->
      withObjCPtr meanTensor $ \raw_meanTensor ->
        withObjCPtr varianceTensor $ \raw_varianceTensor ->
          withObjCPtr gamma $ \raw_gamma ->
            withObjCPtr gammaGradient $ \raw_gammaGradient ->
              withObjCPtr betaGradient $ \raw_betaGradient ->
                withObjCPtr axes $ \raw_axes ->
                  withObjCPtr name $ \raw_name ->
                      sendMsg mpsGraph (mkSelector "normalizationGradientWithIncomingGradientTensor:sourceTensor:meanTensor:varianceTensor:gammaTensor:gammaGradientTensor:betaGradientTensor:reductionAxes:epsilon:name:") (retPtr retVoid) [argPtr (castPtr raw_incomingGradientTensor :: Ptr ()), argPtr (castPtr raw_sourceTensor :: Ptr ()), argPtr (castPtr raw_meanTensor :: Ptr ()), argPtr (castPtr raw_varianceTensor :: Ptr ()), argPtr (castPtr raw_gamma :: Ptr ()), argPtr (castPtr raw_gammaGradient :: Ptr ()), argPtr (castPtr raw_betaGradient :: Ptr ()), argPtr (castPtr raw_axes :: Ptr ()), argCFloat epsilon, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Computes the indices of the non-zero elements of the input tensor.
--
-- The indices are returned as a two-dimensional tensor of size @[number_of_nonzeros, input_rank]@. Each row in the result contains indices of a nonzero elements in input. For example: ```md tensor = [[ 1,  0, 3],           [ 0, 10, 0]] indices = [[ 0, 0],            [ 0, 2],            [ 1, 1]] ```
--
-- - Parameters:   - tensor: An MPSGraphTensor of which to compute the non-zero indices. - Returns: A valid MPSGraphTensor containing indices in signed int32 data type.
--
-- ObjC selector: @- nonZeroIndicesOfTensor:name:@
nonZeroIndicesOfTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> name -> IO (Id MPSGraphTensor)
nonZeroIndicesOfTensor_name mpsGraph  tensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "nonZeroIndicesOfTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a nonMaximumumSuppression operation and returns the result tensor. - Parameters:   - boxesTensor: A tensor containing the coordinates of the input boxes. Must be a rank 3 tensor of shape [N,B,4] of type ``MPSDataTypeFloat32``   - scoresTensor: A tensor containing the scores of the input boxes. Must be a rank 3 tensor of shape [N,B,K] of type ``MPSDataTypeFloat32``   - IOUThreshold: The threshold for when to reject boxes based on their Intersection Over Union. Valid range is [0,1].   - scoreThreshold: The threshold for when to reject boxes based on their score, before IOU suppression.   - perClassSuppression: When this is specified a box will only suppress another box if they have the same class.   - coordinateMode: The coordinate mode the box coordinates are provided in.   - name: The name for the operation.
--
-- ObjC selector: @- nonMaximumSuppressionWithBoxesTensor:scoresTensor:IOUThreshold:scoreThreshold:perClassSuppression:coordinateMode:name:@
nonMaximumSuppressionWithBoxesTensor_scoresTensor_IOUThreshold_scoreThreshold_perClassSuppression_coordinateMode_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor boxesTensor, IsMPSGraphTensor scoresTensor, IsNSString name) => mpsGraph -> boxesTensor -> scoresTensor -> CFloat -> CFloat -> Bool -> MPSGraphNonMaximumSuppressionCoordinateMode -> name -> IO (Id MPSGraphTensor)
nonMaximumSuppressionWithBoxesTensor_scoresTensor_IOUThreshold_scoreThreshold_perClassSuppression_coordinateMode_name mpsGraph  boxesTensor scoresTensor iouThreshold scoreThreshold perClassSuppression coordinateMode name =
  withObjCPtr boxesTensor $ \raw_boxesTensor ->
    withObjCPtr scoresTensor $ \raw_scoresTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "nonMaximumSuppressionWithBoxesTensor:scoresTensor:IOUThreshold:scoreThreshold:perClassSuppression:coordinateMode:name:") (retPtr retVoid) [argPtr (castPtr raw_boxesTensor :: Ptr ()), argPtr (castPtr raw_scoresTensor :: Ptr ()), argCFloat iouThreshold, argCFloat scoreThreshold, argCULong (if perClassSuppression then 1 else 0), argCULong (coerce coordinateMode), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a nonMaximumumSuppression operation and returns the result tensor. - Parameters:   - boxesTensor: A tensor containing the coordinates of the input boxes. Must be a rank 3 tensor of shape [N,B,4] of type ``MPSDataTypeFloat32``   - scoresTensor: A tensor containing the scores of the input boxes. Must be a rank 3 tensor of shape [N,B,1] of type ``MPSDataTypeFloat32``   - classIndicesTensor: A tensor containing the class indices of the input boxes. Must be a rank 2 tensor of shape [N,B] of type ``MPSDataTypeInt32``   - IOUThreshold: The threshold for when to reject boxes based on their Intersection Over Union. Valid range is [0,1].   - scoreThreshold: The threshold for when to reject boxes based on their score, before IOU suppression.   - perClassSuppression: When this is specified a box will only suppress another box if they have the same class.   - coordinateMode: The coordinate mode the box coordinates are provided in.   - name: The name for the operation.
--
-- ObjC selector: @- nonMaximumSuppressionWithBoxesTensor:scoresTensor:classIndicesTensor:IOUThreshold:scoreThreshold:perClassSuppression:coordinateMode:name:@
nonMaximumSuppressionWithBoxesTensor_scoresTensor_classIndicesTensor_IOUThreshold_scoreThreshold_perClassSuppression_coordinateMode_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor boxesTensor, IsMPSGraphTensor scoresTensor, IsMPSGraphTensor classIndicesTensor, IsNSString name) => mpsGraph -> boxesTensor -> scoresTensor -> classIndicesTensor -> CFloat -> CFloat -> Bool -> MPSGraphNonMaximumSuppressionCoordinateMode -> name -> IO (Id MPSGraphTensor)
nonMaximumSuppressionWithBoxesTensor_scoresTensor_classIndicesTensor_IOUThreshold_scoreThreshold_perClassSuppression_coordinateMode_name mpsGraph  boxesTensor scoresTensor classIndicesTensor iouThreshold scoreThreshold perClassSuppression coordinateMode name =
  withObjCPtr boxesTensor $ \raw_boxesTensor ->
    withObjCPtr scoresTensor $ \raw_scoresTensor ->
      withObjCPtr classIndicesTensor $ \raw_classIndicesTensor ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "nonMaximumSuppressionWithBoxesTensor:scoresTensor:classIndicesTensor:IOUThreshold:scoreThreshold:perClassSuppression:coordinateMode:name:") (retPtr retVoid) [argPtr (castPtr raw_boxesTensor :: Ptr ()), argPtr (castPtr raw_scoresTensor :: Ptr ()), argPtr (castPtr raw_classIndicesTensor :: Ptr ()), argCFloat iouThreshold, argCFloat scoreThreshold, argCULong (if perClassSuppression then 1 else 0), argCULong (coerce coordinateMode), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a placeholder operation and returns the result tensor.
--
-- - Parameters:   - shape: The shape of the output tensor. A nil shape will result in an unranked tensor.   - dataType: The dataType of the placeholder tensor.   - name: The name for the placeholder operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- placeholderWithShape:dataType:name:@
placeholderWithShape_dataType_name :: (IsMPSGraph mpsGraph, IsNSString name) => mpsGraph -> RawId -> MPSDataType -> name -> IO (Id MPSGraphTensor)
placeholderWithShape_dataType_name mpsGraph  shape dataType name =
  withObjCPtr name $ \raw_name ->
      sendMsg mpsGraph (mkSelector "placeholderWithShape:dataType:name:") (retPtr retVoid) [argPtr (castPtr (unRawId shape) :: Ptr ()), argCUInt (coerce dataType), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a placeholder operation and returns the result tensor with the dataType of the placeholder tensor set to 32 bit float.
--
-- - Parameters:   - shape: The shape of the output tensor. A nil shape will result in an unranked tensor.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- placeholderWithShape:name:@
placeholderWithShape_name :: (IsMPSGraph mpsGraph, IsNSString name) => mpsGraph -> RawId -> name -> IO (Id MPSGraphTensor)
placeholderWithShape_name mpsGraph  shape name =
  withObjCPtr name $ \raw_name ->
      sendMsg mpsGraph (mkSelector "placeholderWithShape:name:") (retPtr retVoid) [argPtr (castPtr (unRawId shape) :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a constant op with a given shape and data, and returns the result tensor.
--
-- - Parameters:   - data: The data for the tensor. The number of bytes should be sizeof(dataType)numberOfElements.   - shape: The shape of the output tensor. This has to be statically shaped.   - dataType: The dataType of theconstant tensor. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- constantWithData:shape:dataType:@
constantWithData_shape_dataType :: (IsMPSGraph mpsGraph, IsNSData data_) => mpsGraph -> data_ -> RawId -> MPSDataType -> IO (Id MPSGraphTensor)
constantWithData_shape_dataType mpsGraph  data_ shape dataType =
  withObjCPtr data_ $ \raw_data_ ->
      sendMsg mpsGraph (mkSelector "constantWithData:shape:dataType:") (retPtr retVoid) [argPtr (castPtr raw_data_ :: Ptr ()), argPtr (castPtr (unRawId shape) :: Ptr ()), argCUInt (coerce dataType)] >>= retainedObject . castPtr

-- | Creates a constant operation and returns the result tensor.
--
-- - Parameters:   - scalar: The scalar value to fill the entire tensor values with.   - dataType: The dataType of the constant tensor. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- constantWithScalar:dataType:@
constantWithScalar_dataType :: IsMPSGraph mpsGraph => mpsGraph -> CDouble -> MPSDataType -> IO (Id MPSGraphTensor)
constantWithScalar_dataType mpsGraph  scalar dataType =
    sendMsg mpsGraph (mkSelector "constantWithScalar:dataType:") (retPtr retVoid) [argCDouble scalar, argCUInt (coerce dataType)] >>= retainedObject . castPtr

-- | Creates a constant op with a given shape and returns the result tensor.
--
-- - Parameters:   - scalar: The scalar value to fill the entire tensor values with.   - shape: The shape of the output tensor.   - dataType: The dataType of the constant tensor. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- constantWithScalar:shape:dataType:@
constantWithScalar_shape_dataType :: IsMPSGraph mpsGraph => mpsGraph -> CDouble -> RawId -> MPSDataType -> IO (Id MPSGraphTensor)
constantWithScalar_shape_dataType mpsGraph  scalar shape dataType =
    sendMsg mpsGraph (mkSelector "constantWithScalar:shape:dataType:") (retPtr retVoid) [argCDouble scalar, argPtr (castPtr (unRawId shape) :: Ptr ()), argCUInt (coerce dataType)] >>= retainedObject . castPtr

-- | Creates a complex constant op with the MPSDataTypeComplexFloat32 data type and returns the result tensor.
--
-- - Parameters:   - realPart: The real part of the complex scalar to fill the entire tensor values with.   - imaginaryPart: The imaginary part of the complex scalar to fill the entire tensor values with.   - dataType: The dataType of the constant tensor. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- constantWithRealPart:imaginaryPart:@
constantWithRealPart_imaginaryPart :: IsMPSGraph mpsGraph => mpsGraph -> CDouble -> CDouble -> IO (Id MPSGraphTensor)
constantWithRealPart_imaginaryPart mpsGraph  realPart imaginaryPart =
    sendMsg mpsGraph (mkSelector "constantWithRealPart:imaginaryPart:") (retPtr retVoid) [argCDouble realPart, argCDouble imaginaryPart] >>= retainedObject . castPtr

-- | Creates a complex constant operation and returns the result tensor.
--
-- - Parameters:   - realPart: The real part of the complex scalar to fill the entire tensor values with.   - imaginaryPart: The imaginary part of the complex scalar to fill the entire tensor values with.   - dataType: The dataType of the constant tensor. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- constantWithRealPart:imaginaryPart:dataType:@
constantWithRealPart_imaginaryPart_dataType :: IsMPSGraph mpsGraph => mpsGraph -> CDouble -> CDouble -> MPSDataType -> IO (Id MPSGraphTensor)
constantWithRealPart_imaginaryPart_dataType mpsGraph  realPart imaginaryPart dataType =
    sendMsg mpsGraph (mkSelector "constantWithRealPart:imaginaryPart:dataType:") (retPtr retVoid) [argCDouble realPart, argCDouble imaginaryPart, argCUInt (coerce dataType)] >>= retainedObject . castPtr

-- | Creates a complex constant op with a given shape and returns the result tensor.
--
-- - Parameters:   - realPart: The real part of the complex scalar to fill the entire tensor values with.   - imaginaryPart: The imaginary part of the complex scalar to fill the entire tensor values with.   - shape: The shape of the output tensor. This has to be statically shaped.   - dataType: The dataType of the constant tensor. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- constantWithRealPart:imaginaryPart:shape:dataType:@
constantWithRealPart_imaginaryPart_shape_dataType :: IsMPSGraph mpsGraph => mpsGraph -> CDouble -> CDouble -> RawId -> MPSDataType -> IO (Id MPSGraphTensor)
constantWithRealPart_imaginaryPart_shape_dataType mpsGraph  realPart imaginaryPart shape dataType =
    sendMsg mpsGraph (mkSelector "constantWithRealPart:imaginaryPart:shape:dataType:") (retPtr retVoid) [argCDouble realPart, argCDouble imaginaryPart, argPtr (castPtr (unRawId shape) :: Ptr ()), argCUInt (coerce dataType)] >>= retainedObject . castPtr

-- | Creates a variable operation and returns the result tensor.
--
-- - Parameters:   - data: The data for the tensor. The number of bytes should be sizeof(dataType)numberOfElements.   - shape: The shape of the output tensor. This has to be statically shaped.   - dataType: The dataType of the constant tensor.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- variableWithData:shape:dataType:name:@
variableWithData_shape_dataType_name :: (IsMPSGraph mpsGraph, IsNSData data_, IsNSString name) => mpsGraph -> data_ -> RawId -> MPSDataType -> name -> IO (Id MPSGraphTensor)
variableWithData_shape_dataType_name mpsGraph  data_ shape dataType name =
  withObjCPtr data_ $ \raw_data_ ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "variableWithData:shape:dataType:name:") (retPtr retVoid) [argPtr (castPtr raw_data_ :: Ptr ()), argPtr (castPtr (unRawId shape) :: Ptr ()), argCUInt (coerce dataType), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a variable from an input tensor.
--
-- - Parameters:   - tensor: The tensor from which to form the variable.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- variableFromTensorWithTensor:name:@
variableFromTensorWithTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> name -> IO (Id MPSGraphTensor)
variableFromTensorWithTensor_name mpsGraph  tensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "variableFromTensorWithTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a read op which reads at this point of execution of the graph and returns the result tensor.
--
-- - Parameters:   - variable: The variable resource tensor to read from.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- readVariable:name:@
readVariable_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor variable, IsNSString name) => mpsGraph -> variable -> name -> IO (Id MPSGraphTensor)
readVariable_name mpsGraph  variable name =
  withObjCPtr variable $ \raw_variable ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "readVariable:name:") (retPtr retVoid) [argPtr (castPtr raw_variable :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates an assign operation which writes at this point of execution of the graph.
--
-- - Parameters:   - variable: The variable resource tensor to assign to.   - tensor: The tensor to assign to the variable.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- assignVariable:withValueOfTensor:name:@
assignVariable_withValueOfTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor variable, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> variable -> tensor -> name -> IO (Id MPSGraphOperation)
assignVariable_withValueOfTensor_name mpsGraph  variable tensor name =
  withObjCPtr variable $ \raw_variable ->
    withObjCPtr tensor $ \raw_tensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "assignVariable:withValueOfTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_variable :: Ptr ()), argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Computes the matrix multiplication of 2 input tensors with support for broadcasting.
--
-- - Parameters:   - primaryTensor: The left-hand side tensor.   - secondaryTensor: The right-hand side tensor.   - name: The name for the operation. - Returns: A valid tensor containing the product of the input matrices.
--
-- ObjC selector: @- matrixMultiplicationWithPrimaryTensor:secondaryTensor:name:@
matrixMultiplicationWithPrimaryTensor_secondaryTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor primaryTensor, IsMPSGraphTensor secondaryTensor, IsNSString name) => mpsGraph -> primaryTensor -> secondaryTensor -> name -> IO (Id MPSGraphTensor)
matrixMultiplicationWithPrimaryTensor_secondaryTensor_name mpsGraph  primaryTensor secondaryTensor name =
  withObjCPtr primaryTensor $ \raw_primaryTensor ->
    withObjCPtr secondaryTensor $ \raw_secondaryTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "matrixMultiplicationWithPrimaryTensor:secondaryTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_primaryTensor :: Ptr ()), argPtr (castPtr raw_secondaryTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Computes the hamming distance of two input tensors with support for broadcasting.
--
-- The hamming distance is computed between 2 sets of vectors and the last dimension(s) of each  input tensor is considered a vector.
--
-- - Parameters:   - primaryTensor: The first input tensor.   - secondaryTensor: The second input tensor.   - resultDataType: The datatype of the return MPSGraphTensor. Must be either ``MPSDataTypeUInt32`` or ``MPSDataTypeUInt16``.   - name: The name for the operation. - Returns: A valid tensor containing the hamming distance between the input tensors.
--
-- ObjC selector: @- HammingDistanceWithPrimaryTensor:secondaryTensor:resultDataType:name:@
hammingDistanceWithPrimaryTensor_secondaryTensor_resultDataType_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor primaryTensor, IsMPSGraphTensor secondaryTensor, IsNSString name) => mpsGraph -> primaryTensor -> secondaryTensor -> MPSDataType -> name -> IO (Id MPSGraphTensor)
hammingDistanceWithPrimaryTensor_secondaryTensor_resultDataType_name mpsGraph  primaryTensor secondaryTensor resultDataType name =
  withObjCPtr primaryTensor $ \raw_primaryTensor ->
    withObjCPtr secondaryTensor $ \raw_secondaryTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "HammingDistanceWithPrimaryTensor:secondaryTensor:resultDataType:name:") (retPtr retVoid) [argPtr (castPtr raw_primaryTensor :: Ptr ()), argPtr (castPtr raw_secondaryTensor :: Ptr ()), argCUInt (coerce resultDataType), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a scaled dot product attention (SDPA) operation and returns the result tensor.
--
-- SDPA Op computes attention by computing softmax(scale * QK^T + M)V. queryTensor Q with shape [B, Hq, Nq, F] and keyTensor K with shape [B, Hq, Nkv, F], with Q's H dimension expandable to satisfy matmul QK^T. maskTensor M's shape should be broadcast compatible to satisfy (QK^T + M). valueTensor V with shape [B, Hv, Nkv, F] should satisfy the matmul (QK^T + M)V.
--
-- - Parameters:   - queryTensor: A tensor that represents the query projection.   - keyTensor: A tensor that represents the key projection.   - valueTensor: A tensor that represents the value projection.   - maskTensor: An optional tensor that contains a mask that is applied to the scaled, matrix   multiplied query and value matrices. If mask tensor is nil, the QK^T is not element-wise masked.   - scale: A scale that is applied to the result of query and value matrix multiply.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- scaledDotProductAttentionWithQueryTensor:keyTensor:valueTensor:maskTensor:scale:name:@
scaledDotProductAttentionWithQueryTensor_keyTensor_valueTensor_maskTensor_scale_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor queryTensor, IsMPSGraphTensor keyTensor, IsMPSGraphTensor valueTensor, IsMPSGraphTensor maskTensor, IsNSString name) => mpsGraph -> queryTensor -> keyTensor -> valueTensor -> maskTensor -> CFloat -> name -> IO (Id MPSGraphTensor)
scaledDotProductAttentionWithQueryTensor_keyTensor_valueTensor_maskTensor_scale_name mpsGraph  queryTensor keyTensor valueTensor maskTensor scale name =
  withObjCPtr queryTensor $ \raw_queryTensor ->
    withObjCPtr keyTensor $ \raw_keyTensor ->
      withObjCPtr valueTensor $ \raw_valueTensor ->
        withObjCPtr maskTensor $ \raw_maskTensor ->
          withObjCPtr name $ \raw_name ->
              sendMsg mpsGraph (mkSelector "scaledDotProductAttentionWithQueryTensor:keyTensor:valueTensor:maskTensor:scale:name:") (retPtr retVoid) [argPtr (castPtr raw_queryTensor :: Ptr ()), argPtr (castPtr raw_keyTensor :: Ptr ()), argPtr (castPtr raw_valueTensor :: Ptr ()), argPtr (castPtr raw_maskTensor :: Ptr ()), argCFloat scale, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a scaled dot product attention (SDPA) operation (without a mask) and returns the result tensor.
--
-- - Parameters:   - queryTensor: A tensor that represents the query projection.   - keyTensor: A tensor that represents the key projection.   - valueTensor: A tensor that represents the value projection.   - scale: A scale that is applied on the result of query and value matrix multiply.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- scaledDotProductAttentionWithQueryTensor:keyTensor:valueTensor:scale:name:@
scaledDotProductAttentionWithQueryTensor_keyTensor_valueTensor_scale_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor queryTensor, IsMPSGraphTensor keyTensor, IsMPSGraphTensor valueTensor, IsNSString name) => mpsGraph -> queryTensor -> keyTensor -> valueTensor -> CFloat -> name -> IO (Id MPSGraphTensor)
scaledDotProductAttentionWithQueryTensor_keyTensor_valueTensor_scale_name mpsGraph  queryTensor keyTensor valueTensor scale name =
  withObjCPtr queryTensor $ \raw_queryTensor ->
    withObjCPtr keyTensor $ \raw_keyTensor ->
      withObjCPtr valueTensor $ \raw_valueTensor ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "scaledDotProductAttentionWithQueryTensor:keyTensor:valueTensor:scale:name:") (retPtr retVoid) [argPtr (castPtr raw_queryTensor :: Ptr ()), argPtr (castPtr raw_keyTensor :: Ptr ()), argPtr (castPtr raw_valueTensor :: Ptr ()), argCFloat scale, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Computes the inverse of an input tensor.
--
-- The framework computes the inverse of a square matrix by calling LU decomposition and LU solver. All dimensions after the first 2 are treated as batch dimensions and the inverse for each batch is computed. Results are undefined for ill conditioned matrices.
--
-- - Parameters:   - inputTensor: The input tensor.   - name: The name for the operation. - Returns: A valid ``MPSGraphTensor`` object containing the inverse of the input tensor.
--
-- ObjC selector: @- inverseOfTensor:name:@
inverseOfTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor inputTensor, IsNSString name) => mpsGraph -> inputTensor -> name -> IO (Id MPSGraphTensor)
inverseOfTensor_name mpsGraph  inputTensor name =
  withObjCPtr inputTensor $ \raw_inputTensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "inverseOfTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_inputTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a softmax cross-entropy loss operation and returns the result tensor.
--
-- The softmax cross-entropy operation computes: ```md     loss = reduction( - labels*ln( softmax(source) )), where     sotfmax(source) = exp(source) / sum( exp(source) ), and ``` the operation performs the reduction over the @axis@ dimension.
--
-- - Parameters:   - sourceTensor: The source tensor.   - labelsTensor: The labels tensor.   - axis: The axis over which the operation computes the softmax reduction.   - reductionType: The type of reduction MPSGraph uses to reduce across all other axes than @axis@. See: ``MPSGraphLossReductionType``.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- softMaxCrossEntropyWithSourceTensor:labelsTensor:axis:reductionType:name:@
softMaxCrossEntropyWithSourceTensor_labelsTensor_axis_reductionType_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor sourceTensor, IsMPSGraphTensor labelsTensor, IsNSString name) => mpsGraph -> sourceTensor -> labelsTensor -> CLong -> MPSGraphLossReductionType -> name -> IO (Id MPSGraphTensor)
softMaxCrossEntropyWithSourceTensor_labelsTensor_axis_reductionType_name mpsGraph  sourceTensor labelsTensor axis reductionType name =
  withObjCPtr sourceTensor $ \raw_sourceTensor ->
    withObjCPtr labelsTensor $ \raw_labelsTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "softMaxCrossEntropyWithSourceTensor:labelsTensor:axis:reductionType:name:") (retPtr retVoid) [argPtr (castPtr raw_sourceTensor :: Ptr ()), argPtr (castPtr raw_labelsTensor :: Ptr ()), argCLong axis, argCULong (coerce reductionType), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates the gradient of a softmax cross-entropy loss operation and returns the result tensor.
--
-- - Parameters:   - gradientTensor: The input gradientTensor. Note: in most cases this is the initial gradient tensor, which is a constant tensor with value one.   - sourceTensor: The source tensor.   - labelsTensor: The labels tensor.   - axis: The axis over which the operation computes the softmax reduction.   - reductionType: The type of reduction MPSGraph uses to reduce across all other axes than @axis@. See: ``MPSGraphLossReductionType``.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- softMaxCrossEntropyGradientWithIncomingGradientTensor:sourceTensor:labelsTensor:axis:reductionType:name:@
softMaxCrossEntropyGradientWithIncomingGradientTensor_sourceTensor_labelsTensor_axis_reductionType_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor gradientTensor, IsMPSGraphTensor sourceTensor, IsMPSGraphTensor labelsTensor, IsNSString name) => mpsGraph -> gradientTensor -> sourceTensor -> labelsTensor -> CLong -> MPSGraphLossReductionType -> name -> IO (Id MPSGraphTensor)
softMaxCrossEntropyGradientWithIncomingGradientTensor_sourceTensor_labelsTensor_axis_reductionType_name mpsGraph  gradientTensor sourceTensor labelsTensor axis reductionType name =
  withObjCPtr gradientTensor $ \raw_gradientTensor ->
    withObjCPtr sourceTensor $ \raw_sourceTensor ->
      withObjCPtr labelsTensor $ \raw_labelsTensor ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "softMaxCrossEntropyGradientWithIncomingGradientTensor:sourceTensor:labelsTensor:axis:reductionType:name:") (retPtr retVoid) [argPtr (castPtr raw_gradientTensor :: Ptr ()), argPtr (castPtr raw_sourceTensor :: Ptr ()), argPtr (castPtr raw_labelsTensor :: Ptr ()), argCLong axis, argCULong (coerce reductionType), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Computes the band part of an input tensor.
--
-- This operation copies a diagonal band of values from input tensor to a result tensor of the same size. A coordinate @[..., i, j]@ is in the band if  ```md  (numLower < 0 || (i-j) <= numLower) && (numUpper < 0 || (j-i) <= numUpper)  ```  The values outside of the band are set to 0.
--
-- - Parameters:   - inputTensor: input tensor   - numLower: the number of diagonals in the lower triangle to keep. If -1, the framework returns all sub diagnols.   - numUpper: the number of diagonals in the upper triangle to keep. If -1,  the framework returns all super diagnols.   - name: name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- bandPartWithTensor:numLower:numUpper:name:@
bandPartWithTensor_numLower_numUpper_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor inputTensor, IsNSString name) => mpsGraph -> inputTensor -> CLong -> CLong -> name -> IO (Id MPSGraphTensor)
bandPartWithTensor_numLower_numUpper_name mpsGraph  inputTensor numLower numUpper name =
  withObjCPtr inputTensor $ \raw_inputTensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "bandPartWithTensor:numLower:numUpper:name:") (retPtr retVoid) [argPtr (castPtr raw_inputTensor :: Ptr ()), argCLong numLower, argCLong numUpper, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates the band part operation and returns the result.
--
-- See above discussion of bandPartWithTensor: numLower: numUpper: name:
--
-- - Parameters:   - inputTensor: The source tensor to copy.   - numLowerTensor: Scalar Int32 tensor. The number of diagonals in the lower triangle to keep. If -1, keep all.   - numUpperTensor: Scalar Int32 tensor. The number of diagonals in the upper triangle to keep. If -1, keep all.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- bandPartWithTensor:numLowerTensor:numUpperTensor:name:@
bandPartWithTensor_numLowerTensor_numUpperTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor inputTensor, IsMPSGraphTensor numLowerTensor, IsMPSGraphTensor numUpperTensor, IsNSString name) => mpsGraph -> inputTensor -> numLowerTensor -> numUpperTensor -> name -> IO (Id MPSGraphTensor)
bandPartWithTensor_numLowerTensor_numUpperTensor_name mpsGraph  inputTensor numLowerTensor numUpperTensor name =
  withObjCPtr inputTensor $ \raw_inputTensor ->
    withObjCPtr numLowerTensor $ \raw_numLowerTensor ->
      withObjCPtr numUpperTensor $ \raw_numUpperTensor ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "bandPartWithTensor:numLowerTensor:numUpperTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_inputTensor :: Ptr ()), argPtr (castPtr raw_numLowerTensor :: Ptr ()), argPtr (castPtr raw_numUpperTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates an imToCol operation and returns the result tensor.
--
-- - Parameters:   - source: The tensor containing the source data. Must be of rank 4. The layout is defined by @descriptor.dataLayout@.   - descriptor: The descriptor object that specifies the parameters of the operation.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- imToColWithSourceTensor:descriptor:name:@
imToColWithSourceTensor_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor source, IsMPSGraphImToColOpDescriptor descriptor, IsNSString name) => mpsGraph -> source -> descriptor -> name -> IO (Id MPSGraphTensor)
imToColWithSourceTensor_descriptor_name mpsGraph  source descriptor name =
  withObjCPtr source $ \raw_source ->
    withObjCPtr descriptor $ \raw_descriptor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "imToColWithSourceTensor:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a column to image operation and returns the result tensor.
--
-- - Parameters:   - source: The tensor containing the source data. Must be of rank 4. The layout is defined by @descriptor.dataLayout@.   - outputShape: The result tensor shape.   - descriptor: The descriptor object that specifies the parameters of the operation.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- colToImWithSourceTensor:outputShape:descriptor:name:@
colToImWithSourceTensor_outputShape_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor source, IsMPSGraphImToColOpDescriptor descriptor, IsNSString name) => mpsGraph -> source -> RawId -> descriptor -> name -> IO (Id MPSGraphTensor)
colToImWithSourceTensor_outputShape_descriptor_name mpsGraph  source outputShape descriptor name =
  withObjCPtr source $ \raw_source ->
    withObjCPtr descriptor $ \raw_descriptor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "colToImWithSourceTensor:outputShape:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr (unRawId outputShape) :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a GatherAlongAxis operation and returns the result tensor.
--
-- Gather values from @updatesTensor@ along the specified @axis@ at indices in @indicesTensor@.  The shape of @updatesTensor@ and @indicesTensor@ must match except at @axis@.  The shape of the result tensor is equal to the shape of @indicesTensor@.  If an index is out of bounds of the @updatesTensor@ along @axis@ a 0 is inserted.
--
-- - Parameters:   - axis: The axis to gather from. Negative values wrap around   - updatesTensor: The input tensor to gather values from   - indicesTensor: Int32 or Int64 tensor used to index @updatesTensor@   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- gatherAlongAxis:withUpdatesTensor:indicesTensor:name:@
gatherAlongAxis_withUpdatesTensor_indicesTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor updatesTensor, IsMPSGraphTensor indicesTensor, IsNSString name) => mpsGraph -> CLong -> updatesTensor -> indicesTensor -> name -> IO (Id MPSGraphTensor)
gatherAlongAxis_withUpdatesTensor_indicesTensor_name mpsGraph  axis updatesTensor indicesTensor name =
  withObjCPtr updatesTensor $ \raw_updatesTensor ->
    withObjCPtr indicesTensor $ \raw_indicesTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "gatherAlongAxis:withUpdatesTensor:indicesTensor:name:") (retPtr retVoid) [argCLong axis, argPtr (castPtr raw_updatesTensor :: Ptr ()), argPtr (castPtr raw_indicesTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a GatherAlongAxis operation and returns the result tensor.
--
-- Gather values from @updatesTensor@ along the specified @axis@ at indices in @indicesTensor@. The shape of @updatesTensor@ and @indicesTensor@ must match except at @axis@. The shape of the result tensor is equal to the shape of @indicesTensor@. If an index is out of bounds of the @updatesTensor@ along @axis@ a 0 is inserted.
--
-- - Parameters:   - axisTensor: Scalar Int32 tensor. The axis to gather from. Negative values wrap around   - updatesTensor: The input tensor to gather values from   - indicesTensor: Int32 or Int64 tensor used to index @updatesTensor@   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- gatherAlongAxisTensor:withUpdatesTensor:indicesTensor:name:@
gatherAlongAxisTensor_withUpdatesTensor_indicesTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor axisTensor, IsMPSGraphTensor updatesTensor, IsMPSGraphTensor indicesTensor, IsNSString name) => mpsGraph -> axisTensor -> updatesTensor -> indicesTensor -> name -> IO (Id MPSGraphTensor)
gatherAlongAxisTensor_withUpdatesTensor_indicesTensor_name mpsGraph  axisTensor updatesTensor indicesTensor name =
  withObjCPtr axisTensor $ \raw_axisTensor ->
    withObjCPtr updatesTensor $ \raw_updatesTensor ->
      withObjCPtr indicesTensor $ \raw_indicesTensor ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "gatherAlongAxisTensor:withUpdatesTensor:indicesTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_axisTensor :: Ptr ()), argPtr (castPtr raw_updatesTensor :: Ptr ()), argPtr (castPtr raw_indicesTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a Gather operation and returns the result tensor.
--
-- Gathers the values in updatesTensor to the result tensor along the indices in indicesTensor.  The gather is defined as  ```md  B = batchDims  U = updates.rank  P = res.rank  Q = inds.rank  res[p_{0},...p_{axis-1}, i_{B},...,i_{Q}, ...,p_{axis+1},...,p{U-1}] =  updates[p_{0},...p_{axis-1}, indices[p_{0},...,p_{B-1},i_{B},...,i_{Q}, ...,p_{axis+1},...,p{U-1}]  ```  The tensors have the following shape requirements  ```md  P = Q-B + U-1  indices.shape[0:B] = updates.shape[0:B] = res.shape[0:B]  res.shape[0:axis] = updates.shape[0:axis]  res.shape[axis:axis+Q-B] = indices.shape[B:]  res.shape[axis+1+Q-B:] = updates.shape[axis+1:]  ```
--
-- - Parameters:   - updatesTensor: Tensor containing slices to be inserted into the result tensor.   - indicesTensor: Tensor containg the updates indices to read slices from   - axis: The dimension on which to perform the gather   - batchDimensions: The number of batch dimensions   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- gatherWithUpdatesTensor:indicesTensor:axis:batchDimensions:name:@
gatherWithUpdatesTensor_indicesTensor_axis_batchDimensions_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor updatesTensor, IsMPSGraphTensor indicesTensor, IsNSString name) => mpsGraph -> updatesTensor -> indicesTensor -> CULong -> CULong -> name -> IO (Id MPSGraphTensor)
gatherWithUpdatesTensor_indicesTensor_axis_batchDimensions_name mpsGraph  updatesTensor indicesTensor axis batchDimensions name =
  withObjCPtr updatesTensor $ \raw_updatesTensor ->
    withObjCPtr indicesTensor $ \raw_indicesTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "gatherWithUpdatesTensor:indicesTensor:axis:batchDimensions:name:") (retPtr retVoid) [argPtr (castPtr raw_updatesTensor :: Ptr ()), argPtr (castPtr raw_indicesTensor :: Ptr ()), argCULong axis, argCULong batchDimensions, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a GatherND operation and returns the result tensor.
--
-- Gathers the slices in updatesTensor to the result tensor along the indices in indicesTensor.  The gather is defined as  ```md  B = batchDims  U = updates.rank - B  P = res.rank - B  Q = inds.rank - B  K = inds.shape[-1]  index_slice = indices[i_{b0},...,i_{bB},i_{0},..,i_{Q-1}]  res[i_{b0},...,i_{bB},i_{0},...,i_{Q-1}] = updates[i_{b0},...,i_{bB},index_slice[0],...,index_slice[K-1]]  ```  The tensors have the following shape requirements  ```md  U > 0; P > 0; Q > 0  K <= U  P = (U-K) + Q-1  indices.shape[0:Q-1] = res.shape[0:Q-1]  res.shape[Q:P] = updates.shape[K:U]  ```
--
-- - Parameters:   - updatesTensor: Tensor containing slices to be inserted into the result tensor.   - indicesTensor: Tensor containg the updates indices to read slices from   - batchDimensions: The number of batch dimensions   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- gatherNDWithUpdatesTensor:indicesTensor:batchDimensions:name:@
gatherNDWithUpdatesTensor_indicesTensor_batchDimensions_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor updatesTensor, IsMPSGraphTensor indicesTensor, IsNSString name) => mpsGraph -> updatesTensor -> indicesTensor -> CULong -> name -> IO (Id MPSGraphTensor)
gatherNDWithUpdatesTensor_indicesTensor_batchDimensions_name mpsGraph  updatesTensor indicesTensor batchDimensions name =
  withObjCPtr updatesTensor $ \raw_updatesTensor ->
    withObjCPtr indicesTensor $ \raw_indicesTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "gatherNDWithUpdatesTensor:indicesTensor:batchDimensions:name:") (retPtr retVoid) [argPtr (castPtr raw_updatesTensor :: Ptr ()), argPtr (castPtr raw_indicesTensor :: Ptr ()), argCULong batchDimensions, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a fast Fourier transform operation and returns the result tensor.
--
-- This operation computes the fast Fourier transform of the input tensor according to the following formulae. ```md     output[mu] = scale * sum_nu exp( +/- i * 2Pi * mu * nu / n ) input[nu], where ``` @scale = 1@ for @scaling_mode = none@, @scale = 1/V_f@ for @scaling_mode = size@, @scale = 1/sqrt(V_f)@ for @scaling_mode = unitary@, where @V_f@ is the volume of the transformation defined by the dimensions included in @axes@ (`V_f = prod_{i  axes} shape(input)[i]@) (see @@MPSGraphFFTDescriptor/scalingMode@`), @+@ is selected in @+/-@ when @inverse@ is specified, otherwise @-@ is used and the sum is done separately over each dimension in @axes@ and @n@ is the dimension length of that axis.
--
-- > Tip: Currently MPSGraph supports the transformation only within the last four dimensions of the input tensor. In case  you need to transform higher dimensions than the last four, you can tranpose the higher dimensions of the input  with ``MPSGraph/transposeTensor:permutation:name:``  to be within that last four and then transpose  the result tensor back with the inverse of the input transpose.
--
-- - Parameters:   - tensor: A complex or real-valued input tensor.   - axes: An array of numbers that specifies over which axes MPSGraph performs the Fourier transform - all axes must be contained within last four dimensions of the input tensor.   - descriptor: A descriptor that defines the parameters of the Fourier transform operation - see ``MPSGraphFFTDescriptor``.   - name: The name for the operation. - Returns: A valid complex-valued MPSGraphTensor of the same shape as @tensor@.
--
-- ObjC selector: @- fastFourierTransformWithTensor:axes:descriptor:name:@
fastFourierTransformWithTensor_axes_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSArray axes, IsMPSGraphFFTDescriptor descriptor, IsNSString name) => mpsGraph -> tensor -> axes -> descriptor -> name -> IO (Id MPSGraphTensor)
fastFourierTransformWithTensor_axes_descriptor_name mpsGraph  tensor axes descriptor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr axes $ \raw_axes ->
      withObjCPtr descriptor $ \raw_descriptor ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "fastFourierTransformWithTensor:axes:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_axes :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a fast Fourier transform operation and returns the result tensor.
--
-- This operation computes the fast Fourier transform of the input tensor according to the following formulae. ```md     output[mu] = scale * sum_nu exp( +/- i * 2Pi * mu * nu / n ) input[nu], where ``` @scale = 1@ for @scaling_mode = none@, @scale = 1/V_f@ for @scaling_mode = size@, @scale = 1/sqrt(V_f)@ for @scaling_mode = unitary@, where @V_f@ is the volume of the transformation defined by the dimensions included in @axes@ (`V_f = prod_{i  axes} shape(input)[i]@) (see @@MPSGraphFFTDescriptor/scalingMode@`), @+@ is selected in @+/-@ when @inverse@ is specified, otherwise @-@ is used and the sum is done separately over each dimension in @axes@ and @n@ is the dimension length of that axis.
--
-- > Tip: Currently MPSGraph supports the transformation only within the last four dimensions of the input tensor. In case  you need to transform higher dimensions than the last four, you can tranpose the higher dimensions of the input  with ``MPSGraph/transposeTensor:permutation:name:``  to be within that last four and then transpose  the result tensor back with the inverse of the input transpose.
--
-- - Parameters:   - tensor: A complex or real-valued input tensor.   - axesTensor: A tensor of rank one containing the axes over which MPSGraph performs the transformation. See ``MPSGraph/fastFourierTransformWithTensor:axes:descriptor:name:``.   - descriptor: A descriptor that defines the parameters of the Fourier transform operation - see ``MPSGraphFFTDescriptor``.   - name: The name for the operation. - Returns: A valid complex-valued MPSGraphTensor of the same shape as @tensor@.
--
-- ObjC selector: @- fastFourierTransformWithTensor:axesTensor:descriptor:name:@
fastFourierTransformWithTensor_axesTensor_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsMPSGraphTensor axesTensor, IsMPSGraphFFTDescriptor descriptor, IsNSString name) => mpsGraph -> tensor -> axesTensor -> descriptor -> name -> IO (Id MPSGraphTensor)
fastFourierTransformWithTensor_axesTensor_descriptor_name mpsGraph  tensor axesTensor descriptor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr axesTensor $ \raw_axesTensor ->
      withObjCPtr descriptor $ \raw_descriptor ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "fastFourierTransformWithTensor:axesTensor:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_axesTensor :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a Real-to-Hermitean fast Fourier transform operation and returns the result tensor.
--
-- This operation computes the fast Fourier transform of a real-valued input tensor according to the following formulae. ```md     output[mu] = scale * sum_nu exp( +/- i * 2Pi * mu * nu / n ) input[nu], where ``` @scale = 1@ for @scaling_mode = none@, @scale = 1/V_f@ for @scaling_mode = size@, @scale = 1/sqrt(V_f)@ for @scaling_mode = unitary@, where @V_f@ is the volume of the transformation defined by the dimensions included in @axes@ (`V_f = prod_{i  axes} shape(input)[i]@) (see @@MPSGraphFFTDescriptor/scalingMode@`), @+@ is selected in @+/-@ when @inverse@ is specified, otherwise @-@ is used and the sum is done separately over each dimension in @axes@ and @n@ is the dimension length of that axis. With this API MPSGraph writes out only the results for the unique frequencies, resulting in a tensor which has size @(n/2)+1@ in the last dimension defined by @axes@.
--
-- > Tip: Currently MPSGraph supports the transformation only within the last four dimensions of the input tensor. In case  you need to transform higher dimensions than the last four, you can tranpose the higher dimensions of the input  with ``MPSGraph/transposeTensor:permutation:name:``  to be within that last four and then transpose  the result tensor back with the inverse of the input transpose.
--
-- - Parameters:   - tensor: A Real-valued input tensor. Must have datatype @MPSDataTypeFloat32@ or @MPSDatatypeFloat16@.   - axes: An array of numbers that specifies over which axes MPSGraph performs the Fourier transform - all axes must be contained within last four dimensions of the input tensor.   - descriptor: A descriptor that defines the parameters of the Fourier transform operation - see ``MPSGraphFFTDescriptor``.   - name: The name for the operation. - Returns: A valid MPSGraphTensor of type @MPSDataTypeComplexFloat32@ or @MPSDataTypeComplexFloat16@ with reduced size (see Discussion).
--
-- ObjC selector: @- realToHermiteanFFTWithTensor:axes:descriptor:name:@
realToHermiteanFFTWithTensor_axes_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSArray axes, IsMPSGraphFFTDescriptor descriptor, IsNSString name) => mpsGraph -> tensor -> axes -> descriptor -> name -> IO (Id MPSGraphTensor)
realToHermiteanFFTWithTensor_axes_descriptor_name mpsGraph  tensor axes descriptor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr axes $ \raw_axes ->
      withObjCPtr descriptor $ \raw_descriptor ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "realToHermiteanFFTWithTensor:axes:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_axes :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a Real-to-Hermitean fast Fourier transform operation and returns the result tensor.
--
-- This operation computes the fast Fourier transform of a real-valued input tensor according to the following formulae. ```md     output[mu] = scale * sum_nu exp( +/- i * 2Pi * mu * nu / n ) input[nu], where ``` @scale = 1@ for @scaling_mode = none@, @scale = 1/V_f@ for @scaling_mode = size@, @scale = 1/sqrt(V_f)@ for @scaling_mode = unitary@, where @V_f@ is the volume of the transformation defined by the dimensions included in @axes@ (`V_f = prod_{i  axes} shape(input)[i]@) (see @@MPSGraphFFTDescriptor/scalingMode@`), @+@ is selected in @+/-@ when @inverse@ is specified, otherwise @-@ is used and the sum is done separately over each dimension in @axes@ and @n@ is the dimension length of that axis. With this API MPSGraph writes out only the results for the unique frequencies, resulting in a tensor which has size @(n/2)+1@ in the last dimension defined by @axes@.
--
-- > Tip: Currently MPSGraph supports the transformation only within the last four dimensions of the input tensor. In case  you need to transform higher dimensions than the last four, you can tranpose the higher dimensions of the input  with ``MPSGraph/transposeTensor:permutation:name:``  to be within that last four and then transpose  the result tensor back with the inverse of the input transpose.
--
-- - Parameters:   - tensor: A real-valued input tensor. Must have datatype @MPSDataTypeFloat32@ or @MPSDatatypeFloat16@.   - axesTensor: A tensor of rank one containing the axes over which MPSGraph performs the transformation. See ``MPSGraph/fastFourierTransformWithTensor:axes:descriptor:name:``.   - descriptor: A descriptor that defines the parameters of the Fourier transform operation - see ``MPSGraphFFTDescriptor``.   - name: The name for the operation. - Returns: A valid MPSGraphTensor of type @MPSDataTypeComplexFloat32@ or @MPSDataTypeComplexFloat16@  with reduced size (see Discussion).
--
-- ObjC selector: @- realToHermiteanFFTWithTensor:axesTensor:descriptor:name:@
realToHermiteanFFTWithTensor_axesTensor_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsMPSGraphTensor axesTensor, IsMPSGraphFFTDescriptor descriptor, IsNSString name) => mpsGraph -> tensor -> axesTensor -> descriptor -> name -> IO (Id MPSGraphTensor)
realToHermiteanFFTWithTensor_axesTensor_descriptor_name mpsGraph  tensor axesTensor descriptor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr axesTensor $ \raw_axesTensor ->
      withObjCPtr descriptor $ \raw_descriptor ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "realToHermiteanFFTWithTensor:axesTensor:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_axesTensor :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a Hermitean-to-real fast Fourier transform operation and returns the result tensor.
--
-- This operation computes the fast Fourier transform of a complex-valued input tensor according to the following formulae. ```md     output[mu] = scale * sum_nu exp( +/- i * 2Pi * mu * nu / n ) in'[nu], where ``` @in'[nu] = conjugate(in[n - nu])@, for the last dimension defined by @axes@ when @nu@ is out of range of the input dimension. @scale = 1@ for @scaling_mode = none@, @scale = 1/V_f@ for @scaling_mode = size@, @scale = 1/sqrt(V_f)@ for @scaling_mode = unitary@, where @V_f@ is the volume of the transformation defined by the dimensions included in @axes@ (`V_f = prod_{i  axes} shape(input)[i]@) (see @@MPSGraphFFTDescriptor/scalingMode@`), @+@ is selected in @+/-@ when @inverse@ is specified, otherwise @-@ is used and the sum is done separately over each dimension in @axes@ and @n@ is the dimension length of that axis. With this API MPSGraph treats the input tensor to have only the unique frequencies, which means that the resulting tensor has size @(inSize-1)*2 + x@ in the last dimension defined by @axes@, where @inSize = shape(input)[axis] ( = (n/2)+1 )@ is the size of the input @tensor@ in the last transformed dimension and @x = 1@ when ``MPSGraphFFTDescriptor/roundToOddHermitean`` = @YES@ and @x = 0@ otherwise.
--
-- > Tip: Currently transformation is supported only within the last four dimensions of the input tensor. In case  you need to transform higher dimensions than the last four, you can tranpose the higher dimensions of the input  with ``MPSGraph/transposeTensor:permutation:name:``  to be within that last four and then transpose  the result tensor back with the inverse of the input transpose.
--
-- - Parameters:   - tensor: A complex-valued input tensor with reduced size (see Discussion). Must have datatype @MPSDataTypeComplexFloat32@ or @MPSDataTypeComplexFloat16@.   - axes: An array of numbers that specifies over which axes MPSGraph performs the Fourier transform - all axes must be contained within last four dimensions of the input tensor.   - descriptor: A descriptor that defines the parameters of the Fourier transform operation - see ``MPSGraphFFTDescriptor``.   - name: The name for the operation. - Returns: A valid MPSGraphTensor of type @MPSDataTypeFloat32@ or @MPSDataTypeFloat16@ (full size).
--
-- ObjC selector: @- HermiteanToRealFFTWithTensor:axes:descriptor:name:@
hermiteanToRealFFTWithTensor_axes_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSArray axes, IsMPSGraphFFTDescriptor descriptor, IsNSString name) => mpsGraph -> tensor -> axes -> descriptor -> name -> IO (Id MPSGraphTensor)
hermiteanToRealFFTWithTensor_axes_descriptor_name mpsGraph  tensor axes descriptor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr axes $ \raw_axes ->
      withObjCPtr descriptor $ \raw_descriptor ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "HermiteanToRealFFTWithTensor:axes:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_axes :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a Hermitean-to-real fast Fourier transform operation and returns the result tensor.
--
-- This operation computes the fast Fourier transform of a complex-valued input tensor according to the following formulae. ```md     output[mu] = scale * sum_nu exp( +/- i * 2Pi * mu * nu / n ) in'[nu], where ``` @in'[nu] = conjugate(in[n - nu])@, for the last dimension defined by @axes@ when @nu@ is out of range of the input dimension. @scale = 1@ for @scaling_mode = none@, @scale = 1/V_f@ for @scaling_mode = size@, @scale = 1/sqrt(V_f)@ for @scaling_mode = unitary@, where @V_f@ is the volume of the transformation defined by the dimensions included in @axes@ (`V_f = prod_{i  axes} shape(input)[i]@) (see @@MPSGraphFFTDescriptor/scalingMode@`), @+@ is selected in @+/-@ when @inverse@ is specified, otherwise @-@ is used and the sum is done separately over each dimension in @axes@ and @n@ is the dimension length of that axis. With this API MPSGraph treats the input tensor to have only the unique frequencies, which means that the resulting tensor has size @(inSize-1)*2 + x@ in the last dimension defined by @axes@, where @inSize = shape(input)[axis] ( = (n/2)+1 )@ is the size of the input @tensor@ in the last transformed dimension and @x = 1@ when ``MPSGraphFFTDescriptor/roundToOddHermitean`` = @YES@ and @x = 0@ otherwise.
--
-- > Tip: Currently MPSGraph supports the transformation only within the last four dimensions of the input tensor. In case  you need to transform higher dimensions than the last four, you can tranpose the higher dimensions of the input  with ``MPSGraph/transposeTensor:permutation:name:``  to be within that last four and then transpose  the result tensor back with the inverse of the input transpose.
--
-- - Parameters:   - tensor: A complex-valued input tensor with reduced size (see Discussion). Must have datatype @MPSDataTypeComplexFloat32@ or @MPSDataTypeComplexFloat16@.   - axesTensor: A tensor of rank one containing the axes over which MPSGraph performs the transformation. See ``MPSGraph/fastFourierTransformWithTensor:axes:descriptor:name:``.   - descriptor: A descriptor that defines the parameters of the Fourier transform operation - see ``MPSGraphFFTDescriptor``.   - name: The name for the operation. - Returns: A valid MPSGraphTensor of type @MPSDataTypeFloat32@ or @MPSDataTypeFloat16@ (full size).
--
-- ObjC selector: @- HermiteanToRealFFTWithTensor:axesTensor:descriptor:name:@
hermiteanToRealFFTWithTensor_axesTensor_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsMPSGraphTensor axesTensor, IsMPSGraphFFTDescriptor descriptor, IsNSString name) => mpsGraph -> tensor -> axesTensor -> descriptor -> name -> IO (Id MPSGraphTensor)
hermiteanToRealFFTWithTensor_axesTensor_descriptor_name mpsGraph  tensor axesTensor descriptor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr axesTensor $ \raw_axesTensor ->
      withObjCPtr descriptor $ \raw_descriptor ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "HermiteanToRealFFTWithTensor:axesTensor:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_axesTensor :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a 2D-depthwise convolution operation and returns the result tensor.
--
-- - Parameters:   - source: A 2D Image source as tensor - must be of rank=4. The layout is defined by @descriptor.dataLayout@.   - weights: The weights tensor, must be rank=4. The layout is defined by @descriptor.weightsLayout@.   - descriptor: The descriptor object that specifies strides, dilation rates, paddings and layouts.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- depthwiseConvolution2DWithSourceTensor:weightsTensor:descriptor:name:@
depthwiseConvolution2DWithSourceTensor_weightsTensor_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor source, IsMPSGraphTensor weights, IsMPSGraphDepthwiseConvolution2DOpDescriptor descriptor, IsNSString name) => mpsGraph -> source -> weights -> descriptor -> name -> IO (Id MPSGraphTensor)
depthwiseConvolution2DWithSourceTensor_weightsTensor_descriptor_name mpsGraph  source weights descriptor name =
  withObjCPtr source $ \raw_source ->
    withObjCPtr weights $ \raw_weights ->
      withObjCPtr descriptor $ \raw_descriptor ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "depthwiseConvolution2DWithSourceTensor:weightsTensor:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_weights :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a 2D-depthwise convolution gradient for data operation and returns the result tensor.
--
-- - Parameters:   - incomingGradient: A 2D input gradient tensor - must be of rank=4. The layout is defined by @descriptor.dataLayout@.   - weights: The weights tensor, must be rank=4. The layout is defined by @descriptor.weightsLayout@.   - outputShape: The shape of the utput tensor (and therefore input tensor of forward pass).   - descriptor: The descriptor object that specifies strides, dilation rates, paddings and layouts.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- depthwiseConvolution2DDataGradientWithIncomingGradientTensor:weightsTensor:outputShape:descriptor:name:@
depthwiseConvolution2DDataGradientWithIncomingGradientTensor_weightsTensor_outputShape_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor incomingGradient, IsMPSGraphTensor weights, IsMPSGraphDepthwiseConvolution2DOpDescriptor descriptor, IsNSString name) => mpsGraph -> incomingGradient -> weights -> RawId -> descriptor -> name -> IO (Id MPSGraphTensor)
depthwiseConvolution2DDataGradientWithIncomingGradientTensor_weightsTensor_outputShape_descriptor_name mpsGraph  incomingGradient weights outputShape descriptor name =
  withObjCPtr incomingGradient $ \raw_incomingGradient ->
    withObjCPtr weights $ \raw_weights ->
      withObjCPtr descriptor $ \raw_descriptor ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "depthwiseConvolution2DDataGradientWithIncomingGradientTensor:weightsTensor:outputShape:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_incomingGradient :: Ptr ()), argPtr (castPtr raw_weights :: Ptr ()), argPtr (castPtr (unRawId outputShape) :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a 2D-depthwise convolution gradient for weights operation and returns the result tensor.
--
-- - Parameters:   - incomingGradient: A 2D input gradient tensor - must be of rank=4. The layout is defined by @descriptor.dataLayout@.   - source: A 2D Image source as tensor - must be of rank=4. The layout is defined by @descriptor.dataLayout@.   - outputShape: The shape of the utput tensor (and therefore weight tensor of forward pass).   - descriptor: The descriptor object that specifies strides, dilation rates, paddings and layouts.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- depthwiseConvolution2DWeightsGradientWithIncomingGradientTensor:sourceTensor:outputShape:descriptor:name:@
depthwiseConvolution2DWeightsGradientWithIncomingGradientTensor_sourceTensor_outputShape_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor incomingGradient, IsMPSGraphTensor source, IsMPSGraphDepthwiseConvolution2DOpDescriptor descriptor, IsNSString name) => mpsGraph -> incomingGradient -> source -> RawId -> descriptor -> name -> IO (Id MPSGraphTensor)
depthwiseConvolution2DWeightsGradientWithIncomingGradientTensor_sourceTensor_outputShape_descriptor_name mpsGraph  incomingGradient source outputShape descriptor name =
  withObjCPtr incomingGradient $ \raw_incomingGradient ->
    withObjCPtr source $ \raw_source ->
      withObjCPtr descriptor $ \raw_descriptor ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "depthwiseConvolution2DWeightsGradientWithIncomingGradientTensor:sourceTensor:outputShape:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_incomingGradient :: Ptr ()), argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr (unRawId outputShape) :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a 3D depthwise convolution operation and returns the result tensor.
--
-- Works exactly like depthwise convolution2D, but in three dimensions. Supports different layouts with the ``MPSGraphDepthwiseConvolution3DOpDescriptor/channelDimensionIndex`` property. If your weights need a different layout add a permute operation on them before this operation.
--
-- - Parameters:   - source: A 3D Image source as tensor - must be at least rank=4 (CDHW when channelDimensionIndex = -4).   - weights: The weights tensor, must be rank=4 - axes are interpreted as CDHW when channelDimensionIndex = -4 .   - descriptor: The descriptor object that specifies strides, dilation rates and paddings.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- depthwiseConvolution3DWithSourceTensor:weightsTensor:descriptor:name:@
depthwiseConvolution3DWithSourceTensor_weightsTensor_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor source, IsMPSGraphTensor weights, IsMPSGraphDepthwiseConvolution3DOpDescriptor descriptor, IsNSString name) => mpsGraph -> source -> weights -> descriptor -> name -> IO (Id MPSGraphTensor)
depthwiseConvolution3DWithSourceTensor_weightsTensor_descriptor_name mpsGraph  source weights descriptor name =
  withObjCPtr source $ \raw_source ->
    withObjCPtr weights $ \raw_weights ->
      withObjCPtr descriptor $ \raw_descriptor ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "depthwiseConvolution3DWithSourceTensor:weightsTensor:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_weights :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a 3D depthwise convolution gradient for data operation and returns the result tensor.
--
-- - Parameters:   - incomingGradient: A 3D input gradient tensor - must be at least rank=4 (CDHW).   - weights: The weights tensor, must be rank=4 - axes are interpreted as CDHW.   - outputShape: The shape of the utput tensor (and therefore input tensor of forward pass).   - descriptor: The descriptor object that  specifies strides, dilation rates and paddings.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- depthwiseConvolution3DDataGradientWithIncomingGradientTensor:weightsTensor:outputShape:descriptor:name:@
depthwiseConvolution3DDataGradientWithIncomingGradientTensor_weightsTensor_outputShape_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor incomingGradient, IsMPSGraphTensor weights, IsMPSGraphDepthwiseConvolution3DOpDescriptor descriptor, IsNSString name) => mpsGraph -> incomingGradient -> weights -> RawId -> descriptor -> name -> IO (Id MPSGraphTensor)
depthwiseConvolution3DDataGradientWithIncomingGradientTensor_weightsTensor_outputShape_descriptor_name mpsGraph  incomingGradient weights outputShape descriptor name =
  withObjCPtr incomingGradient $ \raw_incomingGradient ->
    withObjCPtr weights $ \raw_weights ->
      withObjCPtr descriptor $ \raw_descriptor ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "depthwiseConvolution3DDataGradientWithIncomingGradientTensor:weightsTensor:outputShape:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_incomingGradient :: Ptr ()), argPtr (castPtr raw_weights :: Ptr ()), argPtr (castPtr (unRawId outputShape) :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a 3D depthwise convolution gradient for weights operation and returns the result tensor.
--
-- - Parameters:   - incomingGradient: A 3D input gradient tensor - must be at least rank=4 (NCDHW).   - source: The forward pass 3D Image source as tensor - must be at least rank=4 (NCDHW).   - outputShape: The shape of the utput tensor (and therefore weight tensor of forward pass).   - descriptor: The descriptor object that specifies strides, dilation rates and paddings.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- depthwiseConvolution3DWeightsGradientWithIncomingGradientTensor:sourceTensor:outputShape:descriptor:name:@
depthwiseConvolution3DWeightsGradientWithIncomingGradientTensor_sourceTensor_outputShape_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor incomingGradient, IsMPSGraphTensor source, IsMPSGraphDepthwiseConvolution3DOpDescriptor descriptor, IsNSString name) => mpsGraph -> incomingGradient -> source -> RawId -> descriptor -> name -> IO (Id MPSGraphTensor)
depthwiseConvolution3DWeightsGradientWithIncomingGradientTensor_sourceTensor_outputShape_descriptor_name mpsGraph  incomingGradient source outputShape descriptor name =
  withObjCPtr incomingGradient $ \raw_incomingGradient ->
    withObjCPtr source $ \raw_source ->
      withObjCPtr descriptor $ \raw_descriptor ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "depthwiseConvolution3DWeightsGradientWithIncomingGradientTensor:sourceTensor:outputShape:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_incomingGradient :: Ptr ()), argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr (unRawId outputShape) :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Computes the cumulative sum of the input tensor along the specified axis.
--
-- - Parameters:   - tensor: The input tensor   - axis: The tensor dimension where you compute the cumulative operation   - exclusive: If true, perform the exclusive cumulative operation, and the first element will be equal to zero   - reverse: If true, reverse the direction of the cumulative operation along the specified axis   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- cumulativeSumWithTensor:axis:exclusive:reverse:name:@
cumulativeSumWithTensor_axis_exclusive_reverse_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> CLong -> Bool -> Bool -> name -> IO (Id MPSGraphTensor)
cumulativeSumWithTensor_axis_exclusive_reverse_name mpsGraph  tensor axis exclusive reverse_ name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "cumulativeSumWithTensor:axis:exclusive:reverse:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argCLong axis, argCULong (if exclusive then 1 else 0), argCULong (if reverse_ then 1 else 0), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Computes the cumulative sum of the input tensor along the specified axis.
--
-- - Parameters:   - tensor: The input tensor   - axisTensor: The tensor dimension where you compute the cumulative operation   - exclusive: If true, perform the exclusive cumulative operation, and the first element will be equal to zero   - reverse: If true, reverse the direction of the cumulative operation along the specified axis   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- cumulativeSumWithTensor:axisTensor:exclusive:reverse:name:@
cumulativeSumWithTensor_axisTensor_exclusive_reverse_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsMPSGraphTensor axisTensor, IsNSString name) => mpsGraph -> tensor -> axisTensor -> Bool -> Bool -> name -> IO (Id MPSGraphTensor)
cumulativeSumWithTensor_axisTensor_exclusive_reverse_name mpsGraph  tensor axisTensor exclusive reverse_ name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr axisTensor $ \raw_axisTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "cumulativeSumWithTensor:axisTensor:exclusive:reverse:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_axisTensor :: Ptr ()), argCULong (if exclusive then 1 else 0), argCULong (if reverse_ then 1 else 0), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Computes the cumulative sum of the input tensor along the specified axis.
--
-- - Parameters:   - tensor: The input tensor   - axis: The tensor dimension where you compute the cumulative operation   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- cumulativeSumWithTensor:axis:name:@
cumulativeSumWithTensor_axis_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> CLong -> name -> IO (Id MPSGraphTensor)
cumulativeSumWithTensor_axis_name mpsGraph  tensor axis name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "cumulativeSumWithTensor:axis:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argCLong axis, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Computes the cumulative sum of the input tensor along the specified axis.
--
-- - Parameters:   - tensor: The input tensor   - axisTensor: The tensor dimension where you compute the cumulative operation   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- cumulativeSumWithTensor:axisTensor:name:@
cumulativeSumWithTensor_axisTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsMPSGraphTensor axisTensor, IsNSString name) => mpsGraph -> tensor -> axisTensor -> name -> IO (Id MPSGraphTensor)
cumulativeSumWithTensor_axisTensor_name mpsGraph  tensor axisTensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr axisTensor $ \raw_axisTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "cumulativeSumWithTensor:axisTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_axisTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Computes the cumulative product of the input tensor along the specified axis.
--
-- - Parameters:   - tensor: The input tensor   - axis: The tensor dimension where you compute the cumulative operation   - exclusive: If true, perform the exclusive cumulative operation, and the first element will be equal to one   - reverse: If true, reverse the direction of the cumulative operation along the specified axis   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- cumulativeProductWithTensor:axis:exclusive:reverse:name:@
cumulativeProductWithTensor_axis_exclusive_reverse_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> CLong -> Bool -> Bool -> name -> IO (Id MPSGraphTensor)
cumulativeProductWithTensor_axis_exclusive_reverse_name mpsGraph  tensor axis exclusive reverse_ name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "cumulativeProductWithTensor:axis:exclusive:reverse:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argCLong axis, argCULong (if exclusive then 1 else 0), argCULong (if reverse_ then 1 else 0), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Computes the cumulative product of the input tensor along the specified axis.
--
-- - Parameters:   - tensor: The input tensor   - axisTensor: The tensor dimension where you compute the cumulative operation   - exclusive: If true, perform the exclusive cumulative operation, and the first element will be equal to one   - reverse: If true, reverse the direction of the cumulative operation along the specified axis   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- cumulativeProductWithTensor:axisTensor:exclusive:reverse:name:@
cumulativeProductWithTensor_axisTensor_exclusive_reverse_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsMPSGraphTensor axisTensor, IsNSString name) => mpsGraph -> tensor -> axisTensor -> Bool -> Bool -> name -> IO (Id MPSGraphTensor)
cumulativeProductWithTensor_axisTensor_exclusive_reverse_name mpsGraph  tensor axisTensor exclusive reverse_ name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr axisTensor $ \raw_axisTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "cumulativeProductWithTensor:axisTensor:exclusive:reverse:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_axisTensor :: Ptr ()), argCULong (if exclusive then 1 else 0), argCULong (if reverse_ then 1 else 0), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Computes the cumulative product of the input tensor along the specified axis.
--
-- - Parameters:   - tensor: The input tensor   - axis: The tensor dimension where you compute the cumulative operation   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- cumulativeProductWithTensor:axis:name:@
cumulativeProductWithTensor_axis_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> CLong -> name -> IO (Id MPSGraphTensor)
cumulativeProductWithTensor_axis_name mpsGraph  tensor axis name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "cumulativeProductWithTensor:axis:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argCLong axis, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Computes the cumulative product of the input tensor along the specified axis.
--
-- - Parameters:   - tensor: The input tensor   - axisTensor: The tensor dimension where you compute the cumulative operation   - exclusive: If true, perform the exclusive cumulative operation, and the first element will be equal to one   - reverse: If true, reverse the direction of the cumulative operation along the specified axis   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- cumulativeProductWithTensor:axisTensor:name:@
cumulativeProductWithTensor_axisTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsMPSGraphTensor axisTensor, IsNSString name) => mpsGraph -> tensor -> axisTensor -> name -> IO (Id MPSGraphTensor)
cumulativeProductWithTensor_axisTensor_name mpsGraph  tensor axisTensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr axisTensor $ \raw_axisTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "cumulativeProductWithTensor:axisTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_axisTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Computes the cumulative minimum of the input tensor along the specified axis.
--
-- - Parameters:   - tensor: The input tensor   - axis: The tensor dimension where you compute the cumulative operation   - exclusive: If true, perform the exclusive cumulative operation, and the first element will be equal to the largest value of the tensor data type   - reverse: If true, reverse the direction of the cumulative operation along the specified axis   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- cumulativeMinimumWithTensor:axis:exclusive:reverse:name:@
cumulativeMinimumWithTensor_axis_exclusive_reverse_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> CLong -> Bool -> Bool -> name -> IO (Id MPSGraphTensor)
cumulativeMinimumWithTensor_axis_exclusive_reverse_name mpsGraph  tensor axis exclusive reverse_ name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "cumulativeMinimumWithTensor:axis:exclusive:reverse:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argCLong axis, argCULong (if exclusive then 1 else 0), argCULong (if reverse_ then 1 else 0), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Computes the cumulative minimum of the input tensor along the specified axis.
--
-- - Parameters:   - tensor: The input tensor   - axisTensor: The tensor dimension where you compute the cumulative operation   - exclusive: If true, perform the exclusive cumulative operation, and the first element will be equal to the largest value of the tensor data type   - reverse: If true, reverse the direction of the cumulative operation along the specified axis   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- cumulativeMinimumWithTensor:axisTensor:exclusive:reverse:name:@
cumulativeMinimumWithTensor_axisTensor_exclusive_reverse_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsMPSGraphTensor axisTensor, IsNSString name) => mpsGraph -> tensor -> axisTensor -> Bool -> Bool -> name -> IO (Id MPSGraphTensor)
cumulativeMinimumWithTensor_axisTensor_exclusive_reverse_name mpsGraph  tensor axisTensor exclusive reverse_ name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr axisTensor $ \raw_axisTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "cumulativeMinimumWithTensor:axisTensor:exclusive:reverse:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_axisTensor :: Ptr ()), argCULong (if exclusive then 1 else 0), argCULong (if reverse_ then 1 else 0), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Computes the cumulative minimum of the input tensor along the specified axis.
--
-- - Parameters:   - tensor: The input tensor   - axis: The tensor dimension where you compute the cumulative operation   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- cumulativeMinimumWithTensor:axis:name:@
cumulativeMinimumWithTensor_axis_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> CLong -> name -> IO (Id MPSGraphTensor)
cumulativeMinimumWithTensor_axis_name mpsGraph  tensor axis name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "cumulativeMinimumWithTensor:axis:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argCLong axis, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Computes the cumulative minimum of the input tensor along the specified axis.
--
-- - Parameters:   - tensor: The input tensor   - axisTensor: The tensor dimension where you compute the cumulative operation   - exclusive: If true, perform the exclusive cumulative operation, and the first element will be equal to the largest value of the tensor data type   - reverse: If true, reverse the direction of the cumulative operation along the specified axis   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- cumulativeMinimumWithTensor:axisTensor:name:@
cumulativeMinimumWithTensor_axisTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsMPSGraphTensor axisTensor, IsNSString name) => mpsGraph -> tensor -> axisTensor -> name -> IO (Id MPSGraphTensor)
cumulativeMinimumWithTensor_axisTensor_name mpsGraph  tensor axisTensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr axisTensor $ \raw_axisTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "cumulativeMinimumWithTensor:axisTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_axisTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Computes the cumulative maximum of the input tensor along the specified axis.
--
-- - Parameters:   - tensor: The input tensor   - axis: The tensor dimension where you compute the cumulative operation   - exclusive: If true, perform the exclusive cumulative operation, and the first element will be equal to the lowest value of the tensor data type   - reverse: If true, reverse the direction of the cumulative operation along the specified axis   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- cumulativeMaximumWithTensor:axis:exclusive:reverse:name:@
cumulativeMaximumWithTensor_axis_exclusive_reverse_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> CLong -> Bool -> Bool -> name -> IO (Id MPSGraphTensor)
cumulativeMaximumWithTensor_axis_exclusive_reverse_name mpsGraph  tensor axis exclusive reverse_ name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "cumulativeMaximumWithTensor:axis:exclusive:reverse:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argCLong axis, argCULong (if exclusive then 1 else 0), argCULong (if reverse_ then 1 else 0), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Computes the cumulative maximum of the input tensor along the specified axis.
--
-- - Parameters:   - tensor: The input tensor   - axisTensor: The tensor dimension where you compute the cumulative operation   - exclusive: If true, perform the exclusive cumulative operation, and the first element will be equal to the lowest value of the tensor data type   - reverse: If true, reverse the direction of the cumulative operation along the specified axis   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- cumulativeMaximumWithTensor:axisTensor:exclusive:reverse:name:@
cumulativeMaximumWithTensor_axisTensor_exclusive_reverse_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsMPSGraphTensor axisTensor, IsNSString name) => mpsGraph -> tensor -> axisTensor -> Bool -> Bool -> name -> IO (Id MPSGraphTensor)
cumulativeMaximumWithTensor_axisTensor_exclusive_reverse_name mpsGraph  tensor axisTensor exclusive reverse_ name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr axisTensor $ \raw_axisTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "cumulativeMaximumWithTensor:axisTensor:exclusive:reverse:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_axisTensor :: Ptr ()), argCULong (if exclusive then 1 else 0), argCULong (if reverse_ then 1 else 0), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Computes the cumulative maximum of the input tensor along the specified axis.
--
-- - Parameters:   - tensor: The input tensor   - axis: The tensor dimension where you compute the cumulative operation   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- cumulativeMaximumWithTensor:axis:name:@
cumulativeMaximumWithTensor_axis_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> CLong -> name -> IO (Id MPSGraphTensor)
cumulativeMaximumWithTensor_axis_name mpsGraph  tensor axis name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "cumulativeMaximumWithTensor:axis:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argCLong axis, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Computes the cumulative maximum of the input tensor along the specified axis.
--
-- - Parameters:   - tensor: The input tensor   - axisTensor: The tensor dimension where you compute the cumulative operation   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- cumulativeMaximumWithTensor:axisTensor:name:@
cumulativeMaximumWithTensor_axisTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsMPSGraphTensor axisTensor, IsNSString name) => mpsGraph -> tensor -> axisTensor -> name -> IO (Id MPSGraphTensor)
cumulativeMaximumWithTensor_axisTensor_name mpsGraph  tensor axisTensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr axisTensor $ \raw_axisTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "cumulativeMaximumWithTensor:axisTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_axisTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Runs the graph for the given feeds and returns the target tensor values, ensuring all target operations also executed.
--
-- This call blocks until execution has completed.
--
-- - Parameters:   - operations: Operations maked as control dependency for all ops created inside the dependent block   - dependentBlock: MPSGraphControlFlowDependencyBlock which is provided by caller to create dependent ops   - name: name of scope - Returns: A valid MPSGraphTensor array with results returned from dependentBlock forwarded
--
-- ObjC selector: @- controlDependencyWithOperations:dependentBlock:name:@
controlDependencyWithOperations_dependentBlock_name :: (IsMPSGraph mpsGraph, IsNSArray operations, IsNSString name) => mpsGraph -> operations -> Ptr () -> name -> IO (Id NSArray)
controlDependencyWithOperations_dependentBlock_name mpsGraph  operations dependentBlock name =
  withObjCPtr operations $ \raw_operations ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "controlDependencyWithOperations:dependentBlock:name:") (retPtr retVoid) [argPtr (castPtr raw_operations :: Ptr ()), argPtr (castPtr dependentBlock :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Adds an if-then-else operation to the graph.
--
-- - Parameters:   - predicateTensor: Tensor must have a single scalar value, used to decide between then/else branches   - thenBlock: If predicate is true operations in this block are executed   - elseBlock: If predicate is false operations in this block are executed   - name: name of operation - Returns: results If no error, the tensors returned by user. If not empty, user must define both then/else block,  both should have same number of arguments and each corresponding argument should have same elementTypes.
--
-- ObjC selector: @- ifWithPredicateTensor:thenBlock:elseBlock:name:@
ifWithPredicateTensor_thenBlock_elseBlock_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor predicateTensor, IsNSString name) => mpsGraph -> predicateTensor -> Ptr () -> Ptr () -> name -> IO (Id NSArray)
ifWithPredicateTensor_thenBlock_elseBlock_name mpsGraph  predicateTensor thenBlock elseBlock name =
  withObjCPtr predicateTensor $ \raw_predicateTensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "ifWithPredicateTensor:thenBlock:elseBlock:name:") (retPtr retVoid) [argPtr (castPtr raw_predicateTensor :: Ptr ()), argPtr (castPtr thenBlock :: Ptr ()), argPtr (castPtr elseBlock :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Adds a while loop operation.
--
-- - Parameters:   - initialInputs: inputTensors to the @beforeBlock@, for the 1st iteration will be same as initialInputs passed to the while loop.   - before: @beforeBlock@, this will be run first and then call the @afterBlock@ with results or return results from the loop.   - after: @afterBlock@, this will execute after the condition evaluation.   - name: name of operation. - Returns: A valid MPSGraphTensor array with results returned from the conditionBlock depending on the predicate tensor.
--
-- ObjC selector: @- whileWithInitialInputs:before:after:name:@
whileWithInitialInputs_before_after_name :: (IsMPSGraph mpsGraph, IsNSArray initialInputs, IsNSString name) => mpsGraph -> initialInputs -> Ptr () -> Ptr () -> name -> IO (Id NSArray)
whileWithInitialInputs_before_after_name mpsGraph  initialInputs before after name =
  withObjCPtr initialInputs $ \raw_initialInputs ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "whileWithInitialInputs:before:after:name:") (retPtr retVoid) [argPtr (castPtr raw_initialInputs :: Ptr ()), argPtr (castPtr before :: Ptr ()), argPtr (castPtr after :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Adds a for loop operation, The lower and upper bounds specify a half-open range: the range includes the lower bound but does not include the upper bound.
--
-- - Parameters:   - lowerBound: Lower bound value of the loop, this is a scalar tensor, this is the index the loop will start with.   - upperBound: Upper bound value of the loop, this is a scalar tensor.   - step: Step value of the loop, this is a scalar tensor and must be positive.   - initialBodyArguments: initial set of iteration arguments passed to the bodyBlock of the for loop.   - body: This block will execute the body of the for loop.   - name: name of operation. - Returns: A valid @MPSGraphTensor@ array with same count and corresponding element types as @initialIterationArguments@ and return types of the for loop.
--
-- ObjC selector: @- forLoopWithLowerBound:upperBound:step:initialBodyArguments:body:name:@
forLoopWithLowerBound_upperBound_step_initialBodyArguments_body_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor lowerBound, IsMPSGraphTensor upperBound, IsMPSGraphTensor step, IsNSArray initialBodyArguments, IsNSString name) => mpsGraph -> lowerBound -> upperBound -> step -> initialBodyArguments -> Ptr () -> name -> IO (Id NSArray)
forLoopWithLowerBound_upperBound_step_initialBodyArguments_body_name mpsGraph  lowerBound upperBound step initialBodyArguments body name =
  withObjCPtr lowerBound $ \raw_lowerBound ->
    withObjCPtr upperBound $ \raw_upperBound ->
      withObjCPtr step $ \raw_step ->
        withObjCPtr initialBodyArguments $ \raw_initialBodyArguments ->
          withObjCPtr name $ \raw_name ->
              sendMsg mpsGraph (mkSelector "forLoopWithLowerBound:upperBound:step:initialBodyArguments:body:name:") (retPtr retVoid) [argPtr (castPtr raw_lowerBound :: Ptr ()), argPtr (castPtr raw_upperBound :: Ptr ()), argPtr (castPtr raw_step :: Ptr ()), argPtr (castPtr raw_initialBodyArguments :: Ptr ()), argPtr (castPtr body :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Adds a for loop operation, with a specific number of iterations.
--
-- - Parameters:   - numberOfIterations: tensor with number of iterations the loop will execute   - initialBodyArguments: initial set of iteration arguments passed to the bodyBlock of the for loop   - body: bodyBlock, this will execute the body of the for loop, index will go from 0 to numberOfIterations-1   - name: name of operation - Returns: A valid MPSGraphTensor array with same count and corresponding elementTypes as initialIterationArguments and return types of the for loop
--
-- ObjC selector: @- forLoopWithNumberOfIterations:initialBodyArguments:body:name:@
forLoopWithNumberOfIterations_initialBodyArguments_body_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor numberOfIterations, IsNSArray initialBodyArguments, IsNSString name) => mpsGraph -> numberOfIterations -> initialBodyArguments -> Ptr () -> name -> IO (Id NSArray)
forLoopWithNumberOfIterations_initialBodyArguments_body_name mpsGraph  numberOfIterations initialBodyArguments body name =
  withObjCPtr numberOfIterations $ \raw_numberOfIterations ->
    withObjCPtr initialBodyArguments $ \raw_initialBodyArguments ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "forLoopWithNumberOfIterations:initialBodyArguments:body:name:") (retPtr retVoid) [argPtr (castPtr raw_numberOfIterations :: Ptr ()), argPtr (castPtr raw_initialBodyArguments :: Ptr ()), argPtr (castPtr body :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a convolution transpose operation and returns the result tensor.
--
-- Convolution Tranpose operation is exactly the same as convolution gradint with respect to input image @convolution2DDataGradientWithIncomingGradient@. Weights tensor and source tensors are interpreted as they are in @convolution2DDataGradientWithIncomingGradient@. Convolution with stride @s@ downsamples source tensor by factor @s@ in spatial dimensions whereas convolution tranpose with stride @s@ upsamples source tensor by factor @s@. Convolution transpose can map the same source size to multiple destination sizes. The relationship between the width of the source and the width of the destination is `(sourceWidth - 1)stride + 1 + (kernelWidth - 1)dilationRate <= destinationWidth + paddingLeft + paddingRight` so there are stride -1 values of the width of the destination that give same width of the source. In order to disambiguate, outputShape parameter is used.
--
-- - Parameters:   - source: input tensor   - weights: weights tensor   - outputShape: shape of the result tensor.   - descriptor: descriptor for the corresponding forward 2D-convolution operation   - name: name for the operation - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- convolutionTranspose2DWithSourceTensor:weightsTensor:outputShape:descriptor:name:@
convolutionTranspose2DWithSourceTensor_weightsTensor_outputShape_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor source, IsMPSGraphTensor weights, IsMPSGraphConvolution2DOpDescriptor descriptor, IsNSString name) => mpsGraph -> source -> weights -> RawId -> descriptor -> name -> IO (Id MPSGraphTensor)
convolutionTranspose2DWithSourceTensor_weightsTensor_outputShape_descriptor_name mpsGraph  source weights outputShape descriptor name =
  withObjCPtr source $ \raw_source ->
    withObjCPtr weights $ \raw_weights ->
      withObjCPtr descriptor $ \raw_descriptor ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "convolutionTranspose2DWithSourceTensor:weightsTensor:outputShape:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_weights :: Ptr ()), argPtr (castPtr (unRawId outputShape) :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a convolution transpose operation and returns the result tensor.
--
-- - Parameters:   - source: input tensor   - weights: weights tensor   - outputShape: 1D Int32 or Int64 tensor. shape of the result tensor.   - descriptor: descriptor for the corresponding forward Conv2D operation   - name: name for the operation - Returns: A valid MPSGraphTensor object.
--
-- ObjC selector: @- convolutionTranspose2DWithSourceTensor:weightsTensor:outputShapeTensor:descriptor:name:@
convolutionTranspose2DWithSourceTensor_weightsTensor_outputShapeTensor_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor source, IsMPSGraphTensor weights, IsMPSGraphTensor outputShape, IsMPSGraphConvolution2DOpDescriptor descriptor, IsNSString name) => mpsGraph -> source -> weights -> outputShape -> descriptor -> name -> IO (Id MPSGraphTensor)
convolutionTranspose2DWithSourceTensor_weightsTensor_outputShapeTensor_descriptor_name mpsGraph  source weights outputShape descriptor name =
  withObjCPtr source $ \raw_source ->
    withObjCPtr weights $ \raw_weights ->
      withObjCPtr outputShape $ \raw_outputShape ->
        withObjCPtr descriptor $ \raw_descriptor ->
          withObjCPtr name $ \raw_name ->
              sendMsg mpsGraph (mkSelector "convolutionTranspose2DWithSourceTensor:weightsTensor:outputShapeTensor:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_weights :: Ptr ()), argPtr (castPtr raw_outputShape :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a convolution transpose gradient operation with respect to the source tensor of convolution transpose operation and returns the result tensor.
--
-- Inserts an operation in graph to compute gradient of convolution transpose with respect to source tensor of the corresponding convolution transpose operation.
--
-- - Parameters:   - incomingGradient: Incoming gradient tensor   - weights: Forward pass weights tensor   - outputShape: Shape of the forward pass source tensor   - forwardConvolutionDescriptor: Forward pass op descriptor   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- convolutionTranspose2DDataGradientWithIncomingGradientTensor:weightsTensor:outputShape:forwardConvolutionDescriptor:name:@
convolutionTranspose2DDataGradientWithIncomingGradientTensor_weightsTensor_outputShape_forwardConvolutionDescriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor incomingGradient, IsMPSGraphTensor weights, IsMPSGraphConvolution2DOpDescriptor forwardConvolutionDescriptor, IsNSString name) => mpsGraph -> incomingGradient -> weights -> RawId -> forwardConvolutionDescriptor -> name -> IO (Id MPSGraphTensor)
convolutionTranspose2DDataGradientWithIncomingGradientTensor_weightsTensor_outputShape_forwardConvolutionDescriptor_name mpsGraph  incomingGradient weights outputShape forwardConvolutionDescriptor name =
  withObjCPtr incomingGradient $ \raw_incomingGradient ->
    withObjCPtr weights $ \raw_weights ->
      withObjCPtr forwardConvolutionDescriptor $ \raw_forwardConvolutionDescriptor ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "convolutionTranspose2DDataGradientWithIncomingGradientTensor:weightsTensor:outputShape:forwardConvolutionDescriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_incomingGradient :: Ptr ()), argPtr (castPtr raw_weights :: Ptr ()), argPtr (castPtr (unRawId outputShape) :: Ptr ()), argPtr (castPtr raw_forwardConvolutionDescriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a convolution transpose gradient operation with respect to the source tensor of convolution transpose operation and returns the result tensor.
--
-- Inserts an operation in graph to compute gradient of convolution transpose with respect to source tensor of the corresponding convolution transpose operation.
--
-- - Parameters:   - incomingGradient: Incoming gradient tensor   - weights: Forward pass weights tensor   - outputShape: 1D Int32 or Int64 Tensor. Shape of the forward pass source tensor   - forwardConvolutionDescriptor: Forward pass op descriptor   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- convolutionTranspose2DDataGradientWithIncomingGradientTensor:weightsTensor:outputShapeTensor:forwardConvolutionDescriptor:name:@
convolutionTranspose2DDataGradientWithIncomingGradientTensor_weightsTensor_outputShapeTensor_forwardConvolutionDescriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor incomingGradient, IsMPSGraphTensor weights, IsMPSGraphTensor outputShape, IsMPSGraphConvolution2DOpDescriptor forwardConvolutionDescriptor, IsNSString name) => mpsGraph -> incomingGradient -> weights -> outputShape -> forwardConvolutionDescriptor -> name -> IO (Id MPSGraphTensor)
convolutionTranspose2DDataGradientWithIncomingGradientTensor_weightsTensor_outputShapeTensor_forwardConvolutionDescriptor_name mpsGraph  incomingGradient weights outputShape forwardConvolutionDescriptor name =
  withObjCPtr incomingGradient $ \raw_incomingGradient ->
    withObjCPtr weights $ \raw_weights ->
      withObjCPtr outputShape $ \raw_outputShape ->
        withObjCPtr forwardConvolutionDescriptor $ \raw_forwardConvolutionDescriptor ->
          withObjCPtr name $ \raw_name ->
              sendMsg mpsGraph (mkSelector "convolutionTranspose2DDataGradientWithIncomingGradientTensor:weightsTensor:outputShapeTensor:forwardConvolutionDescriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_incomingGradient :: Ptr ()), argPtr (castPtr raw_weights :: Ptr ()), argPtr (castPtr raw_outputShape :: Ptr ()), argPtr (castPtr raw_forwardConvolutionDescriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a convolution transpose gradient operation with respect to the weights tensor of the convolution transpose operation and returns the result tensor.
--
-- Inserts an operation in graph to compute gradient of convolution transpose with respect to the weights tensor of the corresponding convolution transpose operation.
--
-- - Parameters:   - incomingGradientTensor: Incoming gradient tensor   - source: Forward pass source tensor   - outputShape: Shape of the forward pass source weights tensor   - forwardConvolutionDescriptor: Forward pass op descriptor   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- convolutionTranspose2DWeightsGradientWithIncomingGradientTensor:sourceTensor:outputShape:forwardConvolutionDescriptor:name:@
convolutionTranspose2DWeightsGradientWithIncomingGradientTensor_sourceTensor_outputShape_forwardConvolutionDescriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor incomingGradientTensor, IsMPSGraphTensor source, IsMPSGraphConvolution2DOpDescriptor forwardConvolutionDescriptor, IsNSString name) => mpsGraph -> incomingGradientTensor -> source -> RawId -> forwardConvolutionDescriptor -> name -> IO (Id MPSGraphTensor)
convolutionTranspose2DWeightsGradientWithIncomingGradientTensor_sourceTensor_outputShape_forwardConvolutionDescriptor_name mpsGraph  incomingGradientTensor source outputShape forwardConvolutionDescriptor name =
  withObjCPtr incomingGradientTensor $ \raw_incomingGradientTensor ->
    withObjCPtr source $ \raw_source ->
      withObjCPtr forwardConvolutionDescriptor $ \raw_forwardConvolutionDescriptor ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "convolutionTranspose2DWeightsGradientWithIncomingGradientTensor:sourceTensor:outputShape:forwardConvolutionDescriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_incomingGradientTensor :: Ptr ()), argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr (unRawId outputShape) :: Ptr ()), argPtr (castPtr raw_forwardConvolutionDescriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a convolution transpose gradient operation with respect to the weights tensor of the convolution transpose operation and returns the result tensor.
--
-- Inserts an operation in graph to compute gradient of convolution transpose with respect to the weights tensor of the corresponding convolution transpose operation.
--
-- - Parameters:   - incomingGradientTensor: Incoming gradient tensor   - source: Forward pass source tensor   - outputShape: 1D Int32 or Int64 Tensor. Shape of the forward pass source weights tensor   - forwardConvolutionDescriptor: Forward pass op descriptor   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- convolutionTranspose2DWeightsGradientWithIncomingGradientTensor:sourceTensor:outputShapeTensor:forwardConvolutionDescriptor:name:@
convolutionTranspose2DWeightsGradientWithIncomingGradientTensor_sourceTensor_outputShapeTensor_forwardConvolutionDescriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor incomingGradientTensor, IsMPSGraphTensor source, IsMPSGraphTensor outputShape, IsMPSGraphConvolution2DOpDescriptor forwardConvolutionDescriptor, IsNSString name) => mpsGraph -> incomingGradientTensor -> source -> outputShape -> forwardConvolutionDescriptor -> name -> IO (Id MPSGraphTensor)
convolutionTranspose2DWeightsGradientWithIncomingGradientTensor_sourceTensor_outputShapeTensor_forwardConvolutionDescriptor_name mpsGraph  incomingGradientTensor source outputShape forwardConvolutionDescriptor name =
  withObjCPtr incomingGradientTensor $ \raw_incomingGradientTensor ->
    withObjCPtr source $ \raw_source ->
      withObjCPtr outputShape $ \raw_outputShape ->
        withObjCPtr forwardConvolutionDescriptor $ \raw_forwardConvolutionDescriptor ->
          withObjCPtr name $ \raw_name ->
              sendMsg mpsGraph (mkSelector "convolutionTranspose2DWeightsGradientWithIncomingGradientTensor:sourceTensor:outputShapeTensor:forwardConvolutionDescriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_incomingGradientTensor :: Ptr ()), argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_outputShape :: Ptr ()), argPtr (castPtr raw_forwardConvolutionDescriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a 2D (forward) convolution operation and returns the result tensor.
--
-- - Parameters:   - source: source tensor - must be a rank 4 tensor. The layout is defined by ``descriptor.dataLayout``.   - weights: weights tensor, must be rank 4. The layout is defined by ``descriptor.weightsLayout``.   - descriptor: Specifies strides, dilation rates, paddings and layouts.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- convolution2DWithSourceTensor:weightsTensor:descriptor:name:@
convolution2DWithSourceTensor_weightsTensor_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor source, IsMPSGraphTensor weights, IsMPSGraphConvolution2DOpDescriptor descriptor, IsNSString name) => mpsGraph -> source -> weights -> descriptor -> name -> IO (Id MPSGraphTensor)
convolution2DWithSourceTensor_weightsTensor_descriptor_name mpsGraph  source weights descriptor name =
  withObjCPtr source $ \raw_source ->
    withObjCPtr weights $ \raw_weights ->
      withObjCPtr descriptor $ \raw_descriptor ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "convolution2DWithSourceTensor:weightsTensor:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_weights :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a 2D convolution gradient operation with respect to the source tensor of the forward convolution.
--
-- If @S@ is source tensor to forward convolution, @R@ is the result/returned tensor from forward convolution, and @L@ is the loss function, @convolution2DDataGradientWithIncomingGradientTensor@ returns tensor @dL/dS = dL/dR * dR/dS@, where @dL/dR@ is the incomingGradient parameter.
--
-- - Parameters:   - incomingGradient: Incoming loss gradient tensor   - weights: Forward pass weights tensor   - outputShape: Shape of the forward pass source tensor   - forwardConvolutionDescriptor: Forward convolution 2D op ``descriptor``   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- convolution2DDataGradientWithIncomingGradientTensor:weightsTensor:outputShape:forwardConvolutionDescriptor:name:@
convolution2DDataGradientWithIncomingGradientTensor_weightsTensor_outputShape_forwardConvolutionDescriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor incomingGradient, IsMPSGraphTensor weights, IsMPSGraphConvolution2DOpDescriptor forwardConvolutionDescriptor, IsNSString name) => mpsGraph -> incomingGradient -> weights -> RawId -> forwardConvolutionDescriptor -> name -> IO (Id MPSGraphTensor)
convolution2DDataGradientWithIncomingGradientTensor_weightsTensor_outputShape_forwardConvolutionDescriptor_name mpsGraph  incomingGradient weights outputShape forwardConvolutionDescriptor name =
  withObjCPtr incomingGradient $ \raw_incomingGradient ->
    withObjCPtr weights $ \raw_weights ->
      withObjCPtr forwardConvolutionDescriptor $ \raw_forwardConvolutionDescriptor ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "convolution2DDataGradientWithIncomingGradientTensor:weightsTensor:outputShape:forwardConvolutionDescriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_incomingGradient :: Ptr ()), argPtr (castPtr raw_weights :: Ptr ()), argPtr (castPtr (unRawId outputShape) :: Ptr ()), argPtr (castPtr raw_forwardConvolutionDescriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a 2D convolution gradient operation with respect to the source tensor of the forward convolution.
--
-- If @S@ is source tensor to forward convolution, @R@ is the result/returned tensor of forward convolution, and @L@ is the loss function, convolution2DDataGradientWithIncomingGradientTensor returns tensor @dL/dS = dL/dR * dR/dS@, where @dL/dR@ is the incomingGradient parameter.
--
-- - Parameters:   - incomingGradient: Incoming loss gradient tensor   - weights: Forward pass weights tensor   - outputShapeTensor: 4D Int32 or Int64 tensor. Shape of the forward pass source tensor   - forwardConvolutionDescriptor: Forward convolution 2D op ``descriptor``   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- convolution2DDataGradientWithIncomingGradientTensor:weightsTensor:outputShapeTensor:forwardConvolutionDescriptor:name:@
convolution2DDataGradientWithIncomingGradientTensor_weightsTensor_outputShapeTensor_forwardConvolutionDescriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor gradient, IsMPSGraphTensor weights, IsMPSGraphTensor outputShapeTensor, IsMPSGraphConvolution2DOpDescriptor forwardConvolutionDescriptor, IsNSString name) => mpsGraph -> gradient -> weights -> outputShapeTensor -> forwardConvolutionDescriptor -> name -> IO (Id MPSGraphTensor)
convolution2DDataGradientWithIncomingGradientTensor_weightsTensor_outputShapeTensor_forwardConvolutionDescriptor_name mpsGraph  gradient weights outputShapeTensor forwardConvolutionDescriptor name =
  withObjCPtr gradient $ \raw_gradient ->
    withObjCPtr weights $ \raw_weights ->
      withObjCPtr outputShapeTensor $ \raw_outputShapeTensor ->
        withObjCPtr forwardConvolutionDescriptor $ \raw_forwardConvolutionDescriptor ->
          withObjCPtr name $ \raw_name ->
              sendMsg mpsGraph (mkSelector "convolution2DDataGradientWithIncomingGradientTensor:weightsTensor:outputShapeTensor:forwardConvolutionDescriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_gradient :: Ptr ()), argPtr (castPtr raw_weights :: Ptr ()), argPtr (castPtr raw_outputShapeTensor :: Ptr ()), argPtr (castPtr raw_forwardConvolutionDescriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a 2D convolution gradient operation with respect to the weights tensor of the forward convolution.
--
-- If @W@ is weights tensor to forward convolution, @R@ is the result/returned tensor of forward convolution, and @L@ is the loss function, convolution2DWeightsGradientWithIncomingGradientTensor returns tensor @dL/dW = dL/dR * dR/dW@, where @dL/dR@ is the incomingGradient parameter.
--
-- - Parameters:   - incomingGradient: Incoming loss gradient tensor   - weights: Forward pass weights tensor   - outputShape: Shape of the forward pass source tensor   - forwardConvolutionDescriptor: Forward convolution 2D op ``descriptor``   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- convolution2DWeightsGradientWithIncomingGradientTensor:sourceTensor:outputShape:forwardConvolutionDescriptor:name:@
convolution2DWeightsGradientWithIncomingGradientTensor_sourceTensor_outputShape_forwardConvolutionDescriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor incomingGradient, IsMPSGraphTensor source, IsMPSGraphConvolution2DOpDescriptor forwardConvolutionDescriptor, IsNSString name) => mpsGraph -> incomingGradient -> source -> RawId -> forwardConvolutionDescriptor -> name -> IO (Id MPSGraphTensor)
convolution2DWeightsGradientWithIncomingGradientTensor_sourceTensor_outputShape_forwardConvolutionDescriptor_name mpsGraph  incomingGradient source outputShape forwardConvolutionDescriptor name =
  withObjCPtr incomingGradient $ \raw_incomingGradient ->
    withObjCPtr source $ \raw_source ->
      withObjCPtr forwardConvolutionDescriptor $ \raw_forwardConvolutionDescriptor ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "convolution2DWeightsGradientWithIncomingGradientTensor:sourceTensor:outputShape:forwardConvolutionDescriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_incomingGradient :: Ptr ()), argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr (unRawId outputShape) :: Ptr ()), argPtr (castPtr raw_forwardConvolutionDescriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a 2D convolution gradient operation with respect to weights tensor of forward convolution.
--
-- If @W@ is weights tensor to forward convolution, @R@ is the result/returned tensor of forward convolution, and @L@ is the loss function, convolution2DWeightsGradientWithIncomingGradientTensor returns tensor @dL/dW = dL/dR * dR/dW@, where @dL/dR@ is the incomingGradient parameter.
--
-- - Parameters:   - incomingGradient: Incoming loss gradient tensor   - weights: Forward pass weights tensor   - outputShapeTensor: 4D int32 or Int64 Tensor. Shape of the forward pass source tensor   - forwardConvolutionDescriptor: Forward convolution 2D op ``descriptor``   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- convolution2DWeightsGradientWithIncomingGradientTensor:sourceTensor:outputShapeTensor:forwardConvolutionDescriptor:name:@
convolution2DWeightsGradientWithIncomingGradientTensor_sourceTensor_outputShapeTensor_forwardConvolutionDescriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor gradient, IsMPSGraphTensor source, IsMPSGraphTensor outputShapeTensor, IsMPSGraphConvolution2DOpDescriptor forwardConvolutionDescriptor, IsNSString name) => mpsGraph -> gradient -> source -> outputShapeTensor -> forwardConvolutionDescriptor -> name -> IO (Id MPSGraphTensor)
convolution2DWeightsGradientWithIncomingGradientTensor_sourceTensor_outputShapeTensor_forwardConvolutionDescriptor_name mpsGraph  gradient source outputShapeTensor forwardConvolutionDescriptor name =
  withObjCPtr gradient $ \raw_gradient ->
    withObjCPtr source $ \raw_source ->
      withObjCPtr outputShapeTensor $ \raw_outputShapeTensor ->
        withObjCPtr forwardConvolutionDescriptor $ \raw_forwardConvolutionDescriptor ->
          withObjCPtr name $ \raw_name ->
              sendMsg mpsGraph (mkSelector "convolution2DWeightsGradientWithIncomingGradientTensor:sourceTensor:outputShapeTensor:forwardConvolutionDescriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_gradient :: Ptr ()), argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_outputShapeTensor :: Ptr ()), argPtr (castPtr raw_forwardConvolutionDescriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a 3D forward convolution operation and returns the result tensor.
--
-- - Parameters:   - source: source tensor - must be of rank 5. The layout is defined by ``descriptor.dataLayout``.   - weights: weights tensor, must be rank 5. The layout is defined by ``descriptor.weightsLayout``.   - descriptor: Specifies strides, dilation rates, paddings and layouts.   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- convolution3DWithSourceTensor:weightsTensor:descriptor:name:@
convolution3DWithSourceTensor_weightsTensor_descriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor source, IsMPSGraphTensor weights, IsMPSGraphConvolution3DOpDescriptor descriptor, IsNSString name) => mpsGraph -> source -> weights -> descriptor -> name -> IO (Id MPSGraphTensor)
convolution3DWithSourceTensor_weightsTensor_descriptor_name mpsGraph  source weights descriptor name =
  withObjCPtr source $ \raw_source ->
    withObjCPtr weights $ \raw_weights ->
      withObjCPtr descriptor $ \raw_descriptor ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "convolution3DWithSourceTensor:weightsTensor:descriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_weights :: Ptr ()), argPtr (castPtr raw_descriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a 3D convolution gradient operation with respect to the source tensor of the forward convolution.
--
-- If @S@ is source tensor to forward convolution, @R@ is the result/returned tensor of forward convolution, and @L@ is the loss function, convolution3DDataGradientWithIncomingGradientTensor returns tensor @dL/dS = dL/dR * dR/dS@, where @dL/dR@ is the incomingGradient parameter.
--
-- - Parameters:   - incomingGradient: Incoming loss gradient tensor   - weights: Forward pass weights tensor   - outputShape: Shape of the forward pass source tensor   - forwardConvolutionDescriptor: Forward convolution 2D op ``descriptor``   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- convolution3DDataGradientWithIncomingGradientTensor:weightsTensor:outputShape:forwardConvolutionDescriptor:name:@
convolution3DDataGradientWithIncomingGradientTensor_weightsTensor_outputShape_forwardConvolutionDescriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor incomingGradient, IsMPSGraphTensor weights, IsMPSGraphConvolution3DOpDescriptor forwardConvolutionDescriptor, IsNSString name) => mpsGraph -> incomingGradient -> weights -> RawId -> forwardConvolutionDescriptor -> name -> IO (Id MPSGraphTensor)
convolution3DDataGradientWithIncomingGradientTensor_weightsTensor_outputShape_forwardConvolutionDescriptor_name mpsGraph  incomingGradient weights outputShape forwardConvolutionDescriptor name =
  withObjCPtr incomingGradient $ \raw_incomingGradient ->
    withObjCPtr weights $ \raw_weights ->
      withObjCPtr forwardConvolutionDescriptor $ \raw_forwardConvolutionDescriptor ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "convolution3DDataGradientWithIncomingGradientTensor:weightsTensor:outputShape:forwardConvolutionDescriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_incomingGradient :: Ptr ()), argPtr (castPtr raw_weights :: Ptr ()), argPtr (castPtr (unRawId outputShape) :: Ptr ()), argPtr (castPtr raw_forwardConvolutionDescriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a 3D convolution gradient operation with respect to the source tensor of the forward convolution.
--
-- If @S@ is source tensor to forward convolution, @R@ is the result/returned tensor of forward convolution, and @L@ is the loss function, convolution3DDataGradientWithIncomingGradientTensor returns tensor @dL/dS = dL/dR * dR/dS@, where @dL/dR@ is the incomingGradient parameter.
--
-- - Parameters:   - incomingGradient: Incoming loss gradient tensor   - weights: Forward pass weights tensor   - outputShapeTensor: 4D Int32 or Int64 tensor. Shape of the forward pass source tensor   - forwardConvolutionDescriptor: Forward convolution 2D op ``descriptor``   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- convolution3DDataGradientWithIncomingGradientTensor:weightsTensor:outputShapeTensor:forwardConvolutionDescriptor:name:@
convolution3DDataGradientWithIncomingGradientTensor_weightsTensor_outputShapeTensor_forwardConvolutionDescriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor gradient, IsMPSGraphTensor weights, IsMPSGraphTensor outputShapeTensor, IsMPSGraphConvolution3DOpDescriptor forwardConvolutionDescriptor, IsNSString name) => mpsGraph -> gradient -> weights -> outputShapeTensor -> forwardConvolutionDescriptor -> name -> IO (Id MPSGraphTensor)
convolution3DDataGradientWithIncomingGradientTensor_weightsTensor_outputShapeTensor_forwardConvolutionDescriptor_name mpsGraph  gradient weights outputShapeTensor forwardConvolutionDescriptor name =
  withObjCPtr gradient $ \raw_gradient ->
    withObjCPtr weights $ \raw_weights ->
      withObjCPtr outputShapeTensor $ \raw_outputShapeTensor ->
        withObjCPtr forwardConvolutionDescriptor $ \raw_forwardConvolutionDescriptor ->
          withObjCPtr name $ \raw_name ->
              sendMsg mpsGraph (mkSelector "convolution3DDataGradientWithIncomingGradientTensor:weightsTensor:outputShapeTensor:forwardConvolutionDescriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_gradient :: Ptr ()), argPtr (castPtr raw_weights :: Ptr ()), argPtr (castPtr raw_outputShapeTensor :: Ptr ()), argPtr (castPtr raw_forwardConvolutionDescriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a 3D convolution gradient operation with respect to the weights tensor of the forward convolution.
--
-- If @W@ is weights tensor to forward convolution, @R@ is the result/returned tensor of forward convolution, and @L@ is the loss function, convolution3DWeightsGradientWithIncomingGradientTensor returns tensor @dL/dW = dL/dR * dR/dW@, where @dL/dR@ is the incomingGradient parameter.
--
-- - Parameters:   - incomingGradient: Incoming loss gradient tensor   - weights: Forward pass weights tensor   - outputShape: Shape of the forward pass source tensor   - forwardConvolutionDescriptor: Forward convolution 2D op ``descriptor``   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- convolution3DWeightsGradientWithIncomingGradientTensor:sourceTensor:outputShape:forwardConvolutionDescriptor:name:@
convolution3DWeightsGradientWithIncomingGradientTensor_sourceTensor_outputShape_forwardConvolutionDescriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor incomingGradient, IsMPSGraphTensor source, IsMPSGraphConvolution3DOpDescriptor forwardConvolutionDescriptor, IsNSString name) => mpsGraph -> incomingGradient -> source -> RawId -> forwardConvolutionDescriptor -> name -> IO (Id MPSGraphTensor)
convolution3DWeightsGradientWithIncomingGradientTensor_sourceTensor_outputShape_forwardConvolutionDescriptor_name mpsGraph  incomingGradient source outputShape forwardConvolutionDescriptor name =
  withObjCPtr incomingGradient $ \raw_incomingGradient ->
    withObjCPtr source $ \raw_source ->
      withObjCPtr forwardConvolutionDescriptor $ \raw_forwardConvolutionDescriptor ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "convolution3DWeightsGradientWithIncomingGradientTensor:sourceTensor:outputShape:forwardConvolutionDescriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_incomingGradient :: Ptr ()), argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr (unRawId outputShape) :: Ptr ()), argPtr (castPtr raw_forwardConvolutionDescriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates a 3D convolution gradient operation with respect to the weights tensor of the forward convolution.
--
-- If @W@ is weights tensor to forward convolution, @R@ is the result/returned tensor of forward convolution, and @L@ is the loss function, convolution3DWeightsGradientWithIncomingGradientTensor returns tensor @dL/dW = dL/dR * dR/dW@, where @dL/dR@ is the incomingGradient parameter.
--
-- - Parameters:   - incomingGradient: Incoming loss gradient tensor   - weights: Forward pass weights tensor   - outputShapeTensor: 4D int32 or Int64 Tensor. Shape of the forward pass source tensor   - forwardConvolutionDescriptor: Forward convolution 2D op ``descriptor``   - name: The name for the operation. - Returns: A valid MPSGraphTensor object
--
-- ObjC selector: @- convolution3DWeightsGradientWithIncomingGradientTensor:sourceTensor:outputShapeTensor:forwardConvolutionDescriptor:name:@
convolution3DWeightsGradientWithIncomingGradientTensor_sourceTensor_outputShapeTensor_forwardConvolutionDescriptor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor gradient, IsMPSGraphTensor source, IsMPSGraphTensor outputShapeTensor, IsMPSGraphConvolution3DOpDescriptor forwardConvolutionDescriptor, IsNSString name) => mpsGraph -> gradient -> source -> outputShapeTensor -> forwardConvolutionDescriptor -> name -> IO (Id MPSGraphTensor)
convolution3DWeightsGradientWithIncomingGradientTensor_sourceTensor_outputShapeTensor_forwardConvolutionDescriptor_name mpsGraph  gradient source outputShapeTensor forwardConvolutionDescriptor name =
  withObjCPtr gradient $ \raw_gradient ->
    withObjCPtr source $ \raw_source ->
      withObjCPtr outputShapeTensor $ \raw_outputShapeTensor ->
        withObjCPtr forwardConvolutionDescriptor $ \raw_forwardConvolutionDescriptor ->
          withObjCPtr name $ \raw_name ->
              sendMsg mpsGraph (mkSelector "convolution3DWeightsGradientWithIncomingGradientTensor:sourceTensor:outputShapeTensor:forwardConvolutionDescriptor:name:") (retPtr retVoid) [argPtr (castPtr raw_gradient :: Ptr ()), argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_outputShapeTensor :: Ptr ()), argPtr (castPtr raw_forwardConvolutionDescriptor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Creates an operation which invokes another executable.
--
-- - Parameters:   - symbolName: The unique identifier used to find the executable in the ``MPSGraphCompilationDescriptor.callables`` directory.   - inputTensors: The tensors which are passed as inputs to the executable being invoked.   - outputTypes: The expected return types of the executable being invoked.   - name: name of operation. - Returns: An array of valid ``MPSGraphTensor`` objects representing the return tensors of the invoked executable.
--
-- ObjC selector: @- callSymbolName:inputTensors:outputTypes:name:@
callSymbolName_inputTensors_outputTypes_name :: (IsMPSGraph mpsGraph, IsNSString symbolName, IsNSArray inputTensors, IsNSArray outputTypes, IsNSString name) => mpsGraph -> symbolName -> inputTensors -> outputTypes -> name -> IO (Id NSArray)
callSymbolName_inputTensors_outputTypes_name mpsGraph  symbolName inputTensors outputTypes name =
  withObjCPtr symbolName $ \raw_symbolName ->
    withObjCPtr inputTensors $ \raw_inputTensors ->
      withObjCPtr outputTypes $ \raw_outputTypes ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "callSymbolName:inputTensors:outputTypes:name:") (retPtr retVoid) [argPtr (castPtr raw_symbolName :: Ptr ()), argPtr (castPtr raw_inputTensors :: Ptr ()), argPtr (castPtr raw_outputTypes :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Copies the input tensor values into the output, behaving as an identity operation.
--
-- - Parameters:   - tensor: The input tensor.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object which is a copy of the input.
--
-- ObjC selector: @- identityWithTensor:name:@
identityWithTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> name -> IO (Id MPSGraphTensor)
identityWithTensor_name mpsGraph  tensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "identityWithTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Applies the natural exponent to the input tensor elements.
--
-- - Parameters:   - tensor: The input tensor.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- exponentWithTensor:name:@
exponentWithTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> name -> IO (Id MPSGraphTensor)
exponentWithTensor_name mpsGraph  tensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "exponentWithTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Applies an exponent with base 2 to the input tensor elements.
--
-- - Parameters:   - tensor: The input tensor.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- exponentBase2WithTensor:name:@
exponentBase2WithTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> name -> IO (Id MPSGraphTensor)
exponentBase2WithTensor_name mpsGraph  tensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "exponentBase2WithTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Applies an exponent with base 10 to the input tensor elements.
--
-- - Parameters:   - tensor: The input tensor.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- exponentBase10WithTensor:name:@
exponentBase10WithTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> name -> IO (Id MPSGraphTensor)
exponentBase10WithTensor_name mpsGraph  tensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "exponentBase10WithTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Computes the natural logarithm to the input tensor elements.
--
-- - Parameters:   - tensor: The input tensor.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- logarithmWithTensor:name:@
logarithmWithTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> name -> IO (Id MPSGraphTensor)
logarithmWithTensor_name mpsGraph  tensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "logarithmWithTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Computes the logarithm with base 2 to the input tensor elements.
--
-- - Parameters:   - tensor: The input tensor.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- logarithmBase2WithTensor:name:@
logarithmBase2WithTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> name -> IO (Id MPSGraphTensor)
logarithmBase2WithTensor_name mpsGraph  tensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "logarithmBase2WithTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Computes the logarithm with base 10 to the input tensor elements.
--
-- - Parameters:   - tensor: The input tensor.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- logarithmBase10WithTensor:name:@
logarithmBase10WithTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> name -> IO (Id MPSGraphTensor)
logarithmBase10WithTensor_name mpsGraph  tensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "logarithmBase10WithTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Applies the square operation to the input tensor elements.
--
-- - Parameters:   - tensor: The input tensor.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- squareWithTensor:name:@
squareWithTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> name -> IO (Id MPSGraphTensor)
squareWithTensor_name mpsGraph  tensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "squareWithTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Applies the square root operation to the input tensor elements.
--
-- - Parameters:   - tensor: The input tensor.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- squareRootWithTensor:name:@
squareRootWithTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> name -> IO (Id MPSGraphTensor)
squareRootWithTensor_name mpsGraph  tensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "squareRootWithTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Applies the reciprocal square root operation to the input tensor elements.
--
-- - Parameters:   - tensor: The input tensor.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- reciprocalSquareRootWithTensor:name:@
reciprocalSquareRootWithTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> name -> IO (Id MPSGraphTensor)
reciprocalSquareRootWithTensor_name mpsGraph  tensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "reciprocalSquareRootWithTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Applies the reverse square root operation to the input tensor elements.
--
-- The reverse square root operation is the reciprocal of the square root.
--
-- - Parameters:   - tensor: The input tensor.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- reverseSquareRootWithTensor:name:@
reverseSquareRootWithTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> name -> IO (Id MPSGraphTensor)
reverseSquareRootWithTensor_name mpsGraph  tensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "reverseSquareRootWithTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Applies the reciprocal operation to the input tensor elements.
--
-- - Parameters:   - tensor: The input tensor.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- reciprocalWithTensor:name:@
reciprocalWithTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> name -> IO (Id MPSGraphTensor)
reciprocalWithTensor_name mpsGraph  tensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "reciprocalWithTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Returns the absolute values of the input tensor elements.
--
-- - Parameters:   - tensor: The input tensor.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- absoluteWithTensor:name:@
absoluteWithTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> name -> IO (Id MPSGraphTensor)
absoluteWithTensor_name mpsGraph  tensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "absoluteWithTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Returns the absolute square of the input tensor elements.
--
-- - Parameters:   - tensor: The input tensor.   - name: An optional string which serves as an identifier for the operation.. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- absoluteSquareWithTensor:name:@
absoluteSquareWithTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> name -> IO (Id MPSGraphTensor)
absoluteSquareWithTensor_name mpsGraph  tensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "absoluteSquareWithTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Applies negative to the input tensor elements.
--
-- - Parameters:   - tensor: The input tensor.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- negativeWithTensor:name:@
negativeWithTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> name -> IO (Id MPSGraphTensor)
negativeWithTensor_name mpsGraph  tensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "negativeWithTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Returns the sign of the input tensor elements.
--
-- This operation returns 1.0 if the correspnding input element is greater than 0, -1.0 if it is lesser than 0, -0.0 if it is equal to -0.0, and +0.0 if it is equal to +0.0.
--
-- - Parameters:   - tensor: The input tensor.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- signWithTensor:name:@
signWithTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> name -> IO (Id MPSGraphTensor)
signWithTensor_name mpsGraph  tensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "signWithTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Returns the sign bit of the input tensor elements.
--
-- This operation returns @true@ if the sign bit is set for the correspnding floating-point input element, otherwise it returns @false@.
--
-- - Parameters:   - tensor: The input tensor.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- signbitWithTensor:name:@
signbitWithTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> name -> IO (Id MPSGraphTensor)
signbitWithTensor_name mpsGraph  tensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "signbitWithTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Applies the ceiling operation to the input tensor elements.
--
-- - Parameters:   - tensor: The input tensor.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- ceilWithTensor:name:@
ceilWithTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> name -> IO (Id MPSGraphTensor)
ceilWithTensor_name mpsGraph  tensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "ceilWithTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Applies the floor operation to the input tensor elements.
--
-- - Parameters:   - tensor: The input tensor.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- floorWithTensor:name:@
floorWithTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> name -> IO (Id MPSGraphTensor)
floorWithTensor_name mpsGraph  tensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "floorWithTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Rounds the input tensor elements.
--
-- - Parameters:   - tensor: The input tensor.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- roundWithTensor:name:@
roundWithTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> name -> IO (Id MPSGraphTensor)
roundWithTensor_name mpsGraph  tensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "roundWithTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Rounds the input tensor elements by rounding to nearest even.
--
-- - Parameters:   - tensor: The input tensor.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- rintWithTensor:name:@
rintWithTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> name -> IO (Id MPSGraphTensor)
rintWithTensor_name mpsGraph  tensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "rintWithTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Applies the sine operation to the input tensor elements.
--
-- - Parameters:   - tensor: The input tensor.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- sinWithTensor:name:@
sinWithTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> name -> IO (Id MPSGraphTensor)
sinWithTensor_name mpsGraph  tensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "sinWithTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Applies the cosine operation to the input tensor elements.
--
-- - Parameters:   - tensor: The input tensor.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- cosWithTensor:name:@
cosWithTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> name -> IO (Id MPSGraphTensor)
cosWithTensor_name mpsGraph  tensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "cosWithTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Applies the tangent operation to the input tensor elements.
--
-- - Parameters:   - tensor: The input tensor.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- tanWithTensor:name:@
tanWithTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> name -> IO (Id MPSGraphTensor)
tanWithTensor_name mpsGraph  tensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "tanWithTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Applies the hyperbolic sine operation to the input tensor elements.
--
-- - Parameters:   - tensor: The input tensor.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- sinhWithTensor:name:@
sinhWithTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> name -> IO (Id MPSGraphTensor)
sinhWithTensor_name mpsGraph  tensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "sinhWithTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Applies the hyperbolic cosine operation to the input tensor elements.
--
-- - Parameters:   - tensor: The input tensor.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- coshWithTensor:name:@
coshWithTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> name -> IO (Id MPSGraphTensor)
coshWithTensor_name mpsGraph  tensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "coshWithTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Applies the hyperbolic tangent operation to the input tensor elements.
--
-- - Parameters:   - tensor: The input tensor.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- tanhWithTensor:name:@
tanhWithTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> name -> IO (Id MPSGraphTensor)
tanhWithTensor_name mpsGraph  tensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "tanhWithTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Applies the inverse sine operation to the input tensor elements.
--
-- - Parameters:   - tensor: The input tensor.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- asinWithTensor:name:@
asinWithTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> name -> IO (Id MPSGraphTensor)
asinWithTensor_name mpsGraph  tensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "asinWithTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Applies the inverse cosine operation to the input tensor elements.
--
-- - Parameters:   - tensor: The input tensor.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- acosWithTensor:name:@
acosWithTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> name -> IO (Id MPSGraphTensor)
acosWithTensor_name mpsGraph  tensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "acosWithTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Applies the inverse tangent operation to the input tensor elements.
--
-- - Parameters:   - tensor: The input tensor.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- atanWithTensor:name:@
atanWithTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> name -> IO (Id MPSGraphTensor)
atanWithTensor_name mpsGraph  tensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "atanWithTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Applies the inverse hyperbolic sine operation to the input tensor elements.
--
-- - Parameters:   - tensor: The input tensor.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- asinhWithTensor:name:@
asinhWithTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> name -> IO (Id MPSGraphTensor)
asinhWithTensor_name mpsGraph  tensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "asinhWithTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Applies the inverse hyperbolic cosine operation to the input tensor elements.
--
-- - Parameters:   - tensor: The input tensor.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- acoshWithTensor:name:@
acoshWithTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> name -> IO (Id MPSGraphTensor)
acoshWithTensor_name mpsGraph  tensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "acoshWithTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Applies the inverse hyperbolic tangent operation to the input tensor elements.
--
-- - Parameters:   - tensor: The input tensor.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- atanhWithTensor:name:@
atanhWithTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> name -> IO (Id MPSGraphTensor)
atanhWithTensor_name mpsGraph  tensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "atanhWithTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Applies the logical NOT operation to the input tensor elements.
--
-- - Parameters:   - tensor: The input tensor.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- notWithTensor:name:@
notWithTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> name -> IO (Id MPSGraphTensor)
notWithTensor_name mpsGraph  tensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "notWithTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Checks if the input tensor elements are infinite or not.
--
-- If the input tensor element is infinite, the operation returns @true@, else it returns @false@.
--
-- - Parameters:   - tensor: The input tensor.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- isInfiniteWithTensor:name:@
isInfiniteWithTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> name -> IO (Id MPSGraphTensor)
isInfiniteWithTensor_name mpsGraph  tensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "isInfiniteWithTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Checks if the input tensor elements are finite or not.
--
-- If the input tensor element is finite, the operation returns @true@, else it returns @false@.
--
-- - Parameters:   - tensor: The input tensor.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- isFiniteWithTensor:name:@
isFiniteWithTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> name -> IO (Id MPSGraphTensor)
isFiniteWithTensor_name mpsGraph  tensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "isFiniteWithTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Checks if the input tensor elements are @NaN@ or not.
--
-- If the input tensor element is @NaN@, the operation returns @true@, else it returns @false@.
--
-- - Parameters:   - tensor: The input tensor.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- isNaNWithTensor:name:@
isNaNWithTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> name -> IO (Id MPSGraphTensor)
isNaNWithTensor_name mpsGraph  tensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "isNaNWithTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Applies the error function to the input tensor elements.
--
-- - Parameters:   - tensor: The input tensor.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- erfWithTensor:name:@
erfWithTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> name -> IO (Id MPSGraphTensor)
erfWithTensor_name mpsGraph  tensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "erfWithTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Applies the truncate operation to the input tensor elements.
--
-- This operation applies the floor operation to positive inputs and ceiling operation to negative inputs.
--
-- - Parameters:   - tensor: The input tensor.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- truncateWithTensor:name:@
truncateWithTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> name -> IO (Id MPSGraphTensor)
truncateWithTensor_name mpsGraph  tensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "truncateWithTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Applies the bitwise NOT operation to the input tensor element.
--
-- This operation only accepts integer tensors.
--
-- - Parameters:   - tensor: The input tensor, which must be of integer type.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- bitwiseNOTWithTensor:name:@
bitwiseNOTWithTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> name -> IO (Id MPSGraphTensor)
bitwiseNOTWithTensor_name mpsGraph  tensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "bitwiseNOTWithTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Returns the population count of the input tensor elements.
--
-- This operation only accepts integer tensors, and returns the number of bits set in the input element.
--
-- - Parameters:   - tensor: The input tensor, which must be of integer type.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- bitwisePopulationCountWithTensor:name:@
bitwisePopulationCountWithTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> name -> IO (Id MPSGraphTensor)
bitwisePopulationCountWithTensor_name mpsGraph  tensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "bitwisePopulationCountWithTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Returns the complex conjugate of the input tensor elements.
--
-- - Parameters:   - tensor: The input tensor.   - name: An optional string which serves as an identifier for the operation.. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- conjugateWithTensor:name:@
conjugateWithTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> name -> IO (Id MPSGraphTensor)
conjugateWithTensor_name mpsGraph  tensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "conjugateWithTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Adds two input tensors.
--
-- This operation creates an add operation and returns the result tensor. It supports broadcasting as well.  ```md  resultTensor = primaryTensor + secondaryTensor  ```
--
-- - Parameters:   - primaryTensor: The LHS tensor of the binary Op.   - secondaryTensor: The RHS tensor of the binary Op.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- additionWithPrimaryTensor:secondaryTensor:name:@
additionWithPrimaryTensor_secondaryTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor primaryTensor, IsMPSGraphTensor secondaryTensor, IsNSString name) => mpsGraph -> primaryTensor -> secondaryTensor -> name -> IO (Id MPSGraphTensor)
additionWithPrimaryTensor_secondaryTensor_name mpsGraph  primaryTensor secondaryTensor name =
  withObjCPtr primaryTensor $ \raw_primaryTensor ->
    withObjCPtr secondaryTensor $ \raw_secondaryTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "additionWithPrimaryTensor:secondaryTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_primaryTensor :: Ptr ()), argPtr (castPtr raw_secondaryTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Subtracts the second input tensor from the first.
--
-- This operation creates a subtract operation and returns the result tensor. It supports broadcasting as well.  ```md  resultTensor = primaryTensor - secondaryTensor  ```
--
-- - Parameters:   - primaryTensor: The LHS tensor of the binary Op.   - secondaryTensor: The RHS tensor of the binary Op.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- subtractionWithPrimaryTensor:secondaryTensor:name:@
subtractionWithPrimaryTensor_secondaryTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor primaryTensor, IsMPSGraphTensor secondaryTensor, IsNSString name) => mpsGraph -> primaryTensor -> secondaryTensor -> name -> IO (Id MPSGraphTensor)
subtractionWithPrimaryTensor_secondaryTensor_name mpsGraph  primaryTensor secondaryTensor name =
  withObjCPtr primaryTensor $ \raw_primaryTensor ->
    withObjCPtr secondaryTensor $ \raw_secondaryTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "subtractionWithPrimaryTensor:secondaryTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_primaryTensor :: Ptr ()), argPtr (castPtr raw_secondaryTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Multiplies two input tensors.
--
-- This operation creates a multiply operation and returns the result tensor. It supports broadcasting as well.  ```md  resultTensor = primaryTensor * secondaryTensor  ```
--
-- - Parameters:   - primaryTensor: The LHS tensor of the binary Op.   - secondaryTensor: The RHS tensor of the binary Op.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- multiplicationWithPrimaryTensor:secondaryTensor:name:@
multiplicationWithPrimaryTensor_secondaryTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor primaryTensor, IsMPSGraphTensor secondaryTensor, IsNSString name) => mpsGraph -> primaryTensor -> secondaryTensor -> name -> IO (Id MPSGraphTensor)
multiplicationWithPrimaryTensor_secondaryTensor_name mpsGraph  primaryTensor secondaryTensor name =
  withObjCPtr primaryTensor $ \raw_primaryTensor ->
    withObjCPtr secondaryTensor $ \raw_secondaryTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "multiplicationWithPrimaryTensor:secondaryTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_primaryTensor :: Ptr ()), argPtr (castPtr raw_secondaryTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Divides the first input tensor by the second.
--
-- This operation creates a divide operation and returns the result tensor. It supports broadcasting as well.  ```md  resultTensor = primaryTensor / secondaryTensor  ```
--
-- - Parameters:   - primaryTensor: The LHS tensor of the binary Op.   - secondaryTensor: The RHS tensor of the binary Op.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- divisionWithPrimaryTensor:secondaryTensor:name:@
divisionWithPrimaryTensor_secondaryTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor primaryTensor, IsMPSGraphTensor secondaryTensor, IsNSString name) => mpsGraph -> primaryTensor -> secondaryTensor -> name -> IO (Id MPSGraphTensor)
divisionWithPrimaryTensor_secondaryTensor_name mpsGraph  primaryTensor secondaryTensor name =
  withObjCPtr primaryTensor $ \raw_primaryTensor ->
    withObjCPtr secondaryTensor $ \raw_secondaryTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "divisionWithPrimaryTensor:secondaryTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_primaryTensor :: Ptr ()), argPtr (castPtr raw_secondaryTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Returns the remainder obtained by dividing the first input tensor by the second.
--
-- This operation creates a modulo operation and returns the result tensor. It supports broadcasting as well.  ```md resultTensor = primaryTensor % secondaryTensor ```
--
-- - Parameters:   - primaryTensor: The LHS tensor of the binary Op.   - secondaryTensor: The RHS tensor of the binary Op.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- moduloWithPrimaryTensor:secondaryTensor:name:@
moduloWithPrimaryTensor_secondaryTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor primaryTensor, IsMPSGraphTensor secondaryTensor, IsNSString name) => mpsGraph -> primaryTensor -> secondaryTensor -> name -> IO (Id MPSGraphTensor)
moduloWithPrimaryTensor_secondaryTensor_name mpsGraph  primaryTensor secondaryTensor name =
  withObjCPtr primaryTensor $ \raw_primaryTensor ->
    withObjCPtr secondaryTensor $ \raw_secondaryTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "moduloWithPrimaryTensor:secondaryTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_primaryTensor :: Ptr ()), argPtr (castPtr raw_secondaryTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Returns the elementwise result of raising the first tensor to the power of the second tensor.
--
-- This operation creates a power operation and returns the result tensor. It supports broadcasting as well.  ```md resultTensor = pow(primaryTensor, secondaryTensor) ```
--
-- - Parameters:   - primaryTensor: The LHS tensor of the binary Op.   - secondaryTensor: The RHS tensor of the binary Op.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- powerWithPrimaryTensor:secondaryTensor:name:@
powerWithPrimaryTensor_secondaryTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor primaryTensor, IsMPSGraphTensor secondaryTensor, IsNSString name) => mpsGraph -> primaryTensor -> secondaryTensor -> name -> IO (Id MPSGraphTensor)
powerWithPrimaryTensor_secondaryTensor_name mpsGraph  primaryTensor secondaryTensor name =
  withObjCPtr primaryTensor $ \raw_primaryTensor ->
    withObjCPtr secondaryTensor $ \raw_secondaryTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "powerWithPrimaryTensor:secondaryTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_primaryTensor :: Ptr ()), argPtr (castPtr raw_secondaryTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Returns the elementwise minimum of the input tensors.
--
-- This operation creates a minimum operation and returns the result tensor. It supports broadcasting as well.  ```md resultTensor = min(primaryTensor, secondaryTensor) ```
--
-- - Parameters:   - primaryTensor: The LHS tensor of the binary Op.   - secondaryTensor: The RHS tensor of the binary Op.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- minimumWithPrimaryTensor:secondaryTensor:name:@
minimumWithPrimaryTensor_secondaryTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor primaryTensor, IsMPSGraphTensor secondaryTensor, IsNSString name) => mpsGraph -> primaryTensor -> secondaryTensor -> name -> IO (Id MPSGraphTensor)
minimumWithPrimaryTensor_secondaryTensor_name mpsGraph  primaryTensor secondaryTensor name =
  withObjCPtr primaryTensor $ \raw_primaryTensor ->
    withObjCPtr secondaryTensor $ \raw_secondaryTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "minimumWithPrimaryTensor:secondaryTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_primaryTensor :: Ptr ()), argPtr (castPtr raw_secondaryTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Returns the elementwise maximum of the input tensors.
--
-- This operation creates a maximum operation and returns the result tensor. It supports broadcasting as well.  ```md resultTensor = max(primaryTensor, secondaryTensor) ```
--
-- - Parameters:   - primaryTensor: The LHS tensor of the binary Op.   - secondaryTensor: The RHS tensor of the binary Op.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- maximumWithPrimaryTensor:secondaryTensor:name:@
maximumWithPrimaryTensor_secondaryTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor primaryTensor, IsMPSGraphTensor secondaryTensor, IsNSString name) => mpsGraph -> primaryTensor -> secondaryTensor -> name -> IO (Id MPSGraphTensor)
maximumWithPrimaryTensor_secondaryTensor_name mpsGraph  primaryTensor secondaryTensor name =
  withObjCPtr primaryTensor $ \raw_primaryTensor ->
    withObjCPtr secondaryTensor $ \raw_secondaryTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "maximumWithPrimaryTensor:secondaryTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_primaryTensor :: Ptr ()), argPtr (castPtr raw_secondaryTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Returns the elementwise minimum of the input tensors, while propagating @NaN@ values.
--
-- This operation creates a minimum with @NaN@ propagation operation and returns the result tensor. This means that if any of the elementwise operands is @NaN@, the result is @NaN@. It supports broadcasting as well.  ```md  resultTensor = isNaN(primaryTensor) || isNan(secondaryTensor) ? NaN : min(primaryTensor, secondaryTensor)  ```
--
-- - Parameters:   - primaryTensor: The LHS tensor of the binary Op.   - secondaryTensor: The RHS tensor of the binary Op.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- minimumWithNaNPropagationWithPrimaryTensor:secondaryTensor:name:@
minimumWithNaNPropagationWithPrimaryTensor_secondaryTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor primaryTensor, IsMPSGraphTensor secondaryTensor, IsNSString name) => mpsGraph -> primaryTensor -> secondaryTensor -> name -> IO (Id MPSGraphTensor)
minimumWithNaNPropagationWithPrimaryTensor_secondaryTensor_name mpsGraph  primaryTensor secondaryTensor name =
  withObjCPtr primaryTensor $ \raw_primaryTensor ->
    withObjCPtr secondaryTensor $ \raw_secondaryTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "minimumWithNaNPropagationWithPrimaryTensor:secondaryTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_primaryTensor :: Ptr ()), argPtr (castPtr raw_secondaryTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Returns the elementwise maximum of the input tensors, while propagating @NaN@ values.
--
-- This operation creates a maximum with @NaN@ propagation operation and returns the result tensor. This means that if any of the elementwise operands is @NaN@, the result is @NaN@. It supports broadcasting as well.  ```md  resultTensor = isNaN(primaryTensor) || isNan(secondaryTensor) ? NaN : max(primaryTensor, secondaryTensor)  ```
--
-- - Parameters:   - primaryTensor: The LHS tensor of the binary Op.   - secondaryTensor: The RHS tensor of the binary Op.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- maximumWithNaNPropagationWithPrimaryTensor:secondaryTensor:name:@
maximumWithNaNPropagationWithPrimaryTensor_secondaryTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor primaryTensor, IsMPSGraphTensor secondaryTensor, IsNSString name) => mpsGraph -> primaryTensor -> secondaryTensor -> name -> IO (Id MPSGraphTensor)
maximumWithNaNPropagationWithPrimaryTensor_secondaryTensor_name mpsGraph  primaryTensor secondaryTensor name =
  withObjCPtr primaryTensor $ \raw_primaryTensor ->
    withObjCPtr secondaryTensor $ \raw_secondaryTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "maximumWithNaNPropagationWithPrimaryTensor:secondaryTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_primaryTensor :: Ptr ()), argPtr (castPtr raw_secondaryTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Returns the elementwise equality check of the input tensors.
--
-- This operation creates a equal operation and returns the result tensor. It supports broadcasting as well.  ```md resultTensor = primaryTensor == secondaryTensor ```
--
-- - Parameters:   - primaryTensor: The LHS tensor of the binary Op.   - secondaryTensor: The RHS tensor of the binary Op.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- equalWithPrimaryTensor:secondaryTensor:name:@
equalWithPrimaryTensor_secondaryTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor primaryTensor, IsMPSGraphTensor secondaryTensor, IsNSString name) => mpsGraph -> primaryTensor -> secondaryTensor -> name -> IO (Id MPSGraphTensor)
equalWithPrimaryTensor_secondaryTensor_name mpsGraph  primaryTensor secondaryTensor name =
  withObjCPtr primaryTensor $ \raw_primaryTensor ->
    withObjCPtr secondaryTensor $ \raw_secondaryTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "equalWithPrimaryTensor:secondaryTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_primaryTensor :: Ptr ()), argPtr (castPtr raw_secondaryTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Returns the elementwise inequality check of the input tensors.
--
-- This operation creates a not equal operation and returns the result tensor. It supports broadcasting as well.  ```md resultTensor = primaryTensor != secondaryTensor ```
--
-- - Parameters:   - primaryTensor: The LHS tensor of the binary Op.   - secondaryTensor: The RHS tensor of the binary Op.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- notEqualWithPrimaryTensor:secondaryTensor:name:@
notEqualWithPrimaryTensor_secondaryTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor primaryTensor, IsMPSGraphTensor secondaryTensor, IsNSString name) => mpsGraph -> primaryTensor -> secondaryTensor -> name -> IO (Id MPSGraphTensor)
notEqualWithPrimaryTensor_secondaryTensor_name mpsGraph  primaryTensor secondaryTensor name =
  withObjCPtr primaryTensor $ \raw_primaryTensor ->
    withObjCPtr secondaryTensor $ \raw_secondaryTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "notEqualWithPrimaryTensor:secondaryTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_primaryTensor :: Ptr ()), argPtr (castPtr raw_secondaryTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Checks in an elementwise manner if the first input tensor is less than the second.
--
-- This operation creates a @lessThan@ operation and returns the result tensor. It supports broadcasting as well.  ```md resultTensor = primaryTensor < secondaryTensor ```
--
-- - Parameters:   - primaryTensor: The LHS tensor of the binary Op.   - secondaryTensor: The RHS tensor of the binary Op.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- lessThanWithPrimaryTensor:secondaryTensor:name:@
lessThanWithPrimaryTensor_secondaryTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor primaryTensor, IsMPSGraphTensor secondaryTensor, IsNSString name) => mpsGraph -> primaryTensor -> secondaryTensor -> name -> IO (Id MPSGraphTensor)
lessThanWithPrimaryTensor_secondaryTensor_name mpsGraph  primaryTensor secondaryTensor name =
  withObjCPtr primaryTensor $ \raw_primaryTensor ->
    withObjCPtr secondaryTensor $ \raw_secondaryTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "lessThanWithPrimaryTensor:secondaryTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_primaryTensor :: Ptr ()), argPtr (castPtr raw_secondaryTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Checks in an elementwise manner if the first input tensor is less than or equal to the second.
--
-- This operation creates a @lessThanOrEqualTo@ operation and returns the result tensor. It supports broadcasting as well.  ```md resultTensor = primaryTensor <= secondaryTensor ```
--
-- - Parameters:   - primaryTensor: The LHS tensor of the binary Op.   - secondaryTensor: The RHS tensor of the binary Op.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- lessThanOrEqualToWithPrimaryTensor:secondaryTensor:name:@
lessThanOrEqualToWithPrimaryTensor_secondaryTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor primaryTensor, IsMPSGraphTensor secondaryTensor, IsNSString name) => mpsGraph -> primaryTensor -> secondaryTensor -> name -> IO (Id MPSGraphTensor)
lessThanOrEqualToWithPrimaryTensor_secondaryTensor_name mpsGraph  primaryTensor secondaryTensor name =
  withObjCPtr primaryTensor $ \raw_primaryTensor ->
    withObjCPtr secondaryTensor $ \raw_secondaryTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "lessThanOrEqualToWithPrimaryTensor:secondaryTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_primaryTensor :: Ptr ()), argPtr (castPtr raw_secondaryTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Checks in an elementwise manner if the first input tensor is greater than the second.
--
-- This operation creates a @greaterThan@ operation and returns the result tensor. It supports broadcasting as well.  ```md resultTensor = primaryTensor > secondaryTensor ```
--
-- - Parameters:   - primaryTensor: The LHS tensor of the binary Op.   - secondaryTensor: The RHS tensor of the binary Op.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- greaterThanWithPrimaryTensor:secondaryTensor:name:@
greaterThanWithPrimaryTensor_secondaryTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor primaryTensor, IsMPSGraphTensor secondaryTensor, IsNSString name) => mpsGraph -> primaryTensor -> secondaryTensor -> name -> IO (Id MPSGraphTensor)
greaterThanWithPrimaryTensor_secondaryTensor_name mpsGraph  primaryTensor secondaryTensor name =
  withObjCPtr primaryTensor $ \raw_primaryTensor ->
    withObjCPtr secondaryTensor $ \raw_secondaryTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "greaterThanWithPrimaryTensor:secondaryTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_primaryTensor :: Ptr ()), argPtr (castPtr raw_secondaryTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Checks in an elementwise manner if the first input tensor is greater than or equal to the second.
--
-- This operation creates a @greaterThanOrEqual@ operation and returns the result tensor. It supports broadcasting as well.  ```md resultTensor = primaryTensor < secondaryTensor ```
--
-- - Parameters:   - primaryTensor: The LHS tensor of the binary Op.   - secondaryTensor: The RHS tensor of the binary Op.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- greaterThanOrEqualToWithPrimaryTensor:secondaryTensor:name:@
greaterThanOrEqualToWithPrimaryTensor_secondaryTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor primaryTensor, IsMPSGraphTensor secondaryTensor, IsNSString name) => mpsGraph -> primaryTensor -> secondaryTensor -> name -> IO (Id MPSGraphTensor)
greaterThanOrEqualToWithPrimaryTensor_secondaryTensor_name mpsGraph  primaryTensor secondaryTensor name =
  withObjCPtr primaryTensor $ \raw_primaryTensor ->
    withObjCPtr secondaryTensor $ \raw_secondaryTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "greaterThanOrEqualToWithPrimaryTensor:secondaryTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_primaryTensor :: Ptr ()), argPtr (castPtr raw_secondaryTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Returns the elementwise logical AND of the input tensors.
--
-- This operation creates a logical AND operation and returns the result tensor. It supports broadcasting as well.  ```md resultTensor = primaryTensor && secondaryTensor ```
--
-- - Parameters:   - primaryTensor: The LHS tensor of the binary Op.   - secondaryTensor: The RHS tensor of the binary Op.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- logicalANDWithPrimaryTensor:secondaryTensor:name:@
logicalANDWithPrimaryTensor_secondaryTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor primaryTensor, IsMPSGraphTensor secondaryTensor, IsNSString name) => mpsGraph -> primaryTensor -> secondaryTensor -> name -> IO (Id MPSGraphTensor)
logicalANDWithPrimaryTensor_secondaryTensor_name mpsGraph  primaryTensor secondaryTensor name =
  withObjCPtr primaryTensor $ \raw_primaryTensor ->
    withObjCPtr secondaryTensor $ \raw_secondaryTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "logicalANDWithPrimaryTensor:secondaryTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_primaryTensor :: Ptr ()), argPtr (castPtr raw_secondaryTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Returns the elementwise logical OR of the input tensors.
--
-- This operation creates a logical OR operation and returns the result tensor. It supports broadcasting as well.  ```md resultTensor = primaryTensor || secondaryTensor ```
--
-- - Parameters:   - primaryTensor: The LHS tensor of the binary Op.   - secondaryTensor: The RHS tensor of the binary Op.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- logicalORWithPrimaryTensor:secondaryTensor:name:@
logicalORWithPrimaryTensor_secondaryTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor primaryTensor, IsMPSGraphTensor secondaryTensor, IsNSString name) => mpsGraph -> primaryTensor -> secondaryTensor -> name -> IO (Id MPSGraphTensor)
logicalORWithPrimaryTensor_secondaryTensor_name mpsGraph  primaryTensor secondaryTensor name =
  withObjCPtr primaryTensor $ \raw_primaryTensor ->
    withObjCPtr secondaryTensor $ \raw_secondaryTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "logicalORWithPrimaryTensor:secondaryTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_primaryTensor :: Ptr ()), argPtr (castPtr raw_secondaryTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Returns the elementwise logical NAND of the input tensors.
--
-- This operation creates a logical NAND operation and returns the result tensor. It supports broadcasting as well.  ```md resultTensor = !(primaryTensor && secondaryTensor) ```
--
-- - Parameters:   - primaryTensor: The LHS tensor of the binary Op.   - secondaryTensor: The RHS tensor of the binary Op.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- logicalNANDWithPrimaryTensor:secondaryTensor:name:@
logicalNANDWithPrimaryTensor_secondaryTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor primaryTensor, IsMPSGraphTensor secondaryTensor, IsNSString name) => mpsGraph -> primaryTensor -> secondaryTensor -> name -> IO (Id MPSGraphTensor)
logicalNANDWithPrimaryTensor_secondaryTensor_name mpsGraph  primaryTensor secondaryTensor name =
  withObjCPtr primaryTensor $ \raw_primaryTensor ->
    withObjCPtr secondaryTensor $ \raw_secondaryTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "logicalNANDWithPrimaryTensor:secondaryTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_primaryTensor :: Ptr ()), argPtr (castPtr raw_secondaryTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Returns the elementwise logical NOR of the input tensors.
--
-- This operation creates a logical NOR operation and returns the result tensor. It supports broadcasting as well.  ```md resultTensor = !(primaryTensor || secondaryTensor) ```
--
-- - Parameters:   - primaryTensor: The LHS tensor of the binary Op.   - secondaryTensor: The RHS tensor of the binary Op.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- logicalNORWithPrimaryTensor:secondaryTensor:name:@
logicalNORWithPrimaryTensor_secondaryTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor primaryTensor, IsMPSGraphTensor secondaryTensor, IsNSString name) => mpsGraph -> primaryTensor -> secondaryTensor -> name -> IO (Id MPSGraphTensor)
logicalNORWithPrimaryTensor_secondaryTensor_name mpsGraph  primaryTensor secondaryTensor name =
  withObjCPtr primaryTensor $ \raw_primaryTensor ->
    withObjCPtr secondaryTensor $ \raw_secondaryTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "logicalNORWithPrimaryTensor:secondaryTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_primaryTensor :: Ptr ()), argPtr (castPtr raw_secondaryTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Returns the elementwise logical XOR of the input tensors.
--
-- This operation creates a logical XOR operation and returns the result tensor. It supports broadcasting as well.  ```md resultTensor = XOR(primaryTensor, secondaryTensor) ```
--
-- - Parameters:   - primaryTensor: The LHS tensor of the binary Op.   - secondaryTensor: The RHS tensor of the binary Op.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- logicalXORWithPrimaryTensor:secondaryTensor:name:@
logicalXORWithPrimaryTensor_secondaryTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor primaryTensor, IsMPSGraphTensor secondaryTensor, IsNSString name) => mpsGraph -> primaryTensor -> secondaryTensor -> name -> IO (Id MPSGraphTensor)
logicalXORWithPrimaryTensor_secondaryTensor_name mpsGraph  primaryTensor secondaryTensor name =
  withObjCPtr primaryTensor $ \raw_primaryTensor ->
    withObjCPtr secondaryTensor $ \raw_secondaryTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "logicalXORWithPrimaryTensor:secondaryTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_primaryTensor :: Ptr ()), argPtr (castPtr raw_secondaryTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Returns the elementwise logical XNOR of the input tensors.
--
-- This operation creates a logical XNOR operation and returns the result tensor. It supports broadcasting as well.  ```md resultTensor = XNOR(primaryTensor, secondaryTensor) ```
--
-- - Parameters:   - primaryTensor: The LHS tensor of the binary Op.   - secondaryTensor: The RHS tensor of the binary Op.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- logicalXNORWithPrimaryTensor:secondaryTensor:name:@
logicalXNORWithPrimaryTensor_secondaryTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor primaryTensor, IsMPSGraphTensor secondaryTensor, IsNSString name) => mpsGraph -> primaryTensor -> secondaryTensor -> name -> IO (Id MPSGraphTensor)
logicalXNORWithPrimaryTensor_secondaryTensor_name mpsGraph  primaryTensor secondaryTensor name =
  withObjCPtr primaryTensor $ \raw_primaryTensor ->
    withObjCPtr secondaryTensor $ \raw_secondaryTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "logicalXNORWithPrimaryTensor:secondaryTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_primaryTensor :: Ptr ()), argPtr (castPtr raw_secondaryTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Returns the elementwise two-argument arctangent of the input tensors.
--
-- This operation creates a @atan2@ operation and returns the result tensor. It supports broadcasting as well.  Graph computes arc tangent of primaryTensor over secondaryTensor. ```md resultTensor = atan2(primaryTensor, secondaryTensor) ```
--
-- - Parameters:   - primaryTensor: The LHS tensor of the binary Op.   - secondaryTensor: The RHS tensor of the binary Op.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- atan2WithPrimaryTensor:secondaryTensor:name:@
atan2WithPrimaryTensor_secondaryTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor primaryTensor, IsMPSGraphTensor secondaryTensor, IsNSString name) => mpsGraph -> primaryTensor -> secondaryTensor -> name -> IO (Id MPSGraphTensor)
atan2WithPrimaryTensor_secondaryTensor_name mpsGraph  primaryTensor secondaryTensor name =
  withObjCPtr primaryTensor $ \raw_primaryTensor ->
    withObjCPtr secondaryTensor $ \raw_secondaryTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "atan2WithPrimaryTensor:secondaryTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_primaryTensor :: Ptr ()), argPtr (castPtr raw_secondaryTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Returns the elementwise bitwise AND of binary representations of two integer tensors.
--
-- - Parameters:   - primaryTensor: The primary input tensor, must be of integer type.   - secondaryTensor: The secondary input tensor, must be of integer type.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- bitwiseANDWithPrimaryTensor:secondaryTensor:name:@
bitwiseANDWithPrimaryTensor_secondaryTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor primaryTensor, IsMPSGraphTensor secondaryTensor, IsNSString name) => mpsGraph -> primaryTensor -> secondaryTensor -> name -> IO (Id MPSGraphTensor)
bitwiseANDWithPrimaryTensor_secondaryTensor_name mpsGraph  primaryTensor secondaryTensor name =
  withObjCPtr primaryTensor $ \raw_primaryTensor ->
    withObjCPtr secondaryTensor $ \raw_secondaryTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "bitwiseANDWithPrimaryTensor:secondaryTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_primaryTensor :: Ptr ()), argPtr (castPtr raw_secondaryTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Returns the elementwise bitwise OR of binary representations of two integer tensors.
--
-- - Parameters:   - primaryTensor: The primary input tensor, must be of integer type.   - secondaryTensor: The secondary input tensor, must be of integer type.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- bitwiseORWithPrimaryTensor:secondaryTensor:name:@
bitwiseORWithPrimaryTensor_secondaryTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor primaryTensor, IsMPSGraphTensor secondaryTensor, IsNSString name) => mpsGraph -> primaryTensor -> secondaryTensor -> name -> IO (Id MPSGraphTensor)
bitwiseORWithPrimaryTensor_secondaryTensor_name mpsGraph  primaryTensor secondaryTensor name =
  withObjCPtr primaryTensor $ \raw_primaryTensor ->
    withObjCPtr secondaryTensor $ \raw_secondaryTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "bitwiseORWithPrimaryTensor:secondaryTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_primaryTensor :: Ptr ()), argPtr (castPtr raw_secondaryTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Returns the elementwise bitwise XOR of binary representations of two integer tensors.
--
-- - Parameters:   - primaryTensor: The primary input tensor, must be of integer type.   - secondaryTensor: The secondary input tensor, must be of integer type.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- bitwiseXORWithPrimaryTensor:secondaryTensor:name:@
bitwiseXORWithPrimaryTensor_secondaryTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor primaryTensor, IsMPSGraphTensor secondaryTensor, IsNSString name) => mpsGraph -> primaryTensor -> secondaryTensor -> name -> IO (Id MPSGraphTensor)
bitwiseXORWithPrimaryTensor_secondaryTensor_name mpsGraph  primaryTensor secondaryTensor name =
  withObjCPtr primaryTensor $ \raw_primaryTensor ->
    withObjCPtr secondaryTensor $ \raw_secondaryTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "bitwiseXORWithPrimaryTensor:secondaryTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_primaryTensor :: Ptr ()), argPtr (castPtr raw_secondaryTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Returns the elementwise left-shifted binary representations of the primary integer by the secondary tensor amount.
--
-- - Parameters:   - primaryTensor: The primary input tensor, must be of integer type.   - secondaryTensor: The secondary input tensor, must be of integer type.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- bitwiseLeftShiftWithPrimaryTensor:secondaryTensor:name:@
bitwiseLeftShiftWithPrimaryTensor_secondaryTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor primaryTensor, IsMPSGraphTensor secondaryTensor, IsNSString name) => mpsGraph -> primaryTensor -> secondaryTensor -> name -> IO (Id MPSGraphTensor)
bitwiseLeftShiftWithPrimaryTensor_secondaryTensor_name mpsGraph  primaryTensor secondaryTensor name =
  withObjCPtr primaryTensor $ \raw_primaryTensor ->
    withObjCPtr secondaryTensor $ \raw_secondaryTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "bitwiseLeftShiftWithPrimaryTensor:secondaryTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_primaryTensor :: Ptr ()), argPtr (castPtr raw_secondaryTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Returns the elementwise right-shifted binary representations of the primary integer by the secondary tensor amount.
--
-- - Parameters:   - primaryTensor: The primary input tensor, must be of integer type.   - secondaryTensor: The secondary input tensor, must be of integer type.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- bitwiseRightShiftWithPrimaryTensor:secondaryTensor:name:@
bitwiseRightShiftWithPrimaryTensor_secondaryTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor primaryTensor, IsMPSGraphTensor secondaryTensor, IsNSString name) => mpsGraph -> primaryTensor -> secondaryTensor -> name -> IO (Id MPSGraphTensor)
bitwiseRightShiftWithPrimaryTensor_secondaryTensor_name mpsGraph  primaryTensor secondaryTensor name =
  withObjCPtr primaryTensor $ \raw_primaryTensor ->
    withObjCPtr secondaryTensor $ \raw_secondaryTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "bitwiseRightShiftWithPrimaryTensor:secondaryTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_primaryTensor :: Ptr ()), argPtr (castPtr raw_secondaryTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Selects values from either the true or false predicate tensor, depending on the values in the first input.
--
-- This operation creates a select operation and returns the result tensor. It supports broadcasting as well.  ```md resultTensor = select(predicateTensor, truePredicateTensor, falseSelectTensor) ```
--
-- - Parameters:   - predicateTensor: The predicate tensor.   - truePredicateTensor: The tensor to select values from if predicate is true.   - falseSelectTensor: The tensor to select values from if predicate is false.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- selectWithPredicateTensor:truePredicateTensor:falsePredicateTensor:name:@
selectWithPredicateTensor_truePredicateTensor_falsePredicateTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor predicateTensor, IsMPSGraphTensor truePredicateTensor, IsMPSGraphTensor falseSelectTensor, IsNSString name) => mpsGraph -> predicateTensor -> truePredicateTensor -> falseSelectTensor -> name -> IO (Id MPSGraphTensor)
selectWithPredicateTensor_truePredicateTensor_falsePredicateTensor_name mpsGraph  predicateTensor truePredicateTensor falseSelectTensor name =
  withObjCPtr predicateTensor $ \raw_predicateTensor ->
    withObjCPtr truePredicateTensor $ \raw_truePredicateTensor ->
      withObjCPtr falseSelectTensor $ \raw_falseSelectTensor ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "selectWithPredicateTensor:truePredicateTensor:falsePredicateTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_predicateTensor :: Ptr ()), argPtr (castPtr raw_truePredicateTensor :: Ptr ()), argPtr (castPtr raw_falseSelectTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Clamps the values in the first tensor between the corresponding values in the minimum and maximum value tensor.
--
-- This operation creates a clamp operation and returns the result tensor. It supports broadcasting as well.  ```md resultTensor = clamp(tensor, minValueTensor, maxValueTensor) ```
--
-- - Parameters:   - tensor: The tensor to be clamped.   - minValueTensor: The tensor with min values to clamp to.   - minValueTensor: The tensor with max values to clamp to.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- clampWithTensor:minValueTensor:maxValueTensor:name:@
clampWithTensor_minValueTensor_maxValueTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsMPSGraphTensor minValueTensor, IsMPSGraphTensor maxValueTensor, IsNSString name) => mpsGraph -> tensor -> minValueTensor -> maxValueTensor -> name -> IO (Id MPSGraphTensor)
clampWithTensor_minValueTensor_maxValueTensor_name mpsGraph  tensor minValueTensor maxValueTensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr minValueTensor $ \raw_minValueTensor ->
      withObjCPtr maxValueTensor $ \raw_maxValueTensor ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "clampWithTensor:minValueTensor:maxValueTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_minValueTensor :: Ptr ()), argPtr (castPtr raw_maxValueTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Divides the first input tensor by the second, with the result being 0 if the denominator is 0.
--
-- ```md resultTensor = select(secondaryTensor, primaryTensor / secondaryTensor, 0) ```
--
-- - Parameters:   - primaryTensor: The LHS tensor of the binary Op.   - secondaryTensor: The RHS tensor of the binary Op.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- divisionNoNaNWithPrimaryTensor:secondaryTensor:name:@
divisionNoNaNWithPrimaryTensor_secondaryTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor primaryTensor, IsMPSGraphTensor secondaryTensor, IsNSString name) => mpsGraph -> primaryTensor -> secondaryTensor -> name -> IO (Id MPSGraphTensor)
divisionNoNaNWithPrimaryTensor_secondaryTensor_name mpsGraph  primaryTensor secondaryTensor name =
  withObjCPtr primaryTensor $ \raw_primaryTensor ->
    withObjCPtr secondaryTensor $ \raw_secondaryTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "divisionNoNaNWithPrimaryTensor:secondaryTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_primaryTensor :: Ptr ()), argPtr (castPtr raw_secondaryTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Returns the remainder of floor divison between the primary and secondary tensor.
--
-- Creates a floorModulo operation and returns the result tensor, it supports broadcasting as well, returns 0 if divisor is 0. ```md resultTensor = primaryTensor - (floor(primaryTensor / secondaryTensor) * secondaryTensor) ```
--
-- - Parameters:   - primaryTensor: The LHS tensor of the binary Op.   - secondaryTensor: The RHS tensor of the binary Op.   - name: An optional string which serves as an identifier for the operation. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- floorModuloWithPrimaryTensor:secondaryTensor:name:@
floorModuloWithPrimaryTensor_secondaryTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor primaryTensor, IsMPSGraphTensor secondaryTensor, IsNSString name) => mpsGraph -> primaryTensor -> secondaryTensor -> name -> IO (Id MPSGraphTensor)
floorModuloWithPrimaryTensor_secondaryTensor_name mpsGraph  primaryTensor secondaryTensor name =
  withObjCPtr primaryTensor $ \raw_primaryTensor ->
    withObjCPtr secondaryTensor $ \raw_secondaryTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "floorModuloWithPrimaryTensor:secondaryTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_primaryTensor :: Ptr ()), argPtr (castPtr raw_secondaryTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Returns the real part of a tensor.
--
-- - Parameters:   - tensor: The input tensor.   - name: An optional string which serves as an identifier for the operation.. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- realPartOfTensor:name:@
realPartOfTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> name -> IO (Id MPSGraphTensor)
realPartOfTensor_name mpsGraph  tensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "realPartOfTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Returns the imaginary part of a tensor.
--
-- - Parameters:   - tensor: The input tensor.   - name: An optional string which serves as an identifier for the operation.. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- imaginaryPartOfTensor:name:@
imaginaryPartOfTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> name -> IO (Id MPSGraphTensor)
imaginaryPartOfTensor_name mpsGraph  tensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "imaginaryPartOfTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Returns a complex tensor from the two input tensors.
--
-- - Parameters:   - realTensor: The real part of the complex tensor.   - imaginaryTensor: The imaginary part of the complex tensor.   - name: An optional string which serves as an identifier for the operation.. - Returns: A valid @MPSGraphTensor@ object containing the elementwise result of the applied operation.
--
-- ObjC selector: @- complexTensorWithRealTensor:imaginaryTensor:name:@
complexTensorWithRealTensor_imaginaryTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor realTensor, IsMPSGraphTensor imaginaryTensor, IsNSString name) => mpsGraph -> realTensor -> imaginaryTensor -> name -> IO (Id MPSGraphTensor)
complexTensorWithRealTensor_imaginaryTensor_name mpsGraph  realTensor imaginaryTensor name =
  withObjCPtr realTensor $ \raw_realTensor ->
    withObjCPtr imaginaryTensor $ \raw_imaginaryTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "complexTensorWithRealTensor:imaginaryTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_realTensor :: Ptr ()), argPtr (castPtr raw_imaginaryTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Computes the ReLU (rectified linear activation unit) function with the input tensor.
--
-- The operation is:  f(x) = max(x, 0).
--
-- - Parameters:   - tensor: The input tensor.   - name: The name for the operation. - Returns: A valid ``MPSGraphTensor`` object.
--
-- ObjC selector: @- reLUWithTensor:name:@
reLUWithTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> name -> IO (Id MPSGraphTensor)
reLUWithTensor_name mpsGraph  tensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "reLUWithTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Computes the gradient of the ReLU  (rectified linear activation unit) function using the incoming gradient.
--
-- - Parameters:   - gradient: The incoming gradient tensor.   - source: The input tensor from forward pass.   - name: The name for the operation. - Returns: A valid ``MPSGraphTensor`` object.
--
-- ObjC selector: @- reLUGradientWithIncomingGradient:sourceTensor:name:@
reLUGradientWithIncomingGradient_sourceTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor gradient, IsMPSGraphTensor source, IsNSString name) => mpsGraph -> gradient -> source -> name -> IO (Id MPSGraphTensor)
reLUGradientWithIncomingGradient_sourceTensor_name mpsGraph  gradient source name =
  withObjCPtr gradient $ \raw_gradient ->
    withObjCPtr source $ \raw_source ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "reLUGradientWithIncomingGradient:sourceTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_gradient :: Ptr ()), argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Computes the sigmoid operation on an input tensor.
--
-- - Parameters:   - tensor: The input tensor.   - name: The name for the operation. - Returns: A valid ``MPSGraphTensor`` object.
--
-- ObjC selector: @- sigmoidWithTensor:name:@
sigmoidWithTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> name -> IO (Id MPSGraphTensor)
sigmoidWithTensor_name mpsGraph  tensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "sigmoidWithTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Computes the gradient of the sigmoid function using the incoming gradient tensor.
--
-- - Parameters:   - gradient: The incoming gradient tensor.   - source: The input tensor.   - name: The name for the operation. - Returns: A valid ``MPSGraphTensor`` object
--
-- ObjC selector: @- sigmoidGradientWithIncomingGradient:sourceTensor:name:@
sigmoidGradientWithIncomingGradient_sourceTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor gradient, IsMPSGraphTensor source, IsNSString name) => mpsGraph -> gradient -> source -> name -> IO (Id MPSGraphTensor)
sigmoidGradientWithIncomingGradient_sourceTensor_name mpsGraph  gradient source name =
  withObjCPtr gradient $ \raw_gradient ->
    withObjCPtr source $ \raw_source ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "sigmoidGradientWithIncomingGradient:sourceTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_gradient :: Ptr ()), argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Computes the softmax function on the input tensor along the specified axis.
--
-- - Parameters:   - tensor: The input tensor.   - axis: The axis along which softmax is computed.   - name: The name for the operation. - Returns: A valid ``MPSGraphTensor`` object
--
-- ObjC selector: @- softMaxWithTensor:axis:name:@
softMaxWithTensor_axis_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> CLong -> name -> IO (Id MPSGraphTensor)
softMaxWithTensor_axis_name mpsGraph  tensor axis name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "softMaxWithTensor:axis:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argCLong axis, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Computes the gradient of the softmax function along the specified axis using the incoming gradient tensor.
--
-- - Parameters:   - gradient: The incoming gradient tensor.   - source: The input tensor.   - axis: The axis along which softmax is computed.   - name: The name for the operation. - Returns: A valid ``MPSGraphTensor`` object
--
-- ObjC selector: @- softMaxGradientWithIncomingGradient:sourceTensor:axis:name:@
softMaxGradientWithIncomingGradient_sourceTensor_axis_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor gradient, IsMPSGraphTensor source, IsNSString name) => mpsGraph -> gradient -> source -> CLong -> name -> IO (Id MPSGraphTensor)
softMaxGradientWithIncomingGradient_sourceTensor_axis_name mpsGraph  gradient source axis name =
  withObjCPtr gradient $ \raw_gradient ->
    withObjCPtr source $ \raw_source ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "softMaxGradientWithIncomingGradient:sourceTensor:axis:name:") (retPtr retVoid) [argPtr (castPtr raw_gradient :: Ptr ()), argPtr (castPtr raw_source :: Ptr ()), argCLong axis, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Computes the leaky rectified linear unit (ReLU) activation function on the input tensor.
--
-- The operation is: f(x) = max(x, alpha).
--
-- - Parameters:   - tensor: An input tensor.   - alpha: The scalar value alpha used by all elements in the input tensor.   - name: The name for the operation. - Returns: A valid ``MPSGraphTensor`` object
--
-- ObjC selector: @- leakyReLUWithTensor:alpha:name:@
leakyReLUWithTensor_alpha_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsNSString name) => mpsGraph -> tensor -> CDouble -> name -> IO (Id MPSGraphTensor)
leakyReLUWithTensor_alpha_name mpsGraph  tensor alpha name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr name $ \raw_name ->
        sendMsg mpsGraph (mkSelector "leakyReLUWithTensor:alpha:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argCDouble alpha, argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Computes the leaky rectified linear unit (ReLU) activation function on the input tensor.
--
-- The operation is: f(x) = max(x, alpha). This operation supports broadcasting with the alpha tensor.
--
-- - Parameters:   - tensor: The input tensor.   - alpha: The alpha tensor.   - name: The name for the operation. - Returns: A valid ``MPSGraphTensor`` object
--
-- ObjC selector: @- leakyReLUWithTensor:alphaTensor:name:@
leakyReLUWithTensor_alphaTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor tensor, IsMPSGraphTensor alphaTensor, IsNSString name) => mpsGraph -> tensor -> alphaTensor -> name -> IO (Id MPSGraphTensor)
leakyReLUWithTensor_alphaTensor_name mpsGraph  tensor alphaTensor name =
  withObjCPtr tensor $ \raw_tensor ->
    withObjCPtr alphaTensor $ \raw_alphaTensor ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "leakyReLUWithTensor:alphaTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_tensor :: Ptr ()), argPtr (castPtr raw_alphaTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Computes the gradient of the leaky rectified linear unit (ReLU) activation.
--
-- This operation supports broadcasting with the alpha tensor.
--
-- - Parameters:   - gradient: The incoming gradient tensor.   - source: The input tensor in forward pass.   - alpha: The alpha tensor   - name: The name for the operation. - Returns: A valid ``MPSGraphTensor`` object
--
-- ObjC selector: @- leakyReLUGradientWithIncomingGradient:sourceTensor:alphaTensor:name:@
leakyReLUGradientWithIncomingGradient_sourceTensor_alphaTensor_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor gradient, IsMPSGraphTensor source, IsMPSGraphTensor alphaTensor, IsNSString name) => mpsGraph -> gradient -> source -> alphaTensor -> name -> IO (Id MPSGraphTensor)
leakyReLUGradientWithIncomingGradient_sourceTensor_alphaTensor_name mpsGraph  gradient source alphaTensor name =
  withObjCPtr gradient $ \raw_gradient ->
    withObjCPtr source $ \raw_source ->
      withObjCPtr alphaTensor $ \raw_alphaTensor ->
        withObjCPtr name $ \raw_name ->
            sendMsg mpsGraph (mkSelector "leakyReLUGradientWithIncomingGradient:sourceTensor:alphaTensor:name:") (retPtr retVoid) [argPtr (castPtr raw_gradient :: Ptr ()), argPtr (castPtr raw_source :: Ptr ()), argPtr (castPtr raw_alphaTensor :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Calculates a partial derivative of primaryTensor with respect to the tensors.
--
-- - Parameters:   - primaryTensor: Tensor to be differentiated (numerator).   - tensors: Tensors to do the differentiation with (denominator).   - name: Name for the gradient operation. - Returns: A valid MPSGraphTensor dictionary object containing partial derivative d(primaryTensor)/d(secondaryTensor) for each tensor as key.
--
-- ObjC selector: @- gradientForPrimaryTensor:withTensors:name:@
gradientForPrimaryTensor_withTensors_name :: (IsMPSGraph mpsGraph, IsMPSGraphTensor primaryTensor, IsNSArray tensors, IsNSString name) => mpsGraph -> primaryTensor -> tensors -> name -> IO (Id NSDictionary)
gradientForPrimaryTensor_withTensors_name mpsGraph  primaryTensor tensors name =
  withObjCPtr primaryTensor $ \raw_primaryTensor ->
    withObjCPtr tensors $ \raw_tensors ->
      withObjCPtr name $ \raw_name ->
          sendMsg mpsGraph (mkSelector "gradientForPrimaryTensor:withTensors:name:") (retPtr retVoid) [argPtr (castPtr raw_primaryTensor :: Ptr ()), argPtr (castPtr raw_tensors :: Ptr ()), argPtr (castPtr raw_name :: Ptr ())] >>= retainedObject . castPtr

-- | Options for the graph.
--
-- The default value is @MPSGraphOptionsDefault@.
--
-- ObjC selector: @- options@
options :: IsMPSGraph mpsGraph => mpsGraph -> IO MPSGraphOptions
options mpsGraph  =
    fmap (coerce :: CULong -> MPSGraphOptions) $ sendMsg mpsGraph (mkSelector "options") retCULong []

-- | Options for the graph.
--
-- The default value is @MPSGraphOptionsDefault@.
--
-- ObjC selector: @- setOptions:@
setOptions :: IsMPSGraph mpsGraph => mpsGraph -> MPSGraphOptions -> IO ()
setOptions mpsGraph  value =
    sendMsg mpsGraph (mkSelector "setOptions:") retVoid [argCULong (coerce value)]

-- | Array of all the placeholder tensors.
--
-- ObjC selector: @- placeholderTensors@
placeholderTensors :: IsMPSGraph mpsGraph => mpsGraph -> IO (Id NSArray)
placeholderTensors mpsGraph  =
    sendMsg mpsGraph (mkSelector "placeholderTensors") (retPtr retVoid) [] >>= retainedObject . castPtr

-- ---------------------------------------------------------------------------
-- Selectors
-- ---------------------------------------------------------------------------

-- | @Selector@ for @new@
newSelector :: Selector
newSelector = mkSelector "new"

-- | @Selector@ for @init@
initSelector :: Selector
initSelector = mkSelector "init"

-- | @Selector@ for @compileWithDevice:feeds:targetTensors:targetOperations:compilationDescriptor:@
compileWithDevice_feeds_targetTensors_targetOperations_compilationDescriptorSelector :: Selector
compileWithDevice_feeds_targetTensors_targetOperations_compilationDescriptorSelector = mkSelector "compileWithDevice:feeds:targetTensors:targetOperations:compilationDescriptor:"

-- | @Selector@ for @runWithFeeds:targetTensors:targetOperations:@
runWithFeeds_targetTensors_targetOperationsSelector :: Selector
runWithFeeds_targetTensors_targetOperationsSelector = mkSelector "runWithFeeds:targetTensors:targetOperations:"

-- | @Selector@ for @runWithMTLCommandQueue:feeds:targetTensors:targetOperations:@
runWithMTLCommandQueue_feeds_targetTensors_targetOperationsSelector :: Selector
runWithMTLCommandQueue_feeds_targetTensors_targetOperationsSelector = mkSelector "runWithMTLCommandQueue:feeds:targetTensors:targetOperations:"

-- | @Selector@ for @runWithMTLCommandQueue:feeds:targetOperations:resultsDictionary:@
runWithMTLCommandQueue_feeds_targetOperations_resultsDictionarySelector :: Selector
runWithMTLCommandQueue_feeds_targetOperations_resultsDictionarySelector = mkSelector "runWithMTLCommandQueue:feeds:targetOperations:resultsDictionary:"

-- | @Selector@ for @runAsyncWithFeeds:targetTensors:targetOperations:executionDescriptor:@
runAsyncWithFeeds_targetTensors_targetOperations_executionDescriptorSelector :: Selector
runAsyncWithFeeds_targetTensors_targetOperations_executionDescriptorSelector = mkSelector "runAsyncWithFeeds:targetTensors:targetOperations:executionDescriptor:"

-- | @Selector@ for @runAsyncWithMTLCommandQueue:feeds:targetTensors:targetOperations:executionDescriptor:@
runAsyncWithMTLCommandQueue_feeds_targetTensors_targetOperations_executionDescriptorSelector :: Selector
runAsyncWithMTLCommandQueue_feeds_targetTensors_targetOperations_executionDescriptorSelector = mkSelector "runAsyncWithMTLCommandQueue:feeds:targetTensors:targetOperations:executionDescriptor:"

-- | @Selector@ for @runAsyncWithMTLCommandQueue:feeds:targetOperations:resultsDictionary:executionDescriptor:@
runAsyncWithMTLCommandQueue_feeds_targetOperations_resultsDictionary_executionDescriptorSelector :: Selector
runAsyncWithMTLCommandQueue_feeds_targetOperations_resultsDictionary_executionDescriptorSelector = mkSelector "runAsyncWithMTLCommandQueue:feeds:targetOperations:resultsDictionary:executionDescriptor:"

-- | @Selector@ for @encodeToCommandBuffer:feeds:targetTensors:targetOperations:executionDescriptor:@
encodeToCommandBuffer_feeds_targetTensors_targetOperations_executionDescriptorSelector :: Selector
encodeToCommandBuffer_feeds_targetTensors_targetOperations_executionDescriptorSelector = mkSelector "encodeToCommandBuffer:feeds:targetTensors:targetOperations:executionDescriptor:"

-- | @Selector@ for @encodeToCommandBuffer:feeds:targetOperations:resultsDictionary:executionDescriptor:@
encodeToCommandBuffer_feeds_targetOperations_resultsDictionary_executionDescriptorSelector :: Selector
encodeToCommandBuffer_feeds_targetOperations_resultsDictionary_executionDescriptorSelector = mkSelector "encodeToCommandBuffer:feeds:targetOperations:resultsDictionary:executionDescriptor:"

-- | @Selector@ for @topKWithGradientTensor:source:k:name:@
topKWithGradientTensor_source_k_nameSelector :: Selector
topKWithGradientTensor_source_k_nameSelector = mkSelector "topKWithGradientTensor:source:k:name:"

-- | @Selector@ for @topKWithGradientTensor:source:axis:k:name:@
topKWithGradientTensor_source_axis_k_nameSelector :: Selector
topKWithGradientTensor_source_axis_k_nameSelector = mkSelector "topKWithGradientTensor:source:axis:k:name:"

-- | @Selector@ for @bottomKWithGradientTensor:source:axis:k:name:@
bottomKWithGradientTensor_source_axis_k_nameSelector :: Selector
bottomKWithGradientTensor_source_axis_k_nameSelector = mkSelector "bottomKWithGradientTensor:source:axis:k:name:"

-- | @Selector@ for @topKWithGradientTensor:source:kTensor:name:@
topKWithGradientTensor_source_kTensor_nameSelector :: Selector
topKWithGradientTensor_source_kTensor_nameSelector = mkSelector "topKWithGradientTensor:source:kTensor:name:"

-- | @Selector@ for @topKWithGradientTensor:source:axisTensor:kTensor:name:@
topKWithGradientTensor_source_axisTensor_kTensor_nameSelector :: Selector
topKWithGradientTensor_source_axisTensor_kTensor_nameSelector = mkSelector "topKWithGradientTensor:source:axisTensor:kTensor:name:"

-- | @Selector@ for @bottomKWithGradientTensor:source:axisTensor:kTensor:name:@
bottomKWithGradientTensor_source_axisTensor_kTensor_nameSelector :: Selector
bottomKWithGradientTensor_source_axisTensor_kTensor_nameSelector = mkSelector "bottomKWithGradientTensor:source:axisTensor:kTensor:name:"

-- | @Selector@ for @topKWithSourceTensor:k:name:@
topKWithSourceTensor_k_nameSelector :: Selector
topKWithSourceTensor_k_nameSelector = mkSelector "topKWithSourceTensor:k:name:"

-- | @Selector@ for @topKWithSourceTensor:kTensor:name:@
topKWithSourceTensor_kTensor_nameSelector :: Selector
topKWithSourceTensor_kTensor_nameSelector = mkSelector "topKWithSourceTensor:kTensor:name:"

-- | @Selector@ for @topKWithSourceTensor:axis:k:name:@
topKWithSourceTensor_axis_k_nameSelector :: Selector
topKWithSourceTensor_axis_k_nameSelector = mkSelector "topKWithSourceTensor:axis:k:name:"

-- | @Selector@ for @bottomKWithSourceTensor:axis:k:name:@
bottomKWithSourceTensor_axis_k_nameSelector :: Selector
bottomKWithSourceTensor_axis_k_nameSelector = mkSelector "bottomKWithSourceTensor:axis:k:name:"

-- | @Selector@ for @topKWithSourceTensor:axisTensor:kTensor:name:@
topKWithSourceTensor_axisTensor_kTensor_nameSelector :: Selector
topKWithSourceTensor_axisTensor_kTensor_nameSelector = mkSelector "topKWithSourceTensor:axisTensor:kTensor:name:"

-- | @Selector@ for @bottomKWithSourceTensor:axisTensor:kTensor:name:@
bottomKWithSourceTensor_axisTensor_kTensor_nameSelector :: Selector
bottomKWithSourceTensor_axisTensor_kTensor_nameSelector = mkSelector "bottomKWithSourceTensor:axisTensor:kTensor:name:"

-- | @Selector@ for @reshapeTensor:withShape:name:@
reshapeTensor_withShape_nameSelector :: Selector
reshapeTensor_withShape_nameSelector = mkSelector "reshapeTensor:withShape:name:"

-- | @Selector@ for @reshapeTensor:withShapeTensor:name:@
reshapeTensor_withShapeTensor_nameSelector :: Selector
reshapeTensor_withShapeTensor_nameSelector = mkSelector "reshapeTensor:withShapeTensor:name:"

-- | @Selector@ for @transposeTensor:dimension:withDimension:name:@
transposeTensor_dimension_withDimension_nameSelector :: Selector
transposeTensor_dimension_withDimension_nameSelector = mkSelector "transposeTensor:dimension:withDimension:name:"

-- | @Selector@ for @transposeTensor:permutation:name:@
transposeTensor_permutation_nameSelector :: Selector
transposeTensor_permutation_nameSelector = mkSelector "transposeTensor:permutation:name:"

-- | @Selector@ for @sliceTensor:dimension:start:length:name:@
sliceTensor_dimension_start_length_nameSelector :: Selector
sliceTensor_dimension_start_length_nameSelector = mkSelector "sliceTensor:dimension:start:length:name:"

-- | @Selector@ for @sliceTensor:starts:ends:strides:name:@
sliceTensor_starts_ends_strides_nameSelector :: Selector
sliceTensor_starts_ends_strides_nameSelector = mkSelector "sliceTensor:starts:ends:strides:name:"

-- | @Selector@ for @sliceTensor:starts:ends:strides:startMask:endMask:squeezeMask:name:@
sliceTensor_starts_ends_strides_startMask_endMask_squeezeMask_nameSelector :: Selector
sliceTensor_starts_ends_strides_startMask_endMask_squeezeMask_nameSelector = mkSelector "sliceTensor:starts:ends:strides:startMask:endMask:squeezeMask:name:"

-- | @Selector@ for @sliceTensor:startTensor:endTensor:strideTensor:startMask:endMask:squeezeMask:name:@
sliceTensor_startTensor_endTensor_strideTensor_startMask_endMask_squeezeMask_nameSelector :: Selector
sliceTensor_startTensor_endTensor_strideTensor_startMask_endMask_squeezeMask_nameSelector = mkSelector "sliceTensor:startTensor:endTensor:strideTensor:startMask:endMask:squeezeMask:name:"

-- | @Selector@ for @sliceTensor:startTensor:sizeTensor:squeezeMask:name:@
sliceTensor_startTensor_sizeTensor_squeezeMask_nameSelector :: Selector
sliceTensor_startTensor_sizeTensor_squeezeMask_nameSelector = mkSelector "sliceTensor:startTensor:sizeTensor:squeezeMask:name:"

-- | @Selector@ for @sliceGradientTensor:fwdInShapeTensor:starts:ends:strides:name:@
sliceGradientTensor_fwdInShapeTensor_starts_ends_strides_nameSelector :: Selector
sliceGradientTensor_fwdInShapeTensor_starts_ends_strides_nameSelector = mkSelector "sliceGradientTensor:fwdInShapeTensor:starts:ends:strides:name:"

-- | @Selector@ for @sliceGradientTensor:fwdInShapeTensor:startTensor:endTensor:strideTensor:startMask:endMask:squeezeMask:name:@
sliceGradientTensor_fwdInShapeTensor_startTensor_endTensor_strideTensor_startMask_endMask_squeezeMask_nameSelector :: Selector
sliceGradientTensor_fwdInShapeTensor_startTensor_endTensor_strideTensor_startMask_endMask_squeezeMask_nameSelector = mkSelector "sliceGradientTensor:fwdInShapeTensor:startTensor:endTensor:strideTensor:startMask:endMask:squeezeMask:name:"

-- | @Selector@ for @sliceGradientTensor:fwdInShapeTensor:startTensor:sizeTensor:squeezeMask:name:@
sliceGradientTensor_fwdInShapeTensor_startTensor_sizeTensor_squeezeMask_nameSelector :: Selector
sliceGradientTensor_fwdInShapeTensor_startTensor_sizeTensor_squeezeMask_nameSelector = mkSelector "sliceGradientTensor:fwdInShapeTensor:startTensor:sizeTensor:squeezeMask:name:"

-- | @Selector@ for @sliceGradientTensor:fwdInShapeTensor:starts:ends:strides:startMask:endMask:squeezeMask:name:@
sliceGradientTensor_fwdInShapeTensor_starts_ends_strides_startMask_endMask_squeezeMask_nameSelector :: Selector
sliceGradientTensor_fwdInShapeTensor_starts_ends_strides_startMask_endMask_squeezeMask_nameSelector = mkSelector "sliceGradientTensor:fwdInShapeTensor:starts:ends:strides:startMask:endMask:squeezeMask:name:"

-- | @Selector@ for @sliceUpdateDataTensor:updateTensor:startsTensor:endsTensor:stridesTensor:startMask:endMask:squeezeMask:name:@
sliceUpdateDataTensor_updateTensor_startsTensor_endsTensor_stridesTensor_startMask_endMask_squeezeMask_nameSelector :: Selector
sliceUpdateDataTensor_updateTensor_startsTensor_endsTensor_stridesTensor_startMask_endMask_squeezeMask_nameSelector = mkSelector "sliceUpdateDataTensor:updateTensor:startsTensor:endsTensor:stridesTensor:startMask:endMask:squeezeMask:name:"

-- | @Selector@ for @sliceUpdateDataTensor:updateTensor:starts:ends:strides:startMask:endMask:squeezeMask:name:@
sliceUpdateDataTensor_updateTensor_starts_ends_strides_startMask_endMask_squeezeMask_nameSelector :: Selector
sliceUpdateDataTensor_updateTensor_starts_ends_strides_startMask_endMask_squeezeMask_nameSelector = mkSelector "sliceUpdateDataTensor:updateTensor:starts:ends:strides:startMask:endMask:squeezeMask:name:"

-- | @Selector@ for @sliceUpdateDataTensor:updateTensor:startsTensor:endsTensor:stridesTensor:name:@
sliceUpdateDataTensor_updateTensor_startsTensor_endsTensor_stridesTensor_nameSelector :: Selector
sliceUpdateDataTensor_updateTensor_startsTensor_endsTensor_stridesTensor_nameSelector = mkSelector "sliceUpdateDataTensor:updateTensor:startsTensor:endsTensor:stridesTensor:name:"

-- | @Selector@ for @sliceUpdateDataTensor:updateTensor:starts:ends:strides:name:@
sliceUpdateDataTensor_updateTensor_starts_ends_strides_nameSelector :: Selector
sliceUpdateDataTensor_updateTensor_starts_ends_strides_nameSelector = mkSelector "sliceUpdateDataTensor:updateTensor:starts:ends:strides:name:"

-- | @Selector@ for @concatTensor:withTensor:dimension:name:@
concatTensor_withTensor_dimension_nameSelector :: Selector
concatTensor_withTensor_dimension_nameSelector = mkSelector "concatTensor:withTensor:dimension:name:"

-- | @Selector@ for @concatTensors:dimension:name:@
concatTensors_dimension_nameSelector :: Selector
concatTensors_dimension_nameSelector = mkSelector "concatTensors:dimension:name:"

-- | @Selector@ for @concatTensors:dimension:interleave:name:@
concatTensors_dimension_interleave_nameSelector :: Selector
concatTensors_dimension_interleave_nameSelector = mkSelector "concatTensors:dimension:interleave:name:"

-- | @Selector@ for @tileTensor:withMultiplier:name:@
tileTensor_withMultiplier_nameSelector :: Selector
tileTensor_withMultiplier_nameSelector = mkSelector "tileTensor:withMultiplier:name:"

-- | @Selector@ for @tileGradientWithIncomingGradientTensor:sourceTensor:withMultiplier:name:@
tileGradientWithIncomingGradientTensor_sourceTensor_withMultiplier_nameSelector :: Selector
tileGradientWithIncomingGradientTensor_sourceTensor_withMultiplier_nameSelector = mkSelector "tileGradientWithIncomingGradientTensor:sourceTensor:withMultiplier:name:"

-- | @Selector@ for @padTensor:withPaddingMode:leftPadding:rightPadding:constantValue:name:@
padTensor_withPaddingMode_leftPadding_rightPadding_constantValue_nameSelector :: Selector
padTensor_withPaddingMode_leftPadding_rightPadding_constantValue_nameSelector = mkSelector "padTensor:withPaddingMode:leftPadding:rightPadding:constantValue:name:"

-- | @Selector@ for @padGradientWithIncomingGradientTensor:sourceTensor:paddingMode:leftPadding:rightPadding:name:@
padGradientWithIncomingGradientTensor_sourceTensor_paddingMode_leftPadding_rightPadding_nameSelector :: Selector
padGradientWithIncomingGradientTensor_sourceTensor_paddingMode_leftPadding_rightPadding_nameSelector = mkSelector "padGradientWithIncomingGradientTensor:sourceTensor:paddingMode:leftPadding:rightPadding:name:"

-- | @Selector@ for @spaceToDepth2DTensor:widthAxis:heightAxis:depthAxis:blockSize:usePixelShuffleOrder:name:@
spaceToDepth2DTensor_widthAxis_heightAxis_depthAxis_blockSize_usePixelShuffleOrder_nameSelector :: Selector
spaceToDepth2DTensor_widthAxis_heightAxis_depthAxis_blockSize_usePixelShuffleOrder_nameSelector = mkSelector "spaceToDepth2DTensor:widthAxis:heightAxis:depthAxis:blockSize:usePixelShuffleOrder:name:"

-- | @Selector@ for @spaceToDepth2DTensor:widthAxisTensor:heightAxisTensor:depthAxisTensor:blockSize:usePixelShuffleOrder:name:@
spaceToDepth2DTensor_widthAxisTensor_heightAxisTensor_depthAxisTensor_blockSize_usePixelShuffleOrder_nameSelector :: Selector
spaceToDepth2DTensor_widthAxisTensor_heightAxisTensor_depthAxisTensor_blockSize_usePixelShuffleOrder_nameSelector = mkSelector "spaceToDepth2DTensor:widthAxisTensor:heightAxisTensor:depthAxisTensor:blockSize:usePixelShuffleOrder:name:"

-- | @Selector@ for @depthToSpace2DTensor:widthAxis:heightAxis:depthAxis:blockSize:usePixelShuffleOrder:name:@
depthToSpace2DTensor_widthAxis_heightAxis_depthAxis_blockSize_usePixelShuffleOrder_nameSelector :: Selector
depthToSpace2DTensor_widthAxis_heightAxis_depthAxis_blockSize_usePixelShuffleOrder_nameSelector = mkSelector "depthToSpace2DTensor:widthAxis:heightAxis:depthAxis:blockSize:usePixelShuffleOrder:name:"

-- | @Selector@ for @depthToSpace2DTensor:widthAxisTensor:heightAxisTensor:depthAxisTensor:blockSize:usePixelShuffleOrder:name:@
depthToSpace2DTensor_widthAxisTensor_heightAxisTensor_depthAxisTensor_blockSize_usePixelShuffleOrder_nameSelector :: Selector
depthToSpace2DTensor_widthAxisTensor_heightAxisTensor_depthAxisTensor_blockSize_usePixelShuffleOrder_nameSelector = mkSelector "depthToSpace2DTensor:widthAxisTensor:heightAxisTensor:depthAxisTensor:blockSize:usePixelShuffleOrder:name:"

-- | @Selector@ for @spaceToBatchTensor:spatialAxes:batchAxis:blockDimensions:usePixelShuffleOrder:name:@
spaceToBatchTensor_spatialAxes_batchAxis_blockDimensions_usePixelShuffleOrder_nameSelector :: Selector
spaceToBatchTensor_spatialAxes_batchAxis_blockDimensions_usePixelShuffleOrder_nameSelector = mkSelector "spaceToBatchTensor:spatialAxes:batchAxis:blockDimensions:usePixelShuffleOrder:name:"

-- | @Selector@ for @spaceToBatchTensor:spatialAxesTensor:batchAxisTensor:blockDimensionsTensor:usePixelShuffleOrder:name:@
spaceToBatchTensor_spatialAxesTensor_batchAxisTensor_blockDimensionsTensor_usePixelShuffleOrder_nameSelector :: Selector
spaceToBatchTensor_spatialAxesTensor_batchAxisTensor_blockDimensionsTensor_usePixelShuffleOrder_nameSelector = mkSelector "spaceToBatchTensor:spatialAxesTensor:batchAxisTensor:blockDimensionsTensor:usePixelShuffleOrder:name:"

-- | @Selector@ for @batchToSpaceTensor:spatialAxes:batchAxis:blockDimensions:usePixelShuffleOrder:name:@
batchToSpaceTensor_spatialAxes_batchAxis_blockDimensions_usePixelShuffleOrder_nameSelector :: Selector
batchToSpaceTensor_spatialAxes_batchAxis_blockDimensions_usePixelShuffleOrder_nameSelector = mkSelector "batchToSpaceTensor:spatialAxes:batchAxis:blockDimensions:usePixelShuffleOrder:name:"

-- | @Selector@ for @batchToSpaceTensor:spatialAxesTensor:batchAxisTensor:blockDimensionsTensor:usePixelShuffleOrder:name:@
batchToSpaceTensor_spatialAxesTensor_batchAxisTensor_blockDimensionsTensor_usePixelShuffleOrder_nameSelector :: Selector
batchToSpaceTensor_spatialAxesTensor_batchAxisTensor_blockDimensionsTensor_usePixelShuffleOrder_nameSelector = mkSelector "batchToSpaceTensor:spatialAxesTensor:batchAxisTensor:blockDimensionsTensor:usePixelShuffleOrder:name:"

-- | @Selector@ for @reverseTensor:axesTensor:name:@
reverseTensor_axesTensor_nameSelector :: Selector
reverseTensor_axesTensor_nameSelector = mkSelector "reverseTensor:axesTensor:name:"

-- | @Selector@ for @reverseTensor:axes:name:@
reverseTensor_axes_nameSelector :: Selector
reverseTensor_axes_nameSelector = mkSelector "reverseTensor:axes:name:"

-- | @Selector@ for @reverseTensor:name:@
reverseTensor_nameSelector :: Selector
reverseTensor_nameSelector = mkSelector "reverseTensor:name:"

-- | @Selector@ for @flatten2DTensor:axis:name:@
flatten2DTensor_axis_nameSelector :: Selector
flatten2DTensor_axis_nameSelector = mkSelector "flatten2DTensor:axis:name:"

-- | @Selector@ for @flatten2DTensor:axisTensor:name:@
flatten2DTensor_axisTensor_nameSelector :: Selector
flatten2DTensor_axisTensor_nameSelector = mkSelector "flatten2DTensor:axisTensor:name:"

-- | @Selector@ for @broadcastTensor:toShape:name:@
broadcastTensor_toShape_nameSelector :: Selector
broadcastTensor_toShape_nameSelector = mkSelector "broadcastTensor:toShape:name:"

-- | @Selector@ for @broadcastTensor:toShapeTensor:name:@
broadcastTensor_toShapeTensor_nameSelector :: Selector
broadcastTensor_toShapeTensor_nameSelector = mkSelector "broadcastTensor:toShapeTensor:name:"

-- | @Selector@ for @shapeOfTensor:name:@
shapeOfTensor_nameSelector :: Selector
shapeOfTensor_nameSelector = mkSelector "shapeOfTensor:name:"

-- | @Selector@ for @castTensor:toType:name:@
castTensor_toType_nameSelector :: Selector
castTensor_toType_nameSelector = mkSelector "castTensor:toType:name:"

-- | @Selector@ for @reinterpretCastTensor:toType:name:@
reinterpretCastTensor_toType_nameSelector :: Selector
reinterpretCastTensor_toType_nameSelector = mkSelector "reinterpretCastTensor:toType:name:"

-- | @Selector@ for @stackTensors:axis:name:@
stackTensors_axis_nameSelector :: Selector
stackTensors_axis_nameSelector = mkSelector "stackTensors:axis:name:"

-- | @Selector@ for @splitTensor:splitSizes:axis:name:@
splitTensor_splitSizes_axis_nameSelector :: Selector
splitTensor_splitSizes_axis_nameSelector = mkSelector "splitTensor:splitSizes:axis:name:"

-- | @Selector@ for @splitTensor:splitSizesTensor:axis:name:@
splitTensor_splitSizesTensor_axis_nameSelector :: Selector
splitTensor_splitSizesTensor_axis_nameSelector = mkSelector "splitTensor:splitSizesTensor:axis:name:"

-- | @Selector@ for @splitTensor:numSplits:axis:name:@
splitTensor_numSplits_axis_nameSelector :: Selector
splitTensor_numSplits_axis_nameSelector = mkSelector "splitTensor:numSplits:axis:name:"

-- | @Selector@ for @squeezeTensor:name:@
squeezeTensor_nameSelector :: Selector
squeezeTensor_nameSelector = mkSelector "squeezeTensor:name:"

-- | @Selector@ for @squeezeTensor:axis:name:@
squeezeTensor_axis_nameSelector :: Selector
squeezeTensor_axis_nameSelector = mkSelector "squeezeTensor:axis:name:"

-- | @Selector@ for @squeezeTensor:axes:name:@
squeezeTensor_axes_nameSelector :: Selector
squeezeTensor_axes_nameSelector = mkSelector "squeezeTensor:axes:name:"

-- | @Selector@ for @squeezeTensor:axesTensor:name:@
squeezeTensor_axesTensor_nameSelector :: Selector
squeezeTensor_axesTensor_nameSelector = mkSelector "squeezeTensor:axesTensor:name:"

-- | @Selector@ for @expandDimsOfTensor:axis:name:@
expandDimsOfTensor_axis_nameSelector :: Selector
expandDimsOfTensor_axis_nameSelector = mkSelector "expandDimsOfTensor:axis:name:"

-- | @Selector@ for @expandDimsOfTensor:axes:name:@
expandDimsOfTensor_axes_nameSelector :: Selector
expandDimsOfTensor_axes_nameSelector = mkSelector "expandDimsOfTensor:axes:name:"

-- | @Selector@ for @expandDimsOfTensor:axesTensor:name:@
expandDimsOfTensor_axesTensor_nameSelector :: Selector
expandDimsOfTensor_axesTensor_nameSelector = mkSelector "expandDimsOfTensor:axesTensor:name:"

-- | @Selector@ for @coordinateAlongAxis:withShape:name:@
coordinateAlongAxis_withShape_nameSelector :: Selector
coordinateAlongAxis_withShape_nameSelector = mkSelector "coordinateAlongAxis:withShape:name:"

-- | @Selector@ for @coordinateAlongAxisTensor:withShape:name:@
coordinateAlongAxisTensor_withShape_nameSelector :: Selector
coordinateAlongAxisTensor_withShape_nameSelector = mkSelector "coordinateAlongAxisTensor:withShape:name:"

-- | @Selector@ for @coordinateAlongAxis:withShapeTensor:name:@
coordinateAlongAxis_withShapeTensor_nameSelector :: Selector
coordinateAlongAxis_withShapeTensor_nameSelector = mkSelector "coordinateAlongAxis:withShapeTensor:name:"

-- | @Selector@ for @coordinateAlongAxisTensor:withShapeTensor:name:@
coordinateAlongAxisTensor_withShapeTensor_nameSelector :: Selector
coordinateAlongAxisTensor_withShapeTensor_nameSelector = mkSelector "coordinateAlongAxisTensor:withShapeTensor:name:"

-- | @Selector@ for @stencilWithSourceTensor:weightsTensor:descriptor:name:@
stencilWithSourceTensor_weightsTensor_descriptor_nameSelector :: Selector
stencilWithSourceTensor_weightsTensor_descriptor_nameSelector = mkSelector "stencilWithSourceTensor:weightsTensor:descriptor:name:"

-- | @Selector@ for @sparseTensorWithType:tensors:shape:dataType:name:@
sparseTensorWithType_tensors_shape_dataType_nameSelector :: Selector
sparseTensorWithType_tensors_shape_dataType_nameSelector = mkSelector "sparseTensorWithType:tensors:shape:dataType:name:"

-- | @Selector@ for @sparseTensorWithDescriptor:tensors:shape:name:@
sparseTensorWithDescriptor_tensors_shape_nameSelector :: Selector
sparseTensorWithDescriptor_tensors_shape_nameSelector = mkSelector "sparseTensorWithDescriptor:tensors:shape:name:"

-- | @Selector@ for @sortWithTensor:axis:descending:name:@
sortWithTensor_axis_descending_nameSelector :: Selector
sortWithTensor_axis_descending_nameSelector = mkSelector "sortWithTensor:axis:descending:name:"

-- | @Selector@ for @sortWithTensor:axisTensor:descending:name:@
sortWithTensor_axisTensor_descending_nameSelector :: Selector
sortWithTensor_axisTensor_descending_nameSelector = mkSelector "sortWithTensor:axisTensor:descending:name:"

-- | @Selector@ for @sortWithTensor:axis:name:@
sortWithTensor_axis_nameSelector :: Selector
sortWithTensor_axis_nameSelector = mkSelector "sortWithTensor:axis:name:"

-- | @Selector@ for @sortWithTensor:axisTensor:name:@
sortWithTensor_axisTensor_nameSelector :: Selector
sortWithTensor_axisTensor_nameSelector = mkSelector "sortWithTensor:axisTensor:name:"

-- | @Selector@ for @argSortWithTensor:axis:descending:name:@
argSortWithTensor_axis_descending_nameSelector :: Selector
argSortWithTensor_axis_descending_nameSelector = mkSelector "argSortWithTensor:axis:descending:name:"

-- | @Selector@ for @argSortWithTensor:axisTensor:descending:name:@
argSortWithTensor_axisTensor_descending_nameSelector :: Selector
argSortWithTensor_axisTensor_descending_nameSelector = mkSelector "argSortWithTensor:axisTensor:descending:name:"

-- | @Selector@ for @argSortWithTensor:axis:name:@
argSortWithTensor_axis_nameSelector :: Selector
argSortWithTensor_axis_nameSelector = mkSelector "argSortWithTensor:axis:name:"

-- | @Selector@ for @argSortWithTensor:axisTensor:name:@
argSortWithTensor_axisTensor_nameSelector :: Selector
argSortWithTensor_axisTensor_nameSelector = mkSelector "argSortWithTensor:axisTensor:name:"

-- | @Selector@ for @scatterAlongAxis:withUpdatesTensor:indicesTensor:shape:mode:name:@
scatterAlongAxis_withUpdatesTensor_indicesTensor_shape_mode_nameSelector :: Selector
scatterAlongAxis_withUpdatesTensor_indicesTensor_shape_mode_nameSelector = mkSelector "scatterAlongAxis:withUpdatesTensor:indicesTensor:shape:mode:name:"

-- | @Selector@ for @scatterAlongAxisTensor:withUpdatesTensor:indicesTensor:shape:mode:name:@
scatterAlongAxisTensor_withUpdatesTensor_indicesTensor_shape_mode_nameSelector :: Selector
scatterAlongAxisTensor_withUpdatesTensor_indicesTensor_shape_mode_nameSelector = mkSelector "scatterAlongAxisTensor:withUpdatesTensor:indicesTensor:shape:mode:name:"

-- | @Selector@ for @scatterAlongAxis:withDataTensor:updatesTensor:indicesTensor:mode:name:@
scatterAlongAxis_withDataTensor_updatesTensor_indicesTensor_mode_nameSelector :: Selector
scatterAlongAxis_withDataTensor_updatesTensor_indicesTensor_mode_nameSelector = mkSelector "scatterAlongAxis:withDataTensor:updatesTensor:indicesTensor:mode:name:"

-- | @Selector@ for @scatterAlongAxisTensor:withDataTensor:updatesTensor:indicesTensor:mode:name:@
scatterAlongAxisTensor_withDataTensor_updatesTensor_indicesTensor_mode_nameSelector :: Selector
scatterAlongAxisTensor_withDataTensor_updatesTensor_indicesTensor_mode_nameSelector = mkSelector "scatterAlongAxisTensor:withDataTensor:updatesTensor:indicesTensor:mode:name:"

-- | @Selector@ for @scatterWithUpdatesTensor:indicesTensor:shape:axis:mode:name:@
scatterWithUpdatesTensor_indicesTensor_shape_axis_mode_nameSelector :: Selector
scatterWithUpdatesTensor_indicesTensor_shape_axis_mode_nameSelector = mkSelector "scatterWithUpdatesTensor:indicesTensor:shape:axis:mode:name:"

-- | @Selector@ for @scatterWithDataTensor:updatesTensor:indicesTensor:axis:mode:name:@
scatterWithDataTensor_updatesTensor_indicesTensor_axis_mode_nameSelector :: Selector
scatterWithDataTensor_updatesTensor_indicesTensor_axis_mode_nameSelector = mkSelector "scatterWithDataTensor:updatesTensor:indicesTensor:axis:mode:name:"

-- | @Selector@ for @scatterNDWithUpdatesTensor:indicesTensor:shape:batchDimensions:mode:name:@
scatterNDWithUpdatesTensor_indicesTensor_shape_batchDimensions_mode_nameSelector :: Selector
scatterNDWithUpdatesTensor_indicesTensor_shape_batchDimensions_mode_nameSelector = mkSelector "scatterNDWithUpdatesTensor:indicesTensor:shape:batchDimensions:mode:name:"

-- | @Selector@ for @scatterNDWithUpdatesTensor:indicesTensor:shape:batchDimensions:name:@
scatterNDWithUpdatesTensor_indicesTensor_shape_batchDimensions_nameSelector :: Selector
scatterNDWithUpdatesTensor_indicesTensor_shape_batchDimensions_nameSelector = mkSelector "scatterNDWithUpdatesTensor:indicesTensor:shape:batchDimensions:name:"

-- | @Selector@ for @scatterNDWithDataTensor:updatesTensor:indicesTensor:batchDimensions:mode:name:@
scatterNDWithDataTensor_updatesTensor_indicesTensor_batchDimensions_mode_nameSelector :: Selector
scatterNDWithDataTensor_updatesTensor_indicesTensor_batchDimensions_mode_nameSelector = mkSelector "scatterNDWithDataTensor:updatesTensor:indicesTensor:batchDimensions:mode:name:"

-- | @Selector@ for @sampleGridWithSourceTensor:coordinateTensor:layout:normalizeCoordinates:relativeCoordinates:alignCorners:paddingMode:samplingMode:constantValue:name:@
sampleGridWithSourceTensor_coordinateTensor_layout_normalizeCoordinates_relativeCoordinates_alignCorners_paddingMode_samplingMode_constantValue_nameSelector :: Selector
sampleGridWithSourceTensor_coordinateTensor_layout_normalizeCoordinates_relativeCoordinates_alignCorners_paddingMode_samplingMode_constantValue_nameSelector = mkSelector "sampleGridWithSourceTensor:coordinateTensor:layout:normalizeCoordinates:relativeCoordinates:alignCorners:paddingMode:samplingMode:constantValue:name:"

-- | @Selector@ for @sampleGridWithSourceTensor:coordinateTensor:layout:normalizeCoordinates:relativeCoordinates:alignCorners:paddingMode:nearestRoundingMode:constantValue:name:@
sampleGridWithSourceTensor_coordinateTensor_layout_normalizeCoordinates_relativeCoordinates_alignCorners_paddingMode_nearestRoundingMode_constantValue_nameSelector :: Selector
sampleGridWithSourceTensor_coordinateTensor_layout_normalizeCoordinates_relativeCoordinates_alignCorners_paddingMode_nearestRoundingMode_constantValue_nameSelector = mkSelector "sampleGridWithSourceTensor:coordinateTensor:layout:normalizeCoordinates:relativeCoordinates:alignCorners:paddingMode:nearestRoundingMode:constantValue:name:"

-- | @Selector@ for @singleGateRNNWithSourceTensor:recurrentWeight:inputWeight:bias:initState:mask:descriptor:name:@
singleGateRNNWithSourceTensor_recurrentWeight_inputWeight_bias_initState_mask_descriptor_nameSelector :: Selector
singleGateRNNWithSourceTensor_recurrentWeight_inputWeight_bias_initState_mask_descriptor_nameSelector = mkSelector "singleGateRNNWithSourceTensor:recurrentWeight:inputWeight:bias:initState:mask:descriptor:name:"

-- | @Selector@ for @singleGateRNNWithSourceTensor:recurrentWeight:inputWeight:bias:initState:descriptor:name:@
singleGateRNNWithSourceTensor_recurrentWeight_inputWeight_bias_initState_descriptor_nameSelector :: Selector
singleGateRNNWithSourceTensor_recurrentWeight_inputWeight_bias_initState_descriptor_nameSelector = mkSelector "singleGateRNNWithSourceTensor:recurrentWeight:inputWeight:bias:initState:descriptor:name:"

-- | @Selector@ for @singleGateRNNWithSourceTensor:recurrentWeight:initState:descriptor:name:@
singleGateRNNWithSourceTensor_recurrentWeight_initState_descriptor_nameSelector :: Selector
singleGateRNNWithSourceTensor_recurrentWeight_initState_descriptor_nameSelector = mkSelector "singleGateRNNWithSourceTensor:recurrentWeight:initState:descriptor:name:"

-- | @Selector@ for @singleGateRNNGradientsWithSourceTensor:recurrentWeight:sourceGradient:zState:stateGradient:inputWeight:bias:initState:mask:descriptor:name:@
singleGateRNNGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_stateGradient_inputWeight_bias_initState_mask_descriptor_nameSelector :: Selector
singleGateRNNGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_stateGradient_inputWeight_bias_initState_mask_descriptor_nameSelector = mkSelector "singleGateRNNGradientsWithSourceTensor:recurrentWeight:sourceGradient:zState:stateGradient:inputWeight:bias:initState:mask:descriptor:name:"

-- | @Selector@ for @singleGateRNNGradientsWithSourceTensor:recurrentWeight:sourceGradient:zState:inputWeight:bias:initState:mask:descriptor:name:@
singleGateRNNGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_inputWeight_bias_initState_mask_descriptor_nameSelector :: Selector
singleGateRNNGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_inputWeight_bias_initState_mask_descriptor_nameSelector = mkSelector "singleGateRNNGradientsWithSourceTensor:recurrentWeight:sourceGradient:zState:inputWeight:bias:initState:mask:descriptor:name:"

-- | @Selector@ for @singleGateRNNGradientsWithSourceTensor:recurrentWeight:sourceGradient:zState:inputWeight:bias:initState:descriptor:name:@
singleGateRNNGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_inputWeight_bias_initState_descriptor_nameSelector :: Selector
singleGateRNNGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_inputWeight_bias_initState_descriptor_nameSelector = mkSelector "singleGateRNNGradientsWithSourceTensor:recurrentWeight:sourceGradient:zState:inputWeight:bias:initState:descriptor:name:"

-- | @Selector@ for @singleGateRNNGradientsWithSourceTensor:recurrentWeight:sourceGradient:zState:initState:descriptor:name:@
singleGateRNNGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_initState_descriptor_nameSelector :: Selector
singleGateRNNGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_initState_descriptor_nameSelector = mkSelector "singleGateRNNGradientsWithSourceTensor:recurrentWeight:sourceGradient:zState:initState:descriptor:name:"

-- | @Selector@ for @LSTMWithSourceTensor:recurrentWeight:inputWeight:bias:initState:initCell:mask:peephole:descriptor:name:@
lstmWithSourceTensor_recurrentWeight_inputWeight_bias_initState_initCell_mask_peephole_descriptor_nameSelector :: Selector
lstmWithSourceTensor_recurrentWeight_inputWeight_bias_initState_initCell_mask_peephole_descriptor_nameSelector = mkSelector "LSTMWithSourceTensor:recurrentWeight:inputWeight:bias:initState:initCell:mask:peephole:descriptor:name:"

-- | @Selector@ for @LSTMWithSourceTensor:recurrentWeight:inputWeight:bias:initState:initCell:descriptor:name:@
lstmWithSourceTensor_recurrentWeight_inputWeight_bias_initState_initCell_descriptor_nameSelector :: Selector
lstmWithSourceTensor_recurrentWeight_inputWeight_bias_initState_initCell_descriptor_nameSelector = mkSelector "LSTMWithSourceTensor:recurrentWeight:inputWeight:bias:initState:initCell:descriptor:name:"

-- | @Selector@ for @LSTMWithSourceTensor:recurrentWeight:initState:initCell:descriptor:name:@
lstmWithSourceTensor_recurrentWeight_initState_initCell_descriptor_nameSelector :: Selector
lstmWithSourceTensor_recurrentWeight_initState_initCell_descriptor_nameSelector = mkSelector "LSTMWithSourceTensor:recurrentWeight:initState:initCell:descriptor:name:"

-- | @Selector@ for @LSTMGradientsWithSourceTensor:recurrentWeight:sourceGradient:zState:cellOutputFwd:stateGradient:cellGradient:inputWeight:bias:initState:initCell:mask:peephole:descriptor:name:@
lstmGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_cellOutputFwd_stateGradient_cellGradient_inputWeight_bias_initState_initCell_mask_peephole_descriptor_nameSelector :: Selector
lstmGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_cellOutputFwd_stateGradient_cellGradient_inputWeight_bias_initState_initCell_mask_peephole_descriptor_nameSelector = mkSelector "LSTMGradientsWithSourceTensor:recurrentWeight:sourceGradient:zState:cellOutputFwd:stateGradient:cellGradient:inputWeight:bias:initState:initCell:mask:peephole:descriptor:name:"

-- | @Selector@ for @LSTMGradientsWithSourceTensor:recurrentWeight:sourceGradient:zState:cellOutputFwd:inputWeight:bias:initState:initCell:mask:descriptor:name:@
lstmGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_cellOutputFwd_inputWeight_bias_initState_initCell_mask_descriptor_nameSelector :: Selector
lstmGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_cellOutputFwd_inputWeight_bias_initState_initCell_mask_descriptor_nameSelector = mkSelector "LSTMGradientsWithSourceTensor:recurrentWeight:sourceGradient:zState:cellOutputFwd:inputWeight:bias:initState:initCell:mask:descriptor:name:"

-- | @Selector@ for @LSTMGradientsWithSourceTensor:recurrentWeight:sourceGradient:zState:cellOutputFwd:inputWeight:bias:initState:initCell:descriptor:name:@
lstmGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_cellOutputFwd_inputWeight_bias_initState_initCell_descriptor_nameSelector :: Selector
lstmGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_cellOutputFwd_inputWeight_bias_initState_initCell_descriptor_nameSelector = mkSelector "LSTMGradientsWithSourceTensor:recurrentWeight:sourceGradient:zState:cellOutputFwd:inputWeight:bias:initState:initCell:descriptor:name:"

-- | @Selector@ for @LSTMGradientsWithSourceTensor:recurrentWeight:sourceGradient:zState:cellOutputFwd:descriptor:name:@
lstmGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_cellOutputFwd_descriptor_nameSelector :: Selector
lstmGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_cellOutputFwd_descriptor_nameSelector = mkSelector "LSTMGradientsWithSourceTensor:recurrentWeight:sourceGradient:zState:cellOutputFwd:descriptor:name:"

-- | @Selector@ for @GRUWithSourceTensor:recurrentWeight:inputWeight:bias:initState:mask:secondaryBias:descriptor:name:@
gruWithSourceTensor_recurrentWeight_inputWeight_bias_initState_mask_secondaryBias_descriptor_nameSelector :: Selector
gruWithSourceTensor_recurrentWeight_inputWeight_bias_initState_mask_secondaryBias_descriptor_nameSelector = mkSelector "GRUWithSourceTensor:recurrentWeight:inputWeight:bias:initState:mask:secondaryBias:descriptor:name:"

-- | @Selector@ for @GRUWithSourceTensor:recurrentWeight:inputWeight:bias:initState:descriptor:name:@
gruWithSourceTensor_recurrentWeight_inputWeight_bias_initState_descriptor_nameSelector :: Selector
gruWithSourceTensor_recurrentWeight_inputWeight_bias_initState_descriptor_nameSelector = mkSelector "GRUWithSourceTensor:recurrentWeight:inputWeight:bias:initState:descriptor:name:"

-- | @Selector@ for @GRUWithSourceTensor:recurrentWeight:inputWeight:bias:descriptor:name:@
gruWithSourceTensor_recurrentWeight_inputWeight_bias_descriptor_nameSelector :: Selector
gruWithSourceTensor_recurrentWeight_inputWeight_bias_descriptor_nameSelector = mkSelector "GRUWithSourceTensor:recurrentWeight:inputWeight:bias:descriptor:name:"

-- | @Selector@ for @GRUGradientsWithSourceTensor:recurrentWeight:sourceGradient:zState:outputFwd:stateGradient:inputWeight:bias:initState:mask:secondaryBias:descriptor:name:@
gruGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_outputFwd_stateGradient_inputWeight_bias_initState_mask_secondaryBias_descriptor_nameSelector :: Selector
gruGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_outputFwd_stateGradient_inputWeight_bias_initState_mask_secondaryBias_descriptor_nameSelector = mkSelector "GRUGradientsWithSourceTensor:recurrentWeight:sourceGradient:zState:outputFwd:stateGradient:inputWeight:bias:initState:mask:secondaryBias:descriptor:name:"

-- | @Selector@ for @GRUGradientsWithSourceTensor:recurrentWeight:sourceGradient:zState:outputFwd:inputWeight:bias:initState:descriptor:name:@
gruGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_outputFwd_inputWeight_bias_initState_descriptor_nameSelector :: Selector
gruGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_outputFwd_inputWeight_bias_initState_descriptor_nameSelector = mkSelector "GRUGradientsWithSourceTensor:recurrentWeight:sourceGradient:zState:outputFwd:inputWeight:bias:initState:descriptor:name:"

-- | @Selector@ for @GRUGradientsWithSourceTensor:recurrentWeight:sourceGradient:zState:outputFwd:inputWeight:bias:descriptor:name:@
gruGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_outputFwd_inputWeight_bias_descriptor_nameSelector :: Selector
gruGradientsWithSourceTensor_recurrentWeight_sourceGradient_zState_outputFwd_inputWeight_bias_descriptor_nameSelector = mkSelector "GRUGradientsWithSourceTensor:recurrentWeight:sourceGradient:zState:outputFwd:inputWeight:bias:descriptor:name:"

-- | @Selector@ for @resizeTensor:size:mode:centerResult:alignCorners:layout:name:@
resizeTensor_size_mode_centerResult_alignCorners_layout_nameSelector :: Selector
resizeTensor_size_mode_centerResult_alignCorners_layout_nameSelector = mkSelector "resizeTensor:size:mode:centerResult:alignCorners:layout:name:"

-- | @Selector@ for @resizeTensor:sizeTensor:mode:centerResult:alignCorners:layout:name:@
resizeTensor_sizeTensor_mode_centerResult_alignCorners_layout_nameSelector :: Selector
resizeTensor_sizeTensor_mode_centerResult_alignCorners_layout_nameSelector = mkSelector "resizeTensor:sizeTensor:mode:centerResult:alignCorners:layout:name:"

-- | @Selector@ for @resizeTensor:sizeTensor:mode:centerResult:alignCorners:name:@
resizeTensor_sizeTensor_mode_centerResult_alignCorners_nameSelector :: Selector
resizeTensor_sizeTensor_mode_centerResult_alignCorners_nameSelector = mkSelector "resizeTensor:sizeTensor:mode:centerResult:alignCorners:name:"

-- | @Selector@ for @resizeNearestWithTensor:sizeTensor:nearestRoundingMode:centerResult:alignCorners:layout:name:@
resizeNearestWithTensor_sizeTensor_nearestRoundingMode_centerResult_alignCorners_layout_nameSelector :: Selector
resizeNearestWithTensor_sizeTensor_nearestRoundingMode_centerResult_alignCorners_layout_nameSelector = mkSelector "resizeNearestWithTensor:sizeTensor:nearestRoundingMode:centerResult:alignCorners:layout:name:"

-- | @Selector@ for @resizeNearestWithTensor:sizeTensor:nearestRoundingMode:centerResult:alignCorners:name:@
resizeNearestWithTensor_sizeTensor_nearestRoundingMode_centerResult_alignCorners_nameSelector :: Selector
resizeNearestWithTensor_sizeTensor_nearestRoundingMode_centerResult_alignCorners_nameSelector = mkSelector "resizeNearestWithTensor:sizeTensor:nearestRoundingMode:centerResult:alignCorners:name:"

-- | @Selector@ for @resizeBilinearWithTensor:sizeTensor:centerResult:alignCorners:layout:name:@
resizeBilinearWithTensor_sizeTensor_centerResult_alignCorners_layout_nameSelector :: Selector
resizeBilinearWithTensor_sizeTensor_centerResult_alignCorners_layout_nameSelector = mkSelector "resizeBilinearWithTensor:sizeTensor:centerResult:alignCorners:layout:name:"

-- | @Selector@ for @resizeBilinearWithTensor:sizeTensor:centerResult:alignCorners:name:@
resizeBilinearWithTensor_sizeTensor_centerResult_alignCorners_nameSelector :: Selector
resizeBilinearWithTensor_sizeTensor_centerResult_alignCorners_nameSelector = mkSelector "resizeBilinearWithTensor:sizeTensor:centerResult:alignCorners:name:"

-- | @Selector@ for @resizeTensor:sizeTensor:scaleOffsetTensor:mode:layout:name:@
resizeTensor_sizeTensor_scaleOffsetTensor_mode_layout_nameSelector :: Selector
resizeTensor_sizeTensor_scaleOffsetTensor_mode_layout_nameSelector = mkSelector "resizeTensor:sizeTensor:scaleOffsetTensor:mode:layout:name:"

-- | @Selector@ for @resizeTensor:sizeTensor:scaleTensor:offsetTensor:mode:name:@
resizeTensor_sizeTensor_scaleTensor_offsetTensor_mode_nameSelector :: Selector
resizeTensor_sizeTensor_scaleTensor_offsetTensor_mode_nameSelector = mkSelector "resizeTensor:sizeTensor:scaleTensor:offsetTensor:mode:name:"

-- | @Selector@ for @resizeNearestWithTensor:sizeTensor:scaleOffsetTensor:nearestRoundingMode:layout:name:@
resizeNearestWithTensor_sizeTensor_scaleOffsetTensor_nearestRoundingMode_layout_nameSelector :: Selector
resizeNearestWithTensor_sizeTensor_scaleOffsetTensor_nearestRoundingMode_layout_nameSelector = mkSelector "resizeNearestWithTensor:sizeTensor:scaleOffsetTensor:nearestRoundingMode:layout:name:"

-- | @Selector@ for @resizeNearestWithTensor:sizeTensor:scaleTensor:offsetTensor:nearestRoundingMode:name:@
resizeNearestWithTensor_sizeTensor_scaleTensor_offsetTensor_nearestRoundingMode_nameSelector :: Selector
resizeNearestWithTensor_sizeTensor_scaleTensor_offsetTensor_nearestRoundingMode_nameSelector = mkSelector "resizeNearestWithTensor:sizeTensor:scaleTensor:offsetTensor:nearestRoundingMode:name:"

-- | @Selector@ for @resizeBilinearWithTensor:sizeTensor:scaleOffsetTensor:layout:name:@
resizeBilinearWithTensor_sizeTensor_scaleOffsetTensor_layout_nameSelector :: Selector
resizeBilinearWithTensor_sizeTensor_scaleOffsetTensor_layout_nameSelector = mkSelector "resizeBilinearWithTensor:sizeTensor:scaleOffsetTensor:layout:name:"

-- | @Selector@ for @resizeBilinearWithTensor:sizeTensor:scaleTensor:offsetTensor:name:@
resizeBilinearWithTensor_sizeTensor_scaleTensor_offsetTensor_nameSelector :: Selector
resizeBilinearWithTensor_sizeTensor_scaleTensor_offsetTensor_nameSelector = mkSelector "resizeBilinearWithTensor:sizeTensor:scaleTensor:offsetTensor:name:"

-- | @Selector@ for @resizeWithGradientTensor:input:mode:centerResult:alignCorners:layout:name:@
resizeWithGradientTensor_input_mode_centerResult_alignCorners_layout_nameSelector :: Selector
resizeWithGradientTensor_input_mode_centerResult_alignCorners_layout_nameSelector = mkSelector "resizeWithGradientTensor:input:mode:centerResult:alignCorners:layout:name:"

-- | @Selector@ for @resizeNearestWithGradientTensor:input:nearestRoundingMode:centerResult:alignCorners:layout:name:@
resizeNearestWithGradientTensor_input_nearestRoundingMode_centerResult_alignCorners_layout_nameSelector :: Selector
resizeNearestWithGradientTensor_input_nearestRoundingMode_centerResult_alignCorners_layout_nameSelector = mkSelector "resizeNearestWithGradientTensor:input:nearestRoundingMode:centerResult:alignCorners:layout:name:"

-- | @Selector@ for @resizeBilinearWithGradientTensor:input:centerResult:alignCorners:layout:name:@
resizeBilinearWithGradientTensor_input_centerResult_alignCorners_layout_nameSelector :: Selector
resizeBilinearWithGradientTensor_input_centerResult_alignCorners_layout_nameSelector = mkSelector "resizeBilinearWithGradientTensor:input:centerResult:alignCorners:layout:name:"

-- | @Selector@ for @resizeWithGradientTensor:input:scaleOffsetTensor:mode:layout:name:@
resizeWithGradientTensor_input_scaleOffsetTensor_mode_layout_nameSelector :: Selector
resizeWithGradientTensor_input_scaleOffsetTensor_mode_layout_nameSelector = mkSelector "resizeWithGradientTensor:input:scaleOffsetTensor:mode:layout:name:"

-- | @Selector@ for @resizeWithGradientTensor:input:scaleTensor:offsetTensor:mode:name:@
resizeWithGradientTensor_input_scaleTensor_offsetTensor_mode_nameSelector :: Selector
resizeWithGradientTensor_input_scaleTensor_offsetTensor_mode_nameSelector = mkSelector "resizeWithGradientTensor:input:scaleTensor:offsetTensor:mode:name:"

-- | @Selector@ for @resizeNearestWithGradientTensor:input:scaleOffsetTensor:nearestRoundingMode:layout:name:@
resizeNearestWithGradientTensor_input_scaleOffsetTensor_nearestRoundingMode_layout_nameSelector :: Selector
resizeNearestWithGradientTensor_input_scaleOffsetTensor_nearestRoundingMode_layout_nameSelector = mkSelector "resizeNearestWithGradientTensor:input:scaleOffsetTensor:nearestRoundingMode:layout:name:"

-- | @Selector@ for @resizeNearestWithGradientTensor:input:scaleTensor:offsetTensor:nearestRoundingMode:name:@
resizeNearestWithGradientTensor_input_scaleTensor_offsetTensor_nearestRoundingMode_nameSelector :: Selector
resizeNearestWithGradientTensor_input_scaleTensor_offsetTensor_nearestRoundingMode_nameSelector = mkSelector "resizeNearestWithGradientTensor:input:scaleTensor:offsetTensor:nearestRoundingMode:name:"

-- | @Selector@ for @resizeBilinearWithGradientTensor:input:scaleOffsetTensor:layout:name:@
resizeBilinearWithGradientTensor_input_scaleOffsetTensor_layout_nameSelector :: Selector
resizeBilinearWithGradientTensor_input_scaleOffsetTensor_layout_nameSelector = mkSelector "resizeBilinearWithGradientTensor:input:scaleOffsetTensor:layout:name:"

-- | @Selector@ for @resizeBilinearWithGradientTensor:input:scaleTensor:offsetTensor:name:@
resizeBilinearWithGradientTensor_input_scaleTensor_offsetTensor_nameSelector :: Selector
resizeBilinearWithGradientTensor_input_scaleTensor_offsetTensor_nameSelector = mkSelector "resizeBilinearWithGradientTensor:input:scaleTensor:offsetTensor:name:"

-- | @Selector@ for @reductionSumWithTensor:axis:name:@
reductionSumWithTensor_axis_nameSelector :: Selector
reductionSumWithTensor_axis_nameSelector = mkSelector "reductionSumWithTensor:axis:name:"

-- | @Selector@ for @reductionSumWithTensor:axes:name:@
reductionSumWithTensor_axes_nameSelector :: Selector
reductionSumWithTensor_axes_nameSelector = mkSelector "reductionSumWithTensor:axes:name:"

-- | @Selector@ for @reductionMaximumWithTensor:axis:name:@
reductionMaximumWithTensor_axis_nameSelector :: Selector
reductionMaximumWithTensor_axis_nameSelector = mkSelector "reductionMaximumWithTensor:axis:name:"

-- | @Selector@ for @reductionMaximumWithTensor:axes:name:@
reductionMaximumWithTensor_axes_nameSelector :: Selector
reductionMaximumWithTensor_axes_nameSelector = mkSelector "reductionMaximumWithTensor:axes:name:"

-- | @Selector@ for @reductionMinimumWithTensor:axis:name:@
reductionMinimumWithTensor_axis_nameSelector :: Selector
reductionMinimumWithTensor_axis_nameSelector = mkSelector "reductionMinimumWithTensor:axis:name:"

-- | @Selector@ for @reductionMinimumWithTensor:axes:name:@
reductionMinimumWithTensor_axes_nameSelector :: Selector
reductionMinimumWithTensor_axes_nameSelector = mkSelector "reductionMinimumWithTensor:axes:name:"

-- | @Selector@ for @reductionMaximumPropagateNaNWithTensor:axis:name:@
reductionMaximumPropagateNaNWithTensor_axis_nameSelector :: Selector
reductionMaximumPropagateNaNWithTensor_axis_nameSelector = mkSelector "reductionMaximumPropagateNaNWithTensor:axis:name:"

-- | @Selector@ for @reductionMaximumPropagateNaNWithTensor:axes:name:@
reductionMaximumPropagateNaNWithTensor_axes_nameSelector :: Selector
reductionMaximumPropagateNaNWithTensor_axes_nameSelector = mkSelector "reductionMaximumPropagateNaNWithTensor:axes:name:"

-- | @Selector@ for @reductionMinimumPropagateNaNWithTensor:axis:name:@
reductionMinimumPropagateNaNWithTensor_axis_nameSelector :: Selector
reductionMinimumPropagateNaNWithTensor_axis_nameSelector = mkSelector "reductionMinimumPropagateNaNWithTensor:axis:name:"

-- | @Selector@ for @reductionMinimumPropagateNaNWithTensor:axes:name:@
reductionMinimumPropagateNaNWithTensor_axes_nameSelector :: Selector
reductionMinimumPropagateNaNWithTensor_axes_nameSelector = mkSelector "reductionMinimumPropagateNaNWithTensor:axes:name:"

-- | @Selector@ for @reductionProductWithTensor:axis:name:@
reductionProductWithTensor_axis_nameSelector :: Selector
reductionProductWithTensor_axis_nameSelector = mkSelector "reductionProductWithTensor:axis:name:"

-- | @Selector@ for @reductionProductWithTensor:axes:name:@
reductionProductWithTensor_axes_nameSelector :: Selector
reductionProductWithTensor_axes_nameSelector = mkSelector "reductionProductWithTensor:axes:name:"

-- | @Selector@ for @reductionArgMaximumWithTensor:axis:name:@
reductionArgMaximumWithTensor_axis_nameSelector :: Selector
reductionArgMaximumWithTensor_axis_nameSelector = mkSelector "reductionArgMaximumWithTensor:axis:name:"

-- | @Selector@ for @reductionArgMinimumWithTensor:axis:name:@
reductionArgMinimumWithTensor_axis_nameSelector :: Selector
reductionArgMinimumWithTensor_axis_nameSelector = mkSelector "reductionArgMinimumWithTensor:axis:name:"

-- | @Selector@ for @reductionAndWithTensor:axis:name:@
reductionAndWithTensor_axis_nameSelector :: Selector
reductionAndWithTensor_axis_nameSelector = mkSelector "reductionAndWithTensor:axis:name:"

-- | @Selector@ for @reductionAndWithTensor:axes:name:@
reductionAndWithTensor_axes_nameSelector :: Selector
reductionAndWithTensor_axes_nameSelector = mkSelector "reductionAndWithTensor:axes:name:"

-- | @Selector@ for @reductionOrWithTensor:axis:name:@
reductionOrWithTensor_axis_nameSelector :: Selector
reductionOrWithTensor_axis_nameSelector = mkSelector "reductionOrWithTensor:axis:name:"

-- | @Selector@ for @reductionOrWithTensor:axes:name:@
reductionOrWithTensor_axes_nameSelector :: Selector
reductionOrWithTensor_axes_nameSelector = mkSelector "reductionOrWithTensor:axes:name:"

-- | @Selector@ for @randomPhiloxStateTensorWithSeed:name:@
randomPhiloxStateTensorWithSeed_nameSelector :: Selector
randomPhiloxStateTensorWithSeed_nameSelector = mkSelector "randomPhiloxStateTensorWithSeed:name:"

-- | @Selector@ for @randomPhiloxStateTensorWithCounterLow:counterHigh:key:name:@
randomPhiloxStateTensorWithCounterLow_counterHigh_key_nameSelector :: Selector
randomPhiloxStateTensorWithCounterLow_counterHigh_key_nameSelector = mkSelector "randomPhiloxStateTensorWithCounterLow:counterHigh:key:name:"

-- | @Selector@ for @randomTensorWithShape:descriptor:name:@
randomTensorWithShape_descriptor_nameSelector :: Selector
randomTensorWithShape_descriptor_nameSelector = mkSelector "randomTensorWithShape:descriptor:name:"

-- | @Selector@ for @randomTensorWithShapeTensor:descriptor:name:@
randomTensorWithShapeTensor_descriptor_nameSelector :: Selector
randomTensorWithShapeTensor_descriptor_nameSelector = mkSelector "randomTensorWithShapeTensor:descriptor:name:"

-- | @Selector@ for @randomTensorWithShape:descriptor:seed:name:@
randomTensorWithShape_descriptor_seed_nameSelector :: Selector
randomTensorWithShape_descriptor_seed_nameSelector = mkSelector "randomTensorWithShape:descriptor:seed:name:"

-- | @Selector@ for @randomTensorWithShapeTensor:descriptor:seed:name:@
randomTensorWithShapeTensor_descriptor_seed_nameSelector :: Selector
randomTensorWithShapeTensor_descriptor_seed_nameSelector = mkSelector "randomTensorWithShapeTensor:descriptor:seed:name:"

-- | @Selector@ for @randomTensorWithShape:descriptor:stateTensor:name:@
randomTensorWithShape_descriptor_stateTensor_nameSelector :: Selector
randomTensorWithShape_descriptor_stateTensor_nameSelector = mkSelector "randomTensorWithShape:descriptor:stateTensor:name:"

-- | @Selector@ for @randomTensorWithShapeTensor:descriptor:stateTensor:name:@
randomTensorWithShapeTensor_descriptor_stateTensor_nameSelector :: Selector
randomTensorWithShapeTensor_descriptor_stateTensor_nameSelector = mkSelector "randomTensorWithShapeTensor:descriptor:stateTensor:name:"

-- | @Selector@ for @randomUniformTensorWithShape:name:@
randomUniformTensorWithShape_nameSelector :: Selector
randomUniformTensorWithShape_nameSelector = mkSelector "randomUniformTensorWithShape:name:"

-- | @Selector@ for @randomUniformTensorWithShapeTensor:name:@
randomUniformTensorWithShapeTensor_nameSelector :: Selector
randomUniformTensorWithShapeTensor_nameSelector = mkSelector "randomUniformTensorWithShapeTensor:name:"

-- | @Selector@ for @randomUniformTensorWithShape:seed:name:@
randomUniformTensorWithShape_seed_nameSelector :: Selector
randomUniformTensorWithShape_seed_nameSelector = mkSelector "randomUniformTensorWithShape:seed:name:"

-- | @Selector@ for @randomUniformTensorWithShapeTensor:seed:name:@
randomUniformTensorWithShapeTensor_seed_nameSelector :: Selector
randomUniformTensorWithShapeTensor_seed_nameSelector = mkSelector "randomUniformTensorWithShapeTensor:seed:name:"

-- | @Selector@ for @randomUniformTensorWithShape:stateTensor:name:@
randomUniformTensorWithShape_stateTensor_nameSelector :: Selector
randomUniformTensorWithShape_stateTensor_nameSelector = mkSelector "randomUniformTensorWithShape:stateTensor:name:"

-- | @Selector@ for @randomUniformTensorWithShapeTensor:stateTensor:name:@
randomUniformTensorWithShapeTensor_stateTensor_nameSelector :: Selector
randomUniformTensorWithShapeTensor_stateTensor_nameSelector = mkSelector "randomUniformTensorWithShapeTensor:stateTensor:name:"

-- | @Selector@ for @dropoutTensor:rate:name:@
dropoutTensor_rate_nameSelector :: Selector
dropoutTensor_rate_nameSelector = mkSelector "dropoutTensor:rate:name:"

-- | @Selector@ for @dropoutTensor:rateTensor:name:@
dropoutTensor_rateTensor_nameSelector :: Selector
dropoutTensor_rateTensor_nameSelector = mkSelector "dropoutTensor:rateTensor:name:"

-- | @Selector@ for @quantizeTensor:scale:zeroPoint:dataType:name:@
quantizeTensor_scale_zeroPoint_dataType_nameSelector :: Selector
quantizeTensor_scale_zeroPoint_dataType_nameSelector = mkSelector "quantizeTensor:scale:zeroPoint:dataType:name:"

-- | @Selector@ for @dequantizeTensor:scale:zeroPoint:dataType:name:@
dequantizeTensor_scale_zeroPoint_dataType_nameSelector :: Selector
dequantizeTensor_scale_zeroPoint_dataType_nameSelector = mkSelector "dequantizeTensor:scale:zeroPoint:dataType:name:"

-- | @Selector@ for @quantizeTensor:scaleTensor:zeroPoint:dataType:axis:name:@
quantizeTensor_scaleTensor_zeroPoint_dataType_axis_nameSelector :: Selector
quantizeTensor_scaleTensor_zeroPoint_dataType_axis_nameSelector = mkSelector "quantizeTensor:scaleTensor:zeroPoint:dataType:axis:name:"

-- | @Selector@ for @dequantizeTensor:scaleTensor:zeroPoint:dataType:axis:name:@
dequantizeTensor_scaleTensor_zeroPoint_dataType_axis_nameSelector :: Selector
dequantizeTensor_scaleTensor_zeroPoint_dataType_axis_nameSelector = mkSelector "dequantizeTensor:scaleTensor:zeroPoint:dataType:axis:name:"

-- | @Selector@ for @quantizeTensor:scaleTensor:zeroPointTensor:dataType:axis:name:@
quantizeTensor_scaleTensor_zeroPointTensor_dataType_axis_nameSelector :: Selector
quantizeTensor_scaleTensor_zeroPointTensor_dataType_axis_nameSelector = mkSelector "quantizeTensor:scaleTensor:zeroPointTensor:dataType:axis:name:"

-- | @Selector@ for @dequantizeTensor:scaleTensor:zeroPointTensor:dataType:axis:name:@
dequantizeTensor_scaleTensor_zeroPointTensor_dataType_axis_nameSelector :: Selector
dequantizeTensor_scaleTensor_zeroPointTensor_dataType_axis_nameSelector = mkSelector "dequantizeTensor:scaleTensor:zeroPointTensor:dataType:axis:name:"

-- | @Selector@ for @dequantizeTensor:scaleTensor:zeroPointTensor:dataType:name:@
dequantizeTensor_scaleTensor_zeroPointTensor_dataType_nameSelector :: Selector
dequantizeTensor_scaleTensor_zeroPointTensor_dataType_nameSelector = mkSelector "dequantizeTensor:scaleTensor:zeroPointTensor:dataType:name:"

-- | @Selector@ for @dequantizeTensor:scaleTensor:dataType:name:@
dequantizeTensor_scaleTensor_dataType_nameSelector :: Selector
dequantizeTensor_scaleTensor_dataType_nameSelector = mkSelector "dequantizeTensor:scaleTensor:dataType:name:"

-- | @Selector@ for @dequantizeTensor:LUTTensor:name:@
dequantizeTensor_LUTTensor_nameSelector :: Selector
dequantizeTensor_LUTTensor_nameSelector = mkSelector "dequantizeTensor:LUTTensor:name:"

-- | @Selector@ for @dequantizeTensor:LUTTensor:axis:name:@
dequantizeTensor_LUTTensor_axis_nameSelector :: Selector
dequantizeTensor_LUTTensor_axis_nameSelector = mkSelector "dequantizeTensor:LUTTensor:axis:name:"

-- | @Selector@ for @maxPooling2DWithSourceTensor:descriptor:name:@
maxPooling2DWithSourceTensor_descriptor_nameSelector :: Selector
maxPooling2DWithSourceTensor_descriptor_nameSelector = mkSelector "maxPooling2DWithSourceTensor:descriptor:name:"

-- | @Selector@ for @maxPooling2DReturnIndicesWithSourceTensor:descriptor:name:@
maxPooling2DReturnIndicesWithSourceTensor_descriptor_nameSelector :: Selector
maxPooling2DReturnIndicesWithSourceTensor_descriptor_nameSelector = mkSelector "maxPooling2DReturnIndicesWithSourceTensor:descriptor:name:"

-- | @Selector@ for @maxPooling2DGradientWithGradientTensor:sourceTensor:descriptor:name:@
maxPooling2DGradientWithGradientTensor_sourceTensor_descriptor_nameSelector :: Selector
maxPooling2DGradientWithGradientTensor_sourceTensor_descriptor_nameSelector = mkSelector "maxPooling2DGradientWithGradientTensor:sourceTensor:descriptor:name:"

-- | @Selector@ for @maxPooling2DGradientWithGradientTensor:indicesTensor:outputShape:descriptor:name:@
maxPooling2DGradientWithGradientTensor_indicesTensor_outputShape_descriptor_nameSelector :: Selector
maxPooling2DGradientWithGradientTensor_indicesTensor_outputShape_descriptor_nameSelector = mkSelector "maxPooling2DGradientWithGradientTensor:indicesTensor:outputShape:descriptor:name:"

-- | @Selector@ for @maxPooling2DGradientWithGradientTensor:indicesTensor:outputShapeTensor:descriptor:name:@
maxPooling2DGradientWithGradientTensor_indicesTensor_outputShapeTensor_descriptor_nameSelector :: Selector
maxPooling2DGradientWithGradientTensor_indicesTensor_outputShapeTensor_descriptor_nameSelector = mkSelector "maxPooling2DGradientWithGradientTensor:indicesTensor:outputShapeTensor:descriptor:name:"

-- | @Selector@ for @avgPooling2DWithSourceTensor:descriptor:name:@
avgPooling2DWithSourceTensor_descriptor_nameSelector :: Selector
avgPooling2DWithSourceTensor_descriptor_nameSelector = mkSelector "avgPooling2DWithSourceTensor:descriptor:name:"

-- | @Selector@ for @avgPooling2DGradientWithGradientTensor:sourceTensor:descriptor:name:@
avgPooling2DGradientWithGradientTensor_sourceTensor_descriptor_nameSelector :: Selector
avgPooling2DGradientWithGradientTensor_sourceTensor_descriptor_nameSelector = mkSelector "avgPooling2DGradientWithGradientTensor:sourceTensor:descriptor:name:"

-- | @Selector@ for @maxPooling4DWithSourceTensor:descriptor:name:@
maxPooling4DWithSourceTensor_descriptor_nameSelector :: Selector
maxPooling4DWithSourceTensor_descriptor_nameSelector = mkSelector "maxPooling4DWithSourceTensor:descriptor:name:"

-- | @Selector@ for @maxPooling4DReturnIndicesWithSourceTensor:descriptor:name:@
maxPooling4DReturnIndicesWithSourceTensor_descriptor_nameSelector :: Selector
maxPooling4DReturnIndicesWithSourceTensor_descriptor_nameSelector = mkSelector "maxPooling4DReturnIndicesWithSourceTensor:descriptor:name:"

-- | @Selector@ for @maxPooling4DGradientWithGradientTensor:sourceTensor:descriptor:name:@
maxPooling4DGradientWithGradientTensor_sourceTensor_descriptor_nameSelector :: Selector
maxPooling4DGradientWithGradientTensor_sourceTensor_descriptor_nameSelector = mkSelector "maxPooling4DGradientWithGradientTensor:sourceTensor:descriptor:name:"

-- | @Selector@ for @maxPooling4DGradientWithGradientTensor:indicesTensor:outputShape:descriptor:name:@
maxPooling4DGradientWithGradientTensor_indicesTensor_outputShape_descriptor_nameSelector :: Selector
maxPooling4DGradientWithGradientTensor_indicesTensor_outputShape_descriptor_nameSelector = mkSelector "maxPooling4DGradientWithGradientTensor:indicesTensor:outputShape:descriptor:name:"

-- | @Selector@ for @maxPooling4DGradientWithGradientTensor:indicesTensor:outputShapeTensor:descriptor:name:@
maxPooling4DGradientWithGradientTensor_indicesTensor_outputShapeTensor_descriptor_nameSelector :: Selector
maxPooling4DGradientWithGradientTensor_indicesTensor_outputShapeTensor_descriptor_nameSelector = mkSelector "maxPooling4DGradientWithGradientTensor:indicesTensor:outputShapeTensor:descriptor:name:"

-- | @Selector@ for @avgPooling4DWithSourceTensor:descriptor:name:@
avgPooling4DWithSourceTensor_descriptor_nameSelector :: Selector
avgPooling4DWithSourceTensor_descriptor_nameSelector = mkSelector "avgPooling4DWithSourceTensor:descriptor:name:"

-- | @Selector@ for @avgPooling4DGradientWithGradientTensor:sourceTensor:descriptor:name:@
avgPooling4DGradientWithGradientTensor_sourceTensor_descriptor_nameSelector :: Selector
avgPooling4DGradientWithGradientTensor_sourceTensor_descriptor_nameSelector = mkSelector "avgPooling4DGradientWithGradientTensor:sourceTensor:descriptor:name:"

-- | @Selector@ for @L2NormPooling4DWithSourceTensor:descriptor:name:@
l2NormPooling4DWithSourceTensor_descriptor_nameSelector :: Selector
l2NormPooling4DWithSourceTensor_descriptor_nameSelector = mkSelector "L2NormPooling4DWithSourceTensor:descriptor:name:"

-- | @Selector@ for @L2NormPooling4DGradientWithGradientTensor:sourceTensor:descriptor:name:@
l2NormPooling4DGradientWithGradientTensor_sourceTensor_descriptor_nameSelector :: Selector
l2NormPooling4DGradientWithGradientTensor_sourceTensor_descriptor_nameSelector = mkSelector "L2NormPooling4DGradientWithGradientTensor:sourceTensor:descriptor:name:"

-- | @Selector@ for @stochasticGradientDescentWithLearningRateTensor:valuesTensor:gradientTensor:name:@
stochasticGradientDescentWithLearningRateTensor_valuesTensor_gradientTensor_nameSelector :: Selector
stochasticGradientDescentWithLearningRateTensor_valuesTensor_gradientTensor_nameSelector = mkSelector "stochasticGradientDescentWithLearningRateTensor:valuesTensor:gradientTensor:name:"

-- | @Selector@ for @applyStochasticGradientDescentWithLearningRateTensor:variable:gradientTensor:name:@
applyStochasticGradientDescentWithLearningRateTensor_variable_gradientTensor_nameSelector :: Selector
applyStochasticGradientDescentWithLearningRateTensor_variable_gradientTensor_nameSelector = mkSelector "applyStochasticGradientDescentWithLearningRateTensor:variable:gradientTensor:name:"

-- | @Selector@ for @adamWithLearningRateTensor:beta1Tensor:beta2Tensor:epsilonTensor:beta1PowerTensor:beta2PowerTensor:valuesTensor:momentumTensor:velocityTensor:maximumVelocityTensor:gradientTensor:name:@
adamWithLearningRateTensor_beta1Tensor_beta2Tensor_epsilonTensor_beta1PowerTensor_beta2PowerTensor_valuesTensor_momentumTensor_velocityTensor_maximumVelocityTensor_gradientTensor_nameSelector :: Selector
adamWithLearningRateTensor_beta1Tensor_beta2Tensor_epsilonTensor_beta1PowerTensor_beta2PowerTensor_valuesTensor_momentumTensor_velocityTensor_maximumVelocityTensor_gradientTensor_nameSelector = mkSelector "adamWithLearningRateTensor:beta1Tensor:beta2Tensor:epsilonTensor:beta1PowerTensor:beta2PowerTensor:valuesTensor:momentumTensor:velocityTensor:maximumVelocityTensor:gradientTensor:name:"

-- | @Selector@ for @adamWithCurrentLearningRateTensor:beta1Tensor:beta2Tensor:epsilonTensor:valuesTensor:momentumTensor:velocityTensor:maximumVelocityTensor:gradientTensor:name:@
adamWithCurrentLearningRateTensor_beta1Tensor_beta2Tensor_epsilonTensor_valuesTensor_momentumTensor_velocityTensor_maximumVelocityTensor_gradientTensor_nameSelector :: Selector
adamWithCurrentLearningRateTensor_beta1Tensor_beta2Tensor_epsilonTensor_valuesTensor_momentumTensor_velocityTensor_maximumVelocityTensor_gradientTensor_nameSelector = mkSelector "adamWithCurrentLearningRateTensor:beta1Tensor:beta2Tensor:epsilonTensor:valuesTensor:momentumTensor:velocityTensor:maximumVelocityTensor:gradientTensor:name:"

-- | @Selector@ for @oneHotWithIndicesTensor:depth:axis:dataType:onValue:offValue:name:@
oneHotWithIndicesTensor_depth_axis_dataType_onValue_offValue_nameSelector :: Selector
oneHotWithIndicesTensor_depth_axis_dataType_onValue_offValue_nameSelector = mkSelector "oneHotWithIndicesTensor:depth:axis:dataType:onValue:offValue:name:"

-- | @Selector@ for @oneHotWithIndicesTensor:depth:dataType:onValue:offValue:name:@
oneHotWithIndicesTensor_depth_dataType_onValue_offValue_nameSelector :: Selector
oneHotWithIndicesTensor_depth_dataType_onValue_offValue_nameSelector = mkSelector "oneHotWithIndicesTensor:depth:dataType:onValue:offValue:name:"

-- | @Selector@ for @oneHotWithIndicesTensor:depth:axis:dataType:name:@
oneHotWithIndicesTensor_depth_axis_dataType_nameSelector :: Selector
oneHotWithIndicesTensor_depth_axis_dataType_nameSelector = mkSelector "oneHotWithIndicesTensor:depth:axis:dataType:name:"

-- | @Selector@ for @oneHotWithIndicesTensor:depth:axis:name:@
oneHotWithIndicesTensor_depth_axis_nameSelector :: Selector
oneHotWithIndicesTensor_depth_axis_nameSelector = mkSelector "oneHotWithIndicesTensor:depth:axis:name:"

-- | @Selector@ for @oneHotWithIndicesTensor:depth:dataType:name:@
oneHotWithIndicesTensor_depth_dataType_nameSelector :: Selector
oneHotWithIndicesTensor_depth_dataType_nameSelector = mkSelector "oneHotWithIndicesTensor:depth:dataType:name:"

-- | @Selector@ for @oneHotWithIndicesTensor:depth:name:@
oneHotWithIndicesTensor_depth_nameSelector :: Selector
oneHotWithIndicesTensor_depth_nameSelector = mkSelector "oneHotWithIndicesTensor:depth:name:"

-- | @Selector@ for @meanOfTensor:axes:name:@
meanOfTensor_axes_nameSelector :: Selector
meanOfTensor_axes_nameSelector = mkSelector "meanOfTensor:axes:name:"

-- | @Selector@ for @varianceOfTensor:meanTensor:axes:name:@
varianceOfTensor_meanTensor_axes_nameSelector :: Selector
varianceOfTensor_meanTensor_axes_nameSelector = mkSelector "varianceOfTensor:meanTensor:axes:name:"

-- | @Selector@ for @varianceOfTensor:axes:name:@
varianceOfTensor_axes_nameSelector :: Selector
varianceOfTensor_axes_nameSelector = mkSelector "varianceOfTensor:axes:name:"

-- | @Selector@ for @normalizationWithTensor:meanTensor:varianceTensor:gammaTensor:betaTensor:epsilon:name:@
normalizationWithTensor_meanTensor_varianceTensor_gammaTensor_betaTensor_epsilon_nameSelector :: Selector
normalizationWithTensor_meanTensor_varianceTensor_gammaTensor_betaTensor_epsilon_nameSelector = mkSelector "normalizationWithTensor:meanTensor:varianceTensor:gammaTensor:betaTensor:epsilon:name:"

-- | @Selector@ for @normalizationGammaGradientWithIncomingGradientTensor:sourceTensor:meanTensor:varianceTensor:reductionAxes:epsilon:name:@
normalizationGammaGradientWithIncomingGradientTensor_sourceTensor_meanTensor_varianceTensor_reductionAxes_epsilon_nameSelector :: Selector
normalizationGammaGradientWithIncomingGradientTensor_sourceTensor_meanTensor_varianceTensor_reductionAxes_epsilon_nameSelector = mkSelector "normalizationGammaGradientWithIncomingGradientTensor:sourceTensor:meanTensor:varianceTensor:reductionAxes:epsilon:name:"

-- | @Selector@ for @normalizationBetaGradientWithIncomingGradientTensor:sourceTensor:reductionAxes:name:@
normalizationBetaGradientWithIncomingGradientTensor_sourceTensor_reductionAxes_nameSelector :: Selector
normalizationBetaGradientWithIncomingGradientTensor_sourceTensor_reductionAxes_nameSelector = mkSelector "normalizationBetaGradientWithIncomingGradientTensor:sourceTensor:reductionAxes:name:"

-- | @Selector@ for @normalizationGradientWithIncomingGradientTensor:sourceTensor:meanTensor:varianceTensor:gammaTensor:gammaGradientTensor:betaGradientTensor:reductionAxes:epsilon:name:@
normalizationGradientWithIncomingGradientTensor_sourceTensor_meanTensor_varianceTensor_gammaTensor_gammaGradientTensor_betaGradientTensor_reductionAxes_epsilon_nameSelector :: Selector
normalizationGradientWithIncomingGradientTensor_sourceTensor_meanTensor_varianceTensor_gammaTensor_gammaGradientTensor_betaGradientTensor_reductionAxes_epsilon_nameSelector = mkSelector "normalizationGradientWithIncomingGradientTensor:sourceTensor:meanTensor:varianceTensor:gammaTensor:gammaGradientTensor:betaGradientTensor:reductionAxes:epsilon:name:"

-- | @Selector@ for @nonZeroIndicesOfTensor:name:@
nonZeroIndicesOfTensor_nameSelector :: Selector
nonZeroIndicesOfTensor_nameSelector = mkSelector "nonZeroIndicesOfTensor:name:"

-- | @Selector@ for @nonMaximumSuppressionWithBoxesTensor:scoresTensor:IOUThreshold:scoreThreshold:perClassSuppression:coordinateMode:name:@
nonMaximumSuppressionWithBoxesTensor_scoresTensor_IOUThreshold_scoreThreshold_perClassSuppression_coordinateMode_nameSelector :: Selector
nonMaximumSuppressionWithBoxesTensor_scoresTensor_IOUThreshold_scoreThreshold_perClassSuppression_coordinateMode_nameSelector = mkSelector "nonMaximumSuppressionWithBoxesTensor:scoresTensor:IOUThreshold:scoreThreshold:perClassSuppression:coordinateMode:name:"

-- | @Selector@ for @nonMaximumSuppressionWithBoxesTensor:scoresTensor:classIndicesTensor:IOUThreshold:scoreThreshold:perClassSuppression:coordinateMode:name:@
nonMaximumSuppressionWithBoxesTensor_scoresTensor_classIndicesTensor_IOUThreshold_scoreThreshold_perClassSuppression_coordinateMode_nameSelector :: Selector
nonMaximumSuppressionWithBoxesTensor_scoresTensor_classIndicesTensor_IOUThreshold_scoreThreshold_perClassSuppression_coordinateMode_nameSelector = mkSelector "nonMaximumSuppressionWithBoxesTensor:scoresTensor:classIndicesTensor:IOUThreshold:scoreThreshold:perClassSuppression:coordinateMode:name:"

-- | @Selector@ for @placeholderWithShape:dataType:name:@
placeholderWithShape_dataType_nameSelector :: Selector
placeholderWithShape_dataType_nameSelector = mkSelector "placeholderWithShape:dataType:name:"

-- | @Selector@ for @placeholderWithShape:name:@
placeholderWithShape_nameSelector :: Selector
placeholderWithShape_nameSelector = mkSelector "placeholderWithShape:name:"

-- | @Selector@ for @constantWithData:shape:dataType:@
constantWithData_shape_dataTypeSelector :: Selector
constantWithData_shape_dataTypeSelector = mkSelector "constantWithData:shape:dataType:"

-- | @Selector@ for @constantWithScalar:dataType:@
constantWithScalar_dataTypeSelector :: Selector
constantWithScalar_dataTypeSelector = mkSelector "constantWithScalar:dataType:"

-- | @Selector@ for @constantWithScalar:shape:dataType:@
constantWithScalar_shape_dataTypeSelector :: Selector
constantWithScalar_shape_dataTypeSelector = mkSelector "constantWithScalar:shape:dataType:"

-- | @Selector@ for @constantWithRealPart:imaginaryPart:@
constantWithRealPart_imaginaryPartSelector :: Selector
constantWithRealPart_imaginaryPartSelector = mkSelector "constantWithRealPart:imaginaryPart:"

-- | @Selector@ for @constantWithRealPart:imaginaryPart:dataType:@
constantWithRealPart_imaginaryPart_dataTypeSelector :: Selector
constantWithRealPart_imaginaryPart_dataTypeSelector = mkSelector "constantWithRealPart:imaginaryPart:dataType:"

-- | @Selector@ for @constantWithRealPart:imaginaryPart:shape:dataType:@
constantWithRealPart_imaginaryPart_shape_dataTypeSelector :: Selector
constantWithRealPart_imaginaryPart_shape_dataTypeSelector = mkSelector "constantWithRealPart:imaginaryPart:shape:dataType:"

-- | @Selector@ for @variableWithData:shape:dataType:name:@
variableWithData_shape_dataType_nameSelector :: Selector
variableWithData_shape_dataType_nameSelector = mkSelector "variableWithData:shape:dataType:name:"

-- | @Selector@ for @variableFromTensorWithTensor:name:@
variableFromTensorWithTensor_nameSelector :: Selector
variableFromTensorWithTensor_nameSelector = mkSelector "variableFromTensorWithTensor:name:"

-- | @Selector@ for @readVariable:name:@
readVariable_nameSelector :: Selector
readVariable_nameSelector = mkSelector "readVariable:name:"

-- | @Selector@ for @assignVariable:withValueOfTensor:name:@
assignVariable_withValueOfTensor_nameSelector :: Selector
assignVariable_withValueOfTensor_nameSelector = mkSelector "assignVariable:withValueOfTensor:name:"

-- | @Selector@ for @matrixMultiplicationWithPrimaryTensor:secondaryTensor:name:@
matrixMultiplicationWithPrimaryTensor_secondaryTensor_nameSelector :: Selector
matrixMultiplicationWithPrimaryTensor_secondaryTensor_nameSelector = mkSelector "matrixMultiplicationWithPrimaryTensor:secondaryTensor:name:"

-- | @Selector@ for @HammingDistanceWithPrimaryTensor:secondaryTensor:resultDataType:name:@
hammingDistanceWithPrimaryTensor_secondaryTensor_resultDataType_nameSelector :: Selector
hammingDistanceWithPrimaryTensor_secondaryTensor_resultDataType_nameSelector = mkSelector "HammingDistanceWithPrimaryTensor:secondaryTensor:resultDataType:name:"

-- | @Selector@ for @scaledDotProductAttentionWithQueryTensor:keyTensor:valueTensor:maskTensor:scale:name:@
scaledDotProductAttentionWithQueryTensor_keyTensor_valueTensor_maskTensor_scale_nameSelector :: Selector
scaledDotProductAttentionWithQueryTensor_keyTensor_valueTensor_maskTensor_scale_nameSelector = mkSelector "scaledDotProductAttentionWithQueryTensor:keyTensor:valueTensor:maskTensor:scale:name:"

-- | @Selector@ for @scaledDotProductAttentionWithQueryTensor:keyTensor:valueTensor:scale:name:@
scaledDotProductAttentionWithQueryTensor_keyTensor_valueTensor_scale_nameSelector :: Selector
scaledDotProductAttentionWithQueryTensor_keyTensor_valueTensor_scale_nameSelector = mkSelector "scaledDotProductAttentionWithQueryTensor:keyTensor:valueTensor:scale:name:"

-- | @Selector@ for @inverseOfTensor:name:@
inverseOfTensor_nameSelector :: Selector
inverseOfTensor_nameSelector = mkSelector "inverseOfTensor:name:"

-- | @Selector@ for @softMaxCrossEntropyWithSourceTensor:labelsTensor:axis:reductionType:name:@
softMaxCrossEntropyWithSourceTensor_labelsTensor_axis_reductionType_nameSelector :: Selector
softMaxCrossEntropyWithSourceTensor_labelsTensor_axis_reductionType_nameSelector = mkSelector "softMaxCrossEntropyWithSourceTensor:labelsTensor:axis:reductionType:name:"

-- | @Selector@ for @softMaxCrossEntropyGradientWithIncomingGradientTensor:sourceTensor:labelsTensor:axis:reductionType:name:@
softMaxCrossEntropyGradientWithIncomingGradientTensor_sourceTensor_labelsTensor_axis_reductionType_nameSelector :: Selector
softMaxCrossEntropyGradientWithIncomingGradientTensor_sourceTensor_labelsTensor_axis_reductionType_nameSelector = mkSelector "softMaxCrossEntropyGradientWithIncomingGradientTensor:sourceTensor:labelsTensor:axis:reductionType:name:"

-- | @Selector@ for @bandPartWithTensor:numLower:numUpper:name:@
bandPartWithTensor_numLower_numUpper_nameSelector :: Selector
bandPartWithTensor_numLower_numUpper_nameSelector = mkSelector "bandPartWithTensor:numLower:numUpper:name:"

-- | @Selector@ for @bandPartWithTensor:numLowerTensor:numUpperTensor:name:@
bandPartWithTensor_numLowerTensor_numUpperTensor_nameSelector :: Selector
bandPartWithTensor_numLowerTensor_numUpperTensor_nameSelector = mkSelector "bandPartWithTensor:numLowerTensor:numUpperTensor:name:"

-- | @Selector@ for @imToColWithSourceTensor:descriptor:name:@
imToColWithSourceTensor_descriptor_nameSelector :: Selector
imToColWithSourceTensor_descriptor_nameSelector = mkSelector "imToColWithSourceTensor:descriptor:name:"

-- | @Selector@ for @colToImWithSourceTensor:outputShape:descriptor:name:@
colToImWithSourceTensor_outputShape_descriptor_nameSelector :: Selector
colToImWithSourceTensor_outputShape_descriptor_nameSelector = mkSelector "colToImWithSourceTensor:outputShape:descriptor:name:"

-- | @Selector@ for @gatherAlongAxis:withUpdatesTensor:indicesTensor:name:@
gatherAlongAxis_withUpdatesTensor_indicesTensor_nameSelector :: Selector
gatherAlongAxis_withUpdatesTensor_indicesTensor_nameSelector = mkSelector "gatherAlongAxis:withUpdatesTensor:indicesTensor:name:"

-- | @Selector@ for @gatherAlongAxisTensor:withUpdatesTensor:indicesTensor:name:@
gatherAlongAxisTensor_withUpdatesTensor_indicesTensor_nameSelector :: Selector
gatherAlongAxisTensor_withUpdatesTensor_indicesTensor_nameSelector = mkSelector "gatherAlongAxisTensor:withUpdatesTensor:indicesTensor:name:"

-- | @Selector@ for @gatherWithUpdatesTensor:indicesTensor:axis:batchDimensions:name:@
gatherWithUpdatesTensor_indicesTensor_axis_batchDimensions_nameSelector :: Selector
gatherWithUpdatesTensor_indicesTensor_axis_batchDimensions_nameSelector = mkSelector "gatherWithUpdatesTensor:indicesTensor:axis:batchDimensions:name:"

-- | @Selector@ for @gatherNDWithUpdatesTensor:indicesTensor:batchDimensions:name:@
gatherNDWithUpdatesTensor_indicesTensor_batchDimensions_nameSelector :: Selector
gatherNDWithUpdatesTensor_indicesTensor_batchDimensions_nameSelector = mkSelector "gatherNDWithUpdatesTensor:indicesTensor:batchDimensions:name:"

-- | @Selector@ for @fastFourierTransformWithTensor:axes:descriptor:name:@
fastFourierTransformWithTensor_axes_descriptor_nameSelector :: Selector
fastFourierTransformWithTensor_axes_descriptor_nameSelector = mkSelector "fastFourierTransformWithTensor:axes:descriptor:name:"

-- | @Selector@ for @fastFourierTransformWithTensor:axesTensor:descriptor:name:@
fastFourierTransformWithTensor_axesTensor_descriptor_nameSelector :: Selector
fastFourierTransformWithTensor_axesTensor_descriptor_nameSelector = mkSelector "fastFourierTransformWithTensor:axesTensor:descriptor:name:"

-- | @Selector@ for @realToHermiteanFFTWithTensor:axes:descriptor:name:@
realToHermiteanFFTWithTensor_axes_descriptor_nameSelector :: Selector
realToHermiteanFFTWithTensor_axes_descriptor_nameSelector = mkSelector "realToHermiteanFFTWithTensor:axes:descriptor:name:"

-- | @Selector@ for @realToHermiteanFFTWithTensor:axesTensor:descriptor:name:@
realToHermiteanFFTWithTensor_axesTensor_descriptor_nameSelector :: Selector
realToHermiteanFFTWithTensor_axesTensor_descriptor_nameSelector = mkSelector "realToHermiteanFFTWithTensor:axesTensor:descriptor:name:"

-- | @Selector@ for @HermiteanToRealFFTWithTensor:axes:descriptor:name:@
hermiteanToRealFFTWithTensor_axes_descriptor_nameSelector :: Selector
hermiteanToRealFFTWithTensor_axes_descriptor_nameSelector = mkSelector "HermiteanToRealFFTWithTensor:axes:descriptor:name:"

-- | @Selector@ for @HermiteanToRealFFTWithTensor:axesTensor:descriptor:name:@
hermiteanToRealFFTWithTensor_axesTensor_descriptor_nameSelector :: Selector
hermiteanToRealFFTWithTensor_axesTensor_descriptor_nameSelector = mkSelector "HermiteanToRealFFTWithTensor:axesTensor:descriptor:name:"

-- | @Selector@ for @depthwiseConvolution2DWithSourceTensor:weightsTensor:descriptor:name:@
depthwiseConvolution2DWithSourceTensor_weightsTensor_descriptor_nameSelector :: Selector
depthwiseConvolution2DWithSourceTensor_weightsTensor_descriptor_nameSelector = mkSelector "depthwiseConvolution2DWithSourceTensor:weightsTensor:descriptor:name:"

-- | @Selector@ for @depthwiseConvolution2DDataGradientWithIncomingGradientTensor:weightsTensor:outputShape:descriptor:name:@
depthwiseConvolution2DDataGradientWithIncomingGradientTensor_weightsTensor_outputShape_descriptor_nameSelector :: Selector
depthwiseConvolution2DDataGradientWithIncomingGradientTensor_weightsTensor_outputShape_descriptor_nameSelector = mkSelector "depthwiseConvolution2DDataGradientWithIncomingGradientTensor:weightsTensor:outputShape:descriptor:name:"

-- | @Selector@ for @depthwiseConvolution2DWeightsGradientWithIncomingGradientTensor:sourceTensor:outputShape:descriptor:name:@
depthwiseConvolution2DWeightsGradientWithIncomingGradientTensor_sourceTensor_outputShape_descriptor_nameSelector :: Selector
depthwiseConvolution2DWeightsGradientWithIncomingGradientTensor_sourceTensor_outputShape_descriptor_nameSelector = mkSelector "depthwiseConvolution2DWeightsGradientWithIncomingGradientTensor:sourceTensor:outputShape:descriptor:name:"

-- | @Selector@ for @depthwiseConvolution3DWithSourceTensor:weightsTensor:descriptor:name:@
depthwiseConvolution3DWithSourceTensor_weightsTensor_descriptor_nameSelector :: Selector
depthwiseConvolution3DWithSourceTensor_weightsTensor_descriptor_nameSelector = mkSelector "depthwiseConvolution3DWithSourceTensor:weightsTensor:descriptor:name:"

-- | @Selector@ for @depthwiseConvolution3DDataGradientWithIncomingGradientTensor:weightsTensor:outputShape:descriptor:name:@
depthwiseConvolution3DDataGradientWithIncomingGradientTensor_weightsTensor_outputShape_descriptor_nameSelector :: Selector
depthwiseConvolution3DDataGradientWithIncomingGradientTensor_weightsTensor_outputShape_descriptor_nameSelector = mkSelector "depthwiseConvolution3DDataGradientWithIncomingGradientTensor:weightsTensor:outputShape:descriptor:name:"

-- | @Selector@ for @depthwiseConvolution3DWeightsGradientWithIncomingGradientTensor:sourceTensor:outputShape:descriptor:name:@
depthwiseConvolution3DWeightsGradientWithIncomingGradientTensor_sourceTensor_outputShape_descriptor_nameSelector :: Selector
depthwiseConvolution3DWeightsGradientWithIncomingGradientTensor_sourceTensor_outputShape_descriptor_nameSelector = mkSelector "depthwiseConvolution3DWeightsGradientWithIncomingGradientTensor:sourceTensor:outputShape:descriptor:name:"

-- | @Selector@ for @cumulativeSumWithTensor:axis:exclusive:reverse:name:@
cumulativeSumWithTensor_axis_exclusive_reverse_nameSelector :: Selector
cumulativeSumWithTensor_axis_exclusive_reverse_nameSelector = mkSelector "cumulativeSumWithTensor:axis:exclusive:reverse:name:"

-- | @Selector@ for @cumulativeSumWithTensor:axisTensor:exclusive:reverse:name:@
cumulativeSumWithTensor_axisTensor_exclusive_reverse_nameSelector :: Selector
cumulativeSumWithTensor_axisTensor_exclusive_reverse_nameSelector = mkSelector "cumulativeSumWithTensor:axisTensor:exclusive:reverse:name:"

-- | @Selector@ for @cumulativeSumWithTensor:axis:name:@
cumulativeSumWithTensor_axis_nameSelector :: Selector
cumulativeSumWithTensor_axis_nameSelector = mkSelector "cumulativeSumWithTensor:axis:name:"

-- | @Selector@ for @cumulativeSumWithTensor:axisTensor:name:@
cumulativeSumWithTensor_axisTensor_nameSelector :: Selector
cumulativeSumWithTensor_axisTensor_nameSelector = mkSelector "cumulativeSumWithTensor:axisTensor:name:"

-- | @Selector@ for @cumulativeProductWithTensor:axis:exclusive:reverse:name:@
cumulativeProductWithTensor_axis_exclusive_reverse_nameSelector :: Selector
cumulativeProductWithTensor_axis_exclusive_reverse_nameSelector = mkSelector "cumulativeProductWithTensor:axis:exclusive:reverse:name:"

-- | @Selector@ for @cumulativeProductWithTensor:axisTensor:exclusive:reverse:name:@
cumulativeProductWithTensor_axisTensor_exclusive_reverse_nameSelector :: Selector
cumulativeProductWithTensor_axisTensor_exclusive_reverse_nameSelector = mkSelector "cumulativeProductWithTensor:axisTensor:exclusive:reverse:name:"

-- | @Selector@ for @cumulativeProductWithTensor:axis:name:@
cumulativeProductWithTensor_axis_nameSelector :: Selector
cumulativeProductWithTensor_axis_nameSelector = mkSelector "cumulativeProductWithTensor:axis:name:"

-- | @Selector@ for @cumulativeProductWithTensor:axisTensor:name:@
cumulativeProductWithTensor_axisTensor_nameSelector :: Selector
cumulativeProductWithTensor_axisTensor_nameSelector = mkSelector "cumulativeProductWithTensor:axisTensor:name:"

-- | @Selector@ for @cumulativeMinimumWithTensor:axis:exclusive:reverse:name:@
cumulativeMinimumWithTensor_axis_exclusive_reverse_nameSelector :: Selector
cumulativeMinimumWithTensor_axis_exclusive_reverse_nameSelector = mkSelector "cumulativeMinimumWithTensor:axis:exclusive:reverse:name:"

-- | @Selector@ for @cumulativeMinimumWithTensor:axisTensor:exclusive:reverse:name:@
cumulativeMinimumWithTensor_axisTensor_exclusive_reverse_nameSelector :: Selector
cumulativeMinimumWithTensor_axisTensor_exclusive_reverse_nameSelector = mkSelector "cumulativeMinimumWithTensor:axisTensor:exclusive:reverse:name:"

-- | @Selector@ for @cumulativeMinimumWithTensor:axis:name:@
cumulativeMinimumWithTensor_axis_nameSelector :: Selector
cumulativeMinimumWithTensor_axis_nameSelector = mkSelector "cumulativeMinimumWithTensor:axis:name:"

-- | @Selector@ for @cumulativeMinimumWithTensor:axisTensor:name:@
cumulativeMinimumWithTensor_axisTensor_nameSelector :: Selector
cumulativeMinimumWithTensor_axisTensor_nameSelector = mkSelector "cumulativeMinimumWithTensor:axisTensor:name:"

-- | @Selector@ for @cumulativeMaximumWithTensor:axis:exclusive:reverse:name:@
cumulativeMaximumWithTensor_axis_exclusive_reverse_nameSelector :: Selector
cumulativeMaximumWithTensor_axis_exclusive_reverse_nameSelector = mkSelector "cumulativeMaximumWithTensor:axis:exclusive:reverse:name:"

-- | @Selector@ for @cumulativeMaximumWithTensor:axisTensor:exclusive:reverse:name:@
cumulativeMaximumWithTensor_axisTensor_exclusive_reverse_nameSelector :: Selector
cumulativeMaximumWithTensor_axisTensor_exclusive_reverse_nameSelector = mkSelector "cumulativeMaximumWithTensor:axisTensor:exclusive:reverse:name:"

-- | @Selector@ for @cumulativeMaximumWithTensor:axis:name:@
cumulativeMaximumWithTensor_axis_nameSelector :: Selector
cumulativeMaximumWithTensor_axis_nameSelector = mkSelector "cumulativeMaximumWithTensor:axis:name:"

-- | @Selector@ for @cumulativeMaximumWithTensor:axisTensor:name:@
cumulativeMaximumWithTensor_axisTensor_nameSelector :: Selector
cumulativeMaximumWithTensor_axisTensor_nameSelector = mkSelector "cumulativeMaximumWithTensor:axisTensor:name:"

-- | @Selector@ for @controlDependencyWithOperations:dependentBlock:name:@
controlDependencyWithOperations_dependentBlock_nameSelector :: Selector
controlDependencyWithOperations_dependentBlock_nameSelector = mkSelector "controlDependencyWithOperations:dependentBlock:name:"

-- | @Selector@ for @ifWithPredicateTensor:thenBlock:elseBlock:name:@
ifWithPredicateTensor_thenBlock_elseBlock_nameSelector :: Selector
ifWithPredicateTensor_thenBlock_elseBlock_nameSelector = mkSelector "ifWithPredicateTensor:thenBlock:elseBlock:name:"

-- | @Selector@ for @whileWithInitialInputs:before:after:name:@
whileWithInitialInputs_before_after_nameSelector :: Selector
whileWithInitialInputs_before_after_nameSelector = mkSelector "whileWithInitialInputs:before:after:name:"

-- | @Selector@ for @forLoopWithLowerBound:upperBound:step:initialBodyArguments:body:name:@
forLoopWithLowerBound_upperBound_step_initialBodyArguments_body_nameSelector :: Selector
forLoopWithLowerBound_upperBound_step_initialBodyArguments_body_nameSelector = mkSelector "forLoopWithLowerBound:upperBound:step:initialBodyArguments:body:name:"

-- | @Selector@ for @forLoopWithNumberOfIterations:initialBodyArguments:body:name:@
forLoopWithNumberOfIterations_initialBodyArguments_body_nameSelector :: Selector
forLoopWithNumberOfIterations_initialBodyArguments_body_nameSelector = mkSelector "forLoopWithNumberOfIterations:initialBodyArguments:body:name:"

-- | @Selector@ for @convolutionTranspose2DWithSourceTensor:weightsTensor:outputShape:descriptor:name:@
convolutionTranspose2DWithSourceTensor_weightsTensor_outputShape_descriptor_nameSelector :: Selector
convolutionTranspose2DWithSourceTensor_weightsTensor_outputShape_descriptor_nameSelector = mkSelector "convolutionTranspose2DWithSourceTensor:weightsTensor:outputShape:descriptor:name:"

-- | @Selector@ for @convolutionTranspose2DWithSourceTensor:weightsTensor:outputShapeTensor:descriptor:name:@
convolutionTranspose2DWithSourceTensor_weightsTensor_outputShapeTensor_descriptor_nameSelector :: Selector
convolutionTranspose2DWithSourceTensor_weightsTensor_outputShapeTensor_descriptor_nameSelector = mkSelector "convolutionTranspose2DWithSourceTensor:weightsTensor:outputShapeTensor:descriptor:name:"

-- | @Selector@ for @convolutionTranspose2DDataGradientWithIncomingGradientTensor:weightsTensor:outputShape:forwardConvolutionDescriptor:name:@
convolutionTranspose2DDataGradientWithIncomingGradientTensor_weightsTensor_outputShape_forwardConvolutionDescriptor_nameSelector :: Selector
convolutionTranspose2DDataGradientWithIncomingGradientTensor_weightsTensor_outputShape_forwardConvolutionDescriptor_nameSelector = mkSelector "convolutionTranspose2DDataGradientWithIncomingGradientTensor:weightsTensor:outputShape:forwardConvolutionDescriptor:name:"

-- | @Selector@ for @convolutionTranspose2DDataGradientWithIncomingGradientTensor:weightsTensor:outputShapeTensor:forwardConvolutionDescriptor:name:@
convolutionTranspose2DDataGradientWithIncomingGradientTensor_weightsTensor_outputShapeTensor_forwardConvolutionDescriptor_nameSelector :: Selector
convolutionTranspose2DDataGradientWithIncomingGradientTensor_weightsTensor_outputShapeTensor_forwardConvolutionDescriptor_nameSelector = mkSelector "convolutionTranspose2DDataGradientWithIncomingGradientTensor:weightsTensor:outputShapeTensor:forwardConvolutionDescriptor:name:"

-- | @Selector@ for @convolutionTranspose2DWeightsGradientWithIncomingGradientTensor:sourceTensor:outputShape:forwardConvolutionDescriptor:name:@
convolutionTranspose2DWeightsGradientWithIncomingGradientTensor_sourceTensor_outputShape_forwardConvolutionDescriptor_nameSelector :: Selector
convolutionTranspose2DWeightsGradientWithIncomingGradientTensor_sourceTensor_outputShape_forwardConvolutionDescriptor_nameSelector = mkSelector "convolutionTranspose2DWeightsGradientWithIncomingGradientTensor:sourceTensor:outputShape:forwardConvolutionDescriptor:name:"

-- | @Selector@ for @convolutionTranspose2DWeightsGradientWithIncomingGradientTensor:sourceTensor:outputShapeTensor:forwardConvolutionDescriptor:name:@
convolutionTranspose2DWeightsGradientWithIncomingGradientTensor_sourceTensor_outputShapeTensor_forwardConvolutionDescriptor_nameSelector :: Selector
convolutionTranspose2DWeightsGradientWithIncomingGradientTensor_sourceTensor_outputShapeTensor_forwardConvolutionDescriptor_nameSelector = mkSelector "convolutionTranspose2DWeightsGradientWithIncomingGradientTensor:sourceTensor:outputShapeTensor:forwardConvolutionDescriptor:name:"

-- | @Selector@ for @convolution2DWithSourceTensor:weightsTensor:descriptor:name:@
convolution2DWithSourceTensor_weightsTensor_descriptor_nameSelector :: Selector
convolution2DWithSourceTensor_weightsTensor_descriptor_nameSelector = mkSelector "convolution2DWithSourceTensor:weightsTensor:descriptor:name:"

-- | @Selector@ for @convolution2DDataGradientWithIncomingGradientTensor:weightsTensor:outputShape:forwardConvolutionDescriptor:name:@
convolution2DDataGradientWithIncomingGradientTensor_weightsTensor_outputShape_forwardConvolutionDescriptor_nameSelector :: Selector
convolution2DDataGradientWithIncomingGradientTensor_weightsTensor_outputShape_forwardConvolutionDescriptor_nameSelector = mkSelector "convolution2DDataGradientWithIncomingGradientTensor:weightsTensor:outputShape:forwardConvolutionDescriptor:name:"

-- | @Selector@ for @convolution2DDataGradientWithIncomingGradientTensor:weightsTensor:outputShapeTensor:forwardConvolutionDescriptor:name:@
convolution2DDataGradientWithIncomingGradientTensor_weightsTensor_outputShapeTensor_forwardConvolutionDescriptor_nameSelector :: Selector
convolution2DDataGradientWithIncomingGradientTensor_weightsTensor_outputShapeTensor_forwardConvolutionDescriptor_nameSelector = mkSelector "convolution2DDataGradientWithIncomingGradientTensor:weightsTensor:outputShapeTensor:forwardConvolutionDescriptor:name:"

-- | @Selector@ for @convolution2DWeightsGradientWithIncomingGradientTensor:sourceTensor:outputShape:forwardConvolutionDescriptor:name:@
convolution2DWeightsGradientWithIncomingGradientTensor_sourceTensor_outputShape_forwardConvolutionDescriptor_nameSelector :: Selector
convolution2DWeightsGradientWithIncomingGradientTensor_sourceTensor_outputShape_forwardConvolutionDescriptor_nameSelector = mkSelector "convolution2DWeightsGradientWithIncomingGradientTensor:sourceTensor:outputShape:forwardConvolutionDescriptor:name:"

-- | @Selector@ for @convolution2DWeightsGradientWithIncomingGradientTensor:sourceTensor:outputShapeTensor:forwardConvolutionDescriptor:name:@
convolution2DWeightsGradientWithIncomingGradientTensor_sourceTensor_outputShapeTensor_forwardConvolutionDescriptor_nameSelector :: Selector
convolution2DWeightsGradientWithIncomingGradientTensor_sourceTensor_outputShapeTensor_forwardConvolutionDescriptor_nameSelector = mkSelector "convolution2DWeightsGradientWithIncomingGradientTensor:sourceTensor:outputShapeTensor:forwardConvolutionDescriptor:name:"

-- | @Selector@ for @convolution3DWithSourceTensor:weightsTensor:descriptor:name:@
convolution3DWithSourceTensor_weightsTensor_descriptor_nameSelector :: Selector
convolution3DWithSourceTensor_weightsTensor_descriptor_nameSelector = mkSelector "convolution3DWithSourceTensor:weightsTensor:descriptor:name:"

-- | @Selector@ for @convolution3DDataGradientWithIncomingGradientTensor:weightsTensor:outputShape:forwardConvolutionDescriptor:name:@
convolution3DDataGradientWithIncomingGradientTensor_weightsTensor_outputShape_forwardConvolutionDescriptor_nameSelector :: Selector
convolution3DDataGradientWithIncomingGradientTensor_weightsTensor_outputShape_forwardConvolutionDescriptor_nameSelector = mkSelector "convolution3DDataGradientWithIncomingGradientTensor:weightsTensor:outputShape:forwardConvolutionDescriptor:name:"

-- | @Selector@ for @convolution3DDataGradientWithIncomingGradientTensor:weightsTensor:outputShapeTensor:forwardConvolutionDescriptor:name:@
convolution3DDataGradientWithIncomingGradientTensor_weightsTensor_outputShapeTensor_forwardConvolutionDescriptor_nameSelector :: Selector
convolution3DDataGradientWithIncomingGradientTensor_weightsTensor_outputShapeTensor_forwardConvolutionDescriptor_nameSelector = mkSelector "convolution3DDataGradientWithIncomingGradientTensor:weightsTensor:outputShapeTensor:forwardConvolutionDescriptor:name:"

-- | @Selector@ for @convolution3DWeightsGradientWithIncomingGradientTensor:sourceTensor:outputShape:forwardConvolutionDescriptor:name:@
convolution3DWeightsGradientWithIncomingGradientTensor_sourceTensor_outputShape_forwardConvolutionDescriptor_nameSelector :: Selector
convolution3DWeightsGradientWithIncomingGradientTensor_sourceTensor_outputShape_forwardConvolutionDescriptor_nameSelector = mkSelector "convolution3DWeightsGradientWithIncomingGradientTensor:sourceTensor:outputShape:forwardConvolutionDescriptor:name:"

-- | @Selector@ for @convolution3DWeightsGradientWithIncomingGradientTensor:sourceTensor:outputShapeTensor:forwardConvolutionDescriptor:name:@
convolution3DWeightsGradientWithIncomingGradientTensor_sourceTensor_outputShapeTensor_forwardConvolutionDescriptor_nameSelector :: Selector
convolution3DWeightsGradientWithIncomingGradientTensor_sourceTensor_outputShapeTensor_forwardConvolutionDescriptor_nameSelector = mkSelector "convolution3DWeightsGradientWithIncomingGradientTensor:sourceTensor:outputShapeTensor:forwardConvolutionDescriptor:name:"

-- | @Selector@ for @callSymbolName:inputTensors:outputTypes:name:@
callSymbolName_inputTensors_outputTypes_nameSelector :: Selector
callSymbolName_inputTensors_outputTypes_nameSelector = mkSelector "callSymbolName:inputTensors:outputTypes:name:"

-- | @Selector@ for @identityWithTensor:name:@
identityWithTensor_nameSelector :: Selector
identityWithTensor_nameSelector = mkSelector "identityWithTensor:name:"

-- | @Selector@ for @exponentWithTensor:name:@
exponentWithTensor_nameSelector :: Selector
exponentWithTensor_nameSelector = mkSelector "exponentWithTensor:name:"

-- | @Selector@ for @exponentBase2WithTensor:name:@
exponentBase2WithTensor_nameSelector :: Selector
exponentBase2WithTensor_nameSelector = mkSelector "exponentBase2WithTensor:name:"

-- | @Selector@ for @exponentBase10WithTensor:name:@
exponentBase10WithTensor_nameSelector :: Selector
exponentBase10WithTensor_nameSelector = mkSelector "exponentBase10WithTensor:name:"

-- | @Selector@ for @logarithmWithTensor:name:@
logarithmWithTensor_nameSelector :: Selector
logarithmWithTensor_nameSelector = mkSelector "logarithmWithTensor:name:"

-- | @Selector@ for @logarithmBase2WithTensor:name:@
logarithmBase2WithTensor_nameSelector :: Selector
logarithmBase2WithTensor_nameSelector = mkSelector "logarithmBase2WithTensor:name:"

-- | @Selector@ for @logarithmBase10WithTensor:name:@
logarithmBase10WithTensor_nameSelector :: Selector
logarithmBase10WithTensor_nameSelector = mkSelector "logarithmBase10WithTensor:name:"

-- | @Selector@ for @squareWithTensor:name:@
squareWithTensor_nameSelector :: Selector
squareWithTensor_nameSelector = mkSelector "squareWithTensor:name:"

-- | @Selector@ for @squareRootWithTensor:name:@
squareRootWithTensor_nameSelector :: Selector
squareRootWithTensor_nameSelector = mkSelector "squareRootWithTensor:name:"

-- | @Selector@ for @reciprocalSquareRootWithTensor:name:@
reciprocalSquareRootWithTensor_nameSelector :: Selector
reciprocalSquareRootWithTensor_nameSelector = mkSelector "reciprocalSquareRootWithTensor:name:"

-- | @Selector@ for @reverseSquareRootWithTensor:name:@
reverseSquareRootWithTensor_nameSelector :: Selector
reverseSquareRootWithTensor_nameSelector = mkSelector "reverseSquareRootWithTensor:name:"

-- | @Selector@ for @reciprocalWithTensor:name:@
reciprocalWithTensor_nameSelector :: Selector
reciprocalWithTensor_nameSelector = mkSelector "reciprocalWithTensor:name:"

-- | @Selector@ for @absoluteWithTensor:name:@
absoluteWithTensor_nameSelector :: Selector
absoluteWithTensor_nameSelector = mkSelector "absoluteWithTensor:name:"

-- | @Selector@ for @absoluteSquareWithTensor:name:@
absoluteSquareWithTensor_nameSelector :: Selector
absoluteSquareWithTensor_nameSelector = mkSelector "absoluteSquareWithTensor:name:"

-- | @Selector@ for @negativeWithTensor:name:@
negativeWithTensor_nameSelector :: Selector
negativeWithTensor_nameSelector = mkSelector "negativeWithTensor:name:"

-- | @Selector@ for @signWithTensor:name:@
signWithTensor_nameSelector :: Selector
signWithTensor_nameSelector = mkSelector "signWithTensor:name:"

-- | @Selector@ for @signbitWithTensor:name:@
signbitWithTensor_nameSelector :: Selector
signbitWithTensor_nameSelector = mkSelector "signbitWithTensor:name:"

-- | @Selector@ for @ceilWithTensor:name:@
ceilWithTensor_nameSelector :: Selector
ceilWithTensor_nameSelector = mkSelector "ceilWithTensor:name:"

-- | @Selector@ for @floorWithTensor:name:@
floorWithTensor_nameSelector :: Selector
floorWithTensor_nameSelector = mkSelector "floorWithTensor:name:"

-- | @Selector@ for @roundWithTensor:name:@
roundWithTensor_nameSelector :: Selector
roundWithTensor_nameSelector = mkSelector "roundWithTensor:name:"

-- | @Selector@ for @rintWithTensor:name:@
rintWithTensor_nameSelector :: Selector
rintWithTensor_nameSelector = mkSelector "rintWithTensor:name:"

-- | @Selector@ for @sinWithTensor:name:@
sinWithTensor_nameSelector :: Selector
sinWithTensor_nameSelector = mkSelector "sinWithTensor:name:"

-- | @Selector@ for @cosWithTensor:name:@
cosWithTensor_nameSelector :: Selector
cosWithTensor_nameSelector = mkSelector "cosWithTensor:name:"

-- | @Selector@ for @tanWithTensor:name:@
tanWithTensor_nameSelector :: Selector
tanWithTensor_nameSelector = mkSelector "tanWithTensor:name:"

-- | @Selector@ for @sinhWithTensor:name:@
sinhWithTensor_nameSelector :: Selector
sinhWithTensor_nameSelector = mkSelector "sinhWithTensor:name:"

-- | @Selector@ for @coshWithTensor:name:@
coshWithTensor_nameSelector :: Selector
coshWithTensor_nameSelector = mkSelector "coshWithTensor:name:"

-- | @Selector@ for @tanhWithTensor:name:@
tanhWithTensor_nameSelector :: Selector
tanhWithTensor_nameSelector = mkSelector "tanhWithTensor:name:"

-- | @Selector@ for @asinWithTensor:name:@
asinWithTensor_nameSelector :: Selector
asinWithTensor_nameSelector = mkSelector "asinWithTensor:name:"

-- | @Selector@ for @acosWithTensor:name:@
acosWithTensor_nameSelector :: Selector
acosWithTensor_nameSelector = mkSelector "acosWithTensor:name:"

-- | @Selector@ for @atanWithTensor:name:@
atanWithTensor_nameSelector :: Selector
atanWithTensor_nameSelector = mkSelector "atanWithTensor:name:"

-- | @Selector@ for @asinhWithTensor:name:@
asinhWithTensor_nameSelector :: Selector
asinhWithTensor_nameSelector = mkSelector "asinhWithTensor:name:"

-- | @Selector@ for @acoshWithTensor:name:@
acoshWithTensor_nameSelector :: Selector
acoshWithTensor_nameSelector = mkSelector "acoshWithTensor:name:"

-- | @Selector@ for @atanhWithTensor:name:@
atanhWithTensor_nameSelector :: Selector
atanhWithTensor_nameSelector = mkSelector "atanhWithTensor:name:"

-- | @Selector@ for @notWithTensor:name:@
notWithTensor_nameSelector :: Selector
notWithTensor_nameSelector = mkSelector "notWithTensor:name:"

-- | @Selector@ for @isInfiniteWithTensor:name:@
isInfiniteWithTensor_nameSelector :: Selector
isInfiniteWithTensor_nameSelector = mkSelector "isInfiniteWithTensor:name:"

-- | @Selector@ for @isFiniteWithTensor:name:@
isFiniteWithTensor_nameSelector :: Selector
isFiniteWithTensor_nameSelector = mkSelector "isFiniteWithTensor:name:"

-- | @Selector@ for @isNaNWithTensor:name:@
isNaNWithTensor_nameSelector :: Selector
isNaNWithTensor_nameSelector = mkSelector "isNaNWithTensor:name:"

-- | @Selector@ for @erfWithTensor:name:@
erfWithTensor_nameSelector :: Selector
erfWithTensor_nameSelector = mkSelector "erfWithTensor:name:"

-- | @Selector@ for @truncateWithTensor:name:@
truncateWithTensor_nameSelector :: Selector
truncateWithTensor_nameSelector = mkSelector "truncateWithTensor:name:"

-- | @Selector@ for @bitwiseNOTWithTensor:name:@
bitwiseNOTWithTensor_nameSelector :: Selector
bitwiseNOTWithTensor_nameSelector = mkSelector "bitwiseNOTWithTensor:name:"

-- | @Selector@ for @bitwisePopulationCountWithTensor:name:@
bitwisePopulationCountWithTensor_nameSelector :: Selector
bitwisePopulationCountWithTensor_nameSelector = mkSelector "bitwisePopulationCountWithTensor:name:"

-- | @Selector@ for @conjugateWithTensor:name:@
conjugateWithTensor_nameSelector :: Selector
conjugateWithTensor_nameSelector = mkSelector "conjugateWithTensor:name:"

-- | @Selector@ for @additionWithPrimaryTensor:secondaryTensor:name:@
additionWithPrimaryTensor_secondaryTensor_nameSelector :: Selector
additionWithPrimaryTensor_secondaryTensor_nameSelector = mkSelector "additionWithPrimaryTensor:secondaryTensor:name:"

-- | @Selector@ for @subtractionWithPrimaryTensor:secondaryTensor:name:@
subtractionWithPrimaryTensor_secondaryTensor_nameSelector :: Selector
subtractionWithPrimaryTensor_secondaryTensor_nameSelector = mkSelector "subtractionWithPrimaryTensor:secondaryTensor:name:"

-- | @Selector@ for @multiplicationWithPrimaryTensor:secondaryTensor:name:@
multiplicationWithPrimaryTensor_secondaryTensor_nameSelector :: Selector
multiplicationWithPrimaryTensor_secondaryTensor_nameSelector = mkSelector "multiplicationWithPrimaryTensor:secondaryTensor:name:"

-- | @Selector@ for @divisionWithPrimaryTensor:secondaryTensor:name:@
divisionWithPrimaryTensor_secondaryTensor_nameSelector :: Selector
divisionWithPrimaryTensor_secondaryTensor_nameSelector = mkSelector "divisionWithPrimaryTensor:secondaryTensor:name:"

-- | @Selector@ for @moduloWithPrimaryTensor:secondaryTensor:name:@
moduloWithPrimaryTensor_secondaryTensor_nameSelector :: Selector
moduloWithPrimaryTensor_secondaryTensor_nameSelector = mkSelector "moduloWithPrimaryTensor:secondaryTensor:name:"

-- | @Selector@ for @powerWithPrimaryTensor:secondaryTensor:name:@
powerWithPrimaryTensor_secondaryTensor_nameSelector :: Selector
powerWithPrimaryTensor_secondaryTensor_nameSelector = mkSelector "powerWithPrimaryTensor:secondaryTensor:name:"

-- | @Selector@ for @minimumWithPrimaryTensor:secondaryTensor:name:@
minimumWithPrimaryTensor_secondaryTensor_nameSelector :: Selector
minimumWithPrimaryTensor_secondaryTensor_nameSelector = mkSelector "minimumWithPrimaryTensor:secondaryTensor:name:"

-- | @Selector@ for @maximumWithPrimaryTensor:secondaryTensor:name:@
maximumWithPrimaryTensor_secondaryTensor_nameSelector :: Selector
maximumWithPrimaryTensor_secondaryTensor_nameSelector = mkSelector "maximumWithPrimaryTensor:secondaryTensor:name:"

-- | @Selector@ for @minimumWithNaNPropagationWithPrimaryTensor:secondaryTensor:name:@
minimumWithNaNPropagationWithPrimaryTensor_secondaryTensor_nameSelector :: Selector
minimumWithNaNPropagationWithPrimaryTensor_secondaryTensor_nameSelector = mkSelector "minimumWithNaNPropagationWithPrimaryTensor:secondaryTensor:name:"

-- | @Selector@ for @maximumWithNaNPropagationWithPrimaryTensor:secondaryTensor:name:@
maximumWithNaNPropagationWithPrimaryTensor_secondaryTensor_nameSelector :: Selector
maximumWithNaNPropagationWithPrimaryTensor_secondaryTensor_nameSelector = mkSelector "maximumWithNaNPropagationWithPrimaryTensor:secondaryTensor:name:"

-- | @Selector@ for @equalWithPrimaryTensor:secondaryTensor:name:@
equalWithPrimaryTensor_secondaryTensor_nameSelector :: Selector
equalWithPrimaryTensor_secondaryTensor_nameSelector = mkSelector "equalWithPrimaryTensor:secondaryTensor:name:"

-- | @Selector@ for @notEqualWithPrimaryTensor:secondaryTensor:name:@
notEqualWithPrimaryTensor_secondaryTensor_nameSelector :: Selector
notEqualWithPrimaryTensor_secondaryTensor_nameSelector = mkSelector "notEqualWithPrimaryTensor:secondaryTensor:name:"

-- | @Selector@ for @lessThanWithPrimaryTensor:secondaryTensor:name:@
lessThanWithPrimaryTensor_secondaryTensor_nameSelector :: Selector
lessThanWithPrimaryTensor_secondaryTensor_nameSelector = mkSelector "lessThanWithPrimaryTensor:secondaryTensor:name:"

-- | @Selector@ for @lessThanOrEqualToWithPrimaryTensor:secondaryTensor:name:@
lessThanOrEqualToWithPrimaryTensor_secondaryTensor_nameSelector :: Selector
lessThanOrEqualToWithPrimaryTensor_secondaryTensor_nameSelector = mkSelector "lessThanOrEqualToWithPrimaryTensor:secondaryTensor:name:"

-- | @Selector@ for @greaterThanWithPrimaryTensor:secondaryTensor:name:@
greaterThanWithPrimaryTensor_secondaryTensor_nameSelector :: Selector
greaterThanWithPrimaryTensor_secondaryTensor_nameSelector = mkSelector "greaterThanWithPrimaryTensor:secondaryTensor:name:"

-- | @Selector@ for @greaterThanOrEqualToWithPrimaryTensor:secondaryTensor:name:@
greaterThanOrEqualToWithPrimaryTensor_secondaryTensor_nameSelector :: Selector
greaterThanOrEqualToWithPrimaryTensor_secondaryTensor_nameSelector = mkSelector "greaterThanOrEqualToWithPrimaryTensor:secondaryTensor:name:"

-- | @Selector@ for @logicalANDWithPrimaryTensor:secondaryTensor:name:@
logicalANDWithPrimaryTensor_secondaryTensor_nameSelector :: Selector
logicalANDWithPrimaryTensor_secondaryTensor_nameSelector = mkSelector "logicalANDWithPrimaryTensor:secondaryTensor:name:"

-- | @Selector@ for @logicalORWithPrimaryTensor:secondaryTensor:name:@
logicalORWithPrimaryTensor_secondaryTensor_nameSelector :: Selector
logicalORWithPrimaryTensor_secondaryTensor_nameSelector = mkSelector "logicalORWithPrimaryTensor:secondaryTensor:name:"

-- | @Selector@ for @logicalNANDWithPrimaryTensor:secondaryTensor:name:@
logicalNANDWithPrimaryTensor_secondaryTensor_nameSelector :: Selector
logicalNANDWithPrimaryTensor_secondaryTensor_nameSelector = mkSelector "logicalNANDWithPrimaryTensor:secondaryTensor:name:"

-- | @Selector@ for @logicalNORWithPrimaryTensor:secondaryTensor:name:@
logicalNORWithPrimaryTensor_secondaryTensor_nameSelector :: Selector
logicalNORWithPrimaryTensor_secondaryTensor_nameSelector = mkSelector "logicalNORWithPrimaryTensor:secondaryTensor:name:"

-- | @Selector@ for @logicalXORWithPrimaryTensor:secondaryTensor:name:@
logicalXORWithPrimaryTensor_secondaryTensor_nameSelector :: Selector
logicalXORWithPrimaryTensor_secondaryTensor_nameSelector = mkSelector "logicalXORWithPrimaryTensor:secondaryTensor:name:"

-- | @Selector@ for @logicalXNORWithPrimaryTensor:secondaryTensor:name:@
logicalXNORWithPrimaryTensor_secondaryTensor_nameSelector :: Selector
logicalXNORWithPrimaryTensor_secondaryTensor_nameSelector = mkSelector "logicalXNORWithPrimaryTensor:secondaryTensor:name:"

-- | @Selector@ for @atan2WithPrimaryTensor:secondaryTensor:name:@
atan2WithPrimaryTensor_secondaryTensor_nameSelector :: Selector
atan2WithPrimaryTensor_secondaryTensor_nameSelector = mkSelector "atan2WithPrimaryTensor:secondaryTensor:name:"

-- | @Selector@ for @bitwiseANDWithPrimaryTensor:secondaryTensor:name:@
bitwiseANDWithPrimaryTensor_secondaryTensor_nameSelector :: Selector
bitwiseANDWithPrimaryTensor_secondaryTensor_nameSelector = mkSelector "bitwiseANDWithPrimaryTensor:secondaryTensor:name:"

-- | @Selector@ for @bitwiseORWithPrimaryTensor:secondaryTensor:name:@
bitwiseORWithPrimaryTensor_secondaryTensor_nameSelector :: Selector
bitwiseORWithPrimaryTensor_secondaryTensor_nameSelector = mkSelector "bitwiseORWithPrimaryTensor:secondaryTensor:name:"

-- | @Selector@ for @bitwiseXORWithPrimaryTensor:secondaryTensor:name:@
bitwiseXORWithPrimaryTensor_secondaryTensor_nameSelector :: Selector
bitwiseXORWithPrimaryTensor_secondaryTensor_nameSelector = mkSelector "bitwiseXORWithPrimaryTensor:secondaryTensor:name:"

-- | @Selector@ for @bitwiseLeftShiftWithPrimaryTensor:secondaryTensor:name:@
bitwiseLeftShiftWithPrimaryTensor_secondaryTensor_nameSelector :: Selector
bitwiseLeftShiftWithPrimaryTensor_secondaryTensor_nameSelector = mkSelector "bitwiseLeftShiftWithPrimaryTensor:secondaryTensor:name:"

-- | @Selector@ for @bitwiseRightShiftWithPrimaryTensor:secondaryTensor:name:@
bitwiseRightShiftWithPrimaryTensor_secondaryTensor_nameSelector :: Selector
bitwiseRightShiftWithPrimaryTensor_secondaryTensor_nameSelector = mkSelector "bitwiseRightShiftWithPrimaryTensor:secondaryTensor:name:"

-- | @Selector@ for @selectWithPredicateTensor:truePredicateTensor:falsePredicateTensor:name:@
selectWithPredicateTensor_truePredicateTensor_falsePredicateTensor_nameSelector :: Selector
selectWithPredicateTensor_truePredicateTensor_falsePredicateTensor_nameSelector = mkSelector "selectWithPredicateTensor:truePredicateTensor:falsePredicateTensor:name:"

-- | @Selector@ for @clampWithTensor:minValueTensor:maxValueTensor:name:@
clampWithTensor_minValueTensor_maxValueTensor_nameSelector :: Selector
clampWithTensor_minValueTensor_maxValueTensor_nameSelector = mkSelector "clampWithTensor:minValueTensor:maxValueTensor:name:"

-- | @Selector@ for @divisionNoNaNWithPrimaryTensor:secondaryTensor:name:@
divisionNoNaNWithPrimaryTensor_secondaryTensor_nameSelector :: Selector
divisionNoNaNWithPrimaryTensor_secondaryTensor_nameSelector = mkSelector "divisionNoNaNWithPrimaryTensor:secondaryTensor:name:"

-- | @Selector@ for @floorModuloWithPrimaryTensor:secondaryTensor:name:@
floorModuloWithPrimaryTensor_secondaryTensor_nameSelector :: Selector
floorModuloWithPrimaryTensor_secondaryTensor_nameSelector = mkSelector "floorModuloWithPrimaryTensor:secondaryTensor:name:"

-- | @Selector@ for @realPartOfTensor:name:@
realPartOfTensor_nameSelector :: Selector
realPartOfTensor_nameSelector = mkSelector "realPartOfTensor:name:"

-- | @Selector@ for @imaginaryPartOfTensor:name:@
imaginaryPartOfTensor_nameSelector :: Selector
imaginaryPartOfTensor_nameSelector = mkSelector "imaginaryPartOfTensor:name:"

-- | @Selector@ for @complexTensorWithRealTensor:imaginaryTensor:name:@
complexTensorWithRealTensor_imaginaryTensor_nameSelector :: Selector
complexTensorWithRealTensor_imaginaryTensor_nameSelector = mkSelector "complexTensorWithRealTensor:imaginaryTensor:name:"

-- | @Selector@ for @reLUWithTensor:name:@
reLUWithTensor_nameSelector :: Selector
reLUWithTensor_nameSelector = mkSelector "reLUWithTensor:name:"

-- | @Selector@ for @reLUGradientWithIncomingGradient:sourceTensor:name:@
reLUGradientWithIncomingGradient_sourceTensor_nameSelector :: Selector
reLUGradientWithIncomingGradient_sourceTensor_nameSelector = mkSelector "reLUGradientWithIncomingGradient:sourceTensor:name:"

-- | @Selector@ for @sigmoidWithTensor:name:@
sigmoidWithTensor_nameSelector :: Selector
sigmoidWithTensor_nameSelector = mkSelector "sigmoidWithTensor:name:"

-- | @Selector@ for @sigmoidGradientWithIncomingGradient:sourceTensor:name:@
sigmoidGradientWithIncomingGradient_sourceTensor_nameSelector :: Selector
sigmoidGradientWithIncomingGradient_sourceTensor_nameSelector = mkSelector "sigmoidGradientWithIncomingGradient:sourceTensor:name:"

-- | @Selector@ for @softMaxWithTensor:axis:name:@
softMaxWithTensor_axis_nameSelector :: Selector
softMaxWithTensor_axis_nameSelector = mkSelector "softMaxWithTensor:axis:name:"

-- | @Selector@ for @softMaxGradientWithIncomingGradient:sourceTensor:axis:name:@
softMaxGradientWithIncomingGradient_sourceTensor_axis_nameSelector :: Selector
softMaxGradientWithIncomingGradient_sourceTensor_axis_nameSelector = mkSelector "softMaxGradientWithIncomingGradient:sourceTensor:axis:name:"

-- | @Selector@ for @leakyReLUWithTensor:alpha:name:@
leakyReLUWithTensor_alpha_nameSelector :: Selector
leakyReLUWithTensor_alpha_nameSelector = mkSelector "leakyReLUWithTensor:alpha:name:"

-- | @Selector@ for @leakyReLUWithTensor:alphaTensor:name:@
leakyReLUWithTensor_alphaTensor_nameSelector :: Selector
leakyReLUWithTensor_alphaTensor_nameSelector = mkSelector "leakyReLUWithTensor:alphaTensor:name:"

-- | @Selector@ for @leakyReLUGradientWithIncomingGradient:sourceTensor:alphaTensor:name:@
leakyReLUGradientWithIncomingGradient_sourceTensor_alphaTensor_nameSelector :: Selector
leakyReLUGradientWithIncomingGradient_sourceTensor_alphaTensor_nameSelector = mkSelector "leakyReLUGradientWithIncomingGradient:sourceTensor:alphaTensor:name:"

-- | @Selector@ for @gradientForPrimaryTensor:withTensors:name:@
gradientForPrimaryTensor_withTensors_nameSelector :: Selector
gradientForPrimaryTensor_withTensors_nameSelector = mkSelector "gradientForPrimaryTensor:withTensors:name:"

-- | @Selector@ for @options@
optionsSelector :: Selector
optionsSelector = mkSelector "options"

-- | @Selector@ for @setOptions:@
setOptionsSelector :: Selector
setOptionsSelector = mkSelector "setOptions:"

-- | @Selector@ for @placeholderTensors@
placeholderTensorsSelector :: Selector
placeholderTensorsSelector = mkSelector "placeholderTensors"

