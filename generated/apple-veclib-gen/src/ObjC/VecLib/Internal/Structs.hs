{-# LANGUAGE RecordWildCards #-}
{-# LANGUAGE TypeFamilies #-}

-- | Struct types for this framework.
--
-- Generated by objc-codegen. Do not edit.
module ObjC.VecLib.Internal.Structs where

import Foreign.Ptr (Ptr, FunPtr)
import Foreign.Storable (Storable(..))
import Foreign.C.Types
import Foreign.LibFFI.Base (Arg, RetType, mkStorableArg, mkStorableRetType, newStructCType)
import Foreign.LibFFI.FFITypes
import Foreign.LibFFI.Internal (CType)
import System.IO.Unsafe (unsafePerformIO)
import ObjC.Runtime.Message (ObjCArgument(..), ObjCReturn(..), MsgSendVariant(..))

data COMPLEX = COMPLEX
  { complexReal :: !CFloat
  , complexImag :: !CFloat
  } deriving (Eq, Show)

instance Storable COMPLEX where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = COMPLEX <$> peekByteOff p 0
    <*> peekByteOff p 4
  poke p (COMPLEX {..}) = do
    pokeByteOff p 0 complexReal
    pokeByteOff p 4 complexImag

{-# NOINLINE complexStructType #-}
complexStructType :: Ptr CType
complexStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_float, ffi_type_float]

argCOMPLEX :: COMPLEX -> Arg
argCOMPLEX = mkStorableArg complexStructType

retCOMPLEX :: RetType COMPLEX
retCOMPLEX = mkStorableRetType complexStructType

instance ObjCArgument COMPLEX where
  withObjCArg x k = k (argCOMPLEX x)

instance ObjCReturn COMPLEX where
  type RawReturn COMPLEX = COMPLEX
  objcRetType = retCOMPLEX
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data COMPLEX_SPLIT = COMPLEX_SPLIT
  { compleX_SPLITRealp :: !(Ptr ())
  , compleX_SPLITImagp :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable COMPLEX_SPLIT where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = COMPLEX_SPLIT <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (COMPLEX_SPLIT {..}) = do
    pokeByteOff p 0 compleX_SPLITRealp
    pokeByteOff p 8 compleX_SPLITImagp

{-# NOINLINE compleX_SPLITStructType #-}
compleX_SPLITStructType :: Ptr CType
compleX_SPLITStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer, ffi_type_pointer]

argCOMPLEX_SPLIT :: COMPLEX_SPLIT -> Arg
argCOMPLEX_SPLIT = mkStorableArg compleX_SPLITStructType

retCOMPLEX_SPLIT :: RetType COMPLEX_SPLIT
retCOMPLEX_SPLIT = mkStorableRetType compleX_SPLITStructType

instance ObjCArgument COMPLEX_SPLIT where
  withObjCArg x k = k (argCOMPLEX_SPLIT x)

instance ObjCReturn COMPLEX_SPLIT where
  type RawReturn COMPLEX_SPLIT = COMPLEX_SPLIT
  objcRetType = retCOMPLEX_SPLIT
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data DOUBLE_COMPLEX = DOUBLE_COMPLEX
  { doublE_COMPLEXReal :: !CDouble
  , doublE_COMPLEXImag :: !CDouble
  } deriving (Eq, Show)

instance Storable DOUBLE_COMPLEX where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = DOUBLE_COMPLEX <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (DOUBLE_COMPLEX {..}) = do
    pokeByteOff p 0 doublE_COMPLEXReal
    pokeByteOff p 8 doublE_COMPLEXImag

{-# NOINLINE doublE_COMPLEXStructType #-}
doublE_COMPLEXStructType :: Ptr CType
doublE_COMPLEXStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_double, ffi_type_double]

argDOUBLE_COMPLEX :: DOUBLE_COMPLEX -> Arg
argDOUBLE_COMPLEX = mkStorableArg doublE_COMPLEXStructType

retDOUBLE_COMPLEX :: RetType DOUBLE_COMPLEX
retDOUBLE_COMPLEX = mkStorableRetType doublE_COMPLEXStructType

instance ObjCArgument DOUBLE_COMPLEX where
  withObjCArg x k = k (argDOUBLE_COMPLEX x)

instance ObjCReturn DOUBLE_COMPLEX where
  type RawReturn DOUBLE_COMPLEX = DOUBLE_COMPLEX
  objcRetType = retDOUBLE_COMPLEX
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data DOUBLE_COMPLEX_SPLIT = DOUBLE_COMPLEX_SPLIT
  { doublE_COMPLEX_SPLITRealp :: !(Ptr ())
  , doublE_COMPLEX_SPLITImagp :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable DOUBLE_COMPLEX_SPLIT where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = DOUBLE_COMPLEX_SPLIT <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (DOUBLE_COMPLEX_SPLIT {..}) = do
    pokeByteOff p 0 doublE_COMPLEX_SPLITRealp
    pokeByteOff p 8 doublE_COMPLEX_SPLITImagp

{-# NOINLINE doublE_COMPLEX_SPLITStructType #-}
doublE_COMPLEX_SPLITStructType :: Ptr CType
doublE_COMPLEX_SPLITStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer, ffi_type_pointer]

argDOUBLE_COMPLEX_SPLIT :: DOUBLE_COMPLEX_SPLIT -> Arg
argDOUBLE_COMPLEX_SPLIT = mkStorableArg doublE_COMPLEX_SPLITStructType

retDOUBLE_COMPLEX_SPLIT :: RetType DOUBLE_COMPLEX_SPLIT
retDOUBLE_COMPLEX_SPLIT = mkStorableRetType doublE_COMPLEX_SPLITStructType

instance ObjCArgument DOUBLE_COMPLEX_SPLIT where
  withObjCArg x k = k (argDOUBLE_COMPLEX_SPLIT x)

instance ObjCReturn DOUBLE_COMPLEX_SPLIT where
  type RawReturn DOUBLE_COMPLEX_SPLIT = DOUBLE_COMPLEX_SPLIT
  objcRetType = retDOUBLE_COMPLEX_SPLIT
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data DSPComplex = DSPComplex
  { dspComplexReal :: !CFloat
  , dspComplexImag :: !CFloat
  } deriving (Eq, Show)

instance Storable DSPComplex where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = DSPComplex <$> peekByteOff p 0
    <*> peekByteOff p 4
  poke p (DSPComplex {..}) = do
    pokeByteOff p 0 dspComplexReal
    pokeByteOff p 4 dspComplexImag

{-# NOINLINE dspComplexStructType #-}
dspComplexStructType :: Ptr CType
dspComplexStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_float, ffi_type_float]

argDSPComplex :: DSPComplex -> Arg
argDSPComplex = mkStorableArg dspComplexStructType

retDSPComplex :: RetType DSPComplex
retDSPComplex = mkStorableRetType dspComplexStructType

instance ObjCArgument DSPComplex where
  withObjCArg x k = k (argDSPComplex x)

instance ObjCReturn DSPComplex where
  type RawReturn DSPComplex = DSPComplex
  objcRetType = retDSPComplex
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data DSPDoubleComplex = DSPDoubleComplex
  { dspDoubleComplexReal :: !CDouble
  , dspDoubleComplexImag :: !CDouble
  } deriving (Eq, Show)

instance Storable DSPDoubleComplex where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = DSPDoubleComplex <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (DSPDoubleComplex {..}) = do
    pokeByteOff p 0 dspDoubleComplexReal
    pokeByteOff p 8 dspDoubleComplexImag

{-# NOINLINE dspDoubleComplexStructType #-}
dspDoubleComplexStructType :: Ptr CType
dspDoubleComplexStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_double, ffi_type_double]

argDSPDoubleComplex :: DSPDoubleComplex -> Arg
argDSPDoubleComplex = mkStorableArg dspDoubleComplexStructType

retDSPDoubleComplex :: RetType DSPDoubleComplex
retDSPDoubleComplex = mkStorableRetType dspDoubleComplexStructType

instance ObjCArgument DSPDoubleComplex where
  withObjCArg x k = k (argDSPDoubleComplex x)

instance ObjCReturn DSPDoubleComplex where
  type RawReturn DSPDoubleComplex = DSPDoubleComplex
  objcRetType = retDSPDoubleComplex
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data DSPDoubleSplitComplex = DSPDoubleSplitComplex
  { dspDoubleSplitComplexRealp :: !(Ptr ())
  , dspDoubleSplitComplexImagp :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable DSPDoubleSplitComplex where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = DSPDoubleSplitComplex <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (DSPDoubleSplitComplex {..}) = do
    pokeByteOff p 0 dspDoubleSplitComplexRealp
    pokeByteOff p 8 dspDoubleSplitComplexImagp

{-# NOINLINE dspDoubleSplitComplexStructType #-}
dspDoubleSplitComplexStructType :: Ptr CType
dspDoubleSplitComplexStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer, ffi_type_pointer]

argDSPDoubleSplitComplex :: DSPDoubleSplitComplex -> Arg
argDSPDoubleSplitComplex = mkStorableArg dspDoubleSplitComplexStructType

retDSPDoubleSplitComplex :: RetType DSPDoubleSplitComplex
retDSPDoubleSplitComplex = mkStorableRetType dspDoubleSplitComplexStructType

instance ObjCArgument DSPDoubleSplitComplex where
  withObjCArg x k = k (argDSPDoubleSplitComplex x)

instance ObjCReturn DSPDoubleSplitComplex where
  type RawReturn DSPDoubleSplitComplex = DSPDoubleSplitComplex
  objcRetType = retDSPDoubleSplitComplex
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure

data DSPSplitComplex = DSPSplitComplex
  { dspSplitComplexRealp :: !(Ptr ())
  , dspSplitComplexImagp :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable DSPSplitComplex where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = DSPSplitComplex <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (DSPSplitComplex {..}) = do
    pokeByteOff p 0 dspSplitComplexRealp
    pokeByteOff p 8 dspSplitComplexImagp

{-# NOINLINE dspSplitComplexStructType #-}
dspSplitComplexStructType :: Ptr CType
dspSplitComplexStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer, ffi_type_pointer]

argDSPSplitComplex :: DSPSplitComplex -> Arg
argDSPSplitComplex = mkStorableArg dspSplitComplexStructType

retDSPSplitComplex :: RetType DSPSplitComplex
retDSPSplitComplex = mkStorableRetType dspSplitComplexStructType

instance ObjCArgument DSPSplitComplex where
  withObjCArg x k = k (argDSPSplitComplex x)

instance ObjCReturn DSPSplitComplex where
  type RawReturn DSPSplitComplex = DSPSplitComplex
  objcRetType = retDSPSplitComplex
  msgSendVariant = MsgSendStret
  fromRetained = pure
  fromOwned = pure
