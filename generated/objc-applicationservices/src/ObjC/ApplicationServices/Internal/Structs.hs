{-# LANGUAGE RecordWildCards #-}

-- | Struct types for this framework.
--
-- Generated by objc-codegen. Do not edit.
module ObjC.ApplicationServices.Internal.Structs where

import Foreign.Ptr (Ptr, FunPtr)
import Foreign.Storable (Storable(..))
import Foreign.C.Types
import Foreign.LibFFI.Base (Arg, RetType, mkStorableArg, mkStorableRetType, newStructCType)
import Foreign.LibFFI.FFITypes
import Foreign.LibFFI.Internal (CType)
import System.IO.Unsafe (unsafePerformIO)
import ObjC.CoreFoundation.Internal.Structs

data ALMXGlyphEntry = ALMXGlyphEntry
  { almxGlyphEntryGlyphIndexOffset :: !CShort
  , almxGlyphEntryHorizontalAdvance :: !CShort
  , almxGlyphEntryXOffsetToHOrigin :: !CShort
  , almxGlyphEntryVerticalAdvance :: !CShort
  , almxGlyphEntryYOffsetToVOrigin :: !CShort
  } deriving (Eq, Show)

instance Storable ALMXGlyphEntry where
  sizeOf    _ = 10
  alignment _ = 2
  peek p = ALMXGlyphEntry <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 6
    <*> peekByteOff p 8
  poke p (ALMXGlyphEntry {..}) = do
    pokeByteOff p 0 almxGlyphEntryGlyphIndexOffset
    pokeByteOff p 2 almxGlyphEntryHorizontalAdvance
    pokeByteOff p 4 almxGlyphEntryXOffsetToHOrigin
    pokeByteOff p 6 almxGlyphEntryVerticalAdvance
    pokeByteOff p 8 almxGlyphEntryYOffsetToVOrigin

{-# NOINLINE almxGlyphEntryStructType #-}
almxGlyphEntryStructType :: Ptr CType
almxGlyphEntryStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16]

argALMXGlyphEntry :: ALMXGlyphEntry -> Arg
argALMXGlyphEntry = mkStorableArg almxGlyphEntryStructType

retALMXGlyphEntry :: RetType ALMXGlyphEntry
retALMXGlyphEntry = mkStorableRetType almxGlyphEntryStructType

data ALMXHeader = ALMXHeader
  { almxHeaderVersion :: !CInt
  , almxHeaderFlags :: !CUShort
  , almxHeaderNMasters :: !CUShort
  , almxHeaderFirstGlyph :: !CUShort
  , almxHeaderLastGlyph :: !CUShort
  , almxHeaderLookup :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable ALMXHeader where
  sizeOf    _ = 24
  alignment _ = 8
  peek p = ALMXHeader <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 6
    <*> peekByteOff p 8
    <*> peekByteOff p 10
    <*> peekByteOff p 16
  poke p (ALMXHeader {..}) = do
    pokeByteOff p 0 almxHeaderVersion
    pokeByteOff p 4 almxHeaderFlags
    pokeByteOff p 6 almxHeaderNMasters
    pokeByteOff p 8 almxHeaderFirstGlyph
    pokeByteOff p 10 almxHeaderLastGlyph
    pokeByteOff p 16 almxHeaderLookup

{-# NOINLINE almxHeaderStructType #-}
almxHeaderStructType :: Ptr CType
almxHeaderStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16, ffi_type_pointer]

argALMXHeader :: ALMXHeader -> Arg
argALMXHeader = mkStorableArg almxHeaderStructType

retALMXHeader :: RetType ALMXHeader
retALMXHeader = mkStorableRetType almxHeaderStructType

data ATSFlatDataFontNameDataHeader = ATSFlatDataFontNameDataHeader
  { atsFlatDataFontNameDataHeaderNameSpecifierType :: !CUInt
  , atsFlatDataFontNameDataHeaderNameSpecifierSize :: !CUInt
  } deriving (Eq, Show)

instance Storable ATSFlatDataFontNameDataHeader where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = ATSFlatDataFontNameDataHeader <$> peekByteOff p 0
    <*> peekByteOff p 4
  poke p (ATSFlatDataFontNameDataHeader {..}) = do
    pokeByteOff p 0 atsFlatDataFontNameDataHeaderNameSpecifierType
    pokeByteOff p 4 atsFlatDataFontNameDataHeaderNameSpecifierSize

{-# NOINLINE atsFlatDataFontNameDataHeaderStructType #-}
atsFlatDataFontNameDataHeaderStructType :: Ptr CType
atsFlatDataFontNameDataHeaderStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint]

argATSFlatDataFontNameDataHeader :: ATSFlatDataFontNameDataHeader -> Arg
argATSFlatDataFontNameDataHeader = mkStorableArg atsFlatDataFontNameDataHeaderStructType

retATSFlatDataFontNameDataHeader :: RetType ATSFlatDataFontNameDataHeader
retATSFlatDataFontNameDataHeader = mkStorableRetType atsFlatDataFontNameDataHeaderStructType

data ATSFlatDataFontSpecRawNameData = ATSFlatDataFontSpecRawNameData
  { atsFlatDataFontSpecRawNameDataFontNameType :: !CUInt
  , atsFlatDataFontSpecRawNameDataFontNamePlatform :: !CUInt
  , atsFlatDataFontSpecRawNameDataFontNameScript :: !CUInt
  , atsFlatDataFontSpecRawNameDataFontNameLanguage :: !CUInt
  , atsFlatDataFontSpecRawNameDataFontNameLength :: !CUInt
  } deriving (Eq, Show)

instance Storable ATSFlatDataFontSpecRawNameData where
  sizeOf    _ = 20
  alignment _ = 4
  peek p = ATSFlatDataFontSpecRawNameData <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
    <*> peekByteOff p 16
  poke p (ATSFlatDataFontSpecRawNameData {..}) = do
    pokeByteOff p 0 atsFlatDataFontSpecRawNameDataFontNameType
    pokeByteOff p 4 atsFlatDataFontSpecRawNameDataFontNamePlatform
    pokeByteOff p 8 atsFlatDataFontSpecRawNameDataFontNameScript
    pokeByteOff p 12 atsFlatDataFontSpecRawNameDataFontNameLanguage
    pokeByteOff p 16 atsFlatDataFontSpecRawNameDataFontNameLength

{-# NOINLINE atsFlatDataFontSpecRawNameDataStructType #-}
atsFlatDataFontSpecRawNameDataStructType :: Ptr CType
atsFlatDataFontSpecRawNameDataStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint]

argATSFlatDataFontSpecRawNameData :: ATSFlatDataFontSpecRawNameData -> Arg
argATSFlatDataFontSpecRawNameData = mkStorableArg atsFlatDataFontSpecRawNameDataStructType

retATSFlatDataFontSpecRawNameData :: RetType ATSFlatDataFontSpecRawNameData
retATSFlatDataFontSpecRawNameData = mkStorableRetType atsFlatDataFontSpecRawNameDataStructType

data ATSFlatDataLineInfoData = ATSFlatDataLineInfoData
  { atsFlatDataLineInfoDataLineLength :: !CUInt
  , atsFlatDataLineInfoDataNumberOfLineControls :: !CUInt
  } deriving (Eq, Show)

instance Storable ATSFlatDataLineInfoData where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = ATSFlatDataLineInfoData <$> peekByteOff p 0
    <*> peekByteOff p 4
  poke p (ATSFlatDataLineInfoData {..}) = do
    pokeByteOff p 0 atsFlatDataLineInfoDataLineLength
    pokeByteOff p 4 atsFlatDataLineInfoDataNumberOfLineControls

{-# NOINLINE atsFlatDataLineInfoDataStructType #-}
atsFlatDataLineInfoDataStructType :: Ptr CType
atsFlatDataLineInfoDataStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint]

argATSFlatDataLineInfoData :: ATSFlatDataLineInfoData -> Arg
argATSFlatDataLineInfoData = mkStorableArg atsFlatDataLineInfoDataStructType

retATSFlatDataLineInfoData :: RetType ATSFlatDataLineInfoData
retATSFlatDataLineInfoData = mkStorableRetType atsFlatDataLineInfoDataStructType

data ATSFlatDataMainHeaderBlock = ATSFlatDataMainHeaderBlock
  { atsFlatDataMainHeaderBlockVersion :: !CUInt
  , atsFlatDataMainHeaderBlockSizeOfDataBlock :: !CUInt
  , atsFlatDataMainHeaderBlockOffsetToTextLayouts :: !CUInt
  , atsFlatDataMainHeaderBlockOffsetToStyleRuns :: !CUInt
  , atsFlatDataMainHeaderBlockOffsetToStyleList :: !CUInt
  } deriving (Eq, Show)

instance Storable ATSFlatDataMainHeaderBlock where
  sizeOf    _ = 20
  alignment _ = 4
  peek p = ATSFlatDataMainHeaderBlock <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
    <*> peekByteOff p 16
  poke p (ATSFlatDataMainHeaderBlock {..}) = do
    pokeByteOff p 0 atsFlatDataMainHeaderBlockVersion
    pokeByteOff p 4 atsFlatDataMainHeaderBlockSizeOfDataBlock
    pokeByteOff p 8 atsFlatDataMainHeaderBlockOffsetToTextLayouts
    pokeByteOff p 12 atsFlatDataMainHeaderBlockOffsetToStyleRuns
    pokeByteOff p 16 atsFlatDataMainHeaderBlockOffsetToStyleList

{-# NOINLINE atsFlatDataMainHeaderBlockStructType #-}
atsFlatDataMainHeaderBlockStructType :: Ptr CType
atsFlatDataMainHeaderBlockStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint]

argATSFlatDataMainHeaderBlock :: ATSFlatDataMainHeaderBlock -> Arg
argATSFlatDataMainHeaderBlock = mkStorableArg atsFlatDataMainHeaderBlockStructType

retATSFlatDataMainHeaderBlock :: RetType ATSFlatDataMainHeaderBlock
retATSFlatDataMainHeaderBlock = mkStorableRetType atsFlatDataMainHeaderBlockStructType

data ATSFlatDataStyleListFeatureData = ATSFlatDataStyleListFeatureData
  { atsFlatDataStyleListFeatureDataTheFeatureType :: !CUShort
  , atsFlatDataStyleListFeatureDataTheFeatureSelector :: !CUShort
  } deriving (Eq, Show)

instance Storable ATSFlatDataStyleListFeatureData where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = ATSFlatDataStyleListFeatureData <$> peekByteOff p 0
    <*> peekByteOff p 2
  poke p (ATSFlatDataStyleListFeatureData {..}) = do
    pokeByteOff p 0 atsFlatDataStyleListFeatureDataTheFeatureType
    pokeByteOff p 2 atsFlatDataStyleListFeatureDataTheFeatureSelector

{-# NOINLINE atsFlatDataStyleListFeatureDataStructType #-}
atsFlatDataStyleListFeatureDataStructType :: Ptr CType
atsFlatDataStyleListFeatureDataStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16]

argATSFlatDataStyleListFeatureData :: ATSFlatDataStyleListFeatureData -> Arg
argATSFlatDataStyleListFeatureData = mkStorableArg atsFlatDataStyleListFeatureDataStructType

retATSFlatDataStyleListFeatureData :: RetType ATSFlatDataStyleListFeatureData
retATSFlatDataStyleListFeatureData = mkStorableRetType atsFlatDataStyleListFeatureDataStructType

data ATSFlatDataStyleListStyleDataHeader = ATSFlatDataStyleListStyleDataHeader
  { atsFlatDataStyleListStyleDataHeaderSizeOfStyleInfo :: !CUInt
  , atsFlatDataStyleListStyleDataHeaderNumberOfSetAttributes :: !CUInt
  , atsFlatDataStyleListStyleDataHeaderNumberOfSetFeatures :: !CUInt
  , atsFlatDataStyleListStyleDataHeaderNumberOfSetVariations :: !CUInt
  } deriving (Eq, Show)

instance Storable ATSFlatDataStyleListStyleDataHeader where
  sizeOf    _ = 16
  alignment _ = 4
  peek p = ATSFlatDataStyleListStyleDataHeader <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
  poke p (ATSFlatDataStyleListStyleDataHeader {..}) = do
    pokeByteOff p 0 atsFlatDataStyleListStyleDataHeaderSizeOfStyleInfo
    pokeByteOff p 4 atsFlatDataStyleListStyleDataHeaderNumberOfSetAttributes
    pokeByteOff p 8 atsFlatDataStyleListStyleDataHeaderNumberOfSetFeatures
    pokeByteOff p 12 atsFlatDataStyleListStyleDataHeaderNumberOfSetVariations

{-# NOINLINE atsFlatDataStyleListStyleDataHeaderStructType #-}
atsFlatDataStyleListStyleDataHeaderStructType :: Ptr CType
atsFlatDataStyleListStyleDataHeaderStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint]

argATSFlatDataStyleListStyleDataHeader :: ATSFlatDataStyleListStyleDataHeader -> Arg
argATSFlatDataStyleListStyleDataHeader = mkStorableArg atsFlatDataStyleListStyleDataHeaderStructType

retATSFlatDataStyleListStyleDataHeader :: RetType ATSFlatDataStyleListStyleDataHeader
retATSFlatDataStyleListStyleDataHeader = mkStorableRetType atsFlatDataStyleListStyleDataHeaderStructType

data ATSFlatDataStyleListVariationData = ATSFlatDataStyleListVariationData
  { atsFlatDataStyleListVariationDataTheVariationAxis :: !CUInt
  , atsFlatDataStyleListVariationDataTheVariationValue :: !CInt
  } deriving (Eq, Show)

instance Storable ATSFlatDataStyleListVariationData where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = ATSFlatDataStyleListVariationData <$> peekByteOff p 0
    <*> peekByteOff p 4
  poke p (ATSFlatDataStyleListVariationData {..}) = do
    pokeByteOff p 0 atsFlatDataStyleListVariationDataTheVariationAxis
    pokeByteOff p 4 atsFlatDataStyleListVariationDataTheVariationValue

{-# NOINLINE atsFlatDataStyleListVariationDataStructType #-}
atsFlatDataStyleListVariationDataStructType :: Ptr CType
atsFlatDataStyleListVariationDataStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_sint]

argATSFlatDataStyleListVariationData :: ATSFlatDataStyleListVariationData -> Arg
argATSFlatDataStyleListVariationData = mkStorableArg atsFlatDataStyleListVariationDataStructType

retATSFlatDataStyleListVariationData :: RetType ATSFlatDataStyleListVariationData
retATSFlatDataStyleListVariationData = mkStorableRetType atsFlatDataStyleListVariationDataStructType

data ATSFlatDataTextLayoutDataHeader = ATSFlatDataTextLayoutDataHeader
  { atsFlatDataTextLayoutDataHeaderSizeOfLayoutData :: !CUInt
  , atsFlatDataTextLayoutDataHeaderTextLayoutLength :: !CUInt
  , atsFlatDataTextLayoutDataHeaderOffsetToLayoutControls :: !CUInt
  , atsFlatDataTextLayoutDataHeaderOffsetToLineInfo :: !CUInt
  } deriving (Eq, Show)

instance Storable ATSFlatDataTextLayoutDataHeader where
  sizeOf    _ = 16
  alignment _ = 4
  peek p = ATSFlatDataTextLayoutDataHeader <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
  poke p (ATSFlatDataTextLayoutDataHeader {..}) = do
    pokeByteOff p 0 atsFlatDataTextLayoutDataHeaderSizeOfLayoutData
    pokeByteOff p 4 atsFlatDataTextLayoutDataHeaderTextLayoutLength
    pokeByteOff p 8 atsFlatDataTextLayoutDataHeaderOffsetToLayoutControls
    pokeByteOff p 12 atsFlatDataTextLayoutDataHeaderOffsetToLineInfo

{-# NOINLINE atsFlatDataTextLayoutDataHeaderStructType #-}
atsFlatDataTextLayoutDataHeaderStructType :: Ptr CType
atsFlatDataTextLayoutDataHeaderStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint]

argATSFlatDataTextLayoutDataHeader :: ATSFlatDataTextLayoutDataHeader -> Arg
argATSFlatDataTextLayoutDataHeader = mkStorableArg atsFlatDataTextLayoutDataHeaderStructType

retATSFlatDataTextLayoutDataHeader :: RetType ATSFlatDataTextLayoutDataHeader
retATSFlatDataTextLayoutDataHeader = mkStorableRetType atsFlatDataTextLayoutDataHeaderStructType

data ATSFontMetrics = ATSFontMetrics
  { atsFontMetricsVersion :: !CUInt
  , atsFontMetricsAscent :: !CDouble
  , atsFontMetricsDescent :: !CDouble
  , atsFontMetricsLeading :: !CDouble
  , atsFontMetricsAvgAdvanceWidth :: !CDouble
  , atsFontMetricsMaxAdvanceWidth :: !CDouble
  , atsFontMetricsMinLeftSideBearing :: !CDouble
  , atsFontMetricsMinRightSideBearing :: !CDouble
  , atsFontMetricsStemWidth :: !CDouble
  , atsFontMetricsStemHeight :: !CDouble
  , atsFontMetricsCapHeight :: !CDouble
  , atsFontMetricsXHeight :: !CDouble
  , atsFontMetricsItalicAngle :: !CDouble
  , atsFontMetricsUnderlinePosition :: !CDouble
  , atsFontMetricsUnderlineThickness :: !CDouble
  } deriving (Eq, Show)

instance Storable ATSFontMetrics where
  sizeOf    _ = 120
  alignment _ = 8
  peek p = ATSFontMetrics <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 24
    <*> peekByteOff p 32
    <*> peekByteOff p 40
    <*> peekByteOff p 48
    <*> peekByteOff p 56
    <*> peekByteOff p 64
    <*> peekByteOff p 72
    <*> peekByteOff p 80
    <*> peekByteOff p 88
    <*> peekByteOff p 96
    <*> peekByteOff p 104
    <*> peekByteOff p 112
  poke p (ATSFontMetrics {..}) = do
    pokeByteOff p 0 atsFontMetricsVersion
    pokeByteOff p 8 atsFontMetricsAscent
    pokeByteOff p 16 atsFontMetricsDescent
    pokeByteOff p 24 atsFontMetricsLeading
    pokeByteOff p 32 atsFontMetricsAvgAdvanceWidth
    pokeByteOff p 40 atsFontMetricsMaxAdvanceWidth
    pokeByteOff p 48 atsFontMetricsMinLeftSideBearing
    pokeByteOff p 56 atsFontMetricsMinRightSideBearing
    pokeByteOff p 64 atsFontMetricsStemWidth
    pokeByteOff p 72 atsFontMetricsStemHeight
    pokeByteOff p 80 atsFontMetricsCapHeight
    pokeByteOff p 88 atsFontMetricsXHeight
    pokeByteOff p 96 atsFontMetricsItalicAngle
    pokeByteOff p 104 atsFontMetricsUnderlinePosition
    pokeByteOff p 112 atsFontMetricsUnderlineThickness

{-# NOINLINE atsFontMetricsStructType #-}
atsFontMetricsStructType :: Ptr CType
atsFontMetricsStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_double, ffi_type_double, ffi_type_double, ffi_type_double, ffi_type_double, ffi_type_double, ffi_type_double, ffi_type_double, ffi_type_double, ffi_type_double, ffi_type_double, ffi_type_double, ffi_type_double, ffi_type_double]

argATSFontMetrics :: ATSFontMetrics -> Arg
argATSFontMetrics = mkStorableArg atsFontMetricsStructType

retATSFontMetrics :: RetType ATSFontMetrics
retATSFontMetrics = mkStorableRetType atsFontMetricsStructType

data ATSFontQuerySourceContext = ATSFontQuerySourceContext
  { atsFontQuerySourceContextVersion :: !CUInt
  , atsFontQuerySourceContextRefCon :: !(Ptr ())
  , atsFontQuerySourceContextRetain :: !(Ptr ())
  , atsFontQuerySourceContextRelease :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable ATSFontQuerySourceContext where
  sizeOf    _ = 32
  alignment _ = 8
  peek p = ATSFontQuerySourceContext <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 24
  poke p (ATSFontQuerySourceContext {..}) = do
    pokeByteOff p 0 atsFontQuerySourceContextVersion
    pokeByteOff p 8 atsFontQuerySourceContextRefCon
    pokeByteOff p 16 atsFontQuerySourceContextRetain
    pokeByteOff p 24 atsFontQuerySourceContextRelease

{-# NOINLINE atsFontQuerySourceContextStructType #-}
atsFontQuerySourceContextStructType :: Ptr CType
atsFontQuerySourceContextStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer]

argATSFontQuerySourceContext :: ATSFontQuerySourceContext -> Arg
argATSFontQuerySourceContext = mkStorableArg atsFontQuerySourceContextStructType

retATSFontQuerySourceContext :: RetType ATSFontQuerySourceContext
retATSFontQuerySourceContext = mkStorableRetType atsFontQuerySourceContextStructType

data ATSJustWidthDeltaEntryOverride = ATSJustWidthDeltaEntryOverride
  { atsJustWidthDeltaEntryOverrideBeforeGrowLimit :: !CInt
  , atsJustWidthDeltaEntryOverrideBeforeShrinkLimit :: !CInt
  , atsJustWidthDeltaEntryOverrideAfterGrowLimit :: !CInt
  , atsJustWidthDeltaEntryOverrideAfterShrinkLimit :: !CInt
  , atsJustWidthDeltaEntryOverrideGrowFlags :: !CUShort
  , atsJustWidthDeltaEntryOverrideShrinkFlags :: !CUShort
  } deriving (Eq, Show)

instance Storable ATSJustWidthDeltaEntryOverride where
  sizeOf    _ = 20
  alignment _ = 4
  peek p = ATSJustWidthDeltaEntryOverride <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
    <*> peekByteOff p 16
    <*> peekByteOff p 18
  poke p (ATSJustWidthDeltaEntryOverride {..}) = do
    pokeByteOff p 0 atsJustWidthDeltaEntryOverrideBeforeGrowLimit
    pokeByteOff p 4 atsJustWidthDeltaEntryOverrideBeforeShrinkLimit
    pokeByteOff p 8 atsJustWidthDeltaEntryOverrideAfterGrowLimit
    pokeByteOff p 12 atsJustWidthDeltaEntryOverrideAfterShrinkLimit
    pokeByteOff p 16 atsJustWidthDeltaEntryOverrideGrowFlags
    pokeByteOff p 18 atsJustWidthDeltaEntryOverrideShrinkFlags

{-# NOINLINE atsJustWidthDeltaEntryOverrideStructType #-}
atsJustWidthDeltaEntryOverrideStructType :: Ptr CType
atsJustWidthDeltaEntryOverrideStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_sint, ffi_type_sint, ffi_type_sint, ffi_type_uint16, ffi_type_uint16]

argATSJustWidthDeltaEntryOverride :: ATSJustWidthDeltaEntryOverride -> Arg
argATSJustWidthDeltaEntryOverride = mkStorableArg atsJustWidthDeltaEntryOverrideStructType

retATSJustWidthDeltaEntryOverride :: RetType ATSJustWidthDeltaEntryOverride
retATSJustWidthDeltaEntryOverride = mkStorableRetType atsJustWidthDeltaEntryOverrideStructType

data ATSLayoutRecord = ATSLayoutRecord
  { atsLayoutRecordGlyphID :: !CUShort
  , atsLayoutRecordFlags :: !CUInt
  , atsLayoutRecordOriginalOffset :: !CULong
  , atsLayoutRecordRealPos :: !CInt
  } deriving (Eq, Show)

instance Storable ATSLayoutRecord where
  sizeOf    _ = 24
  alignment _ = 8
  peek p = ATSLayoutRecord <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 16
  poke p (ATSLayoutRecord {..}) = do
    pokeByteOff p 0 atsLayoutRecordGlyphID
    pokeByteOff p 4 atsLayoutRecordFlags
    pokeByteOff p 8 atsLayoutRecordOriginalOffset
    pokeByteOff p 16 atsLayoutRecordRealPos

{-# NOINLINE atsLayoutRecordStructType #-}
atsLayoutRecordStructType :: Ptr CType
atsLayoutRecordStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint, ffi_type_ulong, ffi_type_sint]

argATSLayoutRecord :: ATSLayoutRecord -> Arg
argATSLayoutRecord = mkStorableArg atsLayoutRecordStructType

retATSLayoutRecord :: RetType ATSLayoutRecord
retATSLayoutRecord = mkStorableRetType atsLayoutRecordStructType

data ATSPoint = ATSPoint
  { atsPointX :: !CDouble
  , atsPointY :: !CDouble
  } deriving (Eq, Show)

instance Storable ATSPoint where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = ATSPoint <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (ATSPoint {..}) = do
    pokeByteOff p 0 atsPointX
    pokeByteOff p 8 atsPointY

{-# NOINLINE atsPointStructType #-}
atsPointStructType :: Ptr CType
atsPointStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_double, ffi_type_double]

argATSPoint :: ATSPoint -> Arg
argATSPoint = mkStorableArg atsPointStructType

retATSPoint :: RetType ATSPoint
retATSPoint = mkStorableRetType atsPointStructType

data ATSUAttributeInfo = ATSUAttributeInfo
  { atsuAttributeInfoFTag :: !CUInt
  , atsuAttributeInfoFValueSize :: !CULong
  } deriving (Eq, Show)

instance Storable ATSUAttributeInfo where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = ATSUAttributeInfo <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (ATSUAttributeInfo {..}) = do
    pokeByteOff p 0 atsuAttributeInfoFTag
    pokeByteOff p 8 atsuAttributeInfoFValueSize

{-# NOINLINE atsuAttributeInfoStructType #-}
atsuAttributeInfoStructType :: Ptr CType
atsuAttributeInfoStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_ulong]

argATSUAttributeInfo :: ATSUAttributeInfo -> Arg
argATSUAttributeInfo = mkStorableArg atsuAttributeInfoStructType

retATSUAttributeInfo :: RetType ATSUAttributeInfo
retATSUAttributeInfo = mkStorableRetType atsuAttributeInfoStructType

data ATSUBackgroundColor = ATSUBackgroundColor
  { atsuBackgroundColorRed :: !CFloat
  , atsuBackgroundColorGreen :: !CFloat
  , atsuBackgroundColorBlue :: !CFloat
  , atsuBackgroundColorAlpha :: !CFloat
  } deriving (Eq, Show)

instance Storable ATSUBackgroundColor where
  sizeOf    _ = 16
  alignment _ = 4
  peek p = ATSUBackgroundColor <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
  poke p (ATSUBackgroundColor {..}) = do
    pokeByteOff p 0 atsuBackgroundColorRed
    pokeByteOff p 4 atsuBackgroundColorGreen
    pokeByteOff p 8 atsuBackgroundColorBlue
    pokeByteOff p 12 atsuBackgroundColorAlpha

{-# NOINLINE atsuBackgroundColorStructType #-}
atsuBackgroundColorStructType :: Ptr CType
atsuBackgroundColorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_float, ffi_type_float, ffi_type_float, ffi_type_float]

argATSUBackgroundColor :: ATSUBackgroundColor -> Arg
argATSUBackgroundColor = mkStorableArg atsuBackgroundColorStructType

retATSUBackgroundColor :: RetType ATSUBackgroundColor
retATSUBackgroundColor = mkStorableRetType atsuBackgroundColorStructType

data ATSUCaret = ATSUCaret
  { atsuCaretFX :: !CInt
  , atsuCaretFY :: !CInt
  , atsuCaretFDeltaX :: !CInt
  , atsuCaretFDeltaY :: !CInt
  } deriving (Eq, Show)

instance Storable ATSUCaret where
  sizeOf    _ = 16
  alignment _ = 4
  peek p = ATSUCaret <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
  poke p (ATSUCaret {..}) = do
    pokeByteOff p 0 atsuCaretFX
    pokeByteOff p 4 atsuCaretFY
    pokeByteOff p 8 atsuCaretFDeltaX
    pokeByteOff p 12 atsuCaretFDeltaY

{-# NOINLINE atsuCaretStructType #-}
atsuCaretStructType :: Ptr CType
atsuCaretStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_sint, ffi_type_sint, ffi_type_sint]

argATSUCaret :: ATSUCaret -> Arg
argATSUCaret = mkStorableArg atsuCaretStructType

retATSUCaret :: RetType ATSUCaret
retATSUCaret = mkStorableRetType atsuCaretStructType

data ATSUGlyphInfo = ATSUGlyphInfo
  { atsuGlyphInfoGlyphID :: !CUShort
  , atsuGlyphInfoReserved :: !CUShort
  , atsuGlyphInfoLayoutFlags :: !CUInt
  , atsuGlyphInfoCharIndex :: !CULong
  , atsuGlyphInfoStyle :: !(Ptr ())
  , atsuGlyphInfoDeltaY :: !CFloat
  , atsuGlyphInfoIdealX :: !CFloat
  , atsuGlyphInfoScreenX :: !CShort
  , atsuGlyphInfoCaretX :: !CShort
  } deriving (Eq, Show)

instance Storable ATSUGlyphInfo where
  sizeOf    _ = 40
  alignment _ = 8
  peek p = ATSUGlyphInfo <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 24
    <*> peekByteOff p 28
    <*> peekByteOff p 32
    <*> peekByteOff p 34
  poke p (ATSUGlyphInfo {..}) = do
    pokeByteOff p 0 atsuGlyphInfoGlyphID
    pokeByteOff p 2 atsuGlyphInfoReserved
    pokeByteOff p 4 atsuGlyphInfoLayoutFlags
    pokeByteOff p 8 atsuGlyphInfoCharIndex
    pokeByteOff p 16 atsuGlyphInfoStyle
    pokeByteOff p 24 atsuGlyphInfoDeltaY
    pokeByteOff p 28 atsuGlyphInfoIdealX
    pokeByteOff p 32 atsuGlyphInfoScreenX
    pokeByteOff p 34 atsuGlyphInfoCaretX

{-# NOINLINE atsuGlyphInfoStructType #-}
atsuGlyphInfoStructType :: Ptr CType
atsuGlyphInfoStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint, ffi_type_ulong, ffi_type_pointer, ffi_type_float, ffi_type_float, ffi_type_sint16, ffi_type_sint16]

argATSUGlyphInfo :: ATSUGlyphInfo -> Arg
argATSUGlyphInfo = mkStorableArg atsuGlyphInfoStructType

retATSUGlyphInfo :: RetType ATSUGlyphInfo
retATSUGlyphInfo = mkStorableRetType atsuGlyphInfoStructType

data ATSUGlyphSelector = ATSUGlyphSelector
  { atsuGlyphSelectorCollection :: !CUShort
  , atsuGlyphSelectorGlyphID :: !CUShort
  } deriving (Eq, Show)

instance Storable ATSUGlyphSelector where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = ATSUGlyphSelector <$> peekByteOff p 0
    <*> peekByteOff p 2
  poke p (ATSUGlyphSelector {..}) = do
    pokeByteOff p 0 atsuGlyphSelectorCollection
    pokeByteOff p 2 atsuGlyphSelectorGlyphID

{-# NOINLINE atsuGlyphSelectorStructType #-}
atsuGlyphSelectorStructType :: Ptr CType
atsuGlyphSelectorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16]

argATSUGlyphSelector :: ATSUGlyphSelector -> Arg
argATSUGlyphSelector = mkStorableArg atsuGlyphSelectorStructType

retATSUGlyphSelector :: RetType ATSUGlyphSelector
retATSUGlyphSelector = mkStorableRetType atsuGlyphSelectorStructType

data ATSURGBAlphaColor = ATSURGBAlphaColor
  { atsurgbAlphaColorRed :: !CFloat
  , atsurgbAlphaColorGreen :: !CFloat
  , atsurgbAlphaColorBlue :: !CFloat
  , atsurgbAlphaColorAlpha :: !CFloat
  } deriving (Eq, Show)

instance Storable ATSURGBAlphaColor where
  sizeOf    _ = 16
  alignment _ = 4
  peek p = ATSURGBAlphaColor <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
  poke p (ATSURGBAlphaColor {..}) = do
    pokeByteOff p 0 atsurgbAlphaColorRed
    pokeByteOff p 4 atsurgbAlphaColorGreen
    pokeByteOff p 8 atsurgbAlphaColorBlue
    pokeByteOff p 12 atsurgbAlphaColorAlpha

{-# NOINLINE atsurgbAlphaColorStructType #-}
atsurgbAlphaColorStructType :: Ptr CType
atsurgbAlphaColorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_float, ffi_type_float, ffi_type_float, ffi_type_float]

argATSURGBAlphaColor :: ATSURGBAlphaColor -> Arg
argATSURGBAlphaColor = mkStorableArg atsurgbAlphaColorStructType

retATSURGBAlphaColor :: RetType ATSURGBAlphaColor
retATSURGBAlphaColor = mkStorableRetType atsurgbAlphaColorStructType

data ATSUStyleRunInfo = ATSUStyleRunInfo
  { atsuStyleRunInfoRunLength :: !CUInt
  , atsuStyleRunInfoStyleObjectIndex :: !CUInt
  } deriving (Eq, Show)

instance Storable ATSUStyleRunInfo where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = ATSUStyleRunInfo <$> peekByteOff p 0
    <*> peekByteOff p 4
  poke p (ATSUStyleRunInfo {..}) = do
    pokeByteOff p 0 atsuStyleRunInfoRunLength
    pokeByteOff p 4 atsuStyleRunInfoStyleObjectIndex

{-# NOINLINE atsuStyleRunInfoStructType #-}
atsuStyleRunInfoStructType :: Ptr CType
atsuStyleRunInfoStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint]

argATSUStyleRunInfo :: ATSUStyleRunInfo -> Arg
argATSUStyleRunInfo = mkStorableArg atsuStyleRunInfoStructType

retATSUStyleRunInfo :: RetType ATSUStyleRunInfo
retATSUStyleRunInfo = mkStorableRetType atsuStyleRunInfoStructType

data ATSUTab = ATSUTab
  { atsuTabTabPosition :: !CInt
  , atsuTabTabType :: !CUShort
  } deriving (Eq, Show)

instance Storable ATSUTab where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = ATSUTab <$> peekByteOff p 0
    <*> peekByteOff p 4
  poke p (ATSUTab {..}) = do
    pokeByteOff p 0 atsuTabTabPosition
    pokeByteOff p 4 atsuTabTabType

{-# NOINLINE atsuTabStructType #-}
atsuTabStructType :: Ptr CType
atsuTabStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_uint16]

argATSUTab :: ATSUTab -> Arg
argATSUTab = mkStorableArg atsuTabStructType

retATSUTab :: RetType ATSUTab
retATSUTab = mkStorableRetType atsuTabStructType

data AnchorPoint = AnchorPoint
  { anchorPointX :: !CShort
  , anchorPointY :: !CShort
  } deriving (Eq, Show)

instance Storable AnchorPoint where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = AnchorPoint <$> peekByteOff p 0
    <*> peekByteOff p 2
  poke p (AnchorPoint {..}) = do
    pokeByteOff p 0 anchorPointX
    pokeByteOff p 2 anchorPointY

{-# NOINLINE anchorPointStructType #-}
anchorPointStructType :: Ptr CType
anchorPointStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16, ffi_type_sint16]

argAnchorPoint :: AnchorPoint -> Arg
argAnchorPoint = mkStorableArg anchorPointStructType

retAnchorPoint :: RetType AnchorPoint
retAnchorPoint = mkStorableRetType anchorPointStructType

data AnkrTable = AnkrTable
  { ankrTableVersion :: !CUShort
  , ankrTableFlags :: !CUShort
  , ankrTableLookupTableOffset :: !CUInt
  , ankrTableAnchorPointTableOffset :: !CUInt
  } deriving (Eq, Show)

instance Storable AnkrTable where
  sizeOf    _ = 12
  alignment _ = 4
  peek p = AnkrTable <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (AnkrTable {..}) = do
    pokeByteOff p 0 ankrTableVersion
    pokeByteOff p 2 ankrTableFlags
    pokeByteOff p 4 ankrTableLookupTableOffset
    pokeByteOff p 8 ankrTableAnchorPointTableOffset

{-# NOINLINE ankrTableStructType #-}
ankrTableStructType :: Ptr CType
ankrTableStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint, ffi_type_uint]

argAnkrTable :: AnkrTable -> Arg
argAnkrTable = mkStorableArg ankrTableStructType

retAnkrTable :: RetType AnkrTable
retAnkrTable = mkStorableRetType ankrTableStructType

data AppParameters = AppParameters
  { appParametersTheMsgEvent :: !(Ptr ())
  , appParametersEventRefCon :: !CUInt
  , appParametersMessageLength :: !CUInt
  } deriving (Eq, Show)

instance Storable AppParameters where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = AppParameters <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 12
  poke p (AppParameters {..}) = do
    pokeByteOff p 0 appParametersTheMsgEvent
    pokeByteOff p 8 appParametersEventRefCon
    pokeByteOff p 12 appParametersMessageLength

{-# NOINLINE appParametersStructType #-}
appParametersStructType :: Ptr CType
appParametersStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer, ffi_type_uint, ffi_type_uint]

argAppParameters :: AppParameters -> Arg
argAppParameters = mkStorableArg appParametersStructType

retAppParameters :: RetType AppParameters
retAppParameters = mkStorableRetType appParametersStructType

data AsscEntry = AsscEntry
  { asscEntryFontSize :: !CShort
  , asscEntryFontStyle :: !CShort
  , asscEntryFontID :: !CShort
  } deriving (Eq, Show)

instance Storable AsscEntry where
  sizeOf    _ = 6
  alignment _ = 2
  peek p = AsscEntry <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
  poke p (AsscEntry {..}) = do
    pokeByteOff p 0 asscEntryFontSize
    pokeByteOff p 2 asscEntryFontStyle
    pokeByteOff p 4 asscEntryFontID

{-# NOINLINE asscEntryStructType #-}
asscEntryStructType :: Ptr CType
asscEntryStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16, ffi_type_sint16, ffi_type_sint16]

argAsscEntry :: AsscEntry -> Arg
argAsscEntry = mkStorableArg asscEntryStructType

retAsscEntry :: RetType AsscEntry
retAsscEntry = mkStorableRetType asscEntryStructType

data CMBitmap = CMBitmap
  { cmBitmapImage :: !(Ptr ())
  , cmBitmapWidth :: !CULong
  , cmBitmapHeight :: !CULong
  , cmBitmapRowBytes :: !CULong
  , cmBitmapPixelSize :: !CULong
  , cmBitmapSpace :: !CUInt
  , cmBitmapUser1 :: !CUInt
  , cmBitmapUser2 :: !CUInt
  } deriving (Eq, Show)

instance Storable CMBitmap where
  sizeOf    _ = 56
  alignment _ = 8
  peek p = CMBitmap <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 24
    <*> peekByteOff p 32
    <*> peekByteOff p 40
    <*> peekByteOff p 44
    <*> peekByteOff p 48
  poke p (CMBitmap {..}) = do
    pokeByteOff p 0 cmBitmapImage
    pokeByteOff p 8 cmBitmapWidth
    pokeByteOff p 16 cmBitmapHeight
    pokeByteOff p 24 cmBitmapRowBytes
    pokeByteOff p 32 cmBitmapPixelSize
    pokeByteOff p 40 cmBitmapSpace
    pokeByteOff p 44 cmBitmapUser1
    pokeByteOff p 48 cmBitmapUser2

{-# NOINLINE cmBitmapStructType #-}
cmBitmapStructType :: Ptr CType
cmBitmapStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer, ffi_type_ulong, ffi_type_ulong, ffi_type_ulong, ffi_type_ulong, ffi_type_uint, ffi_type_uint, ffi_type_uint]

argCMBitmap :: CMBitmap -> Arg
argCMBitmap = mkStorableArg cmBitmapStructType

retCMBitmap :: RetType CMBitmap
retCMBitmap = mkStorableRetType cmBitmapStructType

data CMBufferLocation = CMBufferLocation
  { cmBufferLocationBuffer :: !(Ptr ())
  , cmBufferLocationSize :: !CUInt
  } deriving (Eq, Show)

instance Storable CMBufferLocation where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = CMBufferLocation <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (CMBufferLocation {..}) = do
    pokeByteOff p 0 cmBufferLocationBuffer
    pokeByteOff p 8 cmBufferLocationSize

{-# NOINLINE cmBufferLocationStructType #-}
cmBufferLocationStructType :: Ptr CType
cmBufferLocationStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer, ffi_type_uint]

argCMBufferLocation :: CMBufferLocation -> Arg
argCMBufferLocation = mkStorableArg cmBufferLocationStructType

retCMBufferLocation :: RetType CMBufferLocation
retCMBufferLocation = mkStorableRetType cmBufferLocationStructType

data CMCMYColor = CMCMYColor
  { cmcmyColorCyan :: !CUShort
  , cmcmyColorMagenta :: !CUShort
  , cmcmyColorYellow :: !CUShort
  } deriving (Eq, Show)

instance Storable CMCMYColor where
  sizeOf    _ = 6
  alignment _ = 2
  peek p = CMCMYColor <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
  poke p (CMCMYColor {..}) = do
    pokeByteOff p 0 cmcmyColorCyan
    pokeByteOff p 2 cmcmyColorMagenta
    pokeByteOff p 4 cmcmyColorYellow

{-# NOINLINE cmcmyColorStructType #-}
cmcmyColorStructType :: Ptr CType
cmcmyColorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argCMCMYColor :: CMCMYColor -> Arg
argCMCMYColor = mkStorableArg cmcmyColorStructType

retCMCMYColor :: RetType CMCMYColor
retCMCMYColor = mkStorableRetType cmcmyColorStructType

data CMCMYKColor = CMCMYKColor
  { cmcmykColorCyan :: !CUShort
  , cmcmykColorMagenta :: !CUShort
  , cmcmykColorYellow :: !CUShort
  , cmcmykColorBlack :: !CUShort
  } deriving (Eq, Show)

instance Storable CMCMYKColor where
  sizeOf    _ = 8
  alignment _ = 2
  peek p = CMCMYKColor <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 6
  poke p (CMCMYKColor {..}) = do
    pokeByteOff p 0 cmcmykColorCyan
    pokeByteOff p 2 cmcmykColorMagenta
    pokeByteOff p 4 cmcmykColorYellow
    pokeByteOff p 6 cmcmykColorBlack

{-# NOINLINE cmcmykColorStructType #-}
cmcmykColorStructType :: Ptr CType
cmcmykColorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argCMCMYKColor :: CMCMYKColor -> Arg
argCMCMYKColor = mkStorableArg cmcmykColorStructType

retCMCMYKColor :: RetType CMCMYKColor
retCMCMYKColor = mkStorableRetType cmcmykColorStructType

data CMDateTime = CMDateTime
  { cmDateTimeYear :: !CUShort
  , cmDateTimeMonth :: !CUShort
  , cmDateTimeDayOfTheMonth :: !CUShort
  , cmDateTimeHours :: !CUShort
  , cmDateTimeMinutes :: !CUShort
  , cmDateTimeSeconds :: !CUShort
  } deriving (Eq, Show)

instance Storable CMDateTime where
  sizeOf    _ = 12
  alignment _ = 2
  peek p = CMDateTime <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 6
    <*> peekByteOff p 8
    <*> peekByteOff p 10
  poke p (CMDateTime {..}) = do
    pokeByteOff p 0 cmDateTimeYear
    pokeByteOff p 2 cmDateTimeMonth
    pokeByteOff p 4 cmDateTimeDayOfTheMonth
    pokeByteOff p 6 cmDateTimeHours
    pokeByteOff p 8 cmDateTimeMinutes
    pokeByteOff p 10 cmDateTimeSeconds

{-# NOINLINE cmDateTimeStructType #-}
cmDateTimeStructType :: Ptr CType
cmDateTimeStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argCMDateTime :: CMDateTime -> Arg
argCMDateTime = mkStorableArg cmDateTimeStructType

retCMDateTime :: RetType CMDateTime
retCMDateTime = mkStorableRetType cmDateTimeStructType

data CMDeviceProfileInfo = CMDeviceProfileInfo
  { cmDeviceProfileInfoDataVersion :: !CUInt
  , cmDeviceProfileInfoProfileID :: !CUInt
  , cmDeviceProfileInfoProfileLoc :: !(Ptr ())
  , cmDeviceProfileInfoProfileName :: !(Ptr ())
  , cmDeviceProfileInfoReserved :: !CUInt
  } deriving (Eq, Show)

instance Storable CMDeviceProfileInfo where
  sizeOf    _ = 32
  alignment _ = 8
  peek p = CMDeviceProfileInfo <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 24
  poke p (CMDeviceProfileInfo {..}) = do
    pokeByteOff p 0 cmDeviceProfileInfoDataVersion
    pokeByteOff p 4 cmDeviceProfileInfoProfileID
    pokeByteOff p 8 cmDeviceProfileInfoProfileLoc
    pokeByteOff p 16 cmDeviceProfileInfoProfileName
    pokeByteOff p 24 cmDeviceProfileInfoReserved

{-# NOINLINE cmDeviceProfileInfoStructType #-}
cmDeviceProfileInfoStructType :: Ptr CType
cmDeviceProfileInfoStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_pointer, ffi_type_pointer, ffi_type_uint]

argCMDeviceProfileInfo :: CMDeviceProfileInfo -> Arg
argCMDeviceProfileInfo = mkStorableArg cmDeviceProfileInfoStructType

retCMDeviceProfileInfo :: RetType CMDeviceProfileInfo
retCMDeviceProfileInfo = mkStorableRetType cmDeviceProfileInfoStructType

data CMDeviceProfileScope = CMDeviceProfileScope
  { cmDeviceProfileScopeDeviceUser :: !(Ptr ())
  , cmDeviceProfileScopeDeviceHost :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable CMDeviceProfileScope where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = CMDeviceProfileScope <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (CMDeviceProfileScope {..}) = do
    pokeByteOff p 0 cmDeviceProfileScopeDeviceUser
    pokeByteOff p 8 cmDeviceProfileScopeDeviceHost

{-# NOINLINE cmDeviceProfileScopeStructType #-}
cmDeviceProfileScopeStructType :: Ptr CType
cmDeviceProfileScopeStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer, ffi_type_pointer]

argCMDeviceProfileScope :: CMDeviceProfileScope -> Arg
argCMDeviceProfileScope = mkStorableArg cmDeviceProfileScopeStructType

retCMDeviceProfileScope :: RetType CMDeviceProfileScope
retCMDeviceProfileScope = mkStorableRetType cmDeviceProfileScopeStructType

data CMDeviceScope = CMDeviceScope
  { cmDeviceScopeDeviceUser :: !(Ptr ())
  , cmDeviceScopeDeviceHost :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable CMDeviceScope where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = CMDeviceScope <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (CMDeviceScope {..}) = do
    pokeByteOff p 0 cmDeviceScopeDeviceUser
    pokeByteOff p 8 cmDeviceScopeDeviceHost

{-# NOINLINE cmDeviceScopeStructType #-}
cmDeviceScopeStructType :: Ptr CType
cmDeviceScopeStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer, ffi_type_pointer]

argCMDeviceScope :: CMDeviceScope -> Arg
argCMDeviceScope = mkStorableArg cmDeviceScopeStructType

retCMDeviceScope :: RetType CMDeviceScope
retCMDeviceScope = mkStorableRetType cmDeviceScopeStructType

data CMFixedXYColor = CMFixedXYColor
  { cmFixedXYColorX :: !CInt
  , cmFixedXYColorY :: !CInt
  } deriving (Eq, Show)

instance Storable CMFixedXYColor where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = CMFixedXYColor <$> peekByteOff p 0
    <*> peekByteOff p 4
  poke p (CMFixedXYColor {..}) = do
    pokeByteOff p 0 cmFixedXYColorX
    pokeByteOff p 4 cmFixedXYColorY

{-# NOINLINE cmFixedXYColorStructType #-}
cmFixedXYColorStructType :: Ptr CType
cmFixedXYColorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_sint]

argCMFixedXYColor :: CMFixedXYColor -> Arg
argCMFixedXYColor = mkStorableArg cmFixedXYColorStructType

retCMFixedXYColor :: RetType CMFixedXYColor
retCMFixedXYColor = mkStorableRetType cmFixedXYColorStructType

data CMFixedXYZColor = CMFixedXYZColor
  { cmFixedXYZColorX :: !CInt
  , cmFixedXYZColorY :: !CInt
  , cmFixedXYZColorZ :: !CInt
  } deriving (Eq, Show)

instance Storable CMFixedXYZColor where
  sizeOf    _ = 12
  alignment _ = 4
  peek p = CMFixedXYZColor <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (CMFixedXYZColor {..}) = do
    pokeByteOff p 0 cmFixedXYZColorX
    pokeByteOff p 4 cmFixedXYZColorY
    pokeByteOff p 8 cmFixedXYZColorZ

{-# NOINLINE cmFixedXYZColorStructType #-}
cmFixedXYZColorStructType :: Ptr CType
cmFixedXYZColorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_sint, ffi_type_sint]

argCMFixedXYZColor :: CMFixedXYZColor -> Arg
argCMFixedXYZColor = mkStorableArg cmFixedXYZColorStructType

retCMFixedXYZColor :: RetType CMFixedXYZColor
retCMFixedXYZColor = mkStorableRetType cmFixedXYZColorStructType

data CMGrayColor = CMGrayColor
  { cmGrayColorGray :: !CUShort
  } deriving (Eq, Show)

instance Storable CMGrayColor where
  sizeOf    _ = 2
  alignment _ = 2
  peek p = CMGrayColor <$> peekByteOff p 0
  poke p (CMGrayColor {..}) =
    pokeByteOff p 0 cmGrayColorGray

{-# NOINLINE cmGrayColorStructType #-}
cmGrayColorStructType :: Ptr CType
cmGrayColorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16]

argCMGrayColor :: CMGrayColor -> Arg
argCMGrayColor = mkStorableArg cmGrayColorStructType

retCMGrayColor :: RetType CMGrayColor
retCMGrayColor = mkStorableRetType cmGrayColorStructType

data CMHLSColor = CMHLSColor
  { cmhlsColorHue :: !CUShort
  , cmhlsColorLightness :: !CUShort
  , cmhlsColorSaturation :: !CUShort
  } deriving (Eq, Show)

instance Storable CMHLSColor where
  sizeOf    _ = 6
  alignment _ = 2
  peek p = CMHLSColor <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
  poke p (CMHLSColor {..}) = do
    pokeByteOff p 0 cmhlsColorHue
    pokeByteOff p 2 cmhlsColorLightness
    pokeByteOff p 4 cmhlsColorSaturation

{-# NOINLINE cmhlsColorStructType #-}
cmhlsColorStructType :: Ptr CType
cmhlsColorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argCMHLSColor :: CMHLSColor -> Arg
argCMHLSColor = mkStorableArg cmhlsColorStructType

retCMHLSColor :: RetType CMHLSColor
retCMHLSColor = mkStorableRetType cmhlsColorStructType

data CMHSVColor = CMHSVColor
  { cmhsvColorHue :: !CUShort
  , cmhsvColorSaturation :: !CUShort
  , cmhsvColorValue :: !CUShort
  } deriving (Eq, Show)

instance Storable CMHSVColor where
  sizeOf    _ = 6
  alignment _ = 2
  peek p = CMHSVColor <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
  poke p (CMHSVColor {..}) = do
    pokeByteOff p 0 cmhsvColorHue
    pokeByteOff p 2 cmhsvColorSaturation
    pokeByteOff p 4 cmhsvColorValue

{-# NOINLINE cmhsvColorStructType #-}
cmhsvColorStructType :: Ptr CType
cmhsvColorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argCMHSVColor :: CMHSVColor -> Arg
argCMHSVColor = mkStorableArg cmhsvColorStructType

retCMHSVColor :: RetType CMHSVColor
retCMHSVColor = mkStorableRetType cmhsvColorStructType

data CMHandleLocation = CMHandleLocation
  { cmHandleLocationH :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable CMHandleLocation where
  sizeOf    _ = 8
  alignment _ = 8
  peek p = CMHandleLocation <$> peekByteOff p 0
  poke p (CMHandleLocation {..}) =
    pokeByteOff p 0 cmHandleLocationH

{-# NOINLINE cmHandleLocationStructType #-}
cmHandleLocationStructType :: Ptr CType
cmHandleLocationStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer]

argCMHandleLocation :: CMHandleLocation -> Arg
argCMHandleLocation = mkStorableArg cmHandleLocationStructType

retCMHandleLocation :: RetType CMHandleLocation
retCMHandleLocation = mkStorableRetType cmHandleLocationStructType

data CMIntentCRDVMSize = CMIntentCRDVMSize
  { cmIntentCRDVMSizeRenderingIntent :: !CUInt
  , cmIntentCRDVMSizeVMSize :: !CUInt
  } deriving (Eq, Show)

instance Storable CMIntentCRDVMSize where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = CMIntentCRDVMSize <$> peekByteOff p 0
    <*> peekByteOff p 4
  poke p (CMIntentCRDVMSize {..}) = do
    pokeByteOff p 0 cmIntentCRDVMSizeRenderingIntent
    pokeByteOff p 4 cmIntentCRDVMSizeVMSize

{-# NOINLINE cmIntentCRDVMSizeStructType #-}
cmIntentCRDVMSizeStructType :: Ptr CType
cmIntentCRDVMSizeStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint]

argCMIntentCRDVMSize :: CMIntentCRDVMSize -> Arg
argCMIntentCRDVMSize = mkStorableArg cmIntentCRDVMSizeStructType

retCMIntentCRDVMSize :: RetType CMIntentCRDVMSize
retCMIntentCRDVMSize = mkStorableRetType cmIntentCRDVMSizeStructType

data CMLabColor = CMLabColor
  { cmLabColorL :: !CUShort
  , cmLabColorA :: !CUShort
  , cmLabColorB :: !CUShort
  } deriving (Eq, Show)

instance Storable CMLabColor where
  sizeOf    _ = 6
  alignment _ = 2
  peek p = CMLabColor <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
  poke p (CMLabColor {..}) = do
    pokeByteOff p 0 cmLabColorL
    pokeByteOff p 2 cmLabColorA
    pokeByteOff p 4 cmLabColorB

{-# NOINLINE cmLabColorStructType #-}
cmLabColorStructType :: Ptr CType
cmLabColorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argCMLabColor :: CMLabColor -> Arg
argCMLabColor = mkStorableArg cmLabColorStructType

retCMLabColor :: RetType CMLabColor
retCMLabColor = mkStorableRetType cmLabColorStructType

data CMLuvColor = CMLuvColor
  { cmLuvColorL :: !CUShort
  , cmLuvColorU :: !CUShort
  , cmLuvColorV :: !CUShort
  } deriving (Eq, Show)

instance Storable CMLuvColor where
  sizeOf    _ = 6
  alignment _ = 2
  peek p = CMLuvColor <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
  poke p (CMLuvColor {..}) = do
    pokeByteOff p 0 cmLuvColorL
    pokeByteOff p 2 cmLuvColorU
    pokeByteOff p 4 cmLuvColorV

{-# NOINLINE cmLuvColorStructType #-}
cmLuvColorStructType :: Ptr CType
cmLuvColorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argCMLuvColor :: CMLuvColor -> Arg
argCMLuvColor = mkStorableArg cmLuvColorStructType

retCMLuvColor :: RetType CMLuvColor
retCMLuvColor = mkStorableRetType cmLuvColorStructType

data CMMakeAndModel = CMMakeAndModel
  { cmMakeAndModelManufacturer :: !CUInt
  , cmMakeAndModelModel :: !CUInt
  , cmMakeAndModelSerialNumber :: !CUInt
  , cmMakeAndModelManufactureDate :: !CUInt
  , cmMakeAndModelReserved1 :: !CUInt
  , cmMakeAndModelReserved2 :: !CUInt
  , cmMakeAndModelReserved3 :: !CUInt
  , cmMakeAndModelReserved4 :: !CUInt
  } deriving (Eq, Show)

instance Storable CMMakeAndModel where
  sizeOf    _ = 32
  alignment _ = 4
  peek p = CMMakeAndModel <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
    <*> peekByteOff p 16
    <*> peekByteOff p 20
    <*> peekByteOff p 24
    <*> peekByteOff p 28
  poke p (CMMakeAndModel {..}) = do
    pokeByteOff p 0 cmMakeAndModelManufacturer
    pokeByteOff p 4 cmMakeAndModelModel
    pokeByteOff p 8 cmMakeAndModelSerialNumber
    pokeByteOff p 12 cmMakeAndModelManufactureDate
    pokeByteOff p 16 cmMakeAndModelReserved1
    pokeByteOff p 20 cmMakeAndModelReserved2
    pokeByteOff p 24 cmMakeAndModelReserved3
    pokeByteOff p 28 cmMakeAndModelReserved4

{-# NOINLINE cmMakeAndModelStructType #-}
cmMakeAndModelStructType :: Ptr CType
cmMakeAndModelStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint]

argCMMakeAndModel :: CMMakeAndModel -> Arg
argCMMakeAndModel = mkStorableArg cmMakeAndModelStructType

retCMMakeAndModel :: RetType CMMakeAndModel
retCMMakeAndModel = mkStorableRetType cmMakeAndModelStructType

data CMMultiLocalizedUniCodeType = CMMultiLocalizedUniCodeType
  { cmMultiLocalizedUniCodeTypeTypeDescriptor :: !CUInt
  , cmMultiLocalizedUniCodeTypeReserved :: !CUInt
  , cmMultiLocalizedUniCodeTypeEntryCount :: !CUInt
  , cmMultiLocalizedUniCodeTypeEntrySize :: !CUInt
  } deriving (Eq, Show)

instance Storable CMMultiLocalizedUniCodeType where
  sizeOf    _ = 16
  alignment _ = 4
  peek p = CMMultiLocalizedUniCodeType <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
  poke p (CMMultiLocalizedUniCodeType {..}) = do
    pokeByteOff p 0 cmMultiLocalizedUniCodeTypeTypeDescriptor
    pokeByteOff p 4 cmMultiLocalizedUniCodeTypeReserved
    pokeByteOff p 8 cmMultiLocalizedUniCodeTypeEntryCount
    pokeByteOff p 12 cmMultiLocalizedUniCodeTypeEntrySize

{-# NOINLINE cmMultiLocalizedUniCodeTypeStructType #-}
cmMultiLocalizedUniCodeTypeStructType :: Ptr CType
cmMultiLocalizedUniCodeTypeStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint]

argCMMultiLocalizedUniCodeType :: CMMultiLocalizedUniCodeType -> Arg
argCMMultiLocalizedUniCodeType = mkStorableArg cmMultiLocalizedUniCodeTypeStructType

retCMMultiLocalizedUniCodeType :: RetType CMMultiLocalizedUniCodeType
retCMMultiLocalizedUniCodeType = mkStorableRetType cmMultiLocalizedUniCodeTypeStructType

data CMNamedColor = CMNamedColor
  { cmNamedColorNamedColorIndex :: !CUInt
  } deriving (Eq, Show)

instance Storable CMNamedColor where
  sizeOf    _ = 4
  alignment _ = 4
  peek p = CMNamedColor <$> peekByteOff p 0
  poke p (CMNamedColor {..}) =
    pokeByteOff p 0 cmNamedColorNamedColorIndex

{-# NOINLINE cmNamedColorStructType #-}
cmNamedColorStructType :: Ptr CType
cmNamedColorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint]

argCMNamedColor :: CMNamedColor -> Arg
argCMNamedColor = mkStorableArg cmNamedColorStructType

retCMNamedColor :: RetType CMNamedColor
retCMNamedColor = mkStorableRetType cmNamedColorStructType

data CMNativeDisplayInfoType = CMNativeDisplayInfoType
  { cmNativeDisplayInfoTypeTypeDescriptor :: !CUInt
  , cmNativeDisplayInfoTypeReserved :: !CUInt
  , cmNativeDisplayInfoTypeNativeDisplayInfo :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable CMNativeDisplayInfoType where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = CMNativeDisplayInfoType <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (CMNativeDisplayInfoType {..}) = do
    pokeByteOff p 0 cmNativeDisplayInfoTypeTypeDescriptor
    pokeByteOff p 4 cmNativeDisplayInfoTypeReserved
    pokeByteOff p 8 cmNativeDisplayInfoTypeNativeDisplayInfo

{-# NOINLINE cmNativeDisplayInfoTypeStructType #-}
cmNativeDisplayInfoTypeStructType :: Ptr CType
cmNativeDisplayInfoTypeStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_pointer]

argCMNativeDisplayInfoType :: CMNativeDisplayInfoType -> Arg
argCMNativeDisplayInfoType = mkStorableArg cmNativeDisplayInfoTypeStructType

retCMNativeDisplayInfoType :: RetType CMNativeDisplayInfoType
retCMNativeDisplayInfoType = mkStorableRetType cmNativeDisplayInfoTypeStructType

data CMRGBColor = CMRGBColor
  { cmrgbColorRed :: !CUShort
  , cmrgbColorGreen :: !CUShort
  , cmrgbColorBlue :: !CUShort
  } deriving (Eq, Show)

instance Storable CMRGBColor where
  sizeOf    _ = 6
  alignment _ = 2
  peek p = CMRGBColor <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
  poke p (CMRGBColor {..}) = do
    pokeByteOff p 0 cmrgbColorRed
    pokeByteOff p 2 cmrgbColorGreen
    pokeByteOff p 4 cmrgbColorBlue

{-# NOINLINE cmrgbColorStructType #-}
cmrgbColorStructType :: Ptr CType
cmrgbColorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argCMRGBColor :: CMRGBColor -> Arg
argCMRGBColor = mkStorableArg cmrgbColorStructType

retCMRGBColor :: RetType CMRGBColor
retCMRGBColor = mkStorableRetType cmrgbColorStructType

data CMScreeningChannelRec = CMScreeningChannelRec
  { cmScreeningChannelRecFrequency :: !CInt
  , cmScreeningChannelRecAngle :: !CInt
  , cmScreeningChannelRecSpotFunction :: !CUInt
  } deriving (Eq, Show)

instance Storable CMScreeningChannelRec where
  sizeOf    _ = 12
  alignment _ = 4
  peek p = CMScreeningChannelRec <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (CMScreeningChannelRec {..}) = do
    pokeByteOff p 0 cmScreeningChannelRecFrequency
    pokeByteOff p 4 cmScreeningChannelRecAngle
    pokeByteOff p 8 cmScreeningChannelRecSpotFunction

{-# NOINLINE cmScreeningChannelRecStructType #-}
cmScreeningChannelRecStructType :: Ptr CType
cmScreeningChannelRecStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_sint, ffi_type_uint]

argCMScreeningChannelRec :: CMScreeningChannelRec -> Arg
argCMScreeningChannelRec = mkStorableArg cmScreeningChannelRecStructType

retCMScreeningChannelRec :: RetType CMScreeningChannelRec
retCMScreeningChannelRec = mkStorableRetType cmScreeningChannelRecStructType

data CMSignatureType = CMSignatureType
  { cmSignatureTypeTypeDescriptor :: !CUInt
  , cmSignatureTypeReserved :: !CUInt
  , cmSignatureTypeSignature :: !CUInt
  } deriving (Eq, Show)

instance Storable CMSignatureType where
  sizeOf    _ = 12
  alignment _ = 4
  peek p = CMSignatureType <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (CMSignatureType {..}) = do
    pokeByteOff p 0 cmSignatureTypeTypeDescriptor
    pokeByteOff p 4 cmSignatureTypeReserved
    pokeByteOff p 8 cmSignatureTypeSignature

{-# NOINLINE cmSignatureTypeStructType #-}
cmSignatureTypeStructType :: Ptr CType
cmSignatureTypeStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_uint]

argCMSignatureType :: CMSignatureType -> Arg
argCMSignatureType = mkStorableArg cmSignatureTypeStructType

retCMSignatureType :: RetType CMSignatureType
retCMSignatureType = mkStorableRetType cmSignatureTypeStructType

data CMTagRecord = CMTagRecord
  { cmTagRecordTag :: !CUInt
  , cmTagRecordElementOffset :: !CUInt
  , cmTagRecordElementSize :: !CUInt
  } deriving (Eq, Show)

instance Storable CMTagRecord where
  sizeOf    _ = 12
  alignment _ = 4
  peek p = CMTagRecord <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (CMTagRecord {..}) = do
    pokeByteOff p 0 cmTagRecordTag
    pokeByteOff p 4 cmTagRecordElementOffset
    pokeByteOff p 8 cmTagRecordElementSize

{-# NOINLINE cmTagRecordStructType #-}
cmTagRecordStructType :: Ptr CType
cmTagRecordStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_uint]

argCMTagRecord :: CMTagRecord -> Arg
argCMTagRecord = mkStorableArg cmTagRecordStructType

retCMTagRecord :: RetType CMTagRecord
retCMTagRecord = mkStorableRetType cmTagRecordStructType

data CMVideoCardGammaFormula = CMVideoCardGammaFormula
  { cmVideoCardGammaFormulaRedGamma :: !CInt
  , cmVideoCardGammaFormulaRedMin :: !CInt
  , cmVideoCardGammaFormulaRedMax :: !CInt
  , cmVideoCardGammaFormulaGreenGamma :: !CInt
  , cmVideoCardGammaFormulaGreenMin :: !CInt
  , cmVideoCardGammaFormulaGreenMax :: !CInt
  , cmVideoCardGammaFormulaBlueGamma :: !CInt
  , cmVideoCardGammaFormulaBlueMin :: !CInt
  , cmVideoCardGammaFormulaBlueMax :: !CInt
  } deriving (Eq, Show)

instance Storable CMVideoCardGammaFormula where
  sizeOf    _ = 36
  alignment _ = 4
  peek p = CMVideoCardGammaFormula <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
    <*> peekByteOff p 16
    <*> peekByteOff p 20
    <*> peekByteOff p 24
    <*> peekByteOff p 28
    <*> peekByteOff p 32
  poke p (CMVideoCardGammaFormula {..}) = do
    pokeByteOff p 0 cmVideoCardGammaFormulaRedGamma
    pokeByteOff p 4 cmVideoCardGammaFormulaRedMin
    pokeByteOff p 8 cmVideoCardGammaFormulaRedMax
    pokeByteOff p 12 cmVideoCardGammaFormulaGreenGamma
    pokeByteOff p 16 cmVideoCardGammaFormulaGreenMin
    pokeByteOff p 20 cmVideoCardGammaFormulaGreenMax
    pokeByteOff p 24 cmVideoCardGammaFormulaBlueGamma
    pokeByteOff p 28 cmVideoCardGammaFormulaBlueMin
    pokeByteOff p 32 cmVideoCardGammaFormulaBlueMax

{-# NOINLINE cmVideoCardGammaFormulaStructType #-}
cmVideoCardGammaFormulaStructType :: Ptr CType
cmVideoCardGammaFormulaStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_sint, ffi_type_sint, ffi_type_sint, ffi_type_sint, ffi_type_sint, ffi_type_sint, ffi_type_sint, ffi_type_sint]

argCMVideoCardGammaFormula :: CMVideoCardGammaFormula -> Arg
argCMVideoCardGammaFormula = mkStorableArg cmVideoCardGammaFormulaStructType

retCMVideoCardGammaFormula :: RetType CMVideoCardGammaFormula
retCMVideoCardGammaFormula = mkStorableRetType cmVideoCardGammaFormulaStructType

data CMVideoCardGammaType = CMVideoCardGammaType
  { cmVideoCardGammaTypeTypeDescriptor :: !CUInt
  , cmVideoCardGammaTypeReserved :: !CUInt
  , cmVideoCardGammaTypeGamma :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable CMVideoCardGammaType where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = CMVideoCardGammaType <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (CMVideoCardGammaType {..}) = do
    pokeByteOff p 0 cmVideoCardGammaTypeTypeDescriptor
    pokeByteOff p 4 cmVideoCardGammaTypeReserved
    pokeByteOff p 8 cmVideoCardGammaTypeGamma

{-# NOINLINE cmVideoCardGammaTypeStructType #-}
cmVideoCardGammaTypeStructType :: Ptr CType
cmVideoCardGammaTypeStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_pointer]

argCMVideoCardGammaType :: CMVideoCardGammaType -> Arg
argCMVideoCardGammaType = mkStorableArg cmVideoCardGammaTypeStructType

retCMVideoCardGammaType :: RetType CMVideoCardGammaType
retCMVideoCardGammaType = mkStorableRetType cmVideoCardGammaTypeStructType

data CMXYZColor = CMXYZColor
  { cmxyzColorX :: !CUShort
  , cmxyzColorY :: !CUShort
  , cmxyzColorZ :: !CUShort
  } deriving (Eq, Show)

instance Storable CMXYZColor where
  sizeOf    _ = 6
  alignment _ = 2
  peek p = CMXYZColor <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
  poke p (CMXYZColor {..}) = do
    pokeByteOff p 0 cmxyzColorX
    pokeByteOff p 2 cmxyzColorY
    pokeByteOff p 4 cmxyzColorZ

{-# NOINLINE cmxyzColorStructType #-}
cmxyzColorStructType :: Ptr CType
cmxyzColorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argCMXYZColor :: CMXYZColor -> Arg
argCMXYZColor = mkStorableArg cmxyzColorStructType

retCMXYZColor :: RetType CMXYZColor
retCMXYZColor = mkStorableRetType cmxyzColorStructType

data CMYxyColor = CMYxyColor
  { cmYxyColorCapY :: !CUShort
  , cmYxyColorX :: !CUShort
  , cmYxyColorY :: !CUShort
  } deriving (Eq, Show)

instance Storable CMYxyColor where
  sizeOf    _ = 6
  alignment _ = 2
  peek p = CMYxyColor <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
  poke p (CMYxyColor {..}) = do
    pokeByteOff p 0 cmYxyColorCapY
    pokeByteOff p 2 cmYxyColorX
    pokeByteOff p 4 cmYxyColorY

{-# NOINLINE cmYxyColorStructType #-}
cmYxyColorStructType :: Ptr CType
cmYxyColorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argCMYxyColor :: CMYxyColor -> Arg
argCMYxyColor = mkStorableArg cmYxyColorStructType

retCMYxyColor :: RetType CMYxyColor
retCMYxyColor = mkStorableRetType cmYxyColorStructType

data CQDProcs = CQDProcs
  { cqdProcsTextProc :: !(Ptr ())
  , cqdProcsLineProc :: !(Ptr ())
  , cqdProcsRectProc :: !(Ptr ())
  , cqdProcsRRectProc :: !(Ptr ())
  , cqdProcsOvalProc :: !(Ptr ())
  , cqdProcsArcProc :: !(Ptr ())
  , cqdProcsPolyProc :: !(Ptr ())
  , cqdProcsRgnProc :: !(Ptr ())
  , cqdProcsBitsProc :: !(Ptr ())
  , cqdProcsCommentProc :: !(Ptr ())
  , cqdProcsTxMeasProc :: !(Ptr ())
  , cqdProcsGetPicProc :: !(Ptr ())
  , cqdProcsPutPicProc :: !(Ptr ())
  , cqdProcsOpcodeProc :: !(Ptr ())
  , cqdProcsNewProc1 :: !(Ptr ())
  , cqdProcsGlyphsProc :: !(Ptr ())
  , cqdProcsPrinterStatusProc :: !(Ptr ())
  , cqdProcsNewProc4 :: !(Ptr ())
  , cqdProcsNewProc5 :: !(Ptr ())
  , cqdProcsNewProc6 :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable CQDProcs where
  sizeOf    _ = 160
  alignment _ = 8
  peek p = CQDProcs <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 24
    <*> peekByteOff p 32
    <*> peekByteOff p 40
    <*> peekByteOff p 48
    <*> peekByteOff p 56
    <*> peekByteOff p 64
    <*> peekByteOff p 72
    <*> peekByteOff p 80
    <*> peekByteOff p 88
    <*> peekByteOff p 96
    <*> peekByteOff p 104
    <*> peekByteOff p 112
    <*> peekByteOff p 120
    <*> peekByteOff p 128
    <*> peekByteOff p 136
    <*> peekByteOff p 144
    <*> peekByteOff p 152
  poke p (CQDProcs {..}) = do
    pokeByteOff p 0 cqdProcsTextProc
    pokeByteOff p 8 cqdProcsLineProc
    pokeByteOff p 16 cqdProcsRectProc
    pokeByteOff p 24 cqdProcsRRectProc
    pokeByteOff p 32 cqdProcsOvalProc
    pokeByteOff p 40 cqdProcsArcProc
    pokeByteOff p 48 cqdProcsPolyProc
    pokeByteOff p 56 cqdProcsRgnProc
    pokeByteOff p 64 cqdProcsBitsProc
    pokeByteOff p 72 cqdProcsCommentProc
    pokeByteOff p 80 cqdProcsTxMeasProc
    pokeByteOff p 88 cqdProcsGetPicProc
    pokeByteOff p 96 cqdProcsPutPicProc
    pokeByteOff p 104 cqdProcsOpcodeProc
    pokeByteOff p 112 cqdProcsNewProc1
    pokeByteOff p 120 cqdProcsGlyphsProc
    pokeByteOff p 128 cqdProcsPrinterStatusProc
    pokeByteOff p 136 cqdProcsNewProc4
    pokeByteOff p 144 cqdProcsNewProc5
    pokeByteOff p 152 cqdProcsNewProc6

{-# NOINLINE cqdProcsStructType #-}
cqdProcsStructType :: Ptr CType
cqdProcsStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer]

argCQDProcs :: CQDProcs -> Arg
argCQDProcs = mkStorableArg cqdProcsStructType

retCQDProcs :: RetType CQDProcs
retCQDProcs = mkStorableRetType cqdProcsStructType

data FMFontFamilyInstance = FMFontFamilyInstance
  { fmFontFamilyInstanceFontFamily :: !CShort
  , fmFontFamilyInstanceFontStyle :: !CShort
  } deriving (Eq, Show)

instance Storable FMFontFamilyInstance where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = FMFontFamilyInstance <$> peekByteOff p 0
    <*> peekByteOff p 2
  poke p (FMFontFamilyInstance {..}) = do
    pokeByteOff p 0 fmFontFamilyInstanceFontFamily
    pokeByteOff p 2 fmFontFamilyInstanceFontStyle

{-# NOINLINE fmFontFamilyInstanceStructType #-}
fmFontFamilyInstanceStructType :: Ptr CType
fmFontFamilyInstanceStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16, ffi_type_sint16]

argFMFontFamilyInstance :: FMFontFamilyInstance -> Arg
argFMFontFamilyInstance = mkStorableArg fmFontFamilyInstanceStructType

retFMFontFamilyInstance :: RetType FMFontFamilyInstance
retFMFontFamilyInstance = mkStorableRetType fmFontFamilyInstanceStructType

data FontAssoc = FontAssoc
  { fontAssocNumAssoc :: !CShort
  } deriving (Eq, Show)

instance Storable FontAssoc where
  sizeOf    _ = 2
  alignment _ = 2
  peek p = FontAssoc <$> peekByteOff p 0
  poke p (FontAssoc {..}) =
    pokeByteOff p 0 fontAssocNumAssoc

{-# NOINLINE fontAssocStructType #-}
fontAssocStructType :: Ptr CType
fontAssocStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16]

argFontAssoc :: FontAssoc -> Arg
argFontAssoc = mkStorableArg fontAssocStructType

retFontAssoc :: RetType FontAssoc
retFontAssoc = mkStorableRetType fontAssocStructType

data FontInfo = FontInfo
  { fontInfoAscent :: !CShort
  , fontInfoDescent :: !CShort
  , fontInfoWidMax :: !CShort
  , fontInfoLeading :: !CShort
  } deriving (Eq, Show)

instance Storable FontInfo where
  sizeOf    _ = 8
  alignment _ = 2
  peek p = FontInfo <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 6
  poke p (FontInfo {..}) = do
    pokeByteOff p 0 fontInfoAscent
    pokeByteOff p 2 fontInfoDescent
    pokeByteOff p 4 fontInfoWidMax
    pokeByteOff p 6 fontInfoLeading

{-# NOINLINE fontInfoStructType #-}
fontInfoStructType :: Ptr CType
fontInfoStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16]

argFontInfo :: FontInfo -> Arg
argFontInfo = mkStorableArg fontInfoStructType

retFontInfo :: RetType FontInfo
retFontInfo = mkStorableRetType fontInfoStructType

data FontRec = FontRec
  { fontRecFontType :: !CShort
  , fontRecFirstChar :: !CShort
  , fontRecLastChar :: !CShort
  , fontRecWidMax :: !CShort
  , fontRecKernMax :: !CShort
  , fontRecNDescent :: !CShort
  , fontRecFRectWidth :: !CShort
  , fontRecFRectHeight :: !CShort
  , fontRecOwTLoc :: !CUShort
  , fontRecAscent :: !CShort
  , fontRecDescent :: !CShort
  , fontRecLeading :: !CShort
  , fontRecRowWords :: !CShort
  } deriving (Eq, Show)

instance Storable FontRec where
  sizeOf    _ = 26
  alignment _ = 2
  peek p = FontRec <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 6
    <*> peekByteOff p 8
    <*> peekByteOff p 10
    <*> peekByteOff p 12
    <*> peekByteOff p 14
    <*> peekByteOff p 16
    <*> peekByteOff p 18
    <*> peekByteOff p 20
    <*> peekByteOff p 22
    <*> peekByteOff p 24
  poke p (FontRec {..}) = do
    pokeByteOff p 0 fontRecFontType
    pokeByteOff p 2 fontRecFirstChar
    pokeByteOff p 4 fontRecLastChar
    pokeByteOff p 6 fontRecWidMax
    pokeByteOff p 8 fontRecKernMax
    pokeByteOff p 10 fontRecNDescent
    pokeByteOff p 12 fontRecFRectWidth
    pokeByteOff p 14 fontRecFRectHeight
    pokeByteOff p 16 fontRecOwTLoc
    pokeByteOff p 18 fontRecAscent
    pokeByteOff p 20 fontRecDescent
    pokeByteOff p 22 fontRecLeading
    pokeByteOff p 24 fontRecRowWords

{-# NOINLINE fontRecStructType #-}
fontRecStructType :: Ptr CType
fontRecStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16, ffi_type_uint16, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16]

argFontRec :: FontRec -> Arg
argFontRec = mkStorableArg fontRecStructType

retFontRec :: RetType FontRec
retFontRec = mkStorableRetType fontRecStructType

data FontVariation = FontVariation
  { fontVariationName :: !CUInt
  , fontVariationValue :: !CInt
  } deriving (Eq, Show)

instance Storable FontVariation where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = FontVariation <$> peekByteOff p 0
    <*> peekByteOff p 4
  poke p (FontVariation {..}) = do
    pokeByteOff p 0 fontVariationName
    pokeByteOff p 4 fontVariationValue

{-# NOINLINE fontVariationStructType #-}
fontVariationStructType :: Ptr CType
fontVariationStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_sint]

argFontVariation :: FontVariation -> Arg
argFontVariation = mkStorableArg fontVariationStructType

retFontVariation :: RetType FontVariation
retFontVariation = mkStorableRetType fontVariationStructType

data JustDirectionTable = JustDirectionTable
  { justDirectionTableJustClass :: !CUShort
  , justDirectionTableWidthDeltaClusters :: !CUShort
  , justDirectionTablePostcomp :: !CUShort
  , justDirectionTableLookup :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable JustDirectionTable where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = JustDirectionTable <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (JustDirectionTable {..}) = do
    pokeByteOff p 0 justDirectionTableJustClass
    pokeByteOff p 2 justDirectionTableWidthDeltaClusters
    pokeByteOff p 4 justDirectionTablePostcomp
    pokeByteOff p 8 justDirectionTableLookup

{-# NOINLINE justDirectionTableStructType #-}
justDirectionTableStructType :: Ptr CType
justDirectionTableStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint16, ffi_type_pointer]

argJustDirectionTable :: JustDirectionTable -> Arg
argJustDirectionTable = mkStorableArg justDirectionTableStructType

retJustDirectionTable :: RetType JustDirectionTable
retJustDirectionTable = mkStorableRetType justDirectionTableStructType

data JustPCActionSubrecord = JustPCActionSubrecord
  { justPCActionSubrecordTheClass :: !CUShort
  , justPCActionSubrecordTheType :: !CUShort
  , justPCActionSubrecordLength :: !CUInt
  , justPCActionSubrecordData :: !CUInt
  } deriving (Eq, Show)

instance Storable JustPCActionSubrecord where
  sizeOf    _ = 12
  alignment _ = 4
  peek p = JustPCActionSubrecord <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (JustPCActionSubrecord {..}) = do
    pokeByteOff p 0 justPCActionSubrecordTheClass
    pokeByteOff p 2 justPCActionSubrecordTheType
    pokeByteOff p 4 justPCActionSubrecordLength
    pokeByteOff p 8 justPCActionSubrecordData

{-# NOINLINE justPCActionSubrecordStructType #-}
justPCActionSubrecordStructType :: Ptr CType
justPCActionSubrecordStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint, ffi_type_uint]

argJustPCActionSubrecord :: JustPCActionSubrecord -> Arg
argJustPCActionSubrecord = mkStorableArg justPCActionSubrecordStructType

retJustPCActionSubrecord :: RetType JustPCActionSubrecord
retJustPCActionSubrecord = mkStorableRetType justPCActionSubrecordStructType

data JustPCConditionalAddAction = JustPCConditionalAddAction
  { justPCConditionalAddActionSubstThreshold :: !CInt
  , justPCConditionalAddActionAddGlyph :: !CUShort
  , justPCConditionalAddActionSubstGlyph :: !CUShort
  } deriving (Eq, Show)

instance Storable JustPCConditionalAddAction where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = JustPCConditionalAddAction <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 6
  poke p (JustPCConditionalAddAction {..}) = do
    pokeByteOff p 0 justPCConditionalAddActionSubstThreshold
    pokeByteOff p 4 justPCConditionalAddActionAddGlyph
    pokeByteOff p 6 justPCConditionalAddActionSubstGlyph

{-# NOINLINE justPCConditionalAddActionStructType #-}
justPCConditionalAddActionStructType :: Ptr CType
justPCConditionalAddActionStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_uint16, ffi_type_uint16]

argJustPCConditionalAddAction :: JustPCConditionalAddAction -> Arg
argJustPCConditionalAddAction = mkStorableArg justPCConditionalAddActionStructType

retJustPCConditionalAddAction :: RetType JustPCConditionalAddAction
retJustPCConditionalAddAction = mkStorableRetType justPCConditionalAddActionStructType

data JustPCDuctilityAction = JustPCDuctilityAction
  { justPCDuctilityActionDuctilityAxis :: !CUInt
  , justPCDuctilityActionMinimumLimit :: !CInt
  , justPCDuctilityActionNoStretchValue :: !CInt
  , justPCDuctilityActionMaximumLimit :: !CInt
  } deriving (Eq, Show)

instance Storable JustPCDuctilityAction where
  sizeOf    _ = 16
  alignment _ = 4
  peek p = JustPCDuctilityAction <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
  poke p (JustPCDuctilityAction {..}) = do
    pokeByteOff p 0 justPCDuctilityActionDuctilityAxis
    pokeByteOff p 4 justPCDuctilityActionMinimumLimit
    pokeByteOff p 8 justPCDuctilityActionNoStretchValue
    pokeByteOff p 12 justPCDuctilityActionMaximumLimit

{-# NOINLINE justPCDuctilityActionStructType #-}
justPCDuctilityActionStructType :: Ptr CType
justPCDuctilityActionStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_sint, ffi_type_sint, ffi_type_sint]

argJustPCDuctilityAction :: JustPCDuctilityAction -> Arg
argJustPCDuctilityAction = mkStorableArg justPCDuctilityActionStructType

retJustPCDuctilityAction :: RetType JustPCDuctilityAction
retJustPCDuctilityAction = mkStorableRetType justPCDuctilityActionStructType

data JustPCGlyphRepeatAddAction = JustPCGlyphRepeatAddAction
  { justPCGlyphRepeatAddActionFlags :: !CUShort
  , justPCGlyphRepeatAddActionGlyph :: !CUShort
  } deriving (Eq, Show)

instance Storable JustPCGlyphRepeatAddAction where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = JustPCGlyphRepeatAddAction <$> peekByteOff p 0
    <*> peekByteOff p 2
  poke p (JustPCGlyphRepeatAddAction {..}) = do
    pokeByteOff p 0 justPCGlyphRepeatAddActionFlags
    pokeByteOff p 2 justPCGlyphRepeatAddActionGlyph

{-# NOINLINE justPCGlyphRepeatAddActionStructType #-}
justPCGlyphRepeatAddActionStructType :: Ptr CType
justPCGlyphRepeatAddActionStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16]

argJustPCGlyphRepeatAddAction :: JustPCGlyphRepeatAddAction -> Arg
argJustPCGlyphRepeatAddAction = mkStorableArg justPCGlyphRepeatAddActionStructType

retJustPCGlyphRepeatAddAction :: RetType JustPCGlyphRepeatAddAction
retJustPCGlyphRepeatAddAction = mkStorableRetType justPCGlyphRepeatAddActionStructType

data JustPostcompTable = JustPostcompTable
  { justPostcompTableLookupTable :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable JustPostcompTable where
  sizeOf    _ = 8
  alignment _ = 8
  peek p = JustPostcompTable <$> peekByteOff p 0
  poke p (JustPostcompTable {..}) =
    pokeByteOff p 0 justPostcompTableLookupTable

{-# NOINLINE justPostcompTableStructType #-}
justPostcompTableStructType :: Ptr CType
justPostcompTableStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer]

argJustPostcompTable :: JustPostcompTable -> Arg
argJustPostcompTable = mkStorableArg justPostcompTableStructType

retJustPostcompTable :: RetType JustPostcompTable
retJustPostcompTable = mkStorableRetType justPostcompTableStructType

data JustTable = JustTable
  { justTableVersion :: !CInt
  , justTableFormat :: !CUShort
  , justTableHorizHeaderOffset :: !CUShort
  , justTableVertHeaderOffset :: !CUShort
  } deriving (Eq, Show)

instance Storable JustTable where
  sizeOf    _ = 12
  alignment _ = 4
  peek p = JustTable <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 6
    <*> peekByteOff p 8
  poke p (JustTable {..}) = do
    pokeByteOff p 0 justTableVersion
    pokeByteOff p 4 justTableFormat
    pokeByteOff p 6 justTableHorizHeaderOffset
    pokeByteOff p 8 justTableVertHeaderOffset

{-# NOINLINE justTableStructType #-}
justTableStructType :: Ptr CType
justTableStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argJustTable :: JustTable -> Arg
argJustTable = mkStorableArg justTableStructType

retJustTable :: RetType JustTable
retJustTable = mkStorableRetType justTableStructType

data JustWidthDeltaEntry = JustWidthDeltaEntry
  { justWidthDeltaEntryJustClass :: !CUInt
  , justWidthDeltaEntryBeforeGrowLimit :: !CInt
  , justWidthDeltaEntryBeforeShrinkLimit :: !CInt
  , justWidthDeltaEntryAfterGrowLimit :: !CInt
  , justWidthDeltaEntryAfterShrinkLimit :: !CInt
  , justWidthDeltaEntryGrowFlags :: !CUShort
  , justWidthDeltaEntryShrinkFlags :: !CUShort
  } deriving (Eq, Show)

instance Storable JustWidthDeltaEntry where
  sizeOf    _ = 24
  alignment _ = 4
  peek p = JustWidthDeltaEntry <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
    <*> peekByteOff p 16
    <*> peekByteOff p 20
    <*> peekByteOff p 22
  poke p (JustWidthDeltaEntry {..}) = do
    pokeByteOff p 0 justWidthDeltaEntryJustClass
    pokeByteOff p 4 justWidthDeltaEntryBeforeGrowLimit
    pokeByteOff p 8 justWidthDeltaEntryBeforeShrinkLimit
    pokeByteOff p 12 justWidthDeltaEntryAfterGrowLimit
    pokeByteOff p 16 justWidthDeltaEntryAfterShrinkLimit
    pokeByteOff p 20 justWidthDeltaEntryGrowFlags
    pokeByteOff p 22 justWidthDeltaEntryShrinkFlags

{-# NOINLINE justWidthDeltaEntryStructType #-}
justWidthDeltaEntryStructType :: Ptr CType
justWidthDeltaEntryStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_sint, ffi_type_sint, ffi_type_sint, ffi_type_sint, ffi_type_uint16, ffi_type_uint16]

argJustWidthDeltaEntry :: JustWidthDeltaEntry -> Arg
argJustWidthDeltaEntry = mkStorableArg justWidthDeltaEntryStructType

retJustWidthDeltaEntry :: RetType JustWidthDeltaEntry
retJustWidthDeltaEntry = mkStorableRetType justWidthDeltaEntryStructType

data KernEntry = KernEntry
  { kernEntryKernStyle :: !CShort
  , kernEntryKernLength :: !CShort
  } deriving (Eq, Show)

instance Storable KernEntry where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = KernEntry <$> peekByteOff p 0
    <*> peekByteOff p 2
  poke p (KernEntry {..}) = do
    pokeByteOff p 0 kernEntryKernStyle
    pokeByteOff p 2 kernEntryKernLength

{-# NOINLINE kernEntryStructType #-}
kernEntryStructType :: Ptr CType
kernEntryStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16, ffi_type_sint16]

argKernEntry :: KernEntry -> Arg
argKernEntry = mkStorableArg kernEntryStructType

retKernEntry :: RetType KernEntry
retKernEntry = mkStorableRetType kernEntryStructType

data KernKerningPair = KernKerningPair
  { kernKerningPairLeft :: !CUShort
  , kernKerningPairRight :: !CUShort
  } deriving (Eq, Show)

instance Storable KernKerningPair where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = KernKerningPair <$> peekByteOff p 0
    <*> peekByteOff p 2
  poke p (KernKerningPair {..}) = do
    pokeByteOff p 0 kernKerningPairLeft
    pokeByteOff p 2 kernKerningPairRight

{-# NOINLINE kernKerningPairStructType #-}
kernKerningPairStructType :: Ptr CType
kernKerningPairStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16]

argKernKerningPair :: KernKerningPair -> Arg
argKernKerningPair = mkStorableArg kernKerningPairStructType

retKernKerningPair :: RetType KernKerningPair
retKernKerningPair = mkStorableRetType kernKerningPairStructType

data KernPair = KernPair
  { kernPairKernFirst :: !CChar
  , kernPairKernSecond :: !CChar
  , kernPairKernWidth :: !CShort
  } deriving (Eq, Show)

instance Storable KernPair where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = KernPair <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
  poke p (KernPair {..}) = do
    pokeByteOff p 0 kernPairKernFirst
    pokeByteOff p 1 kernPairKernSecond
    pokeByteOff p 2 kernPairKernWidth

{-# NOINLINE kernPairStructType #-}
kernPairStructType :: Ptr CType
kernPairStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint8, ffi_type_sint8, ffi_type_sint16]

argKernPair :: KernPair -> Arg
argKernPair = mkStorableArg kernPairStructType

retKernPair :: RetType KernPair
retKernPair = mkStorableRetType kernPairStructType

data KernStateEntry = KernStateEntry
  { kernStateEntryNewState :: !CUShort
  , kernStateEntryFlags :: !CUShort
  } deriving (Eq, Show)

instance Storable KernStateEntry where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = KernStateEntry <$> peekByteOff p 0
    <*> peekByteOff p 2
  poke p (KernStateEntry {..}) = do
    pokeByteOff p 0 kernStateEntryNewState
    pokeByteOff p 2 kernStateEntryFlags

{-# NOINLINE kernStateEntryStructType #-}
kernStateEntryStructType :: Ptr CType
kernStateEntryStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16]

argKernStateEntry :: KernStateEntry -> Arg
argKernStateEntry = mkStorableArg kernStateEntryStructType

retKernStateEntry :: RetType KernStateEntry
retKernStateEntry = mkStorableRetType kernStateEntryStructType

data KernTable = KernTable
  { kernTableNumKerns :: !CShort
  } deriving (Eq, Show)

instance Storable KernTable where
  sizeOf    _ = 2
  alignment _ = 2
  peek p = KernTable <$> peekByteOff p 0
  poke p (KernTable {..}) =
    pokeByteOff p 0 kernTableNumKerns

{-# NOINLINE kernTableStructType #-}
kernTableStructType :: Ptr CType
kernTableStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16]

argKernTable :: KernTable -> Arg
argKernTable = mkStorableArg kernTableStructType

retKernTable :: RetType KernTable
retKernTable = mkStorableRetType kernTableStructType

data KerxAnchorPointAction = KerxAnchorPointAction
  { kerxAnchorPointActionMarkAnchorPoint :: !CUShort
  , kerxAnchorPointActionCurrAnchorPoint :: !CUShort
  } deriving (Eq, Show)

instance Storable KerxAnchorPointAction where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = KerxAnchorPointAction <$> peekByteOff p 0
    <*> peekByteOff p 2
  poke p (KerxAnchorPointAction {..}) = do
    pokeByteOff p 0 kerxAnchorPointActionMarkAnchorPoint
    pokeByteOff p 2 kerxAnchorPointActionCurrAnchorPoint

{-# NOINLINE kerxAnchorPointActionStructType #-}
kerxAnchorPointActionStructType :: Ptr CType
kerxAnchorPointActionStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16]

argKerxAnchorPointAction :: KerxAnchorPointAction -> Arg
argKerxAnchorPointAction = mkStorableArg kerxAnchorPointActionStructType

retKerxAnchorPointAction :: RetType KerxAnchorPointAction
retKerxAnchorPointAction = mkStorableRetType kerxAnchorPointActionStructType

data KerxControlPointAction = KerxControlPointAction
  { kerxControlPointActionMarkControlPoint :: !CUShort
  , kerxControlPointActionCurrControlPoint :: !CUShort
  } deriving (Eq, Show)

instance Storable KerxControlPointAction where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = KerxControlPointAction <$> peekByteOff p 0
    <*> peekByteOff p 2
  poke p (KerxControlPointAction {..}) = do
    pokeByteOff p 0 kerxControlPointActionMarkControlPoint
    pokeByteOff p 2 kerxControlPointActionCurrControlPoint

{-# NOINLINE kerxControlPointActionStructType #-}
kerxControlPointActionStructType :: Ptr CType
kerxControlPointActionStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16]

argKerxControlPointAction :: KerxControlPointAction -> Arg
argKerxControlPointAction = mkStorableArg kerxControlPointActionStructType

retKerxControlPointAction :: RetType KerxControlPointAction
retKerxControlPointAction = mkStorableRetType kerxControlPointActionStructType

data KerxControlPointEntry = KerxControlPointEntry
  { kerxControlPointEntryNewState :: !CUShort
  , kerxControlPointEntryFlags :: !CUShort
  , kerxControlPointEntryActionIndex :: !CUShort
  } deriving (Eq, Show)

instance Storable KerxControlPointEntry where
  sizeOf    _ = 6
  alignment _ = 2
  peek p = KerxControlPointEntry <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
  poke p (KerxControlPointEntry {..}) = do
    pokeByteOff p 0 kerxControlPointEntryNewState
    pokeByteOff p 2 kerxControlPointEntryFlags
    pokeByteOff p 4 kerxControlPointEntryActionIndex

{-# NOINLINE kerxControlPointEntryStructType #-}
kerxControlPointEntryStructType :: Ptr CType
kerxControlPointEntryStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argKerxControlPointEntry :: KerxControlPointEntry -> Arg
argKerxControlPointEntry = mkStorableArg kerxControlPointEntryStructType

retKerxControlPointEntry :: RetType KerxControlPointEntry
retKerxControlPointEntry = mkStorableRetType kerxControlPointEntryStructType

data KerxCoordinateAction = KerxCoordinateAction
  { kerxCoordinateActionMarkX :: !CUShort
  , kerxCoordinateActionMarkY :: !CUShort
  , kerxCoordinateActionCurrX :: !CUShort
  , kerxCoordinateActionCurrY :: !CUShort
  } deriving (Eq, Show)

instance Storable KerxCoordinateAction where
  sizeOf    _ = 8
  alignment _ = 2
  peek p = KerxCoordinateAction <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 6
  poke p (KerxCoordinateAction {..}) = do
    pokeByteOff p 0 kerxCoordinateActionMarkX
    pokeByteOff p 2 kerxCoordinateActionMarkY
    pokeByteOff p 4 kerxCoordinateActionCurrX
    pokeByteOff p 6 kerxCoordinateActionCurrY

{-# NOINLINE kerxCoordinateActionStructType #-}
kerxCoordinateActionStructType :: Ptr CType
kerxCoordinateActionStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argKerxCoordinateAction :: KerxCoordinateAction -> Arg
argKerxCoordinateAction = mkStorableArg kerxCoordinateActionStructType

retKerxCoordinateAction :: RetType KerxCoordinateAction
retKerxCoordinateAction = mkStorableRetType kerxCoordinateActionStructType

data KerxIndexArrayHeader = KerxIndexArrayHeader
  { kerxIndexArrayHeaderFlags :: !CUInt
  , kerxIndexArrayHeaderRowCount :: !CUShort
  , kerxIndexArrayHeaderColumnCount :: !CUShort
  , kerxIndexArrayHeaderRowIndexTableOffset :: !CUInt
  , kerxIndexArrayHeaderColumnIndexTableOffset :: !CUInt
  , kerxIndexArrayHeaderKerningArrayOffset :: !CUInt
  , kerxIndexArrayHeaderKerningVectorOffset :: !CUInt
  } deriving (Eq, Show)

instance Storable KerxIndexArrayHeader where
  sizeOf    _ = 24
  alignment _ = 4
  peek p = KerxIndexArrayHeader <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 6
    <*> peekByteOff p 8
    <*> peekByteOff p 12
    <*> peekByteOff p 16
    <*> peekByteOff p 20
  poke p (KerxIndexArrayHeader {..}) = do
    pokeByteOff p 0 kerxIndexArrayHeaderFlags
    pokeByteOff p 4 kerxIndexArrayHeaderRowCount
    pokeByteOff p 6 kerxIndexArrayHeaderColumnCount
    pokeByteOff p 8 kerxIndexArrayHeaderRowIndexTableOffset
    pokeByteOff p 12 kerxIndexArrayHeaderColumnIndexTableOffset
    pokeByteOff p 16 kerxIndexArrayHeaderKerningArrayOffset
    pokeByteOff p 20 kerxIndexArrayHeaderKerningVectorOffset

{-# NOINLINE kerxIndexArrayHeaderStructType #-}
kerxIndexArrayHeaderStructType :: Ptr CType
kerxIndexArrayHeaderStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint16, ffi_type_uint16, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint]

argKerxIndexArrayHeader :: KerxIndexArrayHeader -> Arg
argKerxIndexArrayHeader = mkStorableArg kerxIndexArrayHeaderStructType

retKerxIndexArrayHeader :: RetType KerxIndexArrayHeader
retKerxIndexArrayHeader = mkStorableRetType kerxIndexArrayHeaderStructType

data KerxKerningPair = KerxKerningPair
  { kerxKerningPairLeft :: !CUShort
  , kerxKerningPairRight :: !CUShort
  } deriving (Eq, Show)

instance Storable KerxKerningPair where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = KerxKerningPair <$> peekByteOff p 0
    <*> peekByteOff p 2
  poke p (KerxKerningPair {..}) = do
    pokeByteOff p 0 kerxKerningPairLeft
    pokeByteOff p 2 kerxKerningPairRight

{-# NOINLINE kerxKerningPairStructType #-}
kerxKerningPairStructType :: Ptr CType
kerxKerningPairStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16]

argKerxKerningPair :: KerxKerningPair -> Arg
argKerxKerningPair = mkStorableArg kerxKerningPairStructType

retKerxKerningPair :: RetType KerxKerningPair
retKerxKerningPair = mkStorableRetType kerxKerningPairStructType

data KerxStateEntry = KerxStateEntry
  { kerxStateEntryNewState :: !CUShort
  , kerxStateEntryFlags :: !CUShort
  , kerxStateEntryValueIndex :: !CUShort
  } deriving (Eq, Show)

instance Storable KerxStateEntry where
  sizeOf    _ = 6
  alignment _ = 2
  peek p = KerxStateEntry <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
  poke p (KerxStateEntry {..}) = do
    pokeByteOff p 0 kerxStateEntryNewState
    pokeByteOff p 2 kerxStateEntryFlags
    pokeByteOff p 4 kerxStateEntryValueIndex

{-# NOINLINE kerxStateEntryStructType #-}
kerxStateEntryStructType :: Ptr CType
kerxStateEntryStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argKerxStateEntry :: KerxStateEntry -> Arg
argKerxStateEntry = mkStorableArg kerxStateEntryStructType

retKerxStateEntry :: RetType KerxStateEntry
retKerxStateEntry = mkStorableRetType kerxStateEntryStructType

data LcarCaretTable = LcarCaretTable
  { lcarCaretTableVersion :: !CInt
  , lcarCaretTableFormat :: !CUShort
  , lcarCaretTableLookup :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable LcarCaretTable where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = LcarCaretTable <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (LcarCaretTable {..}) = do
    pokeByteOff p 0 lcarCaretTableVersion
    pokeByteOff p 4 lcarCaretTableFormat
    pokeByteOff p 8 lcarCaretTableLookup

{-# NOINLINE lcarCaretTableStructType #-}
lcarCaretTableStructType :: Ptr CType
lcarCaretTableStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_uint16, ffi_type_pointer]

argLcarCaretTable :: LcarCaretTable -> Arg
argLcarCaretTable = mkStorableArg lcarCaretTableStructType

retLcarCaretTable :: RetType LcarCaretTable
retLcarCaretTable = mkStorableRetType lcarCaretTableStructType

data LtagStringRange = LtagStringRange
  { ltagStringRangeOffset :: !CUShort
  , ltagStringRangeLength :: !CUShort
  } deriving (Eq, Show)

instance Storable LtagStringRange where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = LtagStringRange <$> peekByteOff p 0
    <*> peekByteOff p 2
  poke p (LtagStringRange {..}) = do
    pokeByteOff p 0 ltagStringRangeOffset
    pokeByteOff p 2 ltagStringRangeLength

{-# NOINLINE ltagStringRangeStructType #-}
ltagStringRangeStructType :: Ptr CType
ltagStringRangeStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16]

argLtagStringRange :: LtagStringRange -> Arg
argLtagStringRange = mkStorableArg ltagStringRangeStructType

retLtagStringRange :: RetType LtagStringRange
retLtagStringRange = mkStorableRetType ltagStringRangeStructType

data MortFeatureEntry = MortFeatureEntry
  { mortFeatureEntryFeatureType :: !CUShort
  , mortFeatureEntryFeatureSelector :: !CUShort
  , mortFeatureEntryEnableFlags :: !CUInt
  , mortFeatureEntryDisableFlags :: !CUInt
  } deriving (Eq, Show)

instance Storable MortFeatureEntry where
  sizeOf    _ = 12
  alignment _ = 4
  peek p = MortFeatureEntry <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (MortFeatureEntry {..}) = do
    pokeByteOff p 0 mortFeatureEntryFeatureType
    pokeByteOff p 2 mortFeatureEntryFeatureSelector
    pokeByteOff p 4 mortFeatureEntryEnableFlags
    pokeByteOff p 8 mortFeatureEntryDisableFlags

{-# NOINLINE mortFeatureEntryStructType #-}
mortFeatureEntryStructType :: Ptr CType
mortFeatureEntryStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint, ffi_type_uint]

argMortFeatureEntry :: MortFeatureEntry -> Arg
argMortFeatureEntry = mkStorableArg mortFeatureEntryStructType

retMortFeatureEntry :: RetType MortFeatureEntry
retMortFeatureEntry = mkStorableRetType mortFeatureEntryStructType

data MortSwashSubtable = MortSwashSubtable
  { mortSwashSubtableLookup :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable MortSwashSubtable where
  sizeOf    _ = 8
  alignment _ = 8
  peek p = MortSwashSubtable <$> peekByteOff p 0
  poke p (MortSwashSubtable {..}) =
    pokeByteOff p 0 mortSwashSubtableLookup

{-# NOINLINE mortSwashSubtableStructType #-}
mortSwashSubtableStructType :: Ptr CType
mortSwashSubtableStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer]

argMortSwashSubtable :: MortSwashSubtable -> Arg
argMortSwashSubtable = mkStorableArg mortSwashSubtableStructType

retMortSwashSubtable :: RetType MortSwashSubtable
retMortSwashSubtable = mkStorableRetType mortSwashSubtableStructType

data NCMConcatProfileSpec = NCMConcatProfileSpec
  { ncmConcatProfileSpecRenderingIntent :: !CUInt
  , ncmConcatProfileSpecTransformTag :: !CUInt
  , ncmConcatProfileSpecProfile :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable NCMConcatProfileSpec where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = NCMConcatProfileSpec <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (NCMConcatProfileSpec {..}) = do
    pokeByteOff p 0 ncmConcatProfileSpecRenderingIntent
    pokeByteOff p 4 ncmConcatProfileSpecTransformTag
    pokeByteOff p 8 ncmConcatProfileSpecProfile

{-# NOINLINE ncmConcatProfileSpecStructType #-}
ncmConcatProfileSpecStructType :: Ptr CType
ncmConcatProfileSpecStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_pointer]

argNCMConcatProfileSpec :: NCMConcatProfileSpec -> Arg
argNCMConcatProfileSpec = mkStorableArg ncmConcatProfileSpecStructType

retNCMConcatProfileSpec :: RetType NCMConcatProfileSpec
retNCMConcatProfileSpec = mkStorableRetType ncmConcatProfileSpecStructType

data OpbdSideValues = OpbdSideValues
  { opbdSideValuesLeftSideShift :: !CShort
  , opbdSideValuesTopSideShift :: !CShort
  , opbdSideValuesRightSideShift :: !CShort
  , opbdSideValuesBottomSideShift :: !CShort
  } deriving (Eq, Show)

instance Storable OpbdSideValues where
  sizeOf    _ = 8
  alignment _ = 2
  peek p = OpbdSideValues <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 6
  poke p (OpbdSideValues {..}) = do
    pokeByteOff p 0 opbdSideValuesLeftSideShift
    pokeByteOff p 2 opbdSideValuesTopSideShift
    pokeByteOff p 4 opbdSideValuesRightSideShift
    pokeByteOff p 6 opbdSideValuesBottomSideShift

{-# NOINLINE opbdSideValuesStructType #-}
opbdSideValuesStructType :: Ptr CType
opbdSideValuesStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16]

argOpbdSideValues :: OpbdSideValues -> Arg
argOpbdSideValues = mkStorableArg opbdSideValuesStructType

retOpbdSideValues :: RetType OpbdSideValues
retOpbdSideValues = mkStorableRetType opbdSideValuesStructType

data OpbdTable = OpbdTable
  { opbdTableVersion :: !CInt
  , opbdTableFormat :: !CUShort
  , opbdTableLookupTable :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable OpbdTable where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = OpbdTable <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (OpbdTable {..}) = do
    pokeByteOff p 0 opbdTableVersion
    pokeByteOff p 4 opbdTableFormat
    pokeByteOff p 8 opbdTableLookupTable

{-# NOINLINE opbdTableStructType #-}
opbdTableStructType :: Ptr CType
opbdTableStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_uint16, ffi_type_pointer]

argOpbdTable :: OpbdTable -> Arg
argOpbdTable = mkStorableArg opbdTableStructType

retOpbdTable :: RetType OpbdTable
retOpbdTable = mkStorableRetType opbdTableStructType

data PMPaperMargins = PMPaperMargins
  { pmPaperMarginsTop :: !CDouble
  , pmPaperMarginsLeft :: !CDouble
  , pmPaperMarginsBottom :: !CDouble
  , pmPaperMarginsRight :: !CDouble
  } deriving (Eq, Show)

instance Storable PMPaperMargins where
  sizeOf    _ = 32
  alignment _ = 8
  peek p = PMPaperMargins <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 24
  poke p (PMPaperMargins {..}) = do
    pokeByteOff p 0 pmPaperMarginsTop
    pokeByteOff p 8 pmPaperMarginsLeft
    pokeByteOff p 16 pmPaperMarginsBottom
    pokeByteOff p 24 pmPaperMarginsRight

{-# NOINLINE pmPaperMarginsStructType #-}
pmPaperMarginsStructType :: Ptr CType
pmPaperMarginsStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_double, ffi_type_double, ffi_type_double, ffi_type_double]

argPMPaperMargins :: PMPaperMargins -> Arg
argPMPaperMargins = mkStorableArg pmPaperMarginsStructType

retPMPaperMargins :: RetType PMPaperMargins
retPMPaperMargins = mkStorableRetType pmPaperMarginsStructType

data PMRect = PMRect
  { pmRectTop :: !CDouble
  , pmRectLeft :: !CDouble
  , pmRectBottom :: !CDouble
  , pmRectRight :: !CDouble
  } deriving (Eq, Show)

instance Storable PMRect where
  sizeOf    _ = 32
  alignment _ = 8
  peek p = PMRect <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 24
  poke p (PMRect {..}) = do
    pokeByteOff p 0 pmRectTop
    pokeByteOff p 8 pmRectLeft
    pokeByteOff p 16 pmRectBottom
    pokeByteOff p 24 pmRectRight

{-# NOINLINE pmRectStructType #-}
pmRectStructType :: Ptr CType
pmRectStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_double, ffi_type_double, ffi_type_double, ffi_type_double]

argPMRect :: PMRect -> Arg
argPMRect = mkStorableArg pmRectStructType

retPMRect :: RetType PMRect
retPMRect = mkStorableRetType pmRectStructType

data PMResolution = PMResolution
  { pmResolutionHRes :: !CDouble
  , pmResolutionVRes :: !CDouble
  } deriving (Eq, Show)

instance Storable PMResolution where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = PMResolution <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (PMResolution {..}) = do
    pokeByteOff p 0 pmResolutionHRes
    pokeByteOff p 8 pmResolutionVRes

{-# NOINLINE pmResolutionStructType #-}
pmResolutionStructType :: Ptr CType
pmResolutionStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_double, ffi_type_double]

argPMResolution :: PMResolution -> Arg
argPMResolution = mkStorableArg pmResolutionStructType

retPMResolution :: RetType PMResolution
retPMResolution = mkStorableRetType pmResolutionStructType

data PixPat = PixPat
  { pixPatPatType :: !CShort
  , pixPatPatMap :: !(Ptr ())
  , pixPatPatData :: !(Ptr ())
  , pixPatPatXData :: !(Ptr ())
  , pixPatPatXValid :: !CShort
  , pixPatPatXMap :: !(Ptr ())
  , pixPatPat1Data :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable PixPat where
  sizeOf    _ = 56
  alignment _ = 8
  peek p = PixPat <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 24
    <*> peekByteOff p 32
    <*> peekByteOff p 40
    <*> peekByteOff p 48
  poke p (PixPat {..}) = do
    pokeByteOff p 0 pixPatPatType
    pokeByteOff p 8 pixPatPatMap
    pokeByteOff p 16 pixPatPatData
    pokeByteOff p 24 pixPatPatXData
    pokeByteOff p 32 pixPatPatXValid
    pokeByteOff p 40 pixPatPatXMap
    pokeByteOff p 48 pixPatPat1Data

{-# NOINLINE pixPatStructType #-}
pixPatStructType :: Ptr CType
pixPatStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer, ffi_type_sint16, ffi_type_pointer, ffi_type_pointer]

argPixPat :: PixPat -> Arg
argPixPat = mkStorableArg pixPatStructType

retPixPat :: RetType PixPat
retPixPat = mkStorableRetType pixPatStructType

data PropLookupSegment = PropLookupSegment
  { propLookupSegmentLastGlyph :: !CUShort
  , propLookupSegmentFirstGlyph :: !CUShort
  , propLookupSegmentValue :: !CUShort
  } deriving (Eq, Show)

instance Storable PropLookupSegment where
  sizeOf    _ = 6
  alignment _ = 2
  peek p = PropLookupSegment <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
  poke p (PropLookupSegment {..}) = do
    pokeByteOff p 0 propLookupSegmentLastGlyph
    pokeByteOff p 2 propLookupSegmentFirstGlyph
    pokeByteOff p 4 propLookupSegmentValue

{-# NOINLINE propLookupSegmentStructType #-}
propLookupSegmentStructType :: Ptr CType
propLookupSegmentStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argPropLookupSegment :: PropLookupSegment -> Arg
argPropLookupSegment = mkStorableArg propLookupSegmentStructType

retPropLookupSegment :: RetType PropLookupSegment
retPropLookupSegment = mkStorableRetType propLookupSegmentStructType

data PropLookupSingle = PropLookupSingle
  { propLookupSingleGlyph :: !CUShort
  , propLookupSingleProps :: !CUShort
  } deriving (Eq, Show)

instance Storable PropLookupSingle where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = PropLookupSingle <$> peekByteOff p 0
    <*> peekByteOff p 2
  poke p (PropLookupSingle {..}) = do
    pokeByteOff p 0 propLookupSingleGlyph
    pokeByteOff p 2 propLookupSingleProps

{-# NOINLINE propLookupSingleStructType #-}
propLookupSingleStructType :: Ptr CType
propLookupSingleStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16]

argPropLookupSingle :: PropLookupSingle -> Arg
argPropLookupSingle = mkStorableArg propLookupSingleStructType

retPropLookupSingle :: RetType PropLookupSingle
retPropLookupSingle = mkStorableRetType propLookupSingleStructType

data PropTable = PropTable
  { propTableVersion :: !CInt
  , propTableFormat :: !CUShort
  , propTableDefaultProps :: !CUShort
  , propTableLookup :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable PropTable where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = PropTable <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 6
    <*> peekByteOff p 8
  poke p (PropTable {..}) = do
    pokeByteOff p 0 propTableVersion
    pokeByteOff p 4 propTableFormat
    pokeByteOff p 6 propTableDefaultProps
    pokeByteOff p 8 propTableLookup

{-# NOINLINE propTableStructType #-}
propTableStructType :: Ptr CType
propTableStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_uint16, ffi_type_uint16, ffi_type_pointer]

argPropTable :: PropTable -> Arg
argPropTable = mkStorableArg propTableStructType

retPropTable :: RetType PropTable
retPropTable = mkStorableRetType propTableStructType

data RGBColor = RGBColor
  { rgbColorRed :: !CUShort
  , rgbColorGreen :: !CUShort
  , rgbColorBlue :: !CUShort
  } deriving (Eq, Show)

instance Storable RGBColor where
  sizeOf    _ = 6
  alignment _ = 2
  peek p = RGBColor <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
  poke p (RGBColor {..}) = do
    pokeByteOff p 0 rgbColorRed
    pokeByteOff p 2 rgbColorGreen
    pokeByteOff p 4 rgbColorBlue

{-# NOINLINE rgbColorStructType #-}
rgbColorStructType :: Ptr CType
rgbColorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argRGBColor :: RGBColor -> Arg
argRGBColor = mkStorableArg rgbColorStructType

retRGBColor :: RetType RGBColor
retRGBColor = mkStorableRetType rgbColorStructType

data ROTAGlyphEntry = ROTAGlyphEntry
  { rotaGlyphEntryGlyphIndexOffset :: !CShort
  , rotaGlyphEntryHBaselineOffset :: !CShort
  , rotaGlyphEntryVBaselineOffset :: !CShort
  } deriving (Eq, Show)

instance Storable ROTAGlyphEntry where
  sizeOf    _ = 6
  alignment _ = 2
  peek p = ROTAGlyphEntry <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
  poke p (ROTAGlyphEntry {..}) = do
    pokeByteOff p 0 rotaGlyphEntryGlyphIndexOffset
    pokeByteOff p 2 rotaGlyphEntryHBaselineOffset
    pokeByteOff p 4 rotaGlyphEntryVBaselineOffset

{-# NOINLINE rotaGlyphEntryStructType #-}
rotaGlyphEntryStructType :: Ptr CType
rotaGlyphEntryStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16, ffi_type_sint16, ffi_type_sint16]

argROTAGlyphEntry :: ROTAGlyphEntry -> Arg
argROTAGlyphEntry = mkStorableArg rotaGlyphEntryStructType

retROTAGlyphEntry :: RetType ROTAGlyphEntry
retROTAGlyphEntry = mkStorableRetType rotaGlyphEntryStructType

data ROTAHeader = ROTAHeader
  { rotaHeaderVersion :: !CInt
  , rotaHeaderFlags :: !CUShort
  , rotaHeaderNMasters :: !CUShort
  , rotaHeaderFirstGlyph :: !CUShort
  , rotaHeaderLastGlyph :: !CUShort
  , rotaHeaderLookup :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable ROTAHeader where
  sizeOf    _ = 24
  alignment _ = 8
  peek p = ROTAHeader <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 6
    <*> peekByteOff p 8
    <*> peekByteOff p 10
    <*> peekByteOff p 16
  poke p (ROTAHeader {..}) = do
    pokeByteOff p 0 rotaHeaderVersion
    pokeByteOff p 4 rotaHeaderFlags
    pokeByteOff p 6 rotaHeaderNMasters
    pokeByteOff p 8 rotaHeaderFirstGlyph
    pokeByteOff p 10 rotaHeaderLastGlyph
    pokeByteOff p 16 rotaHeaderLookup

{-# NOINLINE rotaHeaderStructType #-}
rotaHeaderStructType :: Ptr CType
rotaHeaderStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16, ffi_type_pointer]

argROTAHeader :: ROTAHeader -> Arg
argROTAHeader = mkStorableArg rotaHeaderStructType

retROTAHeader :: RetType ROTAHeader
retROTAHeader = mkStorableRetType rotaHeaderStructType

data SFNTLookupBinarySearchHeader = SFNTLookupBinarySearchHeader
  { sfntLookupBinarySearchHeaderUnitSize :: !CUShort
  , sfntLookupBinarySearchHeaderNUnits :: !CUShort
  , sfntLookupBinarySearchHeaderSearchRange :: !CUShort
  , sfntLookupBinarySearchHeaderEntrySelector :: !CUShort
  , sfntLookupBinarySearchHeaderRangeShift :: !CUShort
  } deriving (Eq, Show)

instance Storable SFNTLookupBinarySearchHeader where
  sizeOf    _ = 10
  alignment _ = 2
  peek p = SFNTLookupBinarySearchHeader <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 6
    <*> peekByteOff p 8
  poke p (SFNTLookupBinarySearchHeader {..}) = do
    pokeByteOff p 0 sfntLookupBinarySearchHeaderUnitSize
    pokeByteOff p 2 sfntLookupBinarySearchHeaderNUnits
    pokeByteOff p 4 sfntLookupBinarySearchHeaderSearchRange
    pokeByteOff p 6 sfntLookupBinarySearchHeaderEntrySelector
    pokeByteOff p 8 sfntLookupBinarySearchHeaderRangeShift

{-# NOINLINE sfntLookupBinarySearchHeaderStructType #-}
sfntLookupBinarySearchHeaderStructType :: Ptr CType
sfntLookupBinarySearchHeaderStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argSFNTLookupBinarySearchHeader :: SFNTLookupBinarySearchHeader -> Arg
argSFNTLookupBinarySearchHeader = mkStorableArg sfntLookupBinarySearchHeaderStructType

retSFNTLookupBinarySearchHeader :: RetType SFNTLookupBinarySearchHeader
retSFNTLookupBinarySearchHeader = mkStorableRetType sfntLookupBinarySearchHeaderStructType

data STEntryOne = STEntryOne
  { stEntryOneNewState :: !CUShort
  , stEntryOneFlags :: !CUShort
  , stEntryOneOffset1 :: !CUShort
  } deriving (Eq, Show)

instance Storable STEntryOne where
  sizeOf    _ = 6
  alignment _ = 2
  peek p = STEntryOne <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
  poke p (STEntryOne {..}) = do
    pokeByteOff p 0 stEntryOneNewState
    pokeByteOff p 2 stEntryOneFlags
    pokeByteOff p 4 stEntryOneOffset1

{-# NOINLINE stEntryOneStructType #-}
stEntryOneStructType :: Ptr CType
stEntryOneStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argSTEntryOne :: STEntryOne -> Arg
argSTEntryOne = mkStorableArg stEntryOneStructType

retSTEntryOne :: RetType STEntryOne
retSTEntryOne = mkStorableRetType stEntryOneStructType

data STEntryTwo = STEntryTwo
  { stEntryTwoNewState :: !CUShort
  , stEntryTwoFlags :: !CUShort
  , stEntryTwoOffset1 :: !CUShort
  , stEntryTwoOffset2 :: !CUShort
  } deriving (Eq, Show)

instance Storable STEntryTwo where
  sizeOf    _ = 8
  alignment _ = 2
  peek p = STEntryTwo <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 6
  poke p (STEntryTwo {..}) = do
    pokeByteOff p 0 stEntryTwoNewState
    pokeByteOff p 2 stEntryTwoFlags
    pokeByteOff p 4 stEntryTwoOffset1
    pokeByteOff p 6 stEntryTwoOffset2

{-# NOINLINE stEntryTwoStructType #-}
stEntryTwoStructType :: Ptr CType
stEntryTwoStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argSTEntryTwo :: STEntryTwo -> Arg
argSTEntryTwo = mkStorableArg stEntryTwoStructType

retSTEntryTwo :: RetType STEntryTwo
retSTEntryTwo = mkStorableRetType stEntryTwoStructType

data STEntryZero = STEntryZero
  { stEntryZeroNewState :: !CUShort
  , stEntryZeroFlags :: !CUShort
  } deriving (Eq, Show)

instance Storable STEntryZero where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = STEntryZero <$> peekByteOff p 0
    <*> peekByteOff p 2
  poke p (STEntryZero {..}) = do
    pokeByteOff p 0 stEntryZeroNewState
    pokeByteOff p 2 stEntryZeroFlags

{-# NOINLINE stEntryZeroStructType #-}
stEntryZeroStructType :: Ptr CType
stEntryZeroStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16]

argSTEntryZero :: STEntryZero -> Arg
argSTEntryZero = mkStorableArg stEntryZeroStructType

retSTEntryZero :: RetType STEntryZero
retSTEntryZero = mkStorableRetType stEntryZeroStructType

data STHeader = STHeader
  { stHeaderFiller :: !CUChar
  , stHeaderNClasses :: !CUChar
  , stHeaderClassTableOffset :: !CUShort
  , stHeaderStateArrayOffset :: !CUShort
  , stHeaderEntryTableOffset :: !CUShort
  } deriving (Eq, Show)

instance Storable STHeader where
  sizeOf    _ = 8
  alignment _ = 2
  peek p = STHeader <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 6
  poke p (STHeader {..}) = do
    pokeByteOff p 0 stHeaderFiller
    pokeByteOff p 1 stHeaderNClasses
    pokeByteOff p 2 stHeaderClassTableOffset
    pokeByteOff p 4 stHeaderStateArrayOffset
    pokeByteOff p 6 stHeaderEntryTableOffset

{-# NOINLINE stHeaderStructType #-}
stHeaderStructType :: Ptr CType
stHeaderStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argSTHeader :: STHeader -> Arg
argSTHeader = mkStorableArg stHeaderStructType

retSTHeader :: RetType STHeader
retSTHeader = mkStorableRetType stHeaderStructType

data STXEntryOne = STXEntryOne
  { stxEntryOneNewState :: !CUShort
  , stxEntryOneFlags :: !CUShort
  , stxEntryOneIndex1 :: !CUShort
  } deriving (Eq, Show)

instance Storable STXEntryOne where
  sizeOf    _ = 6
  alignment _ = 2
  peek p = STXEntryOne <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
  poke p (STXEntryOne {..}) = do
    pokeByteOff p 0 stxEntryOneNewState
    pokeByteOff p 2 stxEntryOneFlags
    pokeByteOff p 4 stxEntryOneIndex1

{-# NOINLINE stxEntryOneStructType #-}
stxEntryOneStructType :: Ptr CType
stxEntryOneStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argSTXEntryOne :: STXEntryOne -> Arg
argSTXEntryOne = mkStorableArg stxEntryOneStructType

retSTXEntryOne :: RetType STXEntryOne
retSTXEntryOne = mkStorableRetType stxEntryOneStructType

data STXEntryTwo = STXEntryTwo
  { stxEntryTwoNewState :: !CUShort
  , stxEntryTwoFlags :: !CUShort
  , stxEntryTwoIndex1 :: !CUShort
  , stxEntryTwoIndex2 :: !CUShort
  } deriving (Eq, Show)

instance Storable STXEntryTwo where
  sizeOf    _ = 8
  alignment _ = 2
  peek p = STXEntryTwo <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 6
  poke p (STXEntryTwo {..}) = do
    pokeByteOff p 0 stxEntryTwoNewState
    pokeByteOff p 2 stxEntryTwoFlags
    pokeByteOff p 4 stxEntryTwoIndex1
    pokeByteOff p 6 stxEntryTwoIndex2

{-# NOINLINE stxEntryTwoStructType #-}
stxEntryTwoStructType :: Ptr CType
stxEntryTwoStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argSTXEntryTwo :: STXEntryTwo -> Arg
argSTXEntryTwo = mkStorableArg stxEntryTwoStructType

retSTXEntryTwo :: RetType STXEntryTwo
retSTXEntryTwo = mkStorableRetType stxEntryTwoStructType

data STXEntryZero = STXEntryZero
  { stxEntryZeroNewState :: !CUShort
  , stxEntryZeroFlags :: !CUShort
  } deriving (Eq, Show)

instance Storable STXEntryZero where
  sizeOf    _ = 4
  alignment _ = 2
  peek p = STXEntryZero <$> peekByteOff p 0
    <*> peekByteOff p 2
  poke p (STXEntryZero {..}) = do
    pokeByteOff p 0 stxEntryZeroNewState
    pokeByteOff p 2 stxEntryZeroFlags

{-# NOINLINE stxEntryZeroStructType #-}
stxEntryZeroStructType :: Ptr CType
stxEntryZeroStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint16]

argSTXEntryZero :: STXEntryZero -> Arg
argSTXEntryZero = mkStorableArg stxEntryZeroStructType

retSTXEntryZero :: RetType STXEntryZero
retSTXEntryZero = mkStorableRetType stxEntryZeroStructType

data STXHeader = STXHeader
  { stxHeaderNClasses :: !CUInt
  , stxHeaderClassTableOffset :: !CUInt
  , stxHeaderStateArrayOffset :: !CUInt
  , stxHeaderEntryTableOffset :: !CUInt
  } deriving (Eq, Show)

instance Storable STXHeader where
  sizeOf    _ = 16
  alignment _ = 4
  peek p = STXHeader <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
  poke p (STXHeader {..}) = do
    pokeByteOff p 0 stxHeaderNClasses
    pokeByteOff p 4 stxHeaderClassTableOffset
    pokeByteOff p 8 stxHeaderStateArrayOffset
    pokeByteOff p 12 stxHeaderEntryTableOffset

{-# NOINLINE stxHeaderStructType #-}
stxHeaderStructType :: Ptr CType
stxHeaderStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_uint]

argSTXHeader :: STXHeader -> Arg
argSTXHeader = mkStorableArg stxHeaderStructType

retSTXHeader :: RetType STXHeader
retSTXHeader = mkStorableRetType stxHeaderStructType

data SizeResourceRec = SizeResourceRec
  { sizeResourceRecFlags :: !CUShort
  , sizeResourceRecPreferredHeapSize :: !CUInt
  , sizeResourceRecMinimumHeapSize :: !CUInt
  } deriving (Eq, Show)

instance Storable SizeResourceRec where
  sizeOf    _ = 12
  alignment _ = 4
  peek p = SizeResourceRec <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (SizeResourceRec {..}) = do
    pokeByteOff p 0 sizeResourceRecFlags
    pokeByteOff p 4 sizeResourceRecPreferredHeapSize
    pokeByteOff p 8 sizeResourceRecMinimumHeapSize

{-# NOINLINE sizeResourceRecStructType #-}
sizeResourceRecStructType :: Ptr CType
sizeResourceRecStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint16, ffi_type_uint, ffi_type_uint]

argSizeResourceRec :: SizeResourceRec -> Arg
argSizeResourceRec = mkStorableArg sizeResourceRecStructType

retSizeResourceRec :: RetType SizeResourceRec
retSizeResourceRec = mkStorableRetType sizeResourceRecStructType

data SpeechErrorInfo = SpeechErrorInfo
  { speechErrorInfoCount :: !CShort
  , speechErrorInfoOldest :: !CShort
  , speechErrorInfoOldPos :: !CLong
  , speechErrorInfoNewest :: !CShort
  , speechErrorInfoNewPos :: !CLong
  } deriving (Eq, Show)

instance Storable SpeechErrorInfo where
  sizeOf    _ = 32
  alignment _ = 8
  peek p = SpeechErrorInfo <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 24
  poke p (SpeechErrorInfo {..}) = do
    pokeByteOff p 0 speechErrorInfoCount
    pokeByteOff p 2 speechErrorInfoOldest
    pokeByteOff p 8 speechErrorInfoOldPos
    pokeByteOff p 16 speechErrorInfoNewest
    pokeByteOff p 24 speechErrorInfoNewPos

{-# NOINLINE speechErrorInfoStructType #-}
speechErrorInfoStructType :: Ptr CType
speechErrorInfoStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16, ffi_type_sint16, ffi_type_slong, ffi_type_sint16, ffi_type_slong]

argSpeechErrorInfo :: SpeechErrorInfo -> Arg
argSpeechErrorInfo = mkStorableArg speechErrorInfoStructType

retSpeechErrorInfo :: RetType SpeechErrorInfo
retSpeechErrorInfo = mkStorableRetType speechErrorInfoStructType

data SpeechStatusInfo = SpeechStatusInfo
  { speechStatusInfoOutputBusy :: !CUChar
  , speechStatusInfoOutputPaused :: !CUChar
  , speechStatusInfoInputBytesLeft :: !CLong
  , speechStatusInfoPhonemeCode :: !CShort
  } deriving (Eq, Show)

instance Storable SpeechStatusInfo where
  sizeOf    _ = 24
  alignment _ = 8
  peek p = SpeechStatusInfo <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 8
    <*> peekByteOff p 16
  poke p (SpeechStatusInfo {..}) = do
    pokeByteOff p 0 speechStatusInfoOutputBusy
    pokeByteOff p 1 speechStatusInfoOutputPaused
    pokeByteOff p 8 speechStatusInfoInputBytesLeft
    pokeByteOff p 16 speechStatusInfoPhonemeCode

{-# NOINLINE speechStatusInfoStructType #-}
speechStatusInfoStructType :: Ptr CType
speechStatusInfoStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_slong, ffi_type_sint16]

argSpeechStatusInfo :: SpeechStatusInfo -> Arg
argSpeechStatusInfo = mkStorableArg speechStatusInfoStructType

retSpeechStatusInfo :: RetType SpeechStatusInfo
retSpeechStatusInfo = mkStorableRetType speechStatusInfoStructType

data TrakTable = TrakTable
  { trakTableVersion :: !CInt
  , trakTableFormat :: !CUShort
  , trakTableHorizOffset :: !CUShort
  , trakTableVertOffset :: !CUShort
  } deriving (Eq, Show)

instance Storable TrakTable where
  sizeOf    _ = 12
  alignment _ = 4
  peek p = TrakTable <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 6
    <*> peekByteOff p 8
  poke p (TrakTable {..}) = do
    pokeByteOff p 0 trakTableVersion
    pokeByteOff p 4 trakTableFormat
    pokeByteOff p 6 trakTableHorizOffset
    pokeByteOff p 8 trakTableVertOffset

{-# NOINLINE trakTableStructType #-}
trakTableStructType :: Ptr CType
trakTableStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argTrakTable :: TrakTable -> Arg
argTrakTable = mkStorableArg trakTableStructType

retTrakTable :: RetType TrakTable
retTrakTable = mkStorableRetType trakTableStructType

data TrakTableEntry = TrakTableEntry
  { trakTableEntryTrack :: !CInt
  , trakTableEntryNameTableIndex :: !CUShort
  , trakTableEntrySizesOffset :: !CUShort
  } deriving (Eq, Show)

instance Storable TrakTableEntry where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = TrakTableEntry <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 6
  poke p (TrakTableEntry {..}) = do
    pokeByteOff p 0 trakTableEntryTrack
    pokeByteOff p 4 trakTableEntryNameTableIndex
    pokeByteOff p 6 trakTableEntrySizesOffset

{-# NOINLINE trakTableEntryStructType #-}
trakTableEntryStructType :: Ptr CType
trakTableEntryStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_uint16, ffi_type_uint16]

argTrakTableEntry :: TrakTableEntry -> Arg
argTrakTableEntry = mkStorableArg trakTableEntryStructType

retTrakTableEntry :: RetType TrakTableEntry
retTrakTableEntry = mkStorableRetType trakTableEntryStructType

data VDGammaRecord = VDGammaRecord
  { vdGammaRecordCsGTable :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable VDGammaRecord where
  sizeOf    _ = 8
  alignment _ = 8
  peek p = VDGammaRecord <$> peekByteOff p 0
  poke p (VDGammaRecord {..}) =
    pokeByteOff p 0 vdGammaRecordCsGTable

{-# NOINLINE vdGammaRecordStructType #-}
vdGammaRecordStructType :: Ptr CType
vdGammaRecordStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer]

argVDGammaRecord :: VDGammaRecord -> Arg
argVDGammaRecord = mkStorableArg vdGammaRecordStructType

retVDGammaRecord :: RetType VDGammaRecord
retVDGammaRecord = mkStorableRetType vdGammaRecordStructType

data VoiceFileInfo = VoiceFileInfo
  { voiceFileInfoFileSpec :: !(Ptr ())
  , voiceFileInfoResID :: !CShort
  } deriving (Eq, Show)

instance Storable VoiceFileInfo where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = VoiceFileInfo <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (VoiceFileInfo {..}) = do
    pokeByteOff p 0 voiceFileInfoFileSpec
    pokeByteOff p 8 voiceFileInfoResID

{-# NOINLINE voiceFileInfoStructType #-}
voiceFileInfoStructType :: Ptr CType
voiceFileInfoStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer, ffi_type_sint16]

argVoiceFileInfo :: VoiceFileInfo -> Arg
argVoiceFileInfo = mkStorableArg voiceFileInfoStructType

retVoiceFileInfo :: RetType VoiceFileInfo
retVoiceFileInfo = mkStorableRetType voiceFileInfoStructType

data VoiceSpec = VoiceSpec
  { voiceSpecCreator :: !CUInt
  , voiceSpecId :: !CUInt
  } deriving (Eq, Show)

instance Storable VoiceSpec where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = VoiceSpec <$> peekByteOff p 0
    <*> peekByteOff p 4
  poke p (VoiceSpec {..}) = do
    pokeByteOff p 0 voiceSpecCreator
    pokeByteOff p 4 voiceSpecId

{-# NOINLINE voiceSpecStructType #-}
voiceSpecStructType :: Ptr CType
voiceSpecStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint]

argVoiceSpec :: VoiceSpec -> Arg
argVoiceSpec = mkStorableArg voiceSpecStructType

retVoiceSpec :: RetType VoiceSpec
retVoiceSpec = mkStorableRetType voiceSpecStructType

data ATSGlyphIdealMetrics = ATSGlyphIdealMetrics
  { atsGlyphIdealMetricsAdvance :: !ATSPoint
  , atsGlyphIdealMetricsSideBearing :: !ATSPoint
  , atsGlyphIdealMetricsOtherSideBearing :: !ATSPoint
  } deriving (Eq, Show)

instance Storable ATSGlyphIdealMetrics where
  sizeOf    _ = 48
  alignment _ = 8
  peek p = ATSGlyphIdealMetrics <$> peekByteOff p 0
    <*> peekByteOff p 16
    <*> peekByteOff p 32
  poke p (ATSGlyphIdealMetrics {..}) = do
    pokeByteOff p 0 atsGlyphIdealMetricsAdvance
    pokeByteOff p 16 atsGlyphIdealMetricsSideBearing
    pokeByteOff p 32 atsGlyphIdealMetricsOtherSideBearing

{-# NOINLINE atsGlyphIdealMetricsStructType #-}
atsGlyphIdealMetricsStructType :: Ptr CType
atsGlyphIdealMetricsStructType = unsafePerformIO $ fst <$> newStructCType [atsPointStructType, atsPointStructType, atsPointStructType]

argATSGlyphIdealMetrics :: ATSGlyphIdealMetrics -> Arg
argATSGlyphIdealMetrics = mkStorableArg atsGlyphIdealMetricsStructType

retATSGlyphIdealMetrics :: RetType ATSGlyphIdealMetrics
retATSGlyphIdealMetrics = mkStorableRetType atsGlyphIdealMetricsStructType

data ATSGlyphScreenMetrics = ATSGlyphScreenMetrics
  { atsGlyphScreenMetricsDeviceAdvance :: !ATSPoint
  , atsGlyphScreenMetricsTopLeft :: !ATSPoint
  , atsGlyphScreenMetricsHeight :: !CUInt
  , atsGlyphScreenMetricsWidth :: !CUInt
  , atsGlyphScreenMetricsSideBearing :: !ATSPoint
  , atsGlyphScreenMetricsOtherSideBearing :: !ATSPoint
  } deriving (Eq, Show)

instance Storable ATSGlyphScreenMetrics where
  sizeOf    _ = 72
  alignment _ = 8
  peek p = ATSGlyphScreenMetrics <$> peekByteOff p 0
    <*> peekByteOff p 16
    <*> peekByteOff p 32
    <*> peekByteOff p 36
    <*> peekByteOff p 40
    <*> peekByteOff p 56
  poke p (ATSGlyphScreenMetrics {..}) = do
    pokeByteOff p 0 atsGlyphScreenMetricsDeviceAdvance
    pokeByteOff p 16 atsGlyphScreenMetricsTopLeft
    pokeByteOff p 32 atsGlyphScreenMetricsHeight
    pokeByteOff p 36 atsGlyphScreenMetricsWidth
    pokeByteOff p 40 atsGlyphScreenMetricsSideBearing
    pokeByteOff p 56 atsGlyphScreenMetricsOtherSideBearing

{-# NOINLINE atsGlyphScreenMetricsStructType #-}
atsGlyphScreenMetricsStructType :: Ptr CType
atsGlyphScreenMetricsStructType = unsafePerformIO $ fst <$> newStructCType [atsPointStructType, atsPointStructType, ffi_type_uint, ffi_type_uint, atsPointStructType, atsPointStructType]

argATSGlyphScreenMetrics :: ATSGlyphScreenMetrics -> Arg
argATSGlyphScreenMetrics = mkStorableArg atsGlyphScreenMetricsStructType

retATSGlyphScreenMetrics :: RetType ATSGlyphScreenMetrics
retATSGlyphScreenMetrics = mkStorableRetType atsGlyphScreenMetricsStructType

data ATSTrapezoid = ATSTrapezoid
  { atsTrapezoidUpperLeft :: !FixedPoint
  , atsTrapezoidUpperRight :: !FixedPoint
  , atsTrapezoidLowerRight :: !FixedPoint
  , atsTrapezoidLowerLeft :: !FixedPoint
  } deriving (Eq, Show)

instance Storable ATSTrapezoid where
  sizeOf    _ = 32
  alignment _ = 4
  peek p = ATSTrapezoid <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 24
  poke p (ATSTrapezoid {..}) = do
    pokeByteOff p 0 atsTrapezoidUpperLeft
    pokeByteOff p 8 atsTrapezoidUpperRight
    pokeByteOff p 16 atsTrapezoidLowerRight
    pokeByteOff p 24 atsTrapezoidLowerLeft

{-# NOINLINE atsTrapezoidStructType #-}
atsTrapezoidStructType :: Ptr CType
atsTrapezoidStructType = unsafePerformIO $ fst <$> newStructCType [fixedPointStructType, fixedPointStructType, fixedPointStructType, fixedPointStructType]

argATSTrapezoid :: ATSTrapezoid -> Arg
argATSTrapezoid = mkStorableArg atsTrapezoidStructType

retATSTrapezoid :: RetType ATSTrapezoid
retATSTrapezoid = mkStorableRetType atsTrapezoidStructType

data BitMap = BitMap
  { bitMapBaseAddr :: !(Ptr ())
  , bitMapRowBytes :: !CShort
  , bitMapBounds :: !Rect
  } deriving (Eq, Show)

instance Storable BitMap where
  sizeOf    _ = 24
  alignment _ = 8
  peek p = BitMap <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 10
  poke p (BitMap {..}) = do
    pokeByteOff p 0 bitMapBaseAddr
    pokeByteOff p 8 bitMapRowBytes
    pokeByteOff p 10 bitMapBounds

{-# NOINLINE bitMapStructType #-}
bitMapStructType :: Ptr CType
bitMapStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer, ffi_type_sint16, rectStructType]

argBitMap :: BitMap -> Arg
argBitMap = mkStorableArg bitMapStructType

retBitMap :: RetType BitMap
retBitMap = mkStorableRetType bitMapStructType

data CMDateTimeType = CMDateTimeType
  { cmDateTimeTypeTypeDescriptor :: !CUInt
  , cmDateTimeTypeReserved :: !CUInt
  , cmDateTimeTypeDateTime :: !CMDateTime
  } deriving (Eq, Show)

instance Storable CMDateTimeType where
  sizeOf    _ = 20
  alignment _ = 4
  peek p = CMDateTimeType <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (CMDateTimeType {..}) = do
    pokeByteOff p 0 cmDateTimeTypeTypeDescriptor
    pokeByteOff p 4 cmDateTimeTypeReserved
    pokeByteOff p 8 cmDateTimeTypeDateTime

{-# NOINLINE cmDateTimeTypeStructType #-}
cmDateTimeTypeStructType :: Ptr CType
cmDateTimeTypeStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, cmDateTimeStructType]

argCMDateTimeType :: CMDateTimeType -> Arg
argCMDateTimeType = mkStorableArg cmDateTimeTypeStructType

retCMDateTimeType :: RetType CMDateTimeType
retCMDateTimeType = mkStorableRetType cmDateTimeTypeStructType

data CMMakeAndModelType = CMMakeAndModelType
  { cmMakeAndModelTypeTypeDescriptor :: !CUInt
  , cmMakeAndModelTypeReserved :: !CUInt
  , cmMakeAndModelTypeMakeAndModel :: !CMMakeAndModel
  } deriving (Eq, Show)

instance Storable CMMakeAndModelType where
  sizeOf    _ = 40
  alignment _ = 4
  peek p = CMMakeAndModelType <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (CMMakeAndModelType {..}) = do
    pokeByteOff p 0 cmMakeAndModelTypeTypeDescriptor
    pokeByteOff p 4 cmMakeAndModelTypeReserved
    pokeByteOff p 8 cmMakeAndModelTypeMakeAndModel

{-# NOINLINE cmMakeAndModelTypeStructType #-}
cmMakeAndModelTypeStructType :: Ptr CType
cmMakeAndModelTypeStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, cmMakeAndModelStructType]

argCMMakeAndModelType :: CMMakeAndModelType -> Arg
argCMMakeAndModelType = mkStorableArg cmMakeAndModelTypeStructType

retCMMakeAndModelType :: RetType CMMakeAndModelType
retCMMakeAndModelType = mkStorableRetType cmMakeAndModelTypeStructType

data CMMeasurementType = CMMeasurementType
  { cmMeasurementTypeTypeDescriptor :: !CUInt
  , cmMeasurementTypeReserved :: !CUInt
  , cmMeasurementTypeStandardObserver :: !CUInt
  , cmMeasurementTypeBackingXYZ :: !CMFixedXYZColor
  , cmMeasurementTypeGeometry :: !CUInt
  , cmMeasurementTypeFlare :: !CUInt
  , cmMeasurementTypeIlluminant :: !CUInt
  } deriving (Eq, Show)

instance Storable CMMeasurementType where
  sizeOf    _ = 36
  alignment _ = 4
  peek p = CMMeasurementType <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
    <*> peekByteOff p 24
    <*> peekByteOff p 28
    <*> peekByteOff p 32
  poke p (CMMeasurementType {..}) = do
    pokeByteOff p 0 cmMeasurementTypeTypeDescriptor
    pokeByteOff p 4 cmMeasurementTypeReserved
    pokeByteOff p 8 cmMeasurementTypeStandardObserver
    pokeByteOff p 12 cmMeasurementTypeBackingXYZ
    pokeByteOff p 24 cmMeasurementTypeGeometry
    pokeByteOff p 28 cmMeasurementTypeFlare
    pokeByteOff p 32 cmMeasurementTypeIlluminant

{-# NOINLINE cmMeasurementTypeStructType #-}
cmMeasurementTypeStructType :: Ptr CType
cmMeasurementTypeStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_uint, cmFixedXYZColorStructType, ffi_type_uint, ffi_type_uint, ffi_type_uint]

argCMMeasurementType :: CMMeasurementType -> Arg
argCMMeasurementType = mkStorableArg cmMeasurementTypeStructType

retCMMeasurementType :: RetType CMMeasurementType
retCMMeasurementType = mkStorableRetType cmMeasurementTypeStructType

data CMViewingConditionsType = CMViewingConditionsType
  { cmViewingConditionsTypeTypeDescriptor :: !CUInt
  , cmViewingConditionsTypeReserved :: !CUInt
  , cmViewingConditionsTypeIlluminant :: !CMFixedXYZColor
  , cmViewingConditionsTypeSurround :: !CMFixedXYZColor
  , cmViewingConditionsTypeStdIlluminant :: !CUInt
  } deriving (Eq, Show)

instance Storable CMViewingConditionsType where
  sizeOf    _ = 36
  alignment _ = 4
  peek p = CMViewingConditionsType <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 20
    <*> peekByteOff p 32
  poke p (CMViewingConditionsType {..}) = do
    pokeByteOff p 0 cmViewingConditionsTypeTypeDescriptor
    pokeByteOff p 4 cmViewingConditionsTypeReserved
    pokeByteOff p 8 cmViewingConditionsTypeIlluminant
    pokeByteOff p 20 cmViewingConditionsTypeSurround
    pokeByteOff p 32 cmViewingConditionsTypeStdIlluminant

{-# NOINLINE cmViewingConditionsTypeStructType #-}
cmViewingConditionsTypeStructType :: Ptr CType
cmViewingConditionsTypeStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, cmFixedXYZColorStructType, cmFixedXYZColorStructType, ffi_type_uint]

argCMViewingConditionsType :: CMViewingConditionsType -> Arg
argCMViewingConditionsType = mkStorableArg cmViewingConditionsTypeStructType

retCMViewingConditionsType :: RetType CMViewingConditionsType
retCMViewingConditionsType = mkStorableRetType cmViewingConditionsTypeStructType

data ColorSpec = ColorSpec
  { colorSpecValue :: !CShort
  , colorSpecRgb :: !RGBColor
  } deriving (Eq, Show)

instance Storable ColorSpec where
  sizeOf    _ = 8
  alignment _ = 2
  peek p = ColorSpec <$> peekByteOff p 0
    <*> peekByteOff p 2
  poke p (ColorSpec {..}) = do
    pokeByteOff p 0 colorSpecValue
    pokeByteOff p 2 colorSpecRgb

{-# NOINLINE colorSpecStructType #-}
colorSpecStructType :: Ptr CType
colorSpecStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16, rgbColorStructType]

argColorSpec :: ColorSpec -> Arg
argColorSpec = mkStorableArg colorSpecStructType

retColorSpec :: RetType ColorSpec
retColorSpec = mkStorableRetType colorSpecStructType

data FMInput = FMInput
  { fmInputFamily :: !CShort
  , fmInputSize :: !CShort
  , fmInputFace :: !CUChar
  , fmInputNeedBits :: !CUChar
  , fmInputDevice :: !CShort
  , fmInputNumer :: !Point
  , fmInputDenom :: !Point
  } deriving (Eq, Show)

instance Storable FMInput where
  sizeOf    _ = 16
  alignment _ = 2
  peek p = FMInput <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 5
    <*> peekByteOff p 6
    <*> peekByteOff p 8
    <*> peekByteOff p 12
  poke p (FMInput {..}) = do
    pokeByteOff p 0 fmInputFamily
    pokeByteOff p 2 fmInputSize
    pokeByteOff p 4 fmInputFace
    pokeByteOff p 5 fmInputNeedBits
    pokeByteOff p 6 fmInputDevice
    pokeByteOff p 8 fmInputNumer
    pokeByteOff p 12 fmInputDenom

{-# NOINLINE fmInputStructType #-}
fmInputStructType :: Ptr CType
fmInputStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16, ffi_type_sint16, ffi_type_uint8, ffi_type_uint8, ffi_type_sint16, pointStructType, pointStructType]

argFMInput :: FMInput -> Arg
argFMInput = mkStorableArg fmInputStructType

retFMInput :: RetType FMInput
retFMInput = mkStorableRetType fmInputStructType

data GDevice = GDevice
  { gDeviceGdRefNum :: !CShort
  , gDeviceGdID :: !CShort
  , gDeviceGdType :: !CShort
  , gDeviceGdITable :: !(Ptr ())
  , gDeviceGdResPref :: !CShort
  , gDeviceGdSearchProc :: !(Ptr ())
  , gDeviceGdCompProc :: !(Ptr ())
  , gDeviceGdFlags :: !CShort
  , gDeviceGdPMap :: !(Ptr ())
  , gDeviceGdRefCon :: !CInt
  , gDeviceGdNextGD :: !(Ptr ())
  , gDeviceGdRect :: !Rect
  , gDeviceGdMode :: !CInt
  , gDeviceGdCCBytes :: !CShort
  , gDeviceGdCCDepth :: !CShort
  , gDeviceGdCCXData :: !(Ptr ())
  , gDeviceGdCCXMask :: !(Ptr ())
  , gDeviceGdExt :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable GDevice where
  sizeOf    _ = 112
  alignment _ = 8
  peek p = GDevice <$> peekByteOff p 0
    <*> peekByteOff p 2
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 24
    <*> peekByteOff p 32
    <*> peekByteOff p 40
    <*> peekByteOff p 48
    <*> peekByteOff p 56
    <*> peekByteOff p 64
    <*> peekByteOff p 72
    <*> peekByteOff p 80
    <*> peekByteOff p 84
    <*> peekByteOff p 86
    <*> peekByteOff p 88
    <*> peekByteOff p 96
    <*> peekByteOff p 104
  poke p (GDevice {..}) = do
    pokeByteOff p 0 gDeviceGdRefNum
    pokeByteOff p 2 gDeviceGdID
    pokeByteOff p 4 gDeviceGdType
    pokeByteOff p 8 gDeviceGdITable
    pokeByteOff p 16 gDeviceGdResPref
    pokeByteOff p 24 gDeviceGdSearchProc
    pokeByteOff p 32 gDeviceGdCompProc
    pokeByteOff p 40 gDeviceGdFlags
    pokeByteOff p 48 gDeviceGdPMap
    pokeByteOff p 56 gDeviceGdRefCon
    pokeByteOff p 64 gDeviceGdNextGD
    pokeByteOff p 72 gDeviceGdRect
    pokeByteOff p 80 gDeviceGdMode
    pokeByteOff p 84 gDeviceGdCCBytes
    pokeByteOff p 86 gDeviceGdCCDepth
    pokeByteOff p 88 gDeviceGdCCXData
    pokeByteOff p 96 gDeviceGdCCXMask
    pokeByteOff p 104 gDeviceGdExt

{-# NOINLINE gDeviceStructType #-}
gDeviceStructType :: Ptr CType
gDeviceStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16, ffi_type_sint16, ffi_type_sint16, ffi_type_pointer, ffi_type_sint16, ffi_type_pointer, ffi_type_pointer, ffi_type_sint16, ffi_type_pointer, ffi_type_sint, ffi_type_pointer, rectStructType, ffi_type_sint, ffi_type_sint16, ffi_type_sint16, ffi_type_pointer, ffi_type_pointer, ffi_type_pointer]

argGDevice :: GDevice -> Arg
argGDevice = mkStorableArg gDeviceStructType

retGDevice :: RetType GDevice
retGDevice = mkStorableRetType gDeviceStructType

data KernOrderedListEntry = KernOrderedListEntry
  { kernOrderedListEntryPair :: !KernKerningPair
  , kernOrderedListEntryValue :: !CShort
  } deriving (Eq, Show)

instance Storable KernOrderedListEntry where
  sizeOf    _ = 6
  alignment _ = 2
  peek p = KernOrderedListEntry <$> peekByteOff p 0
    <*> peekByteOff p 4
  poke p (KernOrderedListEntry {..}) = do
    pokeByteOff p 0 kernOrderedListEntryPair
    pokeByteOff p 4 kernOrderedListEntryValue

{-# NOINLINE kernOrderedListEntryStructType #-}
kernOrderedListEntryStructType :: Ptr CType
kernOrderedListEntryStructType = unsafePerformIO $ fst <$> newStructCType [kernKerningPairStructType, ffi_type_sint16]

argKernOrderedListEntry :: KernOrderedListEntry -> Arg
argKernOrderedListEntry = mkStorableArg kernOrderedListEntryStructType

retKernOrderedListEntry :: RetType KernOrderedListEntry
retKernOrderedListEntry = mkStorableRetType kernOrderedListEntryStructType

data KerxOrderedListEntry = KerxOrderedListEntry
  { kerxOrderedListEntryPair :: !KerxKerningPair
  , kerxOrderedListEntryValue :: !CShort
  } deriving (Eq, Show)

instance Storable KerxOrderedListEntry where
  sizeOf    _ = 6
  alignment _ = 2
  peek p = KerxOrderedListEntry <$> peekByteOff p 0
    <*> peekByteOff p 4
  poke p (KerxOrderedListEntry {..}) = do
    pokeByteOff p 0 kerxOrderedListEntryPair
    pokeByteOff p 4 kerxOrderedListEntryValue

{-# NOINLINE kerxOrderedListEntryStructType #-}
kerxOrderedListEntryStructType :: Ptr CType
kerxOrderedListEntryStructType = unsafePerformIO $ fst <$> newStructCType [kerxKerningPairStructType, ffi_type_sint16]

argKerxOrderedListEntry :: KerxOrderedListEntry -> Arg
argKerxOrderedListEntry = mkStorableArg kerxOrderedListEntryStructType

retKerxOrderedListEntry :: RetType KerxOrderedListEntry
retKerxOrderedListEntry = mkStorableRetType kerxOrderedListEntryStructType

data LaunchParamBlockRec = LaunchParamBlockRec
  { launchParamBlockRecReserved1 :: !CUInt
  , launchParamBlockRecReserved2 :: !CUShort
  , launchParamBlockRecLaunchBlockID :: !CUShort
  , launchParamBlockRecLaunchEPBLength :: !CUInt
  , launchParamBlockRecLaunchFileFlags :: !CUShort
  , launchParamBlockRecLaunchControlFlags :: !CUShort
  , launchParamBlockRecLaunchAppRef :: !(Ptr ())
  , launchParamBlockRecLaunchProcessSN :: !ProcessSerialNumber
  , launchParamBlockRecLaunchPreferredSize :: !CUInt
  , launchParamBlockRecLaunchMinimumSize :: !CUInt
  , launchParamBlockRecLaunchAvailableSize :: !CUInt
  , launchParamBlockRecLaunchAppParameters :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable LaunchParamBlockRec where
  sizeOf    _ = 56
  alignment _ = 8
  peek p = LaunchParamBlockRec <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 6
    <*> peekByteOff p 8
    <*> peekByteOff p 12
    <*> peekByteOff p 14
    <*> peekByteOff p 16
    <*> peekByteOff p 24
    <*> peekByteOff p 32
    <*> peekByteOff p 36
    <*> peekByteOff p 40
    <*> peekByteOff p 48
  poke p (LaunchParamBlockRec {..}) = do
    pokeByteOff p 0 launchParamBlockRecReserved1
    pokeByteOff p 4 launchParamBlockRecReserved2
    pokeByteOff p 6 launchParamBlockRecLaunchBlockID
    pokeByteOff p 8 launchParamBlockRecLaunchEPBLength
    pokeByteOff p 12 launchParamBlockRecLaunchFileFlags
    pokeByteOff p 14 launchParamBlockRecLaunchControlFlags
    pokeByteOff p 16 launchParamBlockRecLaunchAppRef
    pokeByteOff p 24 launchParamBlockRecLaunchProcessSN
    pokeByteOff p 32 launchParamBlockRecLaunchPreferredSize
    pokeByteOff p 36 launchParamBlockRecLaunchMinimumSize
    pokeByteOff p 40 launchParamBlockRecLaunchAvailableSize
    pokeByteOff p 48 launchParamBlockRecLaunchAppParameters

{-# NOINLINE launchParamBlockRecStructType #-}
launchParamBlockRecStructType :: Ptr CType
launchParamBlockRecStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint16, ffi_type_uint16, ffi_type_uint, ffi_type_uint16, ffi_type_uint16, ffi_type_pointer, processSerialNumberStructType, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_pointer]

argLaunchParamBlockRec :: LaunchParamBlockRec -> Arg
argLaunchParamBlockRec = mkStorableArg launchParamBlockRecStructType

retLaunchParamBlockRec :: RetType LaunchParamBlockRec
retLaunchParamBlockRec = mkStorableRetType launchParamBlockRecStructType

data MortContextualSubtable = MortContextualSubtable
  { mortContextualSubtableHeader :: !STHeader
  , mortContextualSubtableSubstitutionTableOffset :: !CUShort
  } deriving (Eq, Show)

instance Storable MortContextualSubtable where
  sizeOf    _ = 10
  alignment _ = 2
  peek p = MortContextualSubtable <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (MortContextualSubtable {..}) = do
    pokeByteOff p 0 mortContextualSubtableHeader
    pokeByteOff p 8 mortContextualSubtableSubstitutionTableOffset

{-# NOINLINE mortContextualSubtableStructType #-}
mortContextualSubtableStructType :: Ptr CType
mortContextualSubtableStructType = unsafePerformIO $ fst <$> newStructCType [stHeaderStructType, ffi_type_uint16]

argMortContextualSubtable :: MortContextualSubtable -> Arg
argMortContextualSubtable = mkStorableArg mortContextualSubtableStructType

retMortContextualSubtable :: RetType MortContextualSubtable
retMortContextualSubtable = mkStorableRetType mortContextualSubtableStructType

data MortInsertionSubtable = MortInsertionSubtable
  { mortInsertionSubtableHeader :: !STHeader
  } deriving (Eq, Show)

instance Storable MortInsertionSubtable where
  sizeOf    _ = 8
  alignment _ = 2
  peek p = MortInsertionSubtable <$> peekByteOff p 0
  poke p (MortInsertionSubtable {..}) =
    pokeByteOff p 0 mortInsertionSubtableHeader

{-# NOINLINE mortInsertionSubtableStructType #-}
mortInsertionSubtableStructType :: Ptr CType
mortInsertionSubtableStructType = unsafePerformIO $ fst <$> newStructCType [stHeaderStructType]

argMortInsertionSubtable :: MortInsertionSubtable -> Arg
argMortInsertionSubtable = mkStorableArg mortInsertionSubtableStructType

retMortInsertionSubtable :: RetType MortInsertionSubtable
retMortInsertionSubtable = mkStorableRetType mortInsertionSubtableStructType

data MortLigatureSubtable = MortLigatureSubtable
  { mortLigatureSubtableHeader :: !STHeader
  , mortLigatureSubtableLigatureActionTableOffset :: !CUShort
  , mortLigatureSubtableComponentTableOffset :: !CUShort
  , mortLigatureSubtableLigatureTableOffset :: !CUShort
  } deriving (Eq, Show)

instance Storable MortLigatureSubtable where
  sizeOf    _ = 14
  alignment _ = 2
  peek p = MortLigatureSubtable <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 10
    <*> peekByteOff p 12
  poke p (MortLigatureSubtable {..}) = do
    pokeByteOff p 0 mortLigatureSubtableHeader
    pokeByteOff p 8 mortLigatureSubtableLigatureActionTableOffset
    pokeByteOff p 10 mortLigatureSubtableComponentTableOffset
    pokeByteOff p 12 mortLigatureSubtableLigatureTableOffset

{-# NOINLINE mortLigatureSubtableStructType #-}
mortLigatureSubtableStructType :: Ptr CType
mortLigatureSubtableStructType = unsafePerformIO $ fst <$> newStructCType [stHeaderStructType, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argMortLigatureSubtable :: MortLigatureSubtable -> Arg
argMortLigatureSubtable = mkStorableArg mortLigatureSubtableStructType

retMortLigatureSubtable :: RetType MortLigatureSubtable
retMortLigatureSubtable = mkStorableRetType mortLigatureSubtableStructType

data MortRearrangementSubtable = MortRearrangementSubtable
  { mortRearrangementSubtableHeader :: !STHeader
  } deriving (Eq, Show)

instance Storable MortRearrangementSubtable where
  sizeOf    _ = 8
  alignment _ = 2
  peek p = MortRearrangementSubtable <$> peekByteOff p 0
  poke p (MortRearrangementSubtable {..}) =
    pokeByteOff p 0 mortRearrangementSubtableHeader

{-# NOINLINE mortRearrangementSubtableStructType #-}
mortRearrangementSubtableStructType :: Ptr CType
mortRearrangementSubtableStructType = unsafePerformIO $ fst <$> newStructCType [stHeaderStructType]

argMortRearrangementSubtable :: MortRearrangementSubtable -> Arg
argMortRearrangementSubtable = mkStorableArg mortRearrangementSubtableStructType

retMortRearrangementSubtable :: RetType MortRearrangementSubtable
retMortRearrangementSubtable = mkStorableRetType mortRearrangementSubtableStructType

data MorxContextualSubtable = MorxContextualSubtable
  { morxContextualSubtableHeader :: !STXHeader
  , morxContextualSubtableSubstitutionTableOffset :: !CUInt
  } deriving (Eq, Show)

instance Storable MorxContextualSubtable where
  sizeOf    _ = 20
  alignment _ = 4
  peek p = MorxContextualSubtable <$> peekByteOff p 0
    <*> peekByteOff p 16
  poke p (MorxContextualSubtable {..}) = do
    pokeByteOff p 0 morxContextualSubtableHeader
    pokeByteOff p 16 morxContextualSubtableSubstitutionTableOffset

{-# NOINLINE morxContextualSubtableStructType #-}
morxContextualSubtableStructType :: Ptr CType
morxContextualSubtableStructType = unsafePerformIO $ fst <$> newStructCType [stxHeaderStructType, ffi_type_uint]

argMorxContextualSubtable :: MorxContextualSubtable -> Arg
argMorxContextualSubtable = mkStorableArg morxContextualSubtableStructType

retMorxContextualSubtable :: RetType MorxContextualSubtable
retMorxContextualSubtable = mkStorableRetType morxContextualSubtableStructType

data MorxInsertionSubtable = MorxInsertionSubtable
  { morxInsertionSubtableHeader :: !STXHeader
  , morxInsertionSubtableInsertionGlyphTableOffset :: !CUInt
  } deriving (Eq, Show)

instance Storable MorxInsertionSubtable where
  sizeOf    _ = 20
  alignment _ = 4
  peek p = MorxInsertionSubtable <$> peekByteOff p 0
    <*> peekByteOff p 16
  poke p (MorxInsertionSubtable {..}) = do
    pokeByteOff p 0 morxInsertionSubtableHeader
    pokeByteOff p 16 morxInsertionSubtableInsertionGlyphTableOffset

{-# NOINLINE morxInsertionSubtableStructType #-}
morxInsertionSubtableStructType :: Ptr CType
morxInsertionSubtableStructType = unsafePerformIO $ fst <$> newStructCType [stxHeaderStructType, ffi_type_uint]

argMorxInsertionSubtable :: MorxInsertionSubtable -> Arg
argMorxInsertionSubtable = mkStorableArg morxInsertionSubtableStructType

retMorxInsertionSubtable :: RetType MorxInsertionSubtable
retMorxInsertionSubtable = mkStorableRetType morxInsertionSubtableStructType

data MorxLigatureSubtable = MorxLigatureSubtable
  { morxLigatureSubtableHeader :: !STXHeader
  , morxLigatureSubtableLigatureActionTableOffset :: !CUInt
  , morxLigatureSubtableComponentTableOffset :: !CUInt
  , morxLigatureSubtableLigatureTableOffset :: !CUInt
  } deriving (Eq, Show)

instance Storable MorxLigatureSubtable where
  sizeOf    _ = 28
  alignment _ = 4
  peek p = MorxLigatureSubtable <$> peekByteOff p 0
    <*> peekByteOff p 16
    <*> peekByteOff p 20
    <*> peekByteOff p 24
  poke p (MorxLigatureSubtable {..}) = do
    pokeByteOff p 0 morxLigatureSubtableHeader
    pokeByteOff p 16 morxLigatureSubtableLigatureActionTableOffset
    pokeByteOff p 20 morxLigatureSubtableComponentTableOffset
    pokeByteOff p 24 morxLigatureSubtableLigatureTableOffset

{-# NOINLINE morxLigatureSubtableStructType #-}
morxLigatureSubtableStructType :: Ptr CType
morxLigatureSubtableStructType = unsafePerformIO $ fst <$> newStructCType [stxHeaderStructType, ffi_type_uint, ffi_type_uint, ffi_type_uint]

argMorxLigatureSubtable :: MorxLigatureSubtable -> Arg
argMorxLigatureSubtable = mkStorableArg morxLigatureSubtableStructType

retMorxLigatureSubtable :: RetType MorxLigatureSubtable
retMorxLigatureSubtable = mkStorableRetType morxLigatureSubtableStructType

data MorxRearrangementSubtable = MorxRearrangementSubtable
  { morxRearrangementSubtableHeader :: !STXHeader
  } deriving (Eq, Show)

instance Storable MorxRearrangementSubtable where
  sizeOf    _ = 16
  alignment _ = 4
  peek p = MorxRearrangementSubtable <$> peekByteOff p 0
  poke p (MorxRearrangementSubtable {..}) =
    pokeByteOff p 0 morxRearrangementSubtableHeader

{-# NOINLINE morxRearrangementSubtableStructType #-}
morxRearrangementSubtableStructType :: Ptr CType
morxRearrangementSubtableStructType = unsafePerformIO $ fst <$> newStructCType [stxHeaderStructType]

argMorxRearrangementSubtable :: MorxRearrangementSubtable -> Arg
argMorxRearrangementSubtable = mkStorableArg morxRearrangementSubtableStructType

retMorxRearrangementSubtable :: RetType MorxRearrangementSubtable
retMorxRearrangementSubtable = mkStorableRetType morxRearrangementSubtableStructType

data NCMDeviceProfileInfo = NCMDeviceProfileInfo
  { ncmDeviceProfileInfoDataVersion :: !CUInt
  , ncmDeviceProfileInfoProfileID :: !CUInt
  , ncmDeviceProfileInfoProfileLoc :: !(Ptr ())
  , ncmDeviceProfileInfoProfileName :: !(Ptr ())
  , ncmDeviceProfileInfoProfileScope :: !CMDeviceProfileScope
  , ncmDeviceProfileInfoReserved :: !CUInt
  } deriving (Eq, Show)

instance Storable NCMDeviceProfileInfo where
  sizeOf    _ = 48
  alignment _ = 8
  peek p = NCMDeviceProfileInfo <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 24
    <*> peekByteOff p 40
  poke p (NCMDeviceProfileInfo {..}) = do
    pokeByteOff p 0 ncmDeviceProfileInfoDataVersion
    pokeByteOff p 4 ncmDeviceProfileInfoProfileID
    pokeByteOff p 8 ncmDeviceProfileInfoProfileLoc
    pokeByteOff p 16 ncmDeviceProfileInfoProfileName
    pokeByteOff p 24 ncmDeviceProfileInfoProfileScope
    pokeByteOff p 40 ncmDeviceProfileInfoReserved

{-# NOINLINE ncmDeviceProfileInfoStructType #-}
ncmDeviceProfileInfoStructType :: Ptr CType
ncmDeviceProfileInfoStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_pointer, ffi_type_pointer, cmDeviceProfileScopeStructType, ffi_type_uint]

argNCMDeviceProfileInfo :: NCMDeviceProfileInfo -> Arg
argNCMDeviceProfileInfo = mkStorableArg ncmDeviceProfileInfoStructType

retNCMDeviceProfileInfo :: RetType NCMDeviceProfileInfo
retNCMDeviceProfileInfo = mkStorableRetType ncmDeviceProfileInfoStructType

data OpenCPicParams = OpenCPicParams
  { openCPicParamsSrcRect :: !Rect
  , openCPicParamsHRes :: !CInt
  , openCPicParamsVRes :: !CInt
  , openCPicParamsVersion :: !CShort
  , openCPicParamsReserved1 :: !CShort
  , openCPicParamsReserved2 :: !CInt
  } deriving (Eq, Show)

instance Storable OpenCPicParams where
  sizeOf    _ = 24
  alignment _ = 4
  peek p = OpenCPicParams <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 12
    <*> peekByteOff p 16
    <*> peekByteOff p 18
    <*> peekByteOff p 20
  poke p (OpenCPicParams {..}) = do
    pokeByteOff p 0 openCPicParamsSrcRect
    pokeByteOff p 8 openCPicParamsHRes
    pokeByteOff p 12 openCPicParamsVRes
    pokeByteOff p 16 openCPicParamsVersion
    pokeByteOff p 18 openCPicParamsReserved1
    pokeByteOff p 20 openCPicParamsReserved2

{-# NOINLINE openCPicParamsStructType #-}
openCPicParamsStructType :: Ptr CType
openCPicParamsStructType = unsafePerformIO $ fst <$> newStructCType [rectStructType, ffi_type_sint, ffi_type_sint, ffi_type_sint16, ffi_type_sint16, ffi_type_sint]

argOpenCPicParams :: OpenCPicParams -> Arg
argOpenCPicParams = mkStorableArg openCPicParamsStructType

retOpenCPicParams :: RetType OpenCPicParams
retOpenCPicParams = mkStorableRetType openCPicParamsStructType

data Picture = Picture
  { picturePicSize :: !CShort
  , picturePicFrame :: !Rect
  } deriving (Eq, Show)

instance Storable Picture where
  sizeOf    _ = 10
  alignment _ = 2
  peek p = Picture <$> peekByteOff p 0
    <*> peekByteOff p 2
  poke p (Picture {..}) = do
    pokeByteOff p 0 picturePicSize
    pokeByteOff p 2 picturePicFrame

{-# NOINLINE pictureStructType #-}
pictureStructType :: Ptr CType
pictureStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint16, rectStructType]

argPicture :: Picture -> Arg
argPicture = mkStorableArg pictureStructType

retPicture :: RetType Picture
retPicture = mkStorableRetType pictureStructType

data PixMap = PixMap
  { pixMapBaseAddr :: !(Ptr ())
  , pixMapRowBytes :: !CShort
  , pixMapBounds :: !Rect
  , pixMapPmVersion :: !CShort
  , pixMapPackType :: !CShort
  , pixMapPackSize :: !CInt
  , pixMapHRes :: !CInt
  , pixMapVRes :: !CInt
  , pixMapPixelType :: !CShort
  , pixMapPixelSize :: !CShort
  , pixMapCmpCount :: !CShort
  , pixMapCmpSize :: !CShort
  , pixMapPixelFormat :: !CUInt
  , pixMapPmTable :: !(Ptr ())
  , pixMapPmExt :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable PixMap where
  sizeOf    _ = 64
  alignment _ = 8
  peek p = PixMap <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 10
    <*> peekByteOff p 18
    <*> peekByteOff p 20
    <*> peekByteOff p 24
    <*> peekByteOff p 28
    <*> peekByteOff p 32
    <*> peekByteOff p 36
    <*> peekByteOff p 38
    <*> peekByteOff p 40
    <*> peekByteOff p 42
    <*> peekByteOff p 44
    <*> peekByteOff p 48
    <*> peekByteOff p 56
  poke p (PixMap {..}) = do
    pokeByteOff p 0 pixMapBaseAddr
    pokeByteOff p 8 pixMapRowBytes
    pokeByteOff p 10 pixMapBounds
    pokeByteOff p 18 pixMapPmVersion
    pokeByteOff p 20 pixMapPackType
    pokeByteOff p 24 pixMapPackSize
    pokeByteOff p 28 pixMapHRes
    pokeByteOff p 32 pixMapVRes
    pokeByteOff p 36 pixMapPixelType
    pokeByteOff p 38 pixMapPixelSize
    pokeByteOff p 40 pixMapCmpCount
    pokeByteOff p 42 pixMapCmpSize
    pokeByteOff p 44 pixMapPixelFormat
    pokeByteOff p 48 pixMapPmTable
    pokeByteOff p 56 pixMapPmExt

{-# NOINLINE pixMapStructType #-}
pixMapStructType :: Ptr CType
pixMapStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer, ffi_type_sint16, rectStructType, ffi_type_sint16, ffi_type_sint16, ffi_type_sint, ffi_type_sint, ffi_type_sint, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16, ffi_type_sint16, ffi_type_uint, ffi_type_pointer, ffi_type_pointer]

argPixMap :: PixMap -> Arg
argPixMap = mkStorableArg pixMapStructType

retPixMap :: RetType PixMap
retPixMap = mkStorableRetType pixMapStructType

data ProcessInfoExtendedRec = ProcessInfoExtendedRec
  { processInfoExtendedRecProcessInfoLength :: !CUInt
  , processInfoExtendedRecProcessName :: !(Ptr ())
  , processInfoExtendedRecProcessNumber :: !ProcessSerialNumber
  , processInfoExtendedRecProcessType :: !CUInt
  , processInfoExtendedRecProcessSignature :: !CUInt
  , processInfoExtendedRecProcessMode :: !CUInt
  , processInfoExtendedRecProcessLocation :: !(Ptr ())
  , processInfoExtendedRecProcessSize :: !CUInt
  , processInfoExtendedRecProcessFreeMem :: !CUInt
  , processInfoExtendedRecProcessLauncher :: !ProcessSerialNumber
  , processInfoExtendedRecProcessLaunchDate :: !CUInt
  , processInfoExtendedRecProcessActiveTime :: !CUInt
  , processInfoExtendedRecProcessAppRef :: !(Ptr ())
  , processInfoExtendedRecProcessTempMemTotal :: !CUInt
  , processInfoExtendedRecProcessPurgeableTempMemTotal :: !CUInt
  } deriving (Eq, Show)

instance Storable ProcessInfoExtendedRec where
  sizeOf    _ = 88
  alignment _ = 8
  peek p = ProcessInfoExtendedRec <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 24
    <*> peekByteOff p 28
    <*> peekByteOff p 32
    <*> peekByteOff p 40
    <*> peekByteOff p 48
    <*> peekByteOff p 52
    <*> peekByteOff p 56
    <*> peekByteOff p 64
    <*> peekByteOff p 68
    <*> peekByteOff p 72
    <*> peekByteOff p 80
    <*> peekByteOff p 84
  poke p (ProcessInfoExtendedRec {..}) = do
    pokeByteOff p 0 processInfoExtendedRecProcessInfoLength
    pokeByteOff p 8 processInfoExtendedRecProcessName
    pokeByteOff p 16 processInfoExtendedRecProcessNumber
    pokeByteOff p 24 processInfoExtendedRecProcessType
    pokeByteOff p 28 processInfoExtendedRecProcessSignature
    pokeByteOff p 32 processInfoExtendedRecProcessMode
    pokeByteOff p 40 processInfoExtendedRecProcessLocation
    pokeByteOff p 48 processInfoExtendedRecProcessSize
    pokeByteOff p 52 processInfoExtendedRecProcessFreeMem
    pokeByteOff p 56 processInfoExtendedRecProcessLauncher
    pokeByteOff p 64 processInfoExtendedRecProcessLaunchDate
    pokeByteOff p 68 processInfoExtendedRecProcessActiveTime
    pokeByteOff p 72 processInfoExtendedRecProcessAppRef
    pokeByteOff p 80 processInfoExtendedRecProcessTempMemTotal
    pokeByteOff p 84 processInfoExtendedRecProcessPurgeableTempMemTotal

{-# NOINLINE processInfoExtendedRecStructType #-}
processInfoExtendedRecStructType :: Ptr CType
processInfoExtendedRecStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_pointer, processSerialNumberStructType, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_pointer, ffi_type_uint, ffi_type_uint, processSerialNumberStructType, ffi_type_uint, ffi_type_uint, ffi_type_pointer, ffi_type_uint, ffi_type_uint]

argProcessInfoExtendedRec :: ProcessInfoExtendedRec -> Arg
argProcessInfoExtendedRec = mkStorableArg processInfoExtendedRecStructType

retProcessInfoExtendedRec :: RetType ProcessInfoExtendedRec
retProcessInfoExtendedRec = mkStorableRetType processInfoExtendedRecStructType

data ProcessInfoRec = ProcessInfoRec
  { processInfoRecProcessInfoLength :: !CUInt
  , processInfoRecProcessName :: !(Ptr ())
  , processInfoRecProcessNumber :: !ProcessSerialNumber
  , processInfoRecProcessType :: !CUInt
  , processInfoRecProcessSignature :: !CUInt
  , processInfoRecProcessMode :: !CUInt
  , processInfoRecProcessLocation :: !(Ptr ())
  , processInfoRecProcessSize :: !CUInt
  , processInfoRecProcessFreeMem :: !CUInt
  , processInfoRecProcessLauncher :: !ProcessSerialNumber
  , processInfoRecProcessLaunchDate :: !CUInt
  , processInfoRecProcessActiveTime :: !CUInt
  , processInfoRecProcessAppRef :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable ProcessInfoRec where
  sizeOf    _ = 80
  alignment _ = 8
  peek p = ProcessInfoRec <$> peekByteOff p 0
    <*> peekByteOff p 8
    <*> peekByteOff p 16
    <*> peekByteOff p 24
    <*> peekByteOff p 28
    <*> peekByteOff p 32
    <*> peekByteOff p 40
    <*> peekByteOff p 48
    <*> peekByteOff p 52
    <*> peekByteOff p 56
    <*> peekByteOff p 64
    <*> peekByteOff p 68
    <*> peekByteOff p 72
  poke p (ProcessInfoRec {..}) = do
    pokeByteOff p 0 processInfoRecProcessInfoLength
    pokeByteOff p 8 processInfoRecProcessName
    pokeByteOff p 16 processInfoRecProcessNumber
    pokeByteOff p 24 processInfoRecProcessType
    pokeByteOff p 28 processInfoRecProcessSignature
    pokeByteOff p 32 processInfoRecProcessMode
    pokeByteOff p 40 processInfoRecProcessLocation
    pokeByteOff p 48 processInfoRecProcessSize
    pokeByteOff p 52 processInfoRecProcessFreeMem
    pokeByteOff p 56 processInfoRecProcessLauncher
    pokeByteOff p 64 processInfoRecProcessLaunchDate
    pokeByteOff p 68 processInfoRecProcessActiveTime
    pokeByteOff p 72 processInfoRecProcessAppRef

{-# NOINLINE processInfoRecStructType #-}
processInfoRecStructType :: Ptr CType
processInfoRecStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_pointer, processSerialNumberStructType, ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_pointer, ffi_type_uint, ffi_type_uint, processSerialNumberStructType, ffi_type_uint, ffi_type_uint, ffi_type_pointer]

argProcessInfoRec :: ProcessInfoRec -> Arg
argProcessInfoRec = mkStorableArg processInfoRecStructType

retProcessInfoRec :: RetType ProcessInfoRec
retProcessInfoRec = mkStorableRetType processInfoRecStructType

data SpeechVersionInfo = SpeechVersionInfo
  { speechVersionInfoSynthType :: !CUInt
  , speechVersionInfoSynthSubType :: !CUInt
  , speechVersionInfoSynthManufacturer :: !CUInt
  , speechVersionInfoSynthFlags :: !CInt
  , speechVersionInfoSynthVersion :: !NumVersion
  } deriving (Eq, Show)

instance Storable SpeechVersionInfo where
  sizeOf    _ = 20
  alignment _ = 4
  peek p = SpeechVersionInfo <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
    <*> peekByteOff p 16
  poke p (SpeechVersionInfo {..}) = do
    pokeByteOff p 0 speechVersionInfoSynthType
    pokeByteOff p 4 speechVersionInfoSynthSubType
    pokeByteOff p 8 speechVersionInfoSynthManufacturer
    pokeByteOff p 12 speechVersionInfoSynthFlags
    pokeByteOff p 16 speechVersionInfoSynthVersion

{-# NOINLINE speechVersionInfoStructType #-}
speechVersionInfoStructType :: Ptr CType
speechVersionInfoStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_sint, numVersionStructType]

argSpeechVersionInfo :: SpeechVersionInfo -> Arg
argSpeechVersionInfo = mkStorableArg speechVersionInfoStructType

retSpeechVersionInfo :: RetType SpeechVersionInfo
retSpeechVersionInfo = mkStorableRetType speechVersionInfoStructType
