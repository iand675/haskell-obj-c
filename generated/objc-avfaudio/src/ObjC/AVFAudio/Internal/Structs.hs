{-# LANGUAGE RecordWildCards #-}

-- | Struct types for this framework.
--
-- Generated by objc-codegen. Do not edit.
module ObjC.AVFAudio.Internal.Structs where

import Foreign.Ptr (Ptr, FunPtr)
import Foreign.Storable (Storable(..))
import Foreign.C.Types
import Foreign.LibFFI.Base (Arg, RetType, mkStorableArg, mkStorableRetType, newStructCType)
import Foreign.LibFFI.FFITypes
import Foreign.LibFFI.Internal (CType)
import System.IO.Unsafe (unsafePerformIO)

-- | AUPresetEvent
--
-- The parameters to specify a preset for an audio unit.
data AUPresetEvent = AUPresetEvent
  { auPresetEventScope :: !CUInt
  , auPresetEventElement :: !CUInt
  , auPresetEventPreset :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable AUPresetEvent where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = AUPresetEvent <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (AUPresetEvent {..}) = do
    pokeByteOff p 0 auPresetEventScope
    pokeByteOff p 4 auPresetEventElement
    pokeByteOff p 8 auPresetEventPreset

{-# NOINLINE auPresetEventStructType #-}
auPresetEventStructType :: Ptr CType
auPresetEventStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_pointer]

argAUPresetEvent :: AUPresetEvent -> Arg
argAUPresetEvent = mkStorableArg auPresetEventStructType

retAUPresetEvent :: RetType AUPresetEvent
retAUPresetEvent = mkStorableRetType auPresetEventStructType

-- | AVAudio3DAngularOrientation
--
-- Struct representing the orientation of the listener in 3D space
--
-- Three angles describe the orientation of a listener's head - yaw, pitch and roll.
--
-- Yaw describes the side to side movement of the listener's head.        The yaw axis is perpendicular to the plane of the listener's ears with its origin at the         center of the listener's head and directed towards the bottom of the listener's head. A         positive yaw is in the clockwise direction going from 0 to 180 degrees. A negative yaw is in         the counter-clockwise direction going from 0 to -180 degrees.
--
-- Pitch describes the up-down movement of the listener's head.        The pitch axis is perpendicular to the yaw axis and is parallel to the plane of the         listener's ears with its origin at the center of the listener's head and directed towards         the right ear. A positive pitch is the upwards direction going from 0 to 180 degrees. A         negative pitch is in the downwards direction going from 0 to -180 degrees.
--
-- Roll describes the tilt of the listener's head.        The roll axis is perpendicular to the other two axes with its origin at the center of the         listener's head and is directed towards the listener's nose. A positive roll is to the right         going from 0 to 180 degrees. A negative roll is to the left going from 0 to -180 degrees.
data AVAudio3DAngularOrientation = AVAudio3DAngularOrientation
  { avAudio3DAngularOrientationYaw :: !CFloat
  , avAudio3DAngularOrientationPitch :: !CFloat
  , avAudio3DAngularOrientationRoll :: !CFloat
  } deriving (Eq, Show)

instance Storable AVAudio3DAngularOrientation where
  sizeOf    _ = 12
  alignment _ = 4
  peek p = AVAudio3DAngularOrientation <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (AVAudio3DAngularOrientation {..}) = do
    pokeByteOff p 0 avAudio3DAngularOrientationYaw
    pokeByteOff p 4 avAudio3DAngularOrientationPitch
    pokeByteOff p 8 avAudio3DAngularOrientationRoll

{-# NOINLINE avAudio3DAngularOrientationStructType #-}
avAudio3DAngularOrientationStructType :: Ptr CType
avAudio3DAngularOrientationStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_float, ffi_type_float, ffi_type_float]

argAVAudio3DAngularOrientation :: AVAudio3DAngularOrientation -> Arg
argAVAudio3DAngularOrientation = mkStorableArg avAudio3DAngularOrientationStructType

retAVAudio3DAngularOrientation :: RetType AVAudio3DAngularOrientation
retAVAudio3DAngularOrientation = mkStorableRetType avAudio3DAngularOrientationStructType

-- | AVAudio3DPoint
--
-- Struct representing a point in 3D space
--
-- This struct is used by classes dealing with 3D audio such as @AVAudioMixing@        and @AVAudioEnvironmentNode@ and represents a point in 3D space.
data AVAudio3DPoint = AVAudio3DPoint
  { avAudio3DPointX :: !CFloat
  , avAudio3DPointY :: !CFloat
  , avAudio3DPointZ :: !CFloat
  } deriving (Eq, Show)

instance Storable AVAudio3DPoint where
  sizeOf    _ = 12
  alignment _ = 4
  peek p = AVAudio3DPoint <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (AVAudio3DPoint {..}) = do
    pokeByteOff p 0 avAudio3DPointX
    pokeByteOff p 4 avAudio3DPointY
    pokeByteOff p 8 avAudio3DPointZ

{-# NOINLINE avAudio3DPointStructType #-}
avAudio3DPointStructType :: Ptr CType
avAudio3DPointStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_float, ffi_type_float, ffi_type_float]

argAVAudio3DPoint :: AVAudio3DPoint -> Arg
argAVAudio3DPoint = mkStorableArg avAudio3DPointStructType

retAVAudio3DPoint :: RetType AVAudio3DPoint
retAVAudio3DPoint = mkStorableRetType avAudio3DPointStructType

-- | AVAudio3DPoint
--
-- Struct representing a point in 3D space
--
-- This struct is used by classes dealing with 3D audio such as @AVAudioMixing@        and @AVAudioEnvironmentNode@ and represents a point in 3D space.
data AVAudio3DVector = AVAudio3DVector
  { avAudio3DVectorX :: !CFloat
  , avAudio3DVectorY :: !CFloat
  , avAudio3DVectorZ :: !CFloat
  } deriving (Eq, Show)

instance Storable AVAudio3DVector where
  sizeOf    _ = 12
  alignment _ = 4
  peek p = AVAudio3DVector <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (AVAudio3DVector {..}) = do
    pokeByteOff p 0 avAudio3DVectorX
    pokeByteOff p 4 avAudio3DVectorY
    pokeByteOff p 8 avAudio3DVectorZ

{-# NOINLINE avAudio3DVectorStructType #-}
avAudio3DVectorStructType :: Ptr CType
avAudio3DVectorStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_float, ffi_type_float, ffi_type_float]

argAVAudio3DVector :: AVAudio3DVector -> Arg
argAVAudio3DVector = mkStorableArg avAudio3DVectorStructType

retAVAudio3DVector :: RetType AVAudio3DVector
retAVAudio3DVector = mkStorableRetType avAudio3DVectorStructType

-- | AVAudioConverterPrimeInfo
--
-- This struct is the value of the primeInfo property and specifies priming information.
--
-- When using convertToBuffer:error:withInputFromBlock: (either a single call or a series of calls), some	conversions, particularly involving sample-rate conversion, ideally require a certain	number of input frames previous to the normal start input frame and beyond the end of	the last expected input frame in order to yield high-quality results.
--
-- These are expressed in the leadingFrames and trailingFrames members of the structure.
--
-- The very first call to convertToBuffer:error:withInputFromBlock:, or first call after	reset, will request additional input frames beyond those normally	expected in the input proc callback to fulfill this first AudioConverterFillComplexBuffer()	request. The number of additional frames requested, depending on the prime method, will	be approximately:
--
-- Prime method						| Additional frames	------------------------------------|----------------------	AVAudioConverterPrimeMethod_Pre     | leadingFrames + trailingFrames	AVAudioConverterPrimeMethod_Normal  | trailingFrames	AVAudioConverterPrimeMethod_None    | 0
--
-- Thus, in effect, the first input proc callback(s) may provide not only the leading	frames, but also may "read ahead" by an additional number of trailing frames depending	on the prime method.
--
-- AVAudioConverterPrimeMethod_None is useful in a real-time application processing live input,	in which case trailingFrames (relative to input sample rate) of through latency will be	seen at the beginning of the output of the AudioConverter.  In other real-time	applications such as DAW systems, it may be possible to provide these initial extra	audio frames since they are stored on disk or in memory somewhere and	AVAudioConverterPrimeMethod_Pre may be preferable.  The default method is	AVAudioConverterPrimeMethod_Normal, which requires no pre-seeking of the input stream and	generates no latency at the output.
--
-- leadingFrames        Specifies the number of leading (previous) input frames, relative to the normal/desired        start input frame, required by the converter to perform a high quality conversion. If        using AVAudioConverterPrimeMethod_Pre, the client should "pre-seek" the input stream provided        through the input proc by leadingFrames. If no frames are available previous to the        desired input start frame (because, for example, the desired start frame is at the very        beginning of available audio), then provide "leadingFrames" worth of initial zero frames        in the input proc.  Do not "pre-seek" in the default case of        AVAudioConverterPrimeMethod_Normal or when using AVAudioConverterPrimeMethod_None.
--
-- trailingFrames        Specifies the number of trailing input frames (past the normal/expected end input frame)        required by the converter to perform a high quality conversion.  The client should be        prepared to provide this number of additional input frames except when using        AVAudioConverterPrimeMethod_None. If no more frames of input are available in the input stream        (because, for example, the desired end frame is at the end of an audio file), then zero        (silent) trailing frames will be synthesized for the client.
data AVAudioConverterPrimeInfo = AVAudioConverterPrimeInfo
  { avAudioConverterPrimeInfoLeadingFrames :: !CUInt
  , avAudioConverterPrimeInfoTrailingFrames :: !CUInt
  } deriving (Eq, Show)

instance Storable AVAudioConverterPrimeInfo where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = AVAudioConverterPrimeInfo <$> peekByteOff p 0
    <*> peekByteOff p 4
  poke p (AVAudioConverterPrimeInfo {..}) = do
    pokeByteOff p 0 avAudioConverterPrimeInfoLeadingFrames
    pokeByteOff p 4 avAudioConverterPrimeInfoTrailingFrames

{-# NOINLINE avAudioConverterPrimeInfoStructType #-}
avAudioConverterPrimeInfoStructType :: Ptr CType
avAudioConverterPrimeInfoStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint]

argAVAudioConverterPrimeInfo :: AVAudioConverterPrimeInfo -> Arg
argAVAudioConverterPrimeInfo = mkStorableArg avAudioConverterPrimeInfoStructType

retAVAudioConverterPrimeInfo :: RetType AVAudioConverterPrimeInfo
retAVAudioConverterPrimeInfo = mkStorableRetType avAudioConverterPrimeInfoStructType

-- | AVBeatRange
--
-- Used to describe a specific time range within an AVMusicTrack.
data AVBeatRange = AVBeatRange
  { avBeatRangeStart :: !CDouble
  , avBeatRangeLength :: !CDouble
  } deriving (Eq, Show)

instance Storable AVBeatRange where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = AVBeatRange <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (AVBeatRange {..}) = do
    pokeByteOff p 0 avBeatRangeStart
    pokeByteOff p 8 avBeatRangeLength

{-# NOINLINE avBeatRangeStructType #-}
avBeatRangeStructType :: Ptr CType
avBeatRangeStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_double, ffi_type_double]

argAVBeatRange :: AVBeatRange -> Arg
argAVBeatRange = mkStorableArg avBeatRangeStructType

retAVBeatRange :: RetType AVBeatRange
retAVBeatRange = mkStorableRetType avBeatRangeStructType

-- | CABarBeatTime
--
-- A display representation of a musical time in beats.
--
-- A clock's internal representation of musical time is in beats based on the	beginning of the timeline. Normally, such times should be displayed to the user	in terms of bars, beats, and subbeats (sometimes called "units" or "parts per	quarter" [PPQ]). This data structure is such a display representation.
--
-- By convention, bar 1 is the beginning of the sequence. Beat 1 is the first beat	of the measure. In 4/4 time, beat will have a value from 1 to 4. Music	applications often use beat divisions such as 480 and 960.
--
-- bar
--
-- A measure number.
--
-- beat
--
-- A beat number (1..n).
--
-- subbeat
--
-- The numerator of the fractional number of beats.
--
-- subbeatDivisor
--
-- The denominator of the fractional number of beats.
--
-- reserved
--
-- Must be 0.
data CABarBeatTime = CABarBeatTime
  { caBarBeatTimeBar :: !CInt
  , caBarBeatTimeBeat :: !CUShort
  , caBarBeatTimeSubbeat :: !CUShort
  , caBarBeatTimeSubbeatDivisor :: !CUShort
  , caBarBeatTimeReserved :: !CUShort
  } deriving (Eq, Show)

instance Storable CABarBeatTime where
  sizeOf    _ = 12
  alignment _ = 4
  peek p = CABarBeatTime <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 6
    <*> peekByteOff p 8
    <*> peekByteOff p 10
  poke p (CABarBeatTime {..}) = do
    pokeByteOff p 0 caBarBeatTimeBar
    pokeByteOff p 4 caBarBeatTimeBeat
    pokeByteOff p 6 caBarBeatTimeSubbeat
    pokeByteOff p 8 caBarBeatTimeSubbeatDivisor
    pokeByteOff p 10 caBarBeatTimeReserved

{-# NOINLINE caBarBeatTimeStructType #-}
caBarBeatTimeStructType :: Ptr CType
caBarBeatTimeStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_sint, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16, ffi_type_uint16]

argCABarBeatTime :: CABarBeatTime -> Arg
argCABarBeatTime = mkStorableArg caBarBeatTimeStructType

retCABarBeatTime :: RetType CABarBeatTime
retCABarBeatTime = mkStorableRetType caBarBeatTimeStructType

data ExtendedControlEvent = ExtendedControlEvent
  { extendedControlEventGroupID :: !CUInt
  , extendedControlEventControlID :: !CUInt
  , extendedControlEventValue :: !CFloat
  } deriving (Eq, Show)

instance Storable ExtendedControlEvent where
  sizeOf    _ = 12
  alignment _ = 4
  peek p = ExtendedControlEvent <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (ExtendedControlEvent {..}) = do
    pokeByteOff p 0 extendedControlEventGroupID
    pokeByteOff p 4 extendedControlEventControlID
    pokeByteOff p 8 extendedControlEventValue

{-# NOINLINE extendedControlEventStructType #-}
extendedControlEventStructType :: Ptr CType
extendedControlEventStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_float]

argExtendedControlEvent :: ExtendedControlEvent -> Arg
argExtendedControlEvent = mkStorableArg extendedControlEventStructType

retExtendedControlEvent :: RetType ExtendedControlEvent
retExtendedControlEvent = mkStorableRetType extendedControlEventStructType

-- | ExtendedNoteOnEvent
--
-- The parameters to specify an extended note on event
data ExtendedNoteOnEvent = ExtendedNoteOnEvent
  { extendedNoteOnEventInstrumentID :: !CUInt
  , extendedNoteOnEventGroupID :: !CUInt
  , extendedNoteOnEventDuration :: !CFloat
  , extendedNoteOnEventExtendedParams :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable ExtendedNoteOnEvent where
  sizeOf    _ = 24
  alignment _ = 8
  peek p = ExtendedNoteOnEvent <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 16
  poke p (ExtendedNoteOnEvent {..}) = do
    pokeByteOff p 0 extendedNoteOnEventInstrumentID
    pokeByteOff p 4 extendedNoteOnEventGroupID
    pokeByteOff p 8 extendedNoteOnEventDuration
    pokeByteOff p 16 extendedNoteOnEventExtendedParams

{-# NOINLINE extendedNoteOnEventStructType #-}
extendedNoteOnEventStructType :: Ptr CType
extendedNoteOnEventStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_float, ffi_type_pointer]

argExtendedNoteOnEvent :: ExtendedNoteOnEvent -> Arg
argExtendedNoteOnEvent = mkStorableArg extendedNoteOnEventStructType

retExtendedNoteOnEvent :: RetType ExtendedNoteOnEvent
retExtendedNoteOnEvent = mkStorableRetType extendedNoteOnEventStructType

-- | ExtendedTempoEvent
--
-- specifies the value for a tempo in beats per minute
data ExtendedTempoEvent = ExtendedTempoEvent
  { extendedTempoEventBpm :: !CDouble
  } deriving (Eq, Show)

instance Storable ExtendedTempoEvent where
  sizeOf    _ = 8
  alignment _ = 8
  peek p = ExtendedTempoEvent <$> peekByteOff p 0
  poke p (ExtendedTempoEvent {..}) =
    pokeByteOff p 0 extendedTempoEventBpm

{-# NOINLINE extendedTempoEventStructType #-}
extendedTempoEventStructType :: Ptr CType
extendedTempoEventStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_double]

argExtendedTempoEvent :: ExtendedTempoEvent -> Arg
argExtendedTempoEvent = mkStorableArg extendedTempoEventStructType

retExtendedTempoEvent :: RetType ExtendedTempoEvent
retExtendedTempoEvent = mkStorableRetType extendedTempoEventStructType

-- | MIDIChannelMessage
--
-- The parameters to specify a MIDI channel message
data MIDIChannelMessage = MIDIChannelMessage
  { midiChannelMessageStatus :: !CUChar
  , midiChannelMessageData1 :: !CUChar
  , midiChannelMessageData2 :: !CUChar
  , midiChannelMessageReserved :: !CUChar
  } deriving (Eq, Show)

instance Storable MIDIChannelMessage where
  sizeOf    _ = 4
  alignment _ = 1
  peek p = MIDIChannelMessage <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
    <*> peekByteOff p 3
  poke p (MIDIChannelMessage {..}) = do
    pokeByteOff p 0 midiChannelMessageStatus
    pokeByteOff p 1 midiChannelMessageData1
    pokeByteOff p 2 midiChannelMessageData2
    pokeByteOff p 3 midiChannelMessageReserved

{-# NOINLINE midiChannelMessageStructType #-}
midiChannelMessageStructType :: Ptr CType
midiChannelMessageStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8]

argMIDIChannelMessage :: MIDIChannelMessage -> Arg
argMIDIChannelMessage = mkStorableArg midiChannelMessageStructType

retMIDIChannelMessage :: RetType MIDIChannelMessage
retMIDIChannelMessage = mkStorableRetType midiChannelMessageStructType

-- | MIDINoteMessage
--
-- The parameters to specify a MIDI note
data MIDINoteMessage = MIDINoteMessage
  { midiNoteMessageChannel :: !CUChar
  , midiNoteMessageNote :: !CUChar
  , midiNoteMessageVelocity :: !CUChar
  , midiNoteMessageReleaseVelocity :: !CUChar
  , midiNoteMessageDuration :: !CFloat
  } deriving (Eq, Show)

instance Storable MIDINoteMessage where
  sizeOf    _ = 8
  alignment _ = 4
  peek p = MIDINoteMessage <$> peekByteOff p 0
    <*> peekByteOff p 1
    <*> peekByteOff p 2
    <*> peekByteOff p 3
    <*> peekByteOff p 4
  poke p (MIDINoteMessage {..}) = do
    pokeByteOff p 0 midiNoteMessageChannel
    pokeByteOff p 1 midiNoteMessageNote
    pokeByteOff p 2 midiNoteMessageVelocity
    pokeByteOff p 3 midiNoteMessageReleaseVelocity
    pokeByteOff p 4 midiNoteMessageDuration

{-# NOINLINE midiNoteMessageStructType #-}
midiNoteMessageStructType :: Ptr CType
midiNoteMessageStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_uint8, ffi_type_float]

argMIDINoteMessage :: MIDINoteMessage -> Arg
argMIDINoteMessage = mkStorableArg midiNoteMessageStructType

retMIDINoteMessage :: RetType MIDINoteMessage
retMIDINoteMessage = mkStorableRetType midiNoteMessageStructType

-- | MusicTrackLoopInfo
--
-- Used to control the looping behaviour of a track
data MusicTrackLoopInfo = MusicTrackLoopInfo
  { musicTrackLoopInfoLoopDuration :: !CDouble
  , musicTrackLoopInfoNumberOfLoops :: !CInt
  } deriving (Eq, Show)

instance Storable MusicTrackLoopInfo where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = MusicTrackLoopInfo <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (MusicTrackLoopInfo {..}) = do
    pokeByteOff p 0 musicTrackLoopInfoLoopDuration
    pokeByteOff p 8 musicTrackLoopInfoNumberOfLoops

{-# NOINLINE musicTrackLoopInfoStructType #-}
musicTrackLoopInfoStructType :: Ptr CType
musicTrackLoopInfoStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_double, ffi_type_sint]

argMusicTrackLoopInfo :: MusicTrackLoopInfo -> Arg
argMusicTrackLoopInfo = mkStorableArg musicTrackLoopInfoStructType

retMusicTrackLoopInfo :: RetType MusicTrackLoopInfo
retMusicTrackLoopInfo = mkStorableRetType musicTrackLoopInfoStructType

-- | ParameterEvent
--
-- The parameters to specify a parameter event to an audio unit.
data ParameterEvent = ParameterEvent
  { parameterEventParameterID :: !CUInt
  , parameterEventScope :: !CUInt
  , parameterEventElement :: !CUInt
  , parameterEventValue :: !CFloat
  } deriving (Eq, Show)

instance Storable ParameterEvent where
  sizeOf    _ = 16
  alignment _ = 4
  peek p = ParameterEvent <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
  poke p (ParameterEvent {..}) = do
    pokeByteOff p 0 parameterEventParameterID
    pokeByteOff p 4 parameterEventScope
    pokeByteOff p 8 parameterEventElement
    pokeByteOff p 12 parameterEventValue

{-# NOINLINE parameterEventStructType #-}
parameterEventStructType :: Ptr CType
parameterEventStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_uint, ffi_type_float]

argParameterEvent :: ParameterEvent -> Arg
argParameterEvent = mkStorableArg parameterEventStructType

retParameterEvent :: RetType ParameterEvent
retParameterEvent = mkStorableRetType parameterEventStructType

-- | AVAudio3DVectorOrientation
--
-- Struct representing the orientation of the listener in 3D space
--
-- Two orthogonal vectors describe the orientation of the listener. The forward        vector points in the direction that the listener is facing. The up vector is orthogonal        to the forward vector and points upwards from the listener's head.
data AVAudio3DVectorOrientation = AVAudio3DVectorOrientation
  { avAudio3DVectorOrientationForward :: !AVAudio3DVector
  , avAudio3DVectorOrientationUp :: !AVAudio3DVector
  } deriving (Eq, Show)

instance Storable AVAudio3DVectorOrientation where
  sizeOf    _ = 24
  alignment _ = 4
  peek p = AVAudio3DVectorOrientation <$> peekByteOff p 0
    <*> peekByteOff p 12
  poke p (AVAudio3DVectorOrientation {..}) = do
    pokeByteOff p 0 avAudio3DVectorOrientationForward
    pokeByteOff p 12 avAudio3DVectorOrientationUp

{-# NOINLINE avAudio3DVectorOrientationStructType #-}
avAudio3DVectorOrientationStructType :: Ptr CType
avAudio3DVectorOrientationStructType = unsafePerformIO $ fst <$> newStructCType [avAudio3DVectorStructType, avAudio3DVectorStructType]

argAVAudio3DVectorOrientation :: AVAudio3DVectorOrientation -> Arg
argAVAudio3DVectorOrientation = mkStorableArg avAudio3DVectorOrientationStructType

retAVAudio3DVectorOrientation :: RetType AVAudio3DVectorOrientation
retAVAudio3DVectorOrientation = mkStorableRetType avAudio3DVectorOrientationStructType
