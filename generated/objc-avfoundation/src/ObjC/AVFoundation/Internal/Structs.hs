{-# LANGUAGE RecordWildCards #-}

-- | Struct types for this framework.
--
-- Generated by objc-codegen. Do not edit.
module ObjC.AVFoundation.Internal.Structs where

import Foreign.Ptr (Ptr, FunPtr)
import Foreign.Storable (Storable(..))
import Foreign.C.Types
import Foreign.LibFFI.Base (Arg, RetType, mkStorableArg, mkStorableRetType, newStructCType)
import Foreign.LibFFI.FFITypes
import Foreign.LibFFI.Internal (CType)
import System.IO.Unsafe (unsafePerformIO)
import ObjC.AVFoundation.Internal.Enums
import ObjC.CoreMedia.Internal.Enums

-- | AVCaptionDimension
--
-- The length with a unit or coordinate on a 2D geometric axis  value The value of the coordinate or length.  units The units of the coordinate (e.g., cells, points)
data AVCaptionDimension = AVCaptionDimension
  { avCaptionDimensionValue :: !CDouble
  , avCaptionDimensionUnits :: !AVCaptionUnitsType
  } deriving (Eq, Show)

instance Storable AVCaptionDimension where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = AVCaptionDimension <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (AVCaptionDimension {..}) = do
    pokeByteOff p 0 avCaptionDimensionValue
    pokeByteOff p 8 avCaptionDimensionUnits

{-# NOINLINE avCaptionDimensionStructType #-}
avCaptionDimensionStructType :: Ptr CType
avCaptionDimensionStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_double, ffi_type_slong]

argAVCaptionDimension :: AVCaptionDimension -> Arg
argAVCaptionDimension = mkStorableArg avCaptionDimensionStructType

retAVCaptionDimension :: RetType AVCaptionDimension
retAVCaptionDimension = mkStorableRetType avCaptionDimensionStructType

-- | CMTag
--
-- An efficient structure used to label something about a resource or other media construct.
--
-- A structure holding a CMTagCategory, CMTagDataType, and a CMTagValue serving to represent a particular tag that might be assigned to or associated with another resource. There is only one of each of the category, the dataType and the value so any notion of "has" is about the respective singular element.  CMTags are a value type. No lifetime management such as allocation or retain and release semantics are needed. CMTags can be passed by value, returned by value and stored in other structures or arrays or on the stack.  CMTags carry a single value that can be carried in 64 bits. This can include data types such as signed 64-bit integers, floating point values fitting in 64 bits, up to 64 bit of flags, and other data types fitting within 64 bits. Signaling of the data type is carried in the CMTagDataType. The data types can be extended through registration with the CoreMedia team.  A CMTag value should not be used to carry pointers. If such a reference is needed, it is okay to carry an index into an out-of-band data structure that itself has a memory reference or an object reference.	 category CMTagCategory for the tag.	 dataType CMTagDataType for the tag indicating the data type of the value.	 value CMTagValue for the value of the CMTag (e.g., a signed 64-bit integer.)
data CMTag = CMTag
  { cmTagCategory :: !CMTagCategory
  , cmTagDataType :: !CMTagDataType
  , cmTagValue :: !CULong
  } deriving (Eq, Show)

instance Storable CMTag where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = CMTag <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
  poke p (CMTag {..}) = do
    pokeByteOff p 0 cmTagCategory
    pokeByteOff p 4 cmTagDataType
    pokeByteOff p 8 cmTagValue

{-# NOINLINE cmTagStructType #-}
cmTagStructType :: Ptr CType
cmTagStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_uint, ffi_type_uint, ffi_type_ulong]

argCMTag :: CMTag -> Arg
argCMTag = mkStorableArg cmTagStructType

retCMTag :: RetType CMTag
retCMTag = mkStorableRetType cmTagStructType

-- | AVCaptionPoint
--
-- A two dimensional point made of x and y AVCaptionDimension coordinates  x An AVCaptionDimension holding the x coordinate of the point  y An AVCaptionDimension holding the y coordinate of the point
data AVCaptionPoint = AVCaptionPoint
  { avCaptionPointX :: !AVCaptionDimension
  , avCaptionPointY :: !AVCaptionDimension
  } deriving (Eq, Show)

instance Storable AVCaptionPoint where
  sizeOf    _ = 32
  alignment _ = 8
  peek p = AVCaptionPoint <$> peekByteOff p 0
    <*> peekByteOff p 16
  poke p (AVCaptionPoint {..}) = do
    pokeByteOff p 0 avCaptionPointX
    pokeByteOff p 16 avCaptionPointY

{-# NOINLINE avCaptionPointStructType #-}
avCaptionPointStructType :: Ptr CType
avCaptionPointStructType = unsafePerformIO $ fst <$> newStructCType [avCaptionDimensionStructType, avCaptionDimensionStructType]

argAVCaptionPoint :: AVCaptionPoint -> Arg
argAVCaptionPoint = mkStorableArg avCaptionPointStructType

retAVCaptionPoint :: RetType AVCaptionPoint
retAVCaptionPoint = mkStorableRetType avCaptionPointStructType

-- | AVCaptionSize
--
-- A two dimensional size made of width and height AVCaptionDimensions  width An AVCaptionDimension holding the width  height An AVCaptionDimension holding the height
data AVCaptionSize = AVCaptionSize
  { avCaptionSizeWidth :: !AVCaptionDimension
  , avCaptionSizeHeight :: !AVCaptionDimension
  } deriving (Eq, Show)

instance Storable AVCaptionSize where
  sizeOf    _ = 32
  alignment _ = 8
  peek p = AVCaptionSize <$> peekByteOff p 0
    <*> peekByteOff p 16
  poke p (AVCaptionSize {..}) = do
    pokeByteOff p 0 avCaptionSizeWidth
    pokeByteOff p 16 avCaptionSizeHeight

{-# NOINLINE avCaptionSizeStructType #-}
avCaptionSizeStructType :: Ptr CType
avCaptionSizeStructType = unsafePerformIO $ fst <$> newStructCType [avCaptionDimensionStructType, avCaptionDimensionStructType]

argAVCaptionSize :: AVCaptionSize -> Arg
argAVCaptionSize = mkStorableArg avCaptionSizeStructType

retAVCaptionSize :: RetType AVCaptionSize
retAVCaptionSize = mkStorableRetType avCaptionSizeStructType
