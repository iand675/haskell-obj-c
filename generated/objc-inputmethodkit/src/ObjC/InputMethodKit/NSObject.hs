{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE FlexibleContexts #-}

-- | Generated bindings for @NSObject@.
module ObjC.InputMethodKit.NSObject
  ( NSObject
  , IsNSObject(..)
  , inputText_key_modifiers_client
  , inputText_client
  , handleEvent_client
  , didCommandBySelector_client
  , composedString
  , originalString
  , commitComposition
  , candidates
  , inputText_key_modifiers_clientSelector
  , inputText_clientSelector
  , handleEvent_clientSelector
  , didCommandBySelector_clientSelector
  , composedStringSelector
  , originalStringSelector
  , commitCompositionSelector
  , candidatesSelector


  ) where

import Foreign.Ptr (Ptr, nullPtr, castPtr)
import Foreign.LibFFI
import Foreign.C.Types
import Data.Int (Int8, Int16)
import Data.Word (Word16)
import Data.Coerce (coerce)

import ObjC.Runtime.Types
import ObjC.Runtime.MsgSend (sendMsg, sendClassMsg)
import ObjC.Runtime.Selector (mkSelector)
import ObjC.Runtime.Class (getRequiredClass)

import ObjC.InputMethodKit.Internal.Classes
import ObjC.AppKit.Internal.Classes
import ObjC.Foundation.Internal.Classes

-- | Receive the Unicodes, the key code that generated them and modifier flags.
--
-- Input methods implementing this method should return YES if the input was excepted, and NO if not excepted.
--
-- ObjC selector: @- inputText:key:modifiers:client:@
inputText_key_modifiers_client :: (IsNSObject nsObject, IsNSString string) => nsObject -> string -> CLong -> CULong -> RawId -> IO Bool
inputText_key_modifiers_client nsObject  string keyCode flags sender =
withObjCPtr string $ \raw_string ->
    fmap ((/= 0) :: CULong -> Bool) $ sendMsg nsObject (mkSelector "inputText:key:modifiers:client:") retCULong [argPtr (castPtr raw_string :: Ptr ()), argCLong (fromIntegral keyCode), argCULong (fromIntegral flags), argPtr (castPtr (unRawId sender) :: Ptr ())]

-- | Each keydown that does not map to an action method is delivered to the input method as an NSString.
--
-- If the input string is not excepted the input method should return NO.  When text is accepted return YES.  Input methods should implement this method when they are using keybinding (i.e. have implemented didCommandBySelector:client:).
--
-- ObjC selector: @- inputText:client:@
inputText_client :: (IsNSObject nsObject, IsNSString string) => nsObject -> string -> RawId -> IO Bool
inputText_client nsObject  string sender =
withObjCPtr string $ \raw_string ->
    fmap ((/= 0) :: CULong -> Bool) $ sendMsg nsObject (mkSelector "inputText:client:") retCULong [argPtr (castPtr raw_string :: Ptr ()), argPtr (castPtr (unRawId sender) :: Ptr ())]

-- | Receive all keydown and mouse events as an NSEvent (i.e. the event is simply forwarded onto the input method).
--
-- Return YES if the event was handled. NO if not handled.
--
-- ObjC selector: @- handleEvent:client:@
handleEvent_client :: (IsNSObject nsObject, IsNSEvent event) => nsObject -> event -> RawId -> IO Bool
handleEvent_client nsObject  event sender =
withObjCPtr event $ \raw_event ->
    fmap ((/= 0) :: CULong -> Bool) $ sendMsg nsObject (mkSelector "handleEvent:client:") retCULong [argPtr (castPtr raw_event :: Ptr ()), argPtr (castPtr (unRawId sender) :: Ptr ())]

-- | Called when system binds a keyDown event to an action method.
--
-- This method is designed to return YES if the command is handled and NO if the command is not handled. It is called to process a command that was generated by user action such as typing certain keys or mousing down. It is necessary for this method to return YES or NO so the  event can be passed through to the client if it is not handled.  The selector can be an action specified in the input method's dictionary of keys and actions (i.e. an action specific to the input method) or one of the NSResponder action methods such as insertNewline: or deleteBackward:.  By definition such action methods do not return a value.  For that reason if you implement this method you should test if it is appropriate to call the action method before calling it since calling the action method is agreeing to handle the command
--
-- For example.  Suppose you have implemented a version of insertNewline: that terminates the conversion session and sends the fully converted text to the client.  However, if you conversion buffer is empty you want the application to receive the return key that triggered the call to insertNewline:.  In that case when didCommandBySelector:client: is called you should test your buffer before calling your implementation of insertNewline:.  If the buffer is empty you would return NO indicating that the return key should be passed on to the application.  If the buffer is not empty you would call insertNewline: and then return YES as the result of didCommandBySelector:client:.
--
-- ObjC selector: @- didCommandBySelector:client:@
didCommandBySelector_client :: IsNSObject nsObject => nsObject -> Selector -> RawId -> IO Bool
didCommandBySelector_client nsObject  aSelector sender =
  fmap ((/= 0) :: CULong -> Bool) $ sendMsg nsObject (mkSelector "didCommandBySelector:client:") retCULong [argPtr (unSelector aSelector), argPtr (castPtr (unRawId sender) :: Ptr ())]

-- | Return the current composed string.  This may be an NSString or NSAttributedString.
--
-- A composed string refers to the buffer that an input method typically maintains to mirror the text contained in the active inline area.  It is called the composed string to reflect the fact that the input method composed the string by converting the characters input by the user.  In addition, using the term composed string makes it easier to differentiate between an input method's buffer and the text in the active inline area that the user sees. The returned object should be an autoreleased object.
--
-- ObjC selector: @- composedString:@
composedString :: IsNSObject nsObject => nsObject -> RawId -> IO RawId
composedString nsObject  sender =
  fmap (RawId . castPtr) $ sendMsg nsObject (mkSelector "composedString:") (retPtr retVoid) [argPtr (castPtr (unRawId sender) :: Ptr ())]

-- | Return the a string consisting of the original pre-composition unicodes.
--
-- If an input method stores the original input text it should return that text here.  The return value is an attributed string so that input method's can potentially restore changes they may have made to the font, etc.  The returned object should be an autoreleased object.
--
-- ObjC selector: @- originalString:@
originalString :: IsNSObject nsObject => nsObject -> RawId -> IO (Id NSAttributedString)
originalString nsObject  sender =
  sendMsg nsObject (mkSelector "originalString:") (retPtr retVoid) [argPtr (castPtr (unRawId sender) :: Ptr ())] >>= retainedObject . castPtr

-- | Called to inform the controller that the composition should be committed.
--
-- If an input method implements this method it will be called when the client wishes to end the composition session immediately. A typical response would be to call the client's insertText method and then clean up any per-session buffers and variables.  After receiving this message an input method should consider the given composition session finished.
--
-- ObjC selector: @- commitComposition:@
commitComposition :: IsNSObject nsObject => nsObject -> RawId -> IO ()
commitComposition nsObject  sender =
  sendMsg nsObject (mkSelector "commitComposition:") retVoid [argPtr (castPtr (unRawId sender) :: Ptr ())]

-- | Called to get an array of candidates.
--
-- An input method would look up its currently composed string and return a list of candidate strings that that string might map to. The returned NSArray should be an autoreleased object.
--
-- ObjC selector: @- candidates:@
candidates :: IsNSObject nsObject => nsObject -> RawId -> IO (Id NSArray)
candidates nsObject  sender =
  sendMsg nsObject (mkSelector "candidates:") (retPtr retVoid) [argPtr (castPtr (unRawId sender) :: Ptr ())] >>= retainedObject . castPtr

-- ---------------------------------------------------------------------------
-- Selectors
-- ---------------------------------------------------------------------------

-- | @Selector@ for @inputText:key:modifiers:client:@
inputText_key_modifiers_clientSelector :: Selector
inputText_key_modifiers_clientSelector = mkSelector "inputText:key:modifiers:client:"

-- | @Selector@ for @inputText:client:@
inputText_clientSelector :: Selector
inputText_clientSelector = mkSelector "inputText:client:"

-- | @Selector@ for @handleEvent:client:@
handleEvent_clientSelector :: Selector
handleEvent_clientSelector = mkSelector "handleEvent:client:"

-- | @Selector@ for @didCommandBySelector:client:@
didCommandBySelector_clientSelector :: Selector
didCommandBySelector_clientSelector = mkSelector "didCommandBySelector:client:"

-- | @Selector@ for @composedString:@
composedStringSelector :: Selector
composedStringSelector = mkSelector "composedString:"

-- | @Selector@ for @originalString:@
originalStringSelector :: Selector
originalStringSelector = mkSelector "originalString:"

-- | @Selector@ for @commitComposition:@
commitCompositionSelector :: Selector
commitCompositionSelector = mkSelector "commitComposition:"

-- | @Selector@ for @candidates:@
candidatesSelector :: Selector
candidatesSelector = mkSelector "candidates:"

