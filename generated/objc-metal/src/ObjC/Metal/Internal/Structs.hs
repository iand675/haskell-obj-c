{-# LANGUAGE RecordWildCards #-}

-- | Struct types for this framework.
--
-- Generated by objc-codegen. Do not edit.
module ObjC.Metal.Internal.Structs where

import Foreign.Ptr (Ptr, FunPtr)
import Foreign.Storable (Storable(..))
import Foreign.C.Types
import Foreign.LibFFI.Base (Arg, RetType, mkStorableArg, mkStorableRetType, newStructCType)
import Foreign.LibFFI.FFITypes
import Foreign.LibFFI.Internal (CType)
import System.IO.Unsafe (unsafePerformIO)

-- | A struct representing a range of a Metal buffer. The offset into the buffer is included in the address. The length is generally optional, which a value of (uint64_t)-1 representing the range from the given address to the end of the buffer. However, providing the length can enable more accurate API validation, especially when sub-allocating ranges of a buffer.
data MTL4BufferRange = MTL4BufferRange
  { mtL4BufferRangeBufferAddress :: !CULong
  , mtL4BufferRangeLength :: !CULong
  } deriving (Eq, Show)

instance Storable MTL4BufferRange where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = MTL4BufferRange <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (MTL4BufferRange {..}) = do
    pokeByteOff p 0 mtL4BufferRangeBufferAddress
    pokeByteOff p 8 mtL4BufferRangeLength

{-# NOINLINE mtL4BufferRangeStructType #-}
mtL4BufferRangeStructType :: Ptr CType
mtL4BufferRangeStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_ulong, ffi_type_ulong]

argMTL4BufferRange :: MTL4BufferRange -> Arg
argMTL4BufferRange = mkStorableArg mtL4BufferRangeStructType

retMTL4BufferRange :: RetType MTL4BufferRange
retMTL4BufferRange = mkStorableRetType mtL4BufferRangeStructType

-- | An axis aligned bounding box with a min and max point
data MTLAxisAlignedBoundingBox = MTLAxisAlignedBoundingBox
  { mtlAxisAlignedBoundingBoxMin :: !(Ptr ())
  , mtlAxisAlignedBoundingBoxMax :: !(Ptr ())
  } deriving (Eq, Show)

instance Storable MTLAxisAlignedBoundingBox where
  sizeOf    _ = 16
  alignment _ = 8
  peek p = MTLAxisAlignedBoundingBox <$> peekByteOff p 0
    <*> peekByteOff p 8
  poke p (MTLAxisAlignedBoundingBox {..}) = do
    pokeByteOff p 0 mtlAxisAlignedBoundingBoxMin
    pokeByteOff p 8 mtlAxisAlignedBoundingBoxMax

{-# NOINLINE mtlAxisAlignedBoundingBoxStructType #-}
mtlAxisAlignedBoundingBoxStructType :: Ptr CType
mtlAxisAlignedBoundingBoxStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_pointer, ffi_type_pointer]

argMTLAxisAlignedBoundingBox :: MTLAxisAlignedBoundingBox -> Arg
argMTLAxisAlignedBoundingBox = mkStorableArg mtlAxisAlignedBoundingBoxStructType

retMTLAxisAlignedBoundingBox :: RetType MTLAxisAlignedBoundingBox
retMTLAxisAlignedBoundingBox = mkStorableRetType mtlAxisAlignedBoundingBoxStructType

data MTLPackedFloatQuaternion = MTLPackedFloatQuaternion
  { mtlPackedFloatQuaternionX :: !CFloat
  , mtlPackedFloatQuaternionY :: !CFloat
  , mtlPackedFloatQuaternionZ :: !CFloat
  , mtlPackedFloatQuaternionW :: !CFloat
  } deriving (Eq, Show)

instance Storable MTLPackedFloatQuaternion where
  sizeOf    _ = 16
  alignment _ = 4
  peek p = MTLPackedFloatQuaternion <$> peekByteOff p 0
    <*> peekByteOff p 4
    <*> peekByteOff p 8
    <*> peekByteOff p 12
  poke p (MTLPackedFloatQuaternion {..}) = do
    pokeByteOff p 0 mtlPackedFloatQuaternionX
    pokeByteOff p 4 mtlPackedFloatQuaternionY
    pokeByteOff p 8 mtlPackedFloatQuaternionZ
    pokeByteOff p 12 mtlPackedFloatQuaternionW

{-# NOINLINE mtlPackedFloatQuaternionStructType #-}
mtlPackedFloatQuaternionStructType :: Ptr CType
mtlPackedFloatQuaternionStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_float, ffi_type_float, ffi_type_float, ffi_type_float]

argMTLPackedFloatQuaternion :: MTLPackedFloatQuaternion -> Arg
argMTLPackedFloatQuaternion = mkStorableArg mtlPackedFloatQuaternionStructType

retMTLPackedFloatQuaternion :: RetType MTLPackedFloatQuaternion
retMTLPackedFloatQuaternion = mkStorableRetType mtlPackedFloatQuaternionStructType

-- | MTLResourceID
--
-- Handle of the GPU resource used for binding resources to argument tables, navigating resource view pools and storing resources in an argument buffer
--
-- MTLResourceID represents a specific GPU resource. This handle can be mutated by modifying textureID or samplerID values to get to individual resource views in a resource view pool.
data MTLResourceID = MTLResourceID
  { mtlResourceID_impl :: !CULong
  } deriving (Eq, Show)

instance Storable MTLResourceID where
  sizeOf    _ = 8
  alignment _ = 8
  peek p = MTLResourceID <$> peekByteOff p 0
  poke p (MTLResourceID {..}) =
    pokeByteOff p 0 mtlResourceID_impl

{-# NOINLINE mtlResourceIDStructType #-}
mtlResourceIDStructType :: Ptr CType
mtlResourceIDStructType = unsafePerformIO $ fst <$> newStructCType [ffi_type_ulong]

argMTLResourceID :: MTLResourceID -> Arg
argMTLResourceID = mkStorableArg mtlResourceIDStructType

retMTLResourceID :: RetType MTLResourceID
retMTLResourceID = mkStorableRetType mtlResourceIDStructType
